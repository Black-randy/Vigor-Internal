#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerController

#include "Basic.hpp"

#include "BP_PlayerController_classes.hpp"
#include "BP_PlayerController_parameters.hpp"


namespace SDK
{

// Function BP_PlayerController.BP_PlayerController_C.Possessed A Character__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Possessed_Character                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::Possessed_A_Character__DelegateSignature(class ABP_Character_C* Possessed_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "Possessed A Character__DelegateSignature");

	Params::BP_PlayerController_C_Possessed_A_Character__DelegateSignature Parms{};

	Parms.Possessed_Character = Possessed_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.GameHasStarted__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ABP_PlayerController_C::GameHasStarted__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "GameHasStarted__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.ExecuteUbergraph_BP_PlayerController
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::ExecuteUbergraph_BP_PlayerController(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "ExecuteUbergraph_BP_PlayerController");

	Params::BP_PlayerController_C_ExecuteUbergraph_BP_PlayerController Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.InpAxisEvt_MouseWheel_K2Node_InputAxisEvent_0
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::InpAxisEvt_MouseWheel_K2Node_InputAxisEvent_0(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "InpAxisEvt_MouseWheel_K2Node_InputAxisEvent_0");

	Params::BP_PlayerController_C_InpAxisEvt_MouseWheel_K2Node_InputAxisEvent_0 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_PlayerController_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.AddUserMessage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// TSoftObjectPtr<class USoundBase>        Optional2D_Sound                                       (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::AddUserMessage(const class FText& Message, TSoftObjectPtr<class USoundBase> Optional2D_Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "AddUserMessage");

	Params::BP_PlayerController_C_AddUserMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.Optional2D_Sound = Optional2D_Sound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.AnyMatchStarted
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_PlayerController_C::AnyMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "AnyMatchStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.OnPlayerMenuAction
// (Event, Public, BlueprintEvent)

void ABP_PlayerController_C::OnPlayerMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "OnPlayerMenuAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.CreateGlint
// (Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*                  AttachComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Size                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::CreateGlint(class USceneComponent* AttachComponent, float Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "CreateGlint");

	Params::BP_PlayerController_C_CreateGlint Parms{};

	Parms.AttachComponent = AttachComponent;
	Parms.Size = Size;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.IncrementUsedAmmo
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PlayerController_C::IncrementUsedAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "IncrementUsedAmmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.IncrementShotsFired
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PlayerController_C::IncrementShotsFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "IncrementShotsFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.Possessed
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Possessed_Character                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::Possessed(class ABP_Character_C* Possessed_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "Possessed");

	Params::BP_PlayerController_C_Possessed Parms{};

	Parms.Possessed_Character = Possessed_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.Add User Message
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// TSoftObjectPtr<class USoundBase>        Optional2D_Sound                                       (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::Add_User_Message(const class FText& Message, TSoftObjectPtr<class USoundBase> Optional2D_Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "Add User Message");

	Params::BP_PlayerController_C_Add_User_Message Parms{};

	Parms.Message = std::move(Message);
	Parms.Optional2D_Sound = Optional2D_Sound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.PossessedServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Possessed_Character                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::PossessedServer(class ABP_Character_C* Possessed_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "PossessedServer");

	Params::BP_PlayerController_C_PossessedServer Parms{};

	Parms.Possessed_Character = Possessed_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.InpActEvt_SecondaryWeaponTwo_K2Node_InputActionEvent_0
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::InpActEvt_SecondaryWeaponTwo_K2Node_InputActionEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "InpActEvt_SecondaryWeaponTwo_K2Node_InputActionEvent_0");

	Params::BP_PlayerController_C_InpActEvt_SecondaryWeaponTwo_K2Node_InputActionEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.InpActEvt_SecondaryWeaponOne_K2Node_InputActionEvent_1
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::InpActEvt_SecondaryWeaponOne_K2Node_InputActionEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "InpActEvt_SecondaryWeaponOne_K2Node_InputActionEvent_1");

	Params::BP_PlayerController_C_InpActEvt_SecondaryWeaponOne_K2Node_InputActionEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.InpActEvt_PrimaryWeaponTwo_K2Node_InputActionEvent_2
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::InpActEvt_PrimaryWeaponTwo_K2Node_InputActionEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "InpActEvt_PrimaryWeaponTwo_K2Node_InputActionEvent_2");

	Params::BP_PlayerController_C_InpActEvt_PrimaryWeaponTwo_K2Node_InputActionEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.InpActEvt_PrimaryWeaponOne_K2Node_InputActionEvent_3
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_PlayerController_C::InpActEvt_PrimaryWeaponOne_K2Node_InputActionEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "InpActEvt_PrimaryWeaponOne_K2Node_InputActionEvent_3");

	Params::BP_PlayerController_C_InpActEvt_PrimaryWeaponOne_K2Node_InputActionEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.SetWeatherManagerRef
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_PlayerController_C::SetWeatherManagerRef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "SetWeatherManagerRef");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_PlayerController.BP_PlayerController_C.ChangeWeaponWheel
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DoesIncrement                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PlayerController_C::ChangeWeaponWheel(bool DoesIncrement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "ChangeWeaponWheel");

	Params::BP_PlayerController_C_ChangeWeaponWheel Parms{};

	Parms.DoesIncrement = DoesIncrement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_PlayerController.BP_PlayerController_C.BPI_RegisterMapMarkedActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MapMarkerComponent_C*         MarkerComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bValid                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FName                             UsedTag                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::BPI_RegisterMapMarkedActor(class UBP_MapMarkerComponent_C* MarkerComponent, bool* bValid, class FName* UsedTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "BPI_RegisterMapMarkedActor");

	Params::BP_PlayerController_C_BPI_RegisterMapMarkedActor Parms{};

	Parms.MarkerComponent = MarkerComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bValid != nullptr)
		*bValid = Parms.bValid;

	if (UsedTag != nullptr)
		*UsedTag = Parms.UsedTag;
}


// Function BP_PlayerController.BP_PlayerController_C.BPI_UnRegisterMapMarkedActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MapMarkerComponent_C*         MarkerComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_PlayerController_C::BPI_UnRegisterMapMarkedActor(class UBP_MapMarkerComponent_C* MarkerComponent, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "BPI_UnRegisterMapMarkedActor");

	Params::BP_PlayerController_C_BPI_UnRegisterMapMarkedActor Parms{};

	Parms.MarkerComponent = MarkerComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_PlayerController.BP_PlayerController_C.GetLobbyStateAndTimes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    HasMatchStarted                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    DelayedMatchStartIsInEffect                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   RemainingTimeToEncounter                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalTimeToEncounter                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::GetLobbyStateAndTimes(bool* Valid, bool* HasMatchStarted, bool* DelayedMatchStartIsInEffect, int32* RemainingTimeToEncounter, int32* TotalTimeToEncounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "GetLobbyStateAndTimes");

	Params::BP_PlayerController_C_GetLobbyStateAndTimes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (HasMatchStarted != nullptr)
		*HasMatchStarted = Parms.HasMatchStarted;

	if (DelayedMatchStartIsInEffect != nullptr)
		*DelayedMatchStartIsInEffect = Parms.DelayedMatchStartIsInEffect;

	if (RemainingTimeToEncounter != nullptr)
		*RemainingTimeToEncounter = Parms.RemainingTimeToEncounter;

	if (TotalTimeToEncounter != nullptr)
		*TotalTimeToEncounter = Parms.TotalTimeToEncounter;
}


// Function BP_PlayerController.BP_PlayerController_C.GetGroupID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString                           GroupId                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ABP_PlayerController_C::GetGroupID(bool* Valid, class FString* GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "GetGroupID");

	Params::BP_PlayerController_C_GetGroupID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (GroupId != nullptr)
		*GroupId = std::move(Parms.GroupId);
}


// Function BP_PlayerController.BP_PlayerController_C.GetLastRespawnTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FDateTime                        LastRespawnTime                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_PlayerController_C::GetLastRespawnTime(bool* Valid, struct FDateTime* LastRespawnTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "GetLastRespawnTime");

	Params::BP_PlayerController_C_GetLastRespawnTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (LastRespawnTime != nullptr)
		*LastRespawnTime = std::move(Parms.LastRespawnTime);
}


// Function BP_PlayerController.BP_PlayerController_C.GetLastMatchID_Info
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    LastMatchIDReset                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString                           MatchID_ToSave                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void ABP_PlayerController_C::GetLastMatchID_Info(bool* Valid, bool* LastMatchIDReset, class FString* MatchID_ToSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_PlayerController_C", "GetLastMatchID_Info");

	Params::BP_PlayerController_C_GetLastMatchID_Info Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (LastMatchIDReset != nullptr)
		*LastMatchIDReset = Parms.LastMatchIDReset;

	if (MatchID_ToSave != nullptr)
		*MatchID_ToSave = std::move(Parms.MatchID_ToSave);
}

}


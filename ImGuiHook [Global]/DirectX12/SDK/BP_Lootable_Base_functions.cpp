#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Lootable_Base

#include "Basic.hpp"

#include "BP_Lootable_Base_classes.hpp"
#include "BP_Lootable_Base_parameters.hpp"


namespace SDK
{

// Function BP_Lootable_Base.BP_Lootable_Base_C.On State Changed__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Lootable_State                        Old_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Lootable_State                        New_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::On_State_Changed__DelegateSignature(E_Lootable_State Old_State, E_Lootable_State New_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "On State Changed__DelegateSignature");

	Params::BP_Lootable_Base_C_On_State_Changed__DelegateSignature Parms{};

	Parms.Old_State = Old_State;
	Parms.New_State = New_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.OnStaticMeshChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::OnStaticMeshChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "OnStaticMeshChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.ExecuteUbergraph_BP_Lootable_Base
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::ExecuteUbergraph_BP_Lootable_Base(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "ExecuteUbergraph_BP_Lootable_Base");

	Params::BP_Lootable_Base_C_ExecuteUbergraph_BP_Lootable_Base Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.DelayedDestroy
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::DelayedDestroy(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "DelayedDestroy");

	Params::BP_Lootable_Base_C_DelayedDestroy Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.AddBoobyTrap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Human                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::AddBoobyTrap(class AHumanCharacter* Human)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "AddBoobyTrap");

	Params::BP_Lootable_Base_C_AddBoobyTrap Parms{};

	Parms.Human = Human;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.OnNewMeshLoaded
// (BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::OnNewMeshLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "OnNewMeshLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Apply Mesh From State Descriptor_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FF_Lootable_StateDescriptor      StateDescriptor                                        (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Apply_Mesh_From_State_Descriptor_Event(const struct FF_Lootable_StateDescriptor& StateDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Apply Mesh From State Descriptor_Event");

	Params::BP_Lootable_Base_C_Apply_Mesh_From_State_Descriptor_Event Parms{};

	Parms.StateDescriptor = std::move(StateDescriptor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.DelayedLoadTheme
// (BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::DelayedLoadTheme()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "DelayedLoadTheme");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.OnThemeLoaded
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// ESublevelTheme                          Theme                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::OnThemeLoaded(ESublevelTheme Theme)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "OnThemeLoaded");

	Params::BP_Lootable_Base_C_OnThemeLoaded Parms{};

	Parms.Theme = Theme;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.SetupThemedLootableVisual
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// ESublevelTheme                          Theme                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::SetupThemedLootableVisual(ESublevelTheme Theme)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "SetupThemedLootableVisual");

	Params::BP_Lootable_Base_C_SetupThemedLootableVisual Parms{};

	Parms.Theme = Theme;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.HideAndDestroy
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::HideAndDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "HideAndDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.BoobyTrap Owners Changed
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           BoobyTrap_Owners                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_Lootable_Base_C::BoobyTrap_Owners_Changed(const TArray<int32>& BoobyTrap_Owners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "BoobyTrap Owners Changed");

	Params::BP_Lootable_Base_C_BoobyTrap_Owners_Changed Parms{};

	Parms.BoobyTrap_Owners = std::move(BoobyTrap_Owners);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Loot Accessed
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::Loot_Accessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Loot Accessed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Browsing Character Died
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  DyingCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AHumanCharacter*                  InstigatingCharacter                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           InstigatingItem                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitResult                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Lootable_Base_C::Browsing_Character_Died(class ABP_Character_C* DyingCharacter, float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, class UClass* InstigatingItem, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Browsing Character Died");

	Params::BP_Lootable_Base_C_Browsing_Character_Died Parms{};

	Parms.DyingCharacter = DyingCharacter;
	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Close Local Inventory UI
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::Close_Local_Inventory_UI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Close Local Inventory UI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Open Local Inventory UI
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Browsing_Controller                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Open_Local_Inventory_UI(class AHumanPlayerController* Browsing_Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Open Local Inventory UI");

	Params::BP_Lootable_Base_C_Open_Local_Inventory_UI Parms{};

	Parms.Browsing_Controller = Browsing_Controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Close Inventory
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Browsing_Character                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Close_Inventory(class ABP_Character_C* Browsing_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Close Inventory");

	Params::BP_Lootable_Base_C_Close_Inventory Parms{};

	Parms.Browsing_Character = Browsing_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Open Inventory
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Browsing_Character                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Open_Inventory(class ABP_Character_C* Browsing_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Open Inventory");

	Params::BP_Lootable_Base_C_Open_Inventory Parms{};

	Parms.Browsing_Character = Browsing_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Access Loot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Looting_character                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Access_Loot(class ABP_Character_C* Looting_character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Access Loot");

	Params::BP_Lootable_Base_C_Access_Loot Parms{};

	Parms.Looting_character = Looting_character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Server Interaction End
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Interacting_Character                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Server_Interaction_End(class ABP_Character_C* Interacting_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Server Interaction End");

	Params::BP_Lootable_Base_C_Server_Interaction_End Parms{};

	Parms.Interacting_Character = Interacting_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Server Interaction Start
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Interacting_Character                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Server_Interaction_Start(class ABP_Character_C* Interacting_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Server Interaction Start");

	Params::BP_Lootable_Base_C_Server_Interaction_Start Parms{};

	Parms.Interacting_Character = Interacting_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_6_Interaction End on Server__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Interacting_Actor                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_6_Interaction_End_on_Server__DelegateSignature(class UInteractionItemComponent* Sender, class AActor* Interacting_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_6_Interaction End on Server__DelegateSignature");

	Params::BP_Lootable_Base_C_BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_6_Interaction_End_on_Server__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Interacting_Actor = Interacting_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_1_Interaction Start on Server__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Interacting_Actor                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_1_Interaction_Start_on_Server__DelegateSignature(class UInteractionItemComponent* Sender, class AActor* Interacting_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_1_Interaction Start on Server__DelegateSignature");

	Params::BP_Lootable_Base_C_BndEvt__BP_InteractionItemComponent_K2Node_ComponentBoundEvent_1_Interaction_Start_on_Server__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Interacting_Actor = Interacting_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.State Changed
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Lootable_State                        Old_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Lootable_State                        New_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::State_Changed(E_Lootable_State Old_State, E_Lootable_State New_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "State Changed");

	Params::BP_Lootable_Base_C_State_Changed Parms{};

	Parms.Old_State = Old_State;
	Parms.New_State = New_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.LootDistrubuted
// (Event, Public, BlueprintEvent)

void ABP_Lootable_Base_C::LootDistrubuted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "LootDistrubuted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "ReceiveTick");

	Params::BP_Lootable_Base_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "ReceiveEndPlay");

	Params::BP_Lootable_Base_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Lootable_Base_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.OnRep_State
// (BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "OnRep_State");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Set State
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Lootable_State                        New_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Silent_Change                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    State_Changed                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Lootable_Base_C::Set_State(E_Lootable_State New_State, bool Silent_Change, bool* State_Changed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Set State");

	Params::BP_Lootable_Base_C_Set_State Parms{};

	Parms.New_State = New_State;
	Parms.Silent_Change = Silent_Change;

	UObject::ProcessEvent(Func, &Parms);

	if (State_Changed != nullptr)
		*State_Changed = Parms.State_Changed;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Determine State Based On Current Circumstances
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Lootable_State                        Appropriate_State                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Determine_State_Based_On_Current_Circumstances(E_Lootable_State* Appropriate_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Determine State Based On Current Circumstances");

	Params::BP_Lootable_Base_C_Determine_State_Based_On_Current_Circumstances Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Appropriate_State != nullptr)
		*Appropriate_State = Parms.Appropriate_State;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Is Simple UI Allowed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Simple_UI_Allowed                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Lootable_Base_C::Is_Simple_UI_Allowed(bool* Simple_UI_Allowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Is Simple UI Allowed");

	Params::BP_Lootable_Base_C_Is_Simple_UI_Allowed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Simple_UI_Allowed != nullptr)
		*Simple_UI_Allowed = Parms.Simple_UI_Allowed;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Perform UI-less Item Transfer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Interacting_Character                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Successful                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Lootable_Base_C::Perform_UIMinusless_Item_Transfer(class ABP_Character_C* Interacting_Character, bool* Successful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Perform UI-less Item Transfer");

	Params::BP_Lootable_Base_C_Perform_UIMinusless_Item_Transfer Parms{};

	Parms.Interacting_Character = Interacting_Character;

	UObject::ProcessEvent(Func, &Parms);

	if (Successful != nullptr)
		*Successful = Parms.Successful;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Get State
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Lootable_State                        State_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Get_State(E_Lootable_State* State_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Get State");

	Params::BP_Lootable_Base_C_Get_State Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (State_0 != nullptr)
		*State_0 = Parms.State_0;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.On Rep State
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    New_State_Is_Valid                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Lootable_Base_C::On_Rep_State(bool* New_State_Is_Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "On Rep State");

	Params::BP_Lootable_Base_C_On_Rep_State Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (New_State_Is_Valid != nullptr)
		*New_State_Is_Valid = Parms.New_State_Is_Valid;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Debug State Print
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Debug_State_Print(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Debug State Print");

	Params::BP_Lootable_Base_C_Debug_State_Print Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.GetDefaultAnimBehavior
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EAnimInteractionType                    InteractionType                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::GetDefaultAnimBehavior(EAnimInteractionType* InteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "GetDefaultAnimBehavior");

	Params::BP_Lootable_Base_C_GetDefaultAnimBehavior Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InteractionType != nullptr)
		*InteractionType = Parms.InteractionType;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Apply Materials from State Descriptor
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FF_Lootable_StateDescriptor      State_Descriptor                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Apply_Materials_from_State_Descriptor(const struct FF_Lootable_StateDescriptor& State_Descriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Apply Materials from State Descriptor");

	Params::BP_Lootable_Base_C_Apply_Materials_from_State_Descriptor Parms{};

	Parms.State_Descriptor = std::move(State_Descriptor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Apply Settings from State Descriptor
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FF_Lootable_StateDescriptor      State_Descriptor                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Apply_Settings_from_State_Descriptor(const struct FF_Lootable_StateDescriptor& State_Descriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Apply Settings from State Descriptor");

	Params::BP_Lootable_Base_C_Apply_Settings_from_State_Descriptor Parms{};

	Parms.State_Descriptor = std::move(State_Descriptor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Add BoobyTrap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Trap_Owner_ID                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Add_BoobyTrap(int32 Trap_Owner_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Add BoobyTrap");

	Params::BP_Lootable_Base_C_Add_BoobyTrap Parms{};

	Parms.Trap_Owner_ID = Trap_Owner_ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Remove BoobyTrap
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::Remove_BoobyTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Remove BoobyTrap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Get BoobyTrap Count
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   BoobyTrap_count                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Get_BoobyTrap_Count(int32* BoobyTrap_count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Get BoobyTrap Count");

	Params::BP_Lootable_Base_C_Get_BoobyTrap_Count Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BoobyTrap_count != nullptr)
		*BoobyTrap_count = Parms.BoobyTrap_count;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Remove All BoobyTraps
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Lootable_Base_C::Remove_All_BoobyTraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Remove All BoobyTraps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Get BoobyTrap Owner
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   BoobyTrap_Index                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Player_ID                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Lootable_Base_C::Get_BoobyTrap_Owner(int32 BoobyTrap_Index, int32* Player_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Get BoobyTrap Owner");

	Params::BP_Lootable_Base_C_Get_BoobyTrap_Owner Parms{};

	Parms.BoobyTrap_Index = BoobyTrap_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (Player_ID != nullptr)
		*Player_ID = Parms.Player_ID;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.Is Currently Being Interacted With
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Is_Interacted_With                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Lootable_Base_C::Is_Currently_Being_Interacted_With(bool* Is_Interacted_With)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "Is Currently Being Interacted With");

	Params::BP_Lootable_Base_C_Is_Currently_Being_Interacted_With Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Is_Interacted_With != nullptr)
		*Is_Interacted_With = Parms.Is_Interacted_With;
}


// Function BP_Lootable_Base.BP_Lootable_Base_C.GetStateSettings
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// E_Lootable_State                        State_0                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ValidState                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FF_Lootable_StateDescriptor      Value                                                  (Parm, OutParm, HasGetValueTypeHash)

void ABP_Lootable_Base_C::GetStateSettings(const E_Lootable_State& State_0, bool* ValidState, struct FF_Lootable_StateDescriptor* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Lootable_Base_C", "GetStateSettings");

	Params::BP_Lootable_Base_C_GetStateSettings Parms{};

	Parms.State_0 = State_0;

	UObject::ProcessEvent(Func, &Parms);

	if (ValidState != nullptr)
		*ValidState = Parms.ValidState;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}

}


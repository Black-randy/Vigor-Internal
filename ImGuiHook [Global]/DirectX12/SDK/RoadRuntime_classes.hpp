#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RoadRuntime

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "RoadRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class RoadRuntime.CrossActor
// 0x0030 (0x0260 - 0x0230)
class ACrossActor final : public AStaticMeshActor
{
public:
	class FString                                 UniqueKey;                                         // 0x0230(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrossActorManager>             SideActors;                                        // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCrossMeshManager>              SideMeshes;                                        // 0x0250(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void DestroySideObjects();
	void PushSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void PushSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void UpdateSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void UpdateSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossActor">();
	}
	static class ACrossActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrossActor>();
	}
};
static_assert(alignof(ACrossActor) == 0x000008, "Wrong alignment on ACrossActor");
static_assert(sizeof(ACrossActor) == 0x000260, "Wrong size on ACrossActor");
static_assert(offsetof(ACrossActor, UniqueKey) == 0x000230, "Member 'ACrossActor::UniqueKey' has a wrong offset!");
static_assert(offsetof(ACrossActor, SideActors) == 0x000240, "Member 'ACrossActor::SideActors' has a wrong offset!");
static_assert(offsetof(ACrossActor, SideMeshes) == 0x000250, "Member 'ACrossActor::SideMeshes' has a wrong offset!");

// Class RoadRuntime.RoadActor
// 0x0078 (0x0298 - 0x0220)
class ARoadActor final : public AActor
{
public:
	ESplineMeshAxis                               SplineMeshAxis;                                    // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalOffset;                                       // 0x0224(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARoadActor*                             Father;                                            // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueKey;                                         // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       Spline;                                            // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segmentation;                                      // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepGeneration;                                    // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RoadMesh;                                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           RoadMeshesComp;                                    // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSideActorManager>              SideActors;                                        // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSideMeshManager>               SideMeshes;                                        // 0x0288(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static float ApproxLength(const struct FInterpCurveVector& SplineInfo, const float Start, const float End, const int32 ApproxSections);

	void AddSplineMesh(int32 MeshIndex);
	void ClearSplineMeshes();
	void DestroySideObjects();
	void PushSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void PushSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSegment(int32 SegmentIndex, class USplineComponent* SplineComponent, class UStaticMesh* StaticMesh, ESplineMeshAxis InAxis);
	void UpdateSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSideMeshes(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSplineMesh(int32 MeshIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoadActor">();
	}
	static class ARoadActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoadActor>();
	}
};
static_assert(alignof(ARoadActor) == 0x000008, "Wrong alignment on ARoadActor");
static_assert(sizeof(ARoadActor) == 0x000298, "Wrong size on ARoadActor");
static_assert(offsetof(ARoadActor, SplineMeshAxis) == 0x000220, "Member 'ARoadActor::SplineMeshAxis' has a wrong offset!");
static_assert(offsetof(ARoadActor, LocalOffset) == 0x000224, "Member 'ARoadActor::LocalOffset' has a wrong offset!");
static_assert(offsetof(ARoadActor, Father) == 0x000230, "Member 'ARoadActor::Father' has a wrong offset!");
static_assert(offsetof(ARoadActor, UniqueKey) == 0x000238, "Member 'ARoadActor::UniqueKey' has a wrong offset!");
static_assert(offsetof(ARoadActor, Spline) == 0x000248, "Member 'ARoadActor::Spline' has a wrong offset!");
static_assert(offsetof(ARoadActor, Index_0) == 0x000250, "Member 'ARoadActor::Index_0' has a wrong offset!");
static_assert(offsetof(ARoadActor, Segmentation) == 0x000254, "Member 'ARoadActor::Segmentation' has a wrong offset!");
static_assert(offsetof(ARoadActor, StepGeneration) == 0x000258, "Member 'ARoadActor::StepGeneration' has a wrong offset!");
static_assert(offsetof(ARoadActor, Size) == 0x00025C, "Member 'ARoadActor::Size' has a wrong offset!");
static_assert(offsetof(ARoadActor, RoadMesh) == 0x000260, "Member 'ARoadActor::RoadMesh' has a wrong offset!");
static_assert(offsetof(ARoadActor, RoadMeshesComp) == 0x000268, "Member 'ARoadActor::RoadMeshesComp' has a wrong offset!");
static_assert(offsetof(ARoadActor, SideActors) == 0x000278, "Member 'ARoadActor::SideActors' has a wrong offset!");
static_assert(offsetof(ARoadActor, SideMeshes) == 0x000288, "Member 'ARoadActor::SideMeshes' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_ADM_CombinationChest

#include "Basic.hpp"

#include "BP_ADM_CombinationChest_classes.hpp"
#include "BP_ADM_CombinationChest_parameters.hpp"


namespace SDK
{

// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.ExecuteUbergraph_BP_ADM_CombinationChest
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::ExecuteUbergraph_BP_ADM_CombinationChest(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "ExecuteUbergraph_BP_ADM_CombinationChest");

	Params::BP_ADM_CombinationChest_C_ExecuteUbergraph_BP_ADM_CombinationChest Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_ADM_CombinationChest_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.On player solved combination
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CombinationLock_PCComponent_C*Player_that_opened_lock                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_CombinationLock_Component_C*  Unlocked_Combination_lock                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::On_player_solved_combination(class UBP_CombinationLock_PCComponent_C* Player_that_opened_lock, class UBP_CombinationLock_Component_C* Unlocked_Combination_lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "On player solved combination");

	Params::BP_ADM_CombinationChest_C_On_player_solved_combination Parms{};

	Parms.Player_that_opened_lock = Player_that_opened_lock;
	Parms.Unlocked_Combination_lock = Unlocked_Combination_lock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.Access Loot
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Looting_character                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::Access_Loot(class ABP_Character_C* Looting_character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "Access Loot");

	Params::BP_ADM_CombinationChest_C_Access_Loot Parms{};

	Parms.Looting_character = Looting_character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.State Changed
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Lootable_State                        Old_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Lootable_State                        New_State                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::State_Changed(E_Lootable_State Old_State, E_Lootable_State New_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "State Changed");

	Params::BP_ADM_CombinationChest_C_State_Changed Parms{};

	Parms.Old_State = Old_State;
	Parms.New_State = New_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.Server Interaction Start
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  Interacting_Character                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::Server_Interaction_Start(class ABP_Character_C* Interacting_Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "Server Interaction Start");

	Params::BP_ADM_CombinationChest_C_Server_Interaction_Start Parms{};

	Parms.Interacting_Character = Interacting_Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_ADM_CombinationChest_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.Determine State Based On Current Circumstances
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Lootable_State                        Appropriate_State                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ADM_CombinationChest_C::Determine_State_Based_On_Current_Circumstances(E_Lootable_State* Appropriate_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "Determine State Based On Current Circumstances");

	Params::BP_ADM_CombinationChest_C_Determine_State_Based_On_Current_Circumstances Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Appropriate_State != nullptr)
		*Appropriate_State = Parms.Appropriate_State;
}


// Function BP_ADM_CombinationChest.BP_ADM_CombinationChest_C.On Rep State
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    New_State_Is_Valid                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_ADM_CombinationChest_C::On_Rep_State(bool* New_State_Is_Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ADM_CombinationChest_C", "On Rep State");

	Params::BP_ADM_CombinationChest_C_On_Rep_State Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (New_State_Is_Valid != nullptr)
		*New_State_Is_Valid = Parms.New_State_Is_Valid;
}

}


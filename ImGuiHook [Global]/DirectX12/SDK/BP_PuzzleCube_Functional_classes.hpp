#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PuzzleCube_Functional

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "E_PuzzleCube_SelectedSide_structs.hpp"
#include "FPuzzleCube_RotationInfo_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PuzzleCube_Functional.BP_PuzzleCube_Functional_C
// 0x0138 (0x0358 - 0x0220)
class ABP_PuzzleCube_Functional_C final : public AActor
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0220(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USceneComponent*                        TheCube;                                           // 0x0228(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         Timeline_Lerp_Lerp_E0450BC748EC0BBB68C65A9E19847138; // 0x0238(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            Timeline_Lerp__Direction_E0450BC748EC0BBB68C65A9E19847138; // 0x023C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     Timeline_Lerp;                                     // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UStaticMeshComponent*>           ListOfParts;                                       // 0x0248(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UStaticMeshComponent*>           SMsToRotate;                                       // 0x0258(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          IsRotating;                                        // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	E_PuzzleCube_SelectedSide                     FaceToRotate;                                      // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_26A[0x6];                                      // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     DefaultTransforms;                                 // 0x0270(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FString                                 SaveGameFile;                                      // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FFPuzzleCube_RotationInfo>      RotationInfos;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<struct FQuat>                          CumulativeQuat;                                    // 0x02A0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UUI_PuzzleCube_C*                       OwningUI;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsMeasurementActive;                               // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovesCount;                                        // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTimespan                              SavedTimeTaken;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FDateTime                              StartTime;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         OuterLayerDistance;                                // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CubeSize;                                          // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	TArray<float>                                 LayerDistances;                                    // 0x02D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_PuzzleCube_SaveGame_C*              SaveGameSlot;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<int32>                                 FaceIndicesG;                                      // 0x02F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 FaceIndicesB;                                      // 0x0300(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 FaceIndicesO;                                      // 0x0310(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 FaceIndicesR;                                      // 0x0320(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 FaceIndicesY;                                      // 0x0330(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 FaceIndicesW;                                      // 0x0340(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          ColorBlind;                                        // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_BP_PuzzleCube_Functional(int32 EntryPoint);
	void SaveToSlotAsync(class USaveGame* SaveGameObject, const class FString& SlotName);
	void Rotate(float Angle, E_PuzzleCube_SelectedSide Side, bool RotateCenter_0);
	void ReceiveBeginPlay();
	void OnSaveSucceed_BBA922CF443C06F17BF094A4DDE62BF4(const class FString& SlotName, const int32 UserIndex);
	void OnSaveFailed_BBA922CF443C06F17BF094A4DDE62BF4(const class FString& SlotName, const int32 UserIndex);
	void OnLoadSucceed_3560E73A455123247FA38EB20F6A2859(class USaveGame* SaveGame);
	void OnLoadFailed_3560E73A455123247FA38EB20F6A2859(class USaveGame* SaveGame);
	void Timeline_Lerp__UpdateFunc();
	void Timeline_Lerp__FinishedFunc();
	void GetRotationForFace(class USceneComponent* Part, float Rotation_Roll, E_PuzzleCube_SelectedSide Side, bool RotateCenter_0, bool* Exec, struct FQuat* DeltaQuat);
	void Init();
	void RotateFace(float Angle);
	void SetActiveFace(E_PuzzleCube_SelectedSide SideToRotate);
	void RotateCenter(float Angle);
	struct FVector SnapToGrid_vector_(const struct FVector& Vector, float GridSize);
	void RotationTimelineInit(float Angle, E_PuzzleCube_SelectedSide Side, bool RotateCenter);
	void RotationTimelineFinished();
	void RotationTimelineUpdate(float Alpha);
	void Shuffle();
	void SaveToFile();
	void Solve();
	void Rotate3DCube(const struct FRotator& NewParam);
	void ShuffleInternal(int32 Times);
	void UpdateCumulativeRotationsAndSnapToGrid();
	struct FRotator SnapToGrid_rotator_(const struct FRotator& Rotator, float GridSize);
	void SnapTo90DegGrid(const struct FQuat& Quat, struct FQuat* Quat2);
	void SnapTo90DegGrid_float_(float In, float* Out);
	void IsKubeSolved(bool* Solved);
	void Quat2String(const struct FQuat& Quat, class FString* String);
	void ResetCounters();
	struct FTimespan GetTimeTaken();
	void SolveInternal();
	void SpawnMiniCubes();
	void CloseTheKube(bool* WasClosed);
	bool Equal__Quaternion_(const struct FQuat& A, const struct FQuat& B, float Tolerance);
	void ResizeTheKube(int32* CubeSize_0);
	bool Is_Face_Solved(TArray<int32>& FaceIndices);
	void SetColorBlindSkin(bool ColorBlindActive);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PuzzleCube_Functional_C">();
	}
	static class ABP_PuzzleCube_Functional_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_PuzzleCube_Functional_C>();
	}
};
static_assert(alignof(ABP_PuzzleCube_Functional_C) == 0x000008, "Wrong alignment on ABP_PuzzleCube_Functional_C");
static_assert(sizeof(ABP_PuzzleCube_Functional_C) == 0x000358, "Wrong size on ABP_PuzzleCube_Functional_C");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, UberGraphFrame) == 0x000220, "Member 'ABP_PuzzleCube_Functional_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, TheCube) == 0x000228, "Member 'ABP_PuzzleCube_Functional_C::TheCube' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, DefaultSceneRoot) == 0x000230, "Member 'ABP_PuzzleCube_Functional_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, Timeline_Lerp_Lerp_E0450BC748EC0BBB68C65A9E19847138) == 0x000238, "Member 'ABP_PuzzleCube_Functional_C::Timeline_Lerp_Lerp_E0450BC748EC0BBB68C65A9E19847138' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, Timeline_Lerp__Direction_E0450BC748EC0BBB68C65A9E19847138) == 0x00023C, "Member 'ABP_PuzzleCube_Functional_C::Timeline_Lerp__Direction_E0450BC748EC0BBB68C65A9E19847138' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, Timeline_Lerp) == 0x000240, "Member 'ABP_PuzzleCube_Functional_C::Timeline_Lerp' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, ListOfParts) == 0x000248, "Member 'ABP_PuzzleCube_Functional_C::ListOfParts' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, SMsToRotate) == 0x000258, "Member 'ABP_PuzzleCube_Functional_C::SMsToRotate' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, IsRotating) == 0x000268, "Member 'ABP_PuzzleCube_Functional_C::IsRotating' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceToRotate) == 0x000269, "Member 'ABP_PuzzleCube_Functional_C::FaceToRotate' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, DefaultTransforms) == 0x000270, "Member 'ABP_PuzzleCube_Functional_C::DefaultTransforms' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, SaveGameFile) == 0x000280, "Member 'ABP_PuzzleCube_Functional_C::SaveGameFile' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, RotationInfos) == 0x000290, "Member 'ABP_PuzzleCube_Functional_C::RotationInfos' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, CumulativeQuat) == 0x0002A0, "Member 'ABP_PuzzleCube_Functional_C::CumulativeQuat' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, OwningUI) == 0x0002B0, "Member 'ABP_PuzzleCube_Functional_C::OwningUI' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, IsMeasurementActive) == 0x0002B8, "Member 'ABP_PuzzleCube_Functional_C::IsMeasurementActive' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, MovesCount) == 0x0002BC, "Member 'ABP_PuzzleCube_Functional_C::MovesCount' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, SavedTimeTaken) == 0x0002C0, "Member 'ABP_PuzzleCube_Functional_C::SavedTimeTaken' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, StartTime) == 0x0002C8, "Member 'ABP_PuzzleCube_Functional_C::StartTime' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, OuterLayerDistance) == 0x0002D0, "Member 'ABP_PuzzleCube_Functional_C::OuterLayerDistance' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, CubeSize) == 0x0002D4, "Member 'ABP_PuzzleCube_Functional_C::CubeSize' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, LayerDistances) == 0x0002D8, "Member 'ABP_PuzzleCube_Functional_C::LayerDistances' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, SaveGameSlot) == 0x0002E8, "Member 'ABP_PuzzleCube_Functional_C::SaveGameSlot' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesG) == 0x0002F0, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesG' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesB) == 0x000300, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesB' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesO) == 0x000310, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesO' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesR) == 0x000320, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesR' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesY) == 0x000330, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesY' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, FaceIndicesW) == 0x000340, "Member 'ABP_PuzzleCube_Functional_C::FaceIndicesW' has a wrong offset!");
static_assert(offsetof(ABP_PuzzleCube_Functional_C, ColorBlind) == 0x000350, "Member 'ABP_PuzzleCube_Functional_C::ColorBlind' has a wrong offset!");

}


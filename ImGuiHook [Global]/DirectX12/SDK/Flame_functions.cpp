#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Flame

#include "Basic.hpp"

#include "Flame_classes.hpp"
#include "Flame_parameters.hpp"


namespace SDK
{

// Function Flame.DropPlaneMovementComponent.OnRep_ServerStartTime
// (Final, Native, Private)

void UDropPlaneMovementComponent::OnRep_ServerStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropPlaneMovementComponent", "OnRep_ServerStartTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.DropPlaneMovementComponent.StartFlight
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DirXY                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DropLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FlightRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FlightSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartHeightOffset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DropHeightOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDropPlaneMovementComponent::StartFlight(const struct FVector& DirXY, const struct FVector& DropLocation, float FlightRadius, float FlightSpeed, float StartHeightOffset, float DropHeightOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropPlaneMovementComponent", "StartFlight");

	Params::DropPlaneMovementComponent_StartFlight Parms{};

	Parms.DirXY = std::move(DirXY);
	Parms.DropLocation = std::move(DropLocation);
	Parms.FlightRadius = FlightRadius;
	Parms.FlightSpeed = FlightSpeed;
	Parms.StartHeightOffset = StartHeightOffset;
	Parms.DropHeightOffset = DropHeightOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.DropPlaneMovementComponent.IsCloseToDropLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDropPlaneMovementComponent::IsCloseToDropLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropPlaneMovementComponent", "IsCloseToDropLocation");

	Params::DropPlaneMovementComponent_IsCloseToDropLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DropPlaneMovementComponent.IsCloseToEndPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDropPlaneMovementComponent::IsCloseToEndPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropPlaneMovementComponent", "IsCloseToEndPoint");

	Params::DropPlaneMovementComponent_IsCloseToEndPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponCollisionBuilder.AddReport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWeaponCollisionEntry            Entry                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AWeaponCollisionBuilder::AddReport(const struct FWeaponCollisionEntry& Entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponCollisionBuilder", "AddReport");

	Params::WeaponCollisionBuilder_AddReport Parms{};

	Parms.Entry = std::move(Entry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AccessorComponent.ClientNotifyAboutAccess
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           ActorForAccess                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccessorComponent::ClientNotifyAboutAccess(class AActor* ActorForAccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessorComponent", "ClientNotifyAboutAccess");

	Params::AccessorComponent_ClientNotifyAboutAccess Parms{};

	Parms.ActorForAccess = ActorForAccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AccessorComponent.ClientReactionOnInteract
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccessorComponent::ClientReactionOnInteract(class AActor* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessorComponent", "ClientReactionOnInteract");

	Params::AccessorComponent_ClientReactionOnInteract Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AccessorComponent.ServerAskForDetach
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UAccessorComponent::ServerAskForDetach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessorComponent", "ServerAskForDetach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CanAimComponent.CanAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECanAimState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECanAimState UCanAimComponent::CanAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanAimComponent", "CanAim");

	Params::CanAimComponent_CanAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CanAimComponent.GetUpHeightAdjustment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCanAimComponent::GetUpHeightAdjustment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanAimComponent", "GetUpHeightAdjustment");

	Params::CanAimComponent_GetUpHeightAdjustment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.OnRep_Character
// (Final, Native, Protected)

void AItem::OnRep_Character()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "OnRep_Character");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Item.OnRep_ItemStateBringDown
// (Final, Native, Private)
// Parameters:
// class UItemStateBringDown*              OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem::OnRep_ItemStateBringDown(class UItemStateBringDown* OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "OnRep_ItemStateBringDown");

	Params::Item_OnRep_ItemStateBringDown Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Item.OnRep_ItemStateBringUp
// (Final, Native, Private)
// Parameters:
// class UItemStateBringUp*                OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItem::OnRep_ItemStateBringUp(class UItemStateBringUp* OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "OnRep_ItemStateBringUp");

	Params::Item_OnRep_ItemStateBringUp Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Item.CanBeDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItem::CanBeDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "CanBeDestroyed");

	Params::Item_CanBeDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.CanBeUsedImpl
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItem::CanBeUsedImpl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "CanBeUsedImpl");

	Params::Item_CanBeUsedImpl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetCardImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* AItem::GetCardImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetCardImage");

	Params::Item_GetCardImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetCardSoftImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class UTexture2D>  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TSoftObjectPtr<class UTexture2D> AItem::GetCardSoftImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetCardSoftImage");

	Params::Item_GetCardSoftImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemCategory                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemCategory AItem::GetCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetCategory");

	Params::Item_GetCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetCategoryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AItem::GetCategoryName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetCategoryName");

	Params::Item_GetCategoryName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHumanCharacter* AItem::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetCharacter");

	Params::Item_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetDebugInfo
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AItem::GetDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetDebugInfo");

	Params::Item_GetDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AItem::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetDescription");

	Params::Item_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIconSize                               IconSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* AItem::GetIcon(EIconSize IconSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetIcon");

	Params::Item_GetIcon Parms{};

	Parms.IconSize = IconSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetIconSoft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIconSize                               IconSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> AItem::GetIconSoft(EIconSize IconSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetIconSoft");

	Params::Item_GetIconSoft Parms{};

	Parms.IconSize = IconSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetItemName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AItem::GetItemName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemName");

	Params::Item_GetItemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetRarity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AItem::GetRarity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetRarity");

	Params::Item_GetRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetShelterPreviewSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* AItem::GetShelterPreviewSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetShelterPreviewSkeletalMesh");

	Params::Item_GetShelterPreviewSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetShelterPreviewStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* AItem::GetShelterPreviewStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetShelterPreviewStaticMesh");

	Params::Item_GetShelterPreviewStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetUnitWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AItem::GetUnitWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetUnitWeight");

	Params::Item_GetUnitWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Item.GetWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AItem::GetWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetWeight");

	Params::Item_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemForBackpack.GetCost
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AItemForBackpack::GetCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemForBackpack", "GetCost");

	Params::ItemForBackpack_GetCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemForBackpack.GetStackSize
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AItemForBackpack::GetStackSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemForBackpack", "GetStackSize");

	Params::ItemForBackpack_GetStackSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameWidget.ListenForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float AxisValue)>        Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UFlameWidget::ListenForInputAxis(class FName AxisName, bool bConsume, TDelegate<void(float AxisValue)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "ListenForInputAxis");

	Params::FlameWidget_ListenForInputAxis Parms{};

	Parms.AxisName = AxisName;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameWidget.OnChildFocusChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameWidget::OnChildFocusChange(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "OnChildFocusChange");

	Params::FlameWidget_OnChildFocusChange Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FlameWidget.OnChildFocusLost
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameWidget::OnChildFocusLost(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "OnChildFocusLost");

	Params::FlameWidget_OnChildFocusLost Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameWidget.OnChildFocusReceived
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameWidget::OnChildFocusReceived(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "OnChildFocusReceived");

	Params::FlameWidget_OnChildFocusReceived Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameWidget.StopListeningForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameWidget::StopListeningForInputAxis(class FName AxisName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "StopListeningForInputAxis");

	Params::FlameWidget_StopListeningForInputAxis Parms{};

	Parms.AxisName = AxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameWidget.GetFocusedWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UFlameWidget::GetFocusedWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "GetFocusedWidget");

	Params::FlameWidget_GetFocusedWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameWidget.GetInputAxesToConsume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> UFlameWidget::GetInputAxesToConsume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "GetInputAxesToConsume");

	Params::FlameWidget_GetInputAxesToConsume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameWidget.IsListeningForInputAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameWidget::IsListeningForInputAxis(class FName AxisName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameWidget", "IsListeningForInputAxis");

	Params::FlameWidget_IsListeningForInputAxis Parms{};

	Parms.AxisName = AxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StoredItemsComponent.SotoreItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentStorageComponent*       Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoredItemsComponent::SotoreItems(class UEquipmentStorageComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredItemsComponent", "SotoreItems");

	Params::StoredItemsComponent_SotoreItems Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CanBeSelectedInterface.DoSelect
// (Native, Public, BlueprintCallable)
// Parameters:
// EInputIcon                              InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICanBeSelectedInterface::DoSelect(EInputIcon InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CanBeSelectedInterface", "DoSelect");

	Params::CanBeSelectedInterface_DoSelect Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ActionMachineDebugWidget.GetItemStatesHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UActionMachineDebugWidget::GetItemStatesHistory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionMachineDebugWidget", "GetItemStatesHistory");

	Params::ActionMachineDebugWidget_GetItemStatesHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CanvasFunctions.DrawMaterialQuads
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               RenderMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVQuad>            Quads                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCanvasFunctions::DrawMaterialQuads(class UCanvas* Canvas, class UMaterialInterface* RenderMaterial, const TArray<struct FCanvasUVQuad>& Quads)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CanvasFunctions", "DrawMaterialQuads");

	Params::CanvasFunctions_DrawMaterialQuads Parms{};

	Parms.Canvas = Canvas;
	Parms.RenderMaterial = RenderMaterial;
	Parms.Quads = std::move(Quads);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorTools.GetRealTimeForUserInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float UEditorTools::GetRealTimeForUserInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "GetRealTimeForUserInterface");

	Params::EditorTools_GetRealTimeForUserInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EditorTools.GetSelectedActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ActorList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEditorTools::GetSelectedActors(TArray<class AActor*>* ActorList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "GetSelectedActors");

	Params::EditorTools_GetSelectedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActorList != nullptr)
		*ActorList = std::move(Parms.ActorList);
}


// Function Flame.EditorTools.IsPreviewActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorTools::IsPreviewActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "IsPreviewActor");

	Params::EditorTools_IsPreviewActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EditorTools.SelectActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddToSelection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorTools::SelectActor(class AActor* Actor, bool AddToSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "SelectActor");

	Params::EditorTools_SelectActor Parms{};

	Parms.Actor = Actor;
	Parms.AddToSelection = AddToSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorTools.SelectNoActors
// (Final, Native, Static, Public, BlueprintCallable)

void UEditorTools::SelectNoActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "SelectNoActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorTools.UnSelectActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorTools::UnSelectActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorTools", "UnSelectActor");

	Params::EditorTools_UnSelectActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Customization.GetMeshForGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AGender>              Gender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ACustomization::GetMeshForGender(TSubclassOf<class AGender> Gender) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Customization", "GetMeshForGender");

	Params::Customization_GetMeshForGender Parms{};

	Parms.Gender = Gender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Customization.IsCompatibleWithSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACustomization::IsCompatibleWithSlot(TSubclassOf<class ACustomizationSlot> Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Customization", "IsCompatibleWithSlot");

	Params::Customization_IsCompatibleWithSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AimAssistComponent.OnInputDetectorModeChanged
// (Final, Native, Private)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputMode                              NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::OnInputDetectorModeChanged(int32 PlayerIndex, EInputMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "OnInputDetectorModeChanged");

	Params::AimAssistComponent_OnInputDetectorModeChanged Parms{};

	Parms.PlayerIndex = PlayerIndex;
	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.AddProceduralSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbienceAreaBase::AddProceduralSound(class USoundBase* Sound, float MinDelay, float MaxDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "AddProceduralSound");

	Params::AmbienceAreaBase_AddProceduralSound Parms{};

	Parms.Sound = Sound;
	Parms.MinDelay = MinDelay;
	Parms.MaxDelay = MaxDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.OnPlayProceduralSound
// (Event, Public, BlueprintEvent)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlaceOnGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbienceAreaBase::OnPlayProceduralSound(class USoundBase* Sound, bool PlaceOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "OnPlayProceduralSound");

	Params::AmbienceAreaBase_OnPlayProceduralSound Parms{};

	Parms.Sound = Sound;
	Parms.PlaceOnGround = PlaceOnGround;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.AmbienceAreaBase.StartGlobalAmbienceBlend
// (Final, Native, Public, BlueprintCallable)

void AAmbienceAreaBase::StartGlobalAmbienceBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "StartGlobalAmbienceBlend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.StartProceduralSounds
// (Final, Native, Public, BlueprintCallable)

void AAmbienceAreaBase::StartProceduralSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "StartProceduralSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.StopGlobalAmbienceBlend
// (Final, Native, Public, BlueprintCallable)

void AAmbienceAreaBase::StopGlobalAmbienceBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "StopGlobalAmbienceBlend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.StopProceduralSounds
// (Final, Native, Public, BlueprintCallable)

void AAmbienceAreaBase::StopProceduralSounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "StopProceduralSounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmbienceAreaBase.GetRelativeDistanceFromCenter
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInnerOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAmbienceAreaBase::GetRelativeDistanceFromCenter(const struct FVector& Location, bool bInnerOnly, bool bClamped) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmbienceAreaBase", "GetRelativeDistanceFromCenter");

	Params::AmbienceAreaBase_GetRelativeDistanceFromCenter Parms{};

	Parms.Location = std::move(Location);
	Parms.bInnerOnly = bInnerOnly;
	Parms.bClamped = bClamped;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.ItemsList.OnRep_PostChange
// (Final, Native, Private)

void UItemsList::OnRep_PostChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsList", "OnRep_PostChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ItemsList.OnRep_PostChangeClasses
// (Final, Native, Private)

void UItemsList::OnRep_PostChangeClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsList", "OnRep_PostChangeClasses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ItemsList.GetSlotsClassesConst
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FBackpackItemSlot>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FBackpackItemSlot> UItemsList::GetSlotsClassesConst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsList", "GetSlotsClassesConst");

	Params::ItemsList_GetSlotsClassesConst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingList.GetMissingPartsFor
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APlan>                OnePlanClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class APartItem>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class APartItem>> UCraftingList::GetMissingPartsFor(TSubclassOf<class APlan> OnePlanClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingList", "GetMissingPartsFor");

	Params::CraftingList_GetMissingPartsFor Parms{};

	Parms.OnePlanClass = OnePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingList.GetStashComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStashComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStashComponent* UCraftingList::GetStashComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingList", "GetStashComponent");

	Params::CraftingList_GetStashComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingList.HasAllPartsFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APlan>                OnePlanClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingList::HasAllPartsFor(TSubclassOf<class APlan> OnePlanClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingList", "HasAllPartsFor");

	Params::CraftingList_HasAllPartsFor Parms{};

	Parms.OnePlanClass = OnePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingList.IsPlanUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APlan>                OnePlanClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingList::IsPlanUnlocked(TSubclassOf<class APlan> OnePlanClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingList", "IsPlanUnlocked");

	Params::CraftingList_IsPlanUnlocked Parms{};

	Parms.OnePlanClass = OnePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AmmoCraftingList.AssemblyAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAmmoPlan*                        OnePlan                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAmmoItem*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAmmoItem* UAmmoCraftingList::AssemblyAmmo(const class AAmmoPlan* OnePlan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCraftingList", "AssemblyAmmo");

	Params::AmmoCraftingList_AssemblyAmmo Parms{};

	Parms.OnePlan = OnePlan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AmmoCraftingList.HasMaterialFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAmmoPlan*                        OnePlan                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAmmoCraftingList::HasMaterialFor(const class AAmmoPlan* OnePlan) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCraftingList", "HasMaterialFor");

	Params::AmmoCraftingList_HasMaterialFor Parms{};

	Parms.OnePlan = OnePlan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AmmoCraftingList.HowManyMaterialIsMissingFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAmmoPlan*                        OnePlan                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAmmoCraftingList::HowManyMaterialIsMissingFor(const class AAmmoPlan* OnePlan) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCraftingList", "HowManyMaterialIsMissingFor");

	Params::AmmoCraftingList_HowManyMaterialIsMissingFor Parms{};

	Parms.OnePlan = OnePlan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnalyticsManager.SendEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      EventData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnalyticsManager::SendEvent(class UObject* WorldContextObject, const class FString& EventName, class UJsonObject* EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnalyticsManager", "SendEvent");

	Params::AnalyticsManager_SendEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = std::move(EventName);
	Parms.EventData = EventData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnalyticsManager.OnCloudStateChange
// (Final, Native, Protected)
// Parameters:
// ECloudManagerState                      OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudManagerState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnalyticsManager::OnCloudStateChange(ECloudManagerState OldState, ECloudManagerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalyticsManager", "OnCloudStateChange");

	Params::AnalyticsManager_OnCloudStateChange Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.AdjustAttenuationExtended
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSoundAttenuationSettings        InAttenuationSettings                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAudioComponentExtended::AdjustAttenuationExtended(const struct FSoundAttenuationSettings& InAttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "AdjustAttenuationExtended");

	Params::AudioComponentExtended_AdjustAttenuationExtended Parms{};

	Parms.InAttenuationSettings = std::move(InAttenuationSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.FadeInDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponentExtended::FadeInDelayed(float Delay, float FadeInDuration, float FadeVolumeLevel, float StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "FadeInDelayed");

	Params::AudioComponentExtended_FadeInDelayed Parms{};

	Parms.Delay = Delay;
	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;
	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.FadeOutDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponentExtended::FadeOutDelayed(float Delay, float FadeOutDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "FadeOutDelayed");

	Params::AudioComponentExtended_FadeOutDelayed Parms{};

	Parms.Delay = Delay;
	Parms.FadeOutDuration = FadeOutDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.PlayDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponentExtended::PlayDelayed(float Delay, float StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "PlayDelayed");

	Params::AudioComponentExtended_PlayDelayed Parms{};

	Parms.Delay = Delay;
	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.SetApplyEnvironmentParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bApply                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponentExtended::SetApplyEnvironmentParameters(bool bApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "SetApplyEnvironmentParameters");

	Params::AudioComponentExtended_SetApplyEnvironmentParameters Parms{};

	Parms.bApply = bApply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.SetApplyWeatherParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponentExtended::SetApplyWeatherParameters(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "SetApplyWeatherParameters");

	Params::AudioComponentExtended_SetApplyWeatherParameters Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioComponentExtended.GetSoundTravelTimeForListener
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioComponentExtended::GetSoundTravelTimeForListener() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioComponentExtended", "GetSoundTravelTimeForListener");

	Params::AudioComponentExtended_GetSoundTravelTimeForListener Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemState.GetDebugString
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UItemState::GetDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemState", "GetDebugString");

	Params::ItemState_GetDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemState.GetPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStatePhase                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatePhase UItemState::GetPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemState", "GetPhase");

	Params::ItemState_GetPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemState.GetRunningTimeInSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemState::GetRunningTimeInSec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemState", "GetRunningTimeInSec");

	Params::ItemState_GetRunningTimeInSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.CalculateBoxAttenuationValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SourceLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SourceRotation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxOffset                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InnerRadiusRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      AttenuationCurveX                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      AttenuationCurveY                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      AttenuationCurveZ                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioFunctions::CalculateBoxAttenuationValue(const class UObject* WorldContextObject, const struct FVector& SourceLocation, const struct FRotator& SourceRotation, const struct FVector& BoxExtent, const struct FVector& BoxOffset, float InnerRadiusRatio, class UCurveFloat* AttenuationCurveX, class UCurveFloat* AttenuationCurveY, class UCurveFloat* AttenuationCurveZ, bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "CalculateBoxAttenuationValue");

	Params::AudioFunctions_CalculateBoxAttenuationValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.BoxOffset = std::move(BoxOffset);
	Parms.InnerRadiusRatio = InnerRadiusRatio;
	Parms.AttenuationCurveX = AttenuationCurveX;
	Parms.AttenuationCurveY = AttenuationCurveY;
	Parms.AttenuationCurveZ = AttenuationCurveZ;
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetAudioListenerLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ListenerIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAudioFunctions::GetAudioListenerLocation(const class UObject* WorldContextObject, int32 ListenerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetAudioListenerLocation");

	Params::AudioFunctions_GetAudioListenerLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ListenerIndex = ListenerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetAudioRelativeZLevel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioFunctions::GetAudioRelativeZLevel(const class UObject* WorldContextObject, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetAudioRelativeZLevel");

	Params::AudioFunctions_GetAudioRelativeZLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetAudioWeatherInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAudioWeatherInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAudioWeatherInfo UAudioFunctions::GetAudioWeatherInfo(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetAudioWeatherInfo");

	Params::AudioFunctions_GetAudioWeatherInfo Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetBoolParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioFunctions::GetBoolParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetBoolParameter");

	Params::AudioFunctions_GetBoolParameter Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetFloatParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioFunctions::GetFloatParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetFloatParameter");

	Params::AudioFunctions_GetFloatParameter Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetIntParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAudioFunctions::GetIntParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetIntParameter");

	Params::AudioFunctions_GetIntParameter Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetSoundByGender
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundBase*                       MaleSound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       FemaleSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorWithCustomizationComponent                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* UAudioFunctions::GetSoundByGender(class USoundBase* MaleSound, class USoundBase* FemaleSound, const class AActor* ActorWithCustomizationComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetSoundByGender");

	Params::AudioFunctions_GetSoundByGender Parms{};

	Parms.MaleSound = MaleSound;
	Parms.FemaleSound = FemaleSound;
	Parms.ActorWithCustomizationComponent = ActorWithCustomizationComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.GetSoundClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundClass* UAudioFunctions::GetSoundClass(class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "GetSoundClass");

	Params::AudioFunctions_GetSoundClass Parms{};

	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.HandleVehicleRainSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   RainAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RainAmountCurve                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::HandleVehicleRainSound(float RainAmount, class UCurveFloat* RainAmountCurve, class UAudioComponent* AudioComponent, float FadeInTime, float FadeOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "HandleVehicleRainSound");

	Params::AudioFunctions_HandleVehicleRainSound Parms{};

	Parms.RainAmount = RainAmount;
	Parms.RainAmountCurve = RainAmountCurve;
	Parms.AudioComponent = AudioComponent;
	Parms.FadeInTime = FadeInTime;
	Parms.FadeOutTime = FadeOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetAudioListener
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  ListenerComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAudioFunctions::SetAudioListener(class USceneComponent* ListenerComponent, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetAudioListener");

	Params::AudioFunctions_SetAudioListener Parms{};

	Parms.ListenerComponent = ListenerComponent;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetAudioListenerToCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetAudioListenerToCamera(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetAudioListenerToCamera");

	Params::AudioFunctions_SetAudioListenerToCamera Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetBoolParameterSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetBoolParameterSafe(class UAudioComponent* AudioComponent, class FName InName, bool InBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetBoolParameterSafe");

	Params::AudioFunctions_SetBoolParameterSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.InName = InName;
	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetDefaultAudioListener
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetDefaultAudioListener(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetDefaultAudioListener");

	Params::AudioFunctions_SetDefaultAudioListener Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetFloatParameterSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetFloatParameterSafe(class UAudioComponent* AudioComponent, class FName InName, float InFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetFloatParameterSafe");

	Params::AudioFunctions_SetFloatParameterSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.InName = InName;
	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetIntParameterSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetIntParameterSafe(class UAudioComponent* AudioComponent, class FName InName, int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetIntParameterSafe");

	Params::AudioFunctions_SetIntParameterSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.InName = InName;
	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetPitchMultiplierSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPitchMultiplier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetPitchMultiplierSafe(class UAudioComponent* AudioComponent, float NewPitchMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetPitchMultiplierSafe");

	Params::AudioFunctions_SetPitchMultiplierSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.NewPitchMultiplier = NewPitchMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetVolumeMultiplierSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewVolumeMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetVolumeMultiplierSafe(class UAudioComponent* AudioComponent, float NewVolumeMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetVolumeMultiplierSafe");

	Params::AudioFunctions_SetVolumeMultiplierSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.NewVolumeMultiplier = NewVolumeMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SetWaveParameterSafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                       InWave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFunctions::SetWaveParameterSafe(class UAudioComponent* AudioComponent, class FName InName, class USoundWave* InWave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SetWaveParameterSafe");

	Params::AudioFunctions_SetWaveParameterSafe Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.InName = InName;
	Parms.InWave = InWave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioFunctions.SpawnSoundAtLocationExtended
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSpeedOfSound                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponentExtended*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponentExtended* UAudioFunctions::SpawnSoundAtLocationExtended(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, float Delay, bool bUseSpeedOfSound, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SpawnSoundAtLocationExtended");

	Params::AudioFunctions_SpawnSoundAtLocationExtended Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.Delay = Delay;
	Parms.bUseSpeedOfSound = bUseSpeedOfSound;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.SpawnSoundAttachedExtended
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSpeedOfSound                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponentExtended*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponentExtended* UAudioFunctions::SpawnSoundAttachedExtended(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, float Delay, bool bUseSpeedOfSound, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SpawnSoundAttachedExtended");

	Params::AudioFunctions_SpawnSoundAttachedExtended Parms{};

	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.Delay = Delay;
	Parms.bUseSpeedOfSound = bUseSpeedOfSound;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioFunctions.SpawnVoiceSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       MaleSound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       FemaleSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  OwnerCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VoiceSoundType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RepeatTimeSeconds                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistAcrossLevelTransition                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponentExtended*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponentExtended* UAudioFunctions::SpawnVoiceSound(class USoundBase* MaleSound, class USoundBase* FemaleSound, class AHumanCharacter* OwnerCharacter, class FName VoiceSoundType, float RepeatTimeSeconds, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioFunctions", "SpawnVoiceSound");

	Params::AudioFunctions_SpawnVoiceSound Parms{};

	Parms.MaleSound = MaleSound;
	Parms.FemaleSound = FemaleSound;
	Parms.OwnerCharacter = OwnerCharacter;
	Parms.VoiceSoundType = VoiceSoundType;
	Parms.RepeatTimeSeconds = RepeatTimeSeconds;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioOcclusionComponentBase.CountIndexesFromTraceResults
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAudioOcclusionMainTraceResult   MainTrace                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FAudioOcclusionSideTraceResult>SideTraces                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   OcclusionIndex                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LowPassIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::CountIndexesFromTraceResults(const struct FAudioOcclusionMainTraceResult& MainTrace, const TArray<struct FAudioOcclusionSideTraceResult>& SideTraces, float* OcclusionIndex, float* LowPassIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "CountIndexesFromTraceResults");

	Params::AudioOcclusionComponentBase_CountIndexesFromTraceResults Parms{};

	Parms.MainTrace = std::move(MainTrace);
	Parms.SideTraces = std::move(SideTraces);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OcclusionIndex != nullptr)
		*OcclusionIndex = Parms.OcclusionIndex;

	if (LowPassIndex != nullptr)
		*LowPassIndex = Parms.LowPassIndex;
}


// Function Flame.AudioOcclusionComponentBase.EaseIndexes
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentOcclusionIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentLowPassIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousOcclusionIndex                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousLowPassIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EasedOcclusionIndex                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EasedLowPassIndex                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::EaseIndexes(float DeltaTime, float CurrentOcclusionIndex, float CurrentLowPassIndex, float PreviousOcclusionIndex, float PreviousLowPassIndex, float* EasedOcclusionIndex, float* EasedLowPassIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "EaseIndexes");

	Params::AudioOcclusionComponentBase_EaseIndexes Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.CurrentOcclusionIndex = CurrentOcclusionIndex;
	Parms.CurrentLowPassIndex = CurrentLowPassIndex;
	Parms.PreviousOcclusionIndex = PreviousOcclusionIndex;
	Parms.PreviousLowPassIndex = PreviousLowPassIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EasedOcclusionIndex != nullptr)
		*EasedOcclusionIndex = Parms.EasedOcclusionIndex;

	if (EasedLowPassIndex != nullptr)
		*EasedLowPassIndex = Parms.EasedLowPassIndex;
}


// Function Flame.AudioOcclusionComponentBase.LowPassIndexToLowPassFrequency
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   LowPassIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioOcclusionComponentBase::LowPassIndexToLowPassFrequency(float LowPassIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "LowPassIndexToLowPassFrequency");

	Params::AudioOcclusionComponentBase_LowPassIndexToLowPassFrequency Parms{};

	Parms.LowPassIndex = LowPassIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioOcclusionComponentBase.OcclusionIndexToVolumeMultiplier
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   OcclusionIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAudioOcclusionComponentBase::OcclusionIndexToVolumeMultiplier(float OcclusionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "OcclusionIndexToVolumeMultiplier");

	Params::AudioOcclusionComponentBase_OcclusionIndexToVolumeMultiplier Parms{};

	Parms.OcclusionIndex = OcclusionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AudioOcclusionComponentBase.PerformMainTrace
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAudioComponent*                  AudioSource                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAudioOcclusionMainTraceResult   Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PerformMainTrace(const class UAudioComponent* AudioSource, struct FAudioOcclusionMainTraceResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PerformMainTrace");

	Params::AudioOcclusionComponentBase_PerformMainTrace Parms{};

	Parms.AudioSource = AudioSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Flame.AudioOcclusionComponentBase.PerformSideTrace
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAudioComponent*                  AudioSource                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RingIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TraceInRingIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MainOcclusionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MainLowPassIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAudioOcclusionSideTraceResult   Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PerformSideTrace(const class UAudioComponent* AudioSource, int32 RingIndex, int32 TraceInRingIndex, float MainOcclusionIndex, float MainLowPassIndex, struct FAudioOcclusionSideTraceResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PerformSideTrace");

	Params::AudioOcclusionComponentBase_PerformSideTrace Parms{};

	Parms.AudioSource = AudioSource;
	Parms.RingIndex = RingIndex;
	Parms.TraceInRingIndex = TraceInRingIndex;
	Parms.MainOcclusionIndex = MainOcclusionIndex;
	Parms.MainLowPassIndex = MainLowPassIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Flame.AudioOcclusionComponentBase.PlayDebugSound
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PlayDebugSound(class USoundBase* SoundToPlay, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PlayDebugSound");

	Params::AudioOcclusionComponentBase_PlayDebugSound Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioOcclusionComponentBase.PrintDebugDepthTraceHitInfo
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Depth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DepthIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OcclusionIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PrintDebugDepthTraceHitInfo(EPhysicalSurface SurfaceType, float Depth, float DepthIndex, float Distance, float DistanceIndex, float OcclusionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PrintDebugDepthTraceHitInfo");

	Params::AudioOcclusionComponentBase_PrintDebugDepthTraceHitInfo Parms{};

	Parms.SurfaceType = SurfaceType;
	Parms.Depth = Depth;
	Parms.DepthIndex = DepthIndex;
	Parms.Distance = Distance;
	Parms.DistanceIndex = DistanceIndex;
	Parms.OcclusionIndex = OcclusionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioOcclusionComponentBase.PrintDebugFloat
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PrintDebugFloat(const class FString& Name_0, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PrintDebugFloat");

	Params::AudioOcclusionComponentBase_PrintDebugFloat Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioOcclusionComponentBase.PrintDebugString
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioOcclusionComponentBase::PrintDebugString(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "PrintDebugString");

	Params::AudioOcclusionComponentBase_PrintDebugString Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AudioOcclusionComponentBase.StopDebugSound
// (Final, Native, Public, BlueprintCallable)

void UAudioOcclusionComponentBase::StopDebugSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioOcclusionComponentBase", "StopDebugSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AmmoPlan.GetAmmoClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AAmmoItem>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AAmmoItem> AAmmoPlan::GetAmmoClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPlan", "GetAmmoClass");

	Params::AmmoPlan_GetAmmoClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomisationMeshComponent.GetSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationSlot>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomizationSlot> UCustomisationMeshComponent::GetSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomisationMeshComponent", "GetSlot");

	Params::CustomisationMeshComponent_GetSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.BlueprintDeInit
// (Event, Public, BlueprintEvent)

void UBattlePassSystem::BlueprintDeInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "BlueprintDeInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.BattlePassSystem.BlueprintInit
// (Event, Public, BlueprintEvent)

void UBattlePassSystem::BlueprintInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "BlueprintInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.BattlePassSystem.ClaimBattlePassRewards
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCloudBattlePassSeasonClaim>ClaimInfo                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::ClaimBattlePassRewards(class AHumanPlayerController* Player, const TArray<struct FCloudBattlePassSeasonClaim>& ClaimInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "ClaimBattlePassRewards");

	Params::BattlePassSystem_ClaimBattlePassRewards Parms{};

	Parms.Player = Player;
	Parms.ClaimInfo = std::move(ClaimInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.ClaimBattlePassRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudBattlePassRewardsClaim     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattlePassSystem::ClaimBattlePassRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassRewardsClaim& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "ClaimBattlePassRewardsDelegate__DelegateSignature");

	Params::BattlePassSystem_ClaimBattlePassRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.GetAllBattlePassSeasonsState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetAllBattlePassSeasonsState(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetAllBattlePassSeasonsState");

	Params::BattlePassSystem_GetAllBattlePassSeasonsState Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.GetAllBattlePassSeasonsStateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudBattlePassSeasonsState     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattlePassSystem::GetAllBattlePassSeasonsStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassSeasonsState& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetAllBattlePassSeasonsStateDelegate__DelegateSignature");

	Params::BattlePassSystem_GetAllBattlePassSeasonsStateDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.GetCurrentBattlePassSeasonState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetCurrentBattlePassSeasonState(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetCurrentBattlePassSeasonState");

	Params::BattlePassSystem_GetCurrentBattlePassSeasonState Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.GetCurrentBattlePassSeasonStateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudBattlePassSeasonState      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBattlePassSystem::GetCurrentBattlePassSeasonStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassSeasonState& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetCurrentBattlePassSeasonStateDelegate__DelegateSignature");

	Params::BattlePassSystem_GetCurrentBattlePassSeasonStateDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.GetGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFlameGameInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameInstance* UBattlePassSystem::GetGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetGameInstance");

	Params::BattlePassSystem_GetGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetLevelInSeason
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SeasonName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetLevelInSeason(class FName SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetLevelInSeason");

	Params::BattlePassSystem_GetLevelInSeason Parms{};

	Parms.SeasonName = SeasonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetPremiumStatus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SeasonName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattlePassSystem::GetPremiumStatus(class FName SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetPremiumStatus");

	Params::BattlePassSystem_GetPremiumStatus Parms{};

	Parms.SeasonName = SeasonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetSeasonName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattlePassSeasonType                   SeasonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBattlePassSystem::GetSeasonName(EBattlePassSeasonType SeasonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetSeasonName");

	Params::BattlePassSystem_GetSeasonName Parms{};

	Parms.SeasonType = SeasonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetTotalXP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SeasonName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetTotalXP(class FName SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetTotalXP");

	Params::BattlePassSystem_GetTotalXP Parms{};

	Parms.SeasonName = SeasonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetUnclaimedRewardsCode
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsLegacy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBattlePassLevelRewardFull>FreeRewards                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FBattlePassLevelRewardFull>PremiumRewards                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UBattlePassSystem::GetUnclaimedRewardsCode(bool IsLegacy, TArray<struct FBattlePassLevelRewardFull>* FreeRewards, TArray<struct FBattlePassLevelRewardFull>* PremiumRewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetUnclaimedRewardsCode");

	Params::BattlePassSystem_GetUnclaimedRewardsCode Parms{};

	Parms.IsLegacy = IsLegacy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FreeRewards != nullptr)
		*FreeRewards = std::move(Parms.FreeRewards);

	if (PremiumRewards != nullptr)
		*PremiumRewards = std::move(Parms.PremiumRewards);

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetXPBooster
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetXPBooster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetXPBooster");

	Params::BattlePassSystem_GetXPBooster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BattlePassSystem.GetXPWithinLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SeasonName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::GetXPWithinLevel(class FName SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "GetXPWithinLevel");

	Params::BattlePassSystem_GetXPWithinLevel Parms{};

	Parms.SeasonName = SeasonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.OnNewExperienceEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudBattlePassExperienceEvent  Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBattlePassSystem::OnNewExperienceEvent__DelegateSignature(class AHumanPlayerController* Player, const struct FCloudBattlePassExperienceEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "OnNewExperienceEvent__DelegateSignature");

	Params::BattlePassSystem_OnNewExperienceEvent__DelegateSignature Parms{};

	Parms.Player = Player;
	Parms.Event = std::move(Event);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.PurchaseBattlePassLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SeasonName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Price                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::PurchaseBattlePassLevel(class AHumanPlayerController* Player, const class FName& SeasonName, int32 CurrentLevel, int32 TargetLevel, int32 Price)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "PurchaseBattlePassLevel");

	Params::BattlePassSystem_PurchaseBattlePassLevel Parms{};

	Parms.Player = Player;
	Parms.SeasonName = SeasonName;
	Parms.CurrentLevel = CurrentLevel;
	Parms.TargetLevel = TargetLevel;
	Parms.Price = Price;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.PurchaseBattlePassLevelDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudBattlePassLevelPurchase    Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattlePassSystem::PurchaseBattlePassLevelDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassLevelPurchase& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "PurchaseBattlePassLevelDelegate__DelegateSignature");

	Params::BattlePassSystem_PurchaseBattlePassLevelDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.SelectLegacySeason
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SeasonName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassSystem::SelectLegacySeason(class AHumanPlayerController* Player, const class FName& SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "SelectLegacySeason");

	Params::BattlePassSystem_SelectLegacySeason Parms{};

	Parms.Player = Player;
	Parms.SeasonName = SeasonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.BattlePassSystem.SelectLegacySeasonDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattlePassSystem::SelectLegacySeasonDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "SelectLegacySeasonDelegate__DelegateSignature");

	Params::BattlePassSystem_SelectLegacySeasonDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BattlePassSystem.Tick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattlePassSystem::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassSystem", "Tick");

	Params::BattlePassSystem_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BiSignificanceManagerImpl.MyPostSignificanceFunctionBody
// (Final, Native, Static, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bucket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABiSignificanceManagerImpl::MyPostSignificanceFunctionBody(class AActor* Actor, int32 Bucket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BiSignificanceManagerImpl", "MyPostSignificanceFunctionBody");

	Params::BiSignificanceManagerImpl_MyPostSignificanceFunctionBody Parms{};

	Parms.Actor = Actor;
	Parms.Bucket = Bucket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BitwiseBPFunctions.BitwiseShiftLeft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bits                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBitwiseBPFunctions::BitwiseShiftLeft(const int32 A, const int32 Bits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BitwiseBPFunctions", "BitwiseShiftLeft");

	Params::BitwiseBPFunctions_BitwiseShiftLeft Parms{};

	Parms.A = A;
	Parms.Bits = Bits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BitwiseBPFunctions.BitwiseShiftRight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bits                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBitwiseBPFunctions::BitwiseShiftRight(const int32 A, const int32 Bits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BitwiseBPFunctions", "BitwiseShiftRight");

	Params::BitwiseBPFunctions_BitwiseShiftRight Parms{};

	Parms.A = A;
	Parms.Bits = Bits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemUseState.GetMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemUseMode                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemUseMode UItemUseState::GetMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemUseState", "GetMode");

	Params::ItemUseState_GetMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemUseState.GetProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemUseState::GetProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemUseState", "GetProgress");

	Params::ItemUseState_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemUseState.GetTargetUnderCursor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UItemUseState::GetTargetUnderCursor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemUseState", "GetTargetUnderCursor");

	Params::ItemUseState_GetTargetUnderCursor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WorldLadder.Interact
// (Final, Native, Public)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorldLadder::Interact(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldLadder", "Interact");

	Params::WorldLadder_Interact Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementWidget.OnUpdateWidget
// (Event, Public, BlueprintEvent)

void UOptionsElementWidget::OnUpdateWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "OnUpdateWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.OptionsElementWidget.ResetElementToDefault
// (Native, Event, Public, BlueprintEvent)

void UOptionsElementWidget::ResetElementToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "ResetElementToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementWidget.SetValue
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FOptionsElementValue             InValues                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsElementWidget::SetValue(const struct FOptionsElementValue& InValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "SetValue");

	Params::OptionsElementWidget_SetValue Parms{};

	Parms.InValues = std::move(InValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementWidget.CanModifyElement
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsElementWidget::CanModifyElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "CanModifyElement");

	Params::OptionsElementWidget_CanModifyElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsElementWidget.CanResetElementToDefault
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsElementWidget::CanResetElementToDefault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "CanResetElementToDefault");

	Params::OptionsElementWidget_CanResetElementToDefault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsElementWidget.IsElementVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsElementWidget::IsElementVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "IsElementVisible");

	Params::OptionsElementWidget_IsElementVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsElementWidget.PopulateValues
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FOptionsElementValue             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOptionsElementValue UOptionsElementWidget::PopulateValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementWidget", "PopulateValues");

	Params::OptionsElementWidget_PopulateValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsElementPicker.OnNavigateIndex
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BypassConditions                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BroadcastValueChange                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsElementPicker::OnNavigateIndex(int32 Index_0, bool BypassConditions, bool BroadcastValueChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "OnNavigateIndex");

	Params::OptionsElementPicker_OnNavigateIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.BypassConditions = BypassConditions;
	Parms.BroadcastValueChange = BroadcastValueChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementPicker.OnNavigateNext
// (Final, Native, Private, BlueprintCallable)

void UOptionsElementPicker::OnNavigateNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "OnNavigateNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementPicker.OnNavigatePrevious
// (Final, Native, Private, BlueprintCallable)

void UOptionsElementPicker::OnNavigatePrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "OnNavigatePrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementPicker.OnNavigateVisualIndex
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsElementPicker::OnNavigateVisualIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "OnNavigateVisualIndex");

	Params::OptionsElementPicker_OnNavigateVisualIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementPicker.OnVisualUpdated
// (Event, Public, BlueprintEvent)

void UOptionsElementPicker::OnVisualUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "OnVisualUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.OptionsElementPicker.UpdateOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FOptionsPickerValue>      InOptions                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOptionsElementPicker::UpdateOptions(const TArray<struct FOptionsPickerValue>& InOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementPicker", "UpdateOptions");

	Params::OptionsElementPicker_UpdateOptions Parms{};

	Parms.InOptions = std::move(InOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.BinaryOperation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInvetoryItemDescriptor          LootItemDsc                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInvetoryItemDescriptor          HumanItemDsc                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryOperationsComponent::BinaryOperation(const struct FInvetoryItemDescriptor& LootItemDsc, const struct FInvetoryItemDescriptor& HumanItemDsc, const struct FInventoryOperationContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "BinaryOperation");

	Params::InventoryOperationsComponent_BinaryOperation Parms{};

	Parms.LootItemDsc = std::move(LootItemDsc);
	Parms.HumanItemDsc = std::move(HumanItemDsc);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.BinaryOperationSwitch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FInvetoryItemDescriptor          FirstDsc                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInvetoryItemDescriptor          SecondDsc                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EOperationResult                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOperationResult UInventoryOperationsComponent::BinaryOperationSwitch(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "BinaryOperationSwitch");

	Params::InventoryOperationsComponent_BinaryOperationSwitch Parms{};

	Parms.FirstDsc = std::move(FirstDsc);
	Parms.SecondDsc = std::move(SecondDsc);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.ClientConfirmOperation
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FInventoryOperationInfoServer    ResultFromServer                                       (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryOperationsComponent::ClientConfirmOperation(const struct FInventoryOperationInfoServer& ResultFromServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "ClientConfirmOperation");

	Params::InventoryOperationsComponent_ClientConfirmOperation Parms{};

	Parms.ResultFromServer = std::move(ResultFromServer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.ClientResetOperations
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UInventoryOperationsComponent::ClientResetOperations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "ClientResetOperations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.ServerAskForBinaryOperation
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FInvetoryItemDescriptor          FirstDsc                                               (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInvetoryItemDescriptor          SecondDsc                                              (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryOperationsComponent::ServerAskForBinaryOperation(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context, int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "ServerAskForBinaryOperation");

	Params::InventoryOperationsComponent_ServerAskForBinaryOperation Parms{};

	Parms.FirstDsc = std::move(FirstDsc);
	Parms.SecondDsc = std::move(SecondDsc);
	Parms.Context = std::move(Context);
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.ServerAskForUnaryOperation
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryOperationsComponent::ServerAskForUnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context, int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "ServerAskForUnaryOperation");

	Params::InventoryOperationsComponent_ServerAskForUnaryOperation Parms{};

	Parms.Descriptor = std::move(Descriptor);
	Parms.Context = std::move(Context);
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.UnaryOperation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryOperationsComponent::UnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "UnaryOperation");

	Params::InventoryOperationsComponent_UnaryOperation Parms{};

	Parms.Descriptor = std::move(Descriptor);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryOperationsComponent.UnaryOperationSwitch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EOperationResult                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOperationResult UInventoryOperationsComponent::UnaryOperationSwitch(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "UnaryOperationSwitch");

	Params::InventoryOperationsComponent_UnaryOperationSwitch Parms{};

	Parms.Descriptor = std::move(Descriptor);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.CanProcessBinaryOperation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInvetoryItemDescriptor          FirstDsc                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInvetoryItemDescriptor          SecondDsc                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryOperationsComponent::CanProcessBinaryOperation(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "CanProcessBinaryOperation");

	Params::InventoryOperationsComponent_CanProcessBinaryOperation Parms{};

	Parms.FirstDsc = std::move(FirstDsc);
	Parms.SecondDsc = std::move(SecondDsc);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.CanProcessBinaryOperationSwitch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInvetoryItemDescriptor          FirstDsc                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInvetoryItemDescriptor          SecondDsc                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryOperationsComponent::CanProcessBinaryOperationSwitch(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "CanProcessBinaryOperationSwitch");

	Params::InventoryOperationsComponent_CanProcessBinaryOperationSwitch Parms{};

	Parms.FirstDsc = std::move(FirstDsc);
	Parms.SecondDsc = std::move(SecondDsc);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.CanProcessUnaryOperation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryOperationsComponent::CanProcessUnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "CanProcessUnaryOperation");

	Params::InventoryOperationsComponent_CanProcessUnaryOperation Parms{};

	Parms.Descriptor = std::move(Descriptor);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.CanProcessUnaryOperationSwitch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInventoryOperationContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryOperationsComponent::CanProcessUnaryOperationSwitch(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "CanProcessUnaryOperationSwitch");

	Params::InventoryOperationsComponent_CanProcessUnaryOperationSwitch Parms{};

	Parms.Descriptor = std::move(Descriptor);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.FindOpositeEquipment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEquipmentStorageComponent*       Storage                                                (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentStorageComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentStorageComponent* UInventoryOperationsComponent::FindOpositeEquipment(const class UEquipmentStorageComponent* Storage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "FindOpositeEquipment");

	Params::InventoryOperationsComponent_FindOpositeEquipment Parms{};

	Parms.Storage = Storage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryOperationsComponent.FindParentEquipment
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInvetoryItemDescriptor          Descriptor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UEquipmentStorageComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentStorageComponent* UInventoryOperationsComponent::FindParentEquipment(const struct FInvetoryItemDescriptor& Descriptor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryOperationsComponent", "FindParentEquipment");

	Params::InventoryOperationsComponent_FindParentEquipment Parms{};

	Parms.Descriptor = std::move(Descriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.GetBuildingAtPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABuilding*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABuilding* UBuildingReferenceHelper::GetBuildingAtPoint(class UObject* WorldContext, const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "GetBuildingAtPoint");

	Params::BuildingReferenceHelper_GetBuildingAtPoint Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.ResolveDoorReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDoorReference                   Reference                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ADoor*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADoor* UBuildingReferenceHelper::ResolveDoorReference(const struct FDoorReference& Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "ResolveDoorReference");

	Params::BuildingReferenceHelper_ResolveDoorReference Parms{};

	Parms.Reference = std::move(Reference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.ResolveWindowReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWindowReference                 Reference                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AWindow*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWindow* UBuildingReferenceHelper::ResolveWindowReference(const struct FWindowReference& Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "ResolveWindowReference");

	Params::BuildingReferenceHelper_ResolveWindowReference Parms{};

	Parms.Reference = std::move(Reference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.ResolveWindowSashSetReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWindowSashSetReference          Reference                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AWindowSashSet*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWindowSashSet* UBuildingReferenceHelper::ResolveWindowSashSetReference(const struct FWindowSashSetReference& Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "ResolveWindowSashSetReference");

	Params::BuildingReferenceHelper_ResolveWindowSashSetReference Parms{};

	Parms.Reference = std::move(Reference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.UpdateDoorReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDoorReference                   RefToUpdate                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildingReferenceHelper::UpdateDoorReference(struct FDoorReference& RefToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "UpdateDoorReference");

	Params::BuildingReferenceHelper_UpdateDoorReference Parms{};

	Parms.RefToUpdate = std::move(RefToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RefToUpdate = std::move(Parms.RefToUpdate);

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.UpdateWindowReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWindowReference                 RefToUpdate                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildingReferenceHelper::UpdateWindowReference(struct FWindowReference& RefToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "UpdateWindowReference");

	Params::BuildingReferenceHelper_UpdateWindowReference Parms{};

	Parms.RefToUpdate = std::move(RefToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RefToUpdate = std::move(Parms.RefToUpdate);

	return Parms.ReturnValue;
}


// Function Flame.BuildingReferenceHelper.UpdateWindowSashSetReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWindowSashSetReference          RefToUpdate                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBuildingReferenceHelper::UpdateWindowSashSetReference(struct FWindowSashSetReference& RefToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildingReferenceHelper", "UpdateWindowSashSetReference");

	Params::BuildingReferenceHelper_UpdateWindowSashSetReference Parms{};

	Parms.RefToUpdate = std::move(RefToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RefToUpdate = std::move(Parms.RefToUpdate);

	return Parms.ReturnValue;
}


// Function Flame.Building.HideInterior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuilding::HideInterior(bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "HideInterior");

	Params::Building_HideInterior Parms{};

	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Building.GetDoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADoor*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADoor* ABuilding::GetDoor(const int32 Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "GetDoor");

	Params::Building_GetDoor Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Building.GetDoorIdx
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADoor*                            Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABuilding::GetDoorIdx(class ADoor* Door, int32* Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "GetDoorIdx");

	Params::Building_GetDoorIdx Parms{};

	Parms.Door = Door;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Idx != nullptr)
		*Idx = Parms.Idx;

	return Parms.ReturnValue;
}


// Function Flame.Building.GetWindow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWindow*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWindow* ABuilding::GetWindow(const int32 Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "GetWindow");

	Params::Building_GetWindow Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Building.GetWindowIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWindow*                          Window                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABuilding::GetWindowIndex(class AWindow* Window, int32* Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "GetWindowIndex");

	Params::Building_GetWindowIndex Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Idx != nullptr)
		*Idx = Parms.Idx;

	return Parms.ReturnValue;
}


// Function Flame.Building.MulticastLockDoorsAndWindows
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, Const)
// Parameters:
// EBuildingOverrideBehavior               DoorBehaviorExterior                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingOverrideBehavior               DoorBehaviorInterior                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingOverrideBehavior               WindowBehavior                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTakeDefaultFromObjectsIfNoChange                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuilding::MulticastLockDoorsAndWindows(const EBuildingOverrideBehavior DoorBehaviorExterior, const EBuildingOverrideBehavior DoorBehaviorInterior, const EBuildingOverrideBehavior WindowBehavior, bool bTakeDefaultFromObjectsIfNoChange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Building", "MulticastLockDoorsAndWindows");

	Params::Building_MulticastLockDoorsAndWindows Parms{};

	Parms.DoorBehaviorExterior = DoorBehaviorExterior;
	Parms.DoorBehaviorInterior = DoorBehaviorInterior;
	Parms.WindowBehavior = WindowBehavior;
	Parms.bTakeDefaultFromObjectsIfNoChange = bTakeDefaultFromObjectsIfNoChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.GetOtherActorDirection
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADoor::GetOtherActorDirection(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "GetOtherActorDirection");

	Params::Door_GetOtherActorDirection Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Door.GetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDoorState ADoor::GetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "GetState");

	Params::Door_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Door.HandleProgress
// (Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::HandleProgress(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "HandleProgress");

	Params::Door_HandleProgress Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.Interact
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::Interact(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "Interact");

	Params::Door_Interact Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.OnDoorClose
// (Event, Protected, BlueprintEvent)

void ADoor::OnDoorClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnDoorClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Door.OnDoorOpen
// (Event, Protected, BlueprintEvent)

void ADoor::OnDoorOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnDoorOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Door.OnRep_ChangeDoorState
// (Native, Protected)

void ADoor::OnRep_ChangeDoorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnRep_ChangeDoorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.ServerChangeStateTo
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// EDoorState                              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::ServerChangeStateTo(EDoorState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "ServerChangeStateTo");

	Params::Door_ServerChangeStateTo Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.SetCanOpenBackward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAble                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetCanOpenBackward(bool bAble)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetCanOpenBackward");

	Params::Door_SetCanOpenBackward Parms{};

	Parms.bAble = bAble;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.SetCanOpenForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAble                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetCanOpenForward(bool bAble)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetCanOpenForward");

	Params::Door_SetCanOpenForward Parms{};

	Parms.bAble = bAble;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.SetDoorBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlocked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorBlocked(bool bBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorBlocked");

	Params::Door_SetDoorBlocked Parms{};

	Parms.bBlocked = bBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.SetDoorLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorLocked(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorLocked");

	Params::Door_SetDoorLocked Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.SetDoorOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorOpen(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorOpen");

	Params::Door_SetDoorOpen Parms{};

	Parms.bOpen = bOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.TimelineFinished
// (Final, Native, Protected)

void ADoor::TimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "TimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Door.IsPointInFront
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::IsPointInFront(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "IsPointInFront");

	Params::Door_IsPointInFront Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BulletDecalManager.BeginPlay
// (Native, Protected)

void ABulletDecalManager::BeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDecalManager", "BeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletDecalManager.CreateDecal
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDecalInfo                       Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* ABulletDecalManager::CreateDecal(const struct FDecalInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDecalManager", "CreateDecal");

	Params::BulletDecalManager_CreateDecal Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.BulletDecalManager.DestroyDecal
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UDecalComponent*                  DecalActor                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletDecalManager::DestroyDecal(class UDecalComponent* DecalActor, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDecalManager", "DestroyDecal");

	Params::BulletDecalManager_DestroyDecal Parms{};

	Parms.DecalActor = DecalActor;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletDecalManager.RequestDecal
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Position                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SizeMultiplier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletDecalManager::RequestDecal(const struct FTransform& Position, class UMaterialInterface* Material, float SizeMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDecalManager", "RequestDecal");

	Params::BulletDecalManager_RequestDecal Parms{};

	Parms.Position = std::move(Position);
	Parms.Material = Material;
	Parms.SizeMultiplier = SizeMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletDecalManager.Tick
// (Native, Protected)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletDecalManager::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletDecalManager", "Tick");

	Params::BulletDecalManager_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ADSAction
// (Final, Native, Public)

void AHumanCharacter::ADSAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ADSAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.BeforeDied
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHumanCharacter::BeforeDied(float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "BeforeDied");

	Params::HumanCharacter_BeforeDied Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.BeginAdrenalineBoostTick
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::BeginAdrenalineBoostTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "BeginAdrenalineBoostTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.BlockADSInput
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::BlockADSInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "BlockADSInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.CalculateExplosionExposure
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExplosionComponent*              ExplosionComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FExplosionEffect                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FExplosionEffect AHumanCharacter::CalculateExplosionExposure(class UExplosionComponent* ExplosionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CalculateExplosionExposure");

	Params::HumanCharacter_CalculateExplosionExposure Parms{};

	Parms.ExplosionComponent = ExplosionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanAimChanged
// (Final, Native, Private)
// Parameters:
// class UObject*                          Sender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanAimComponentState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::CanAimChanged(class UObject* Sender, bool CanAimComponentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanAimChanged");

	Params::HumanCharacter_CanAimChanged Parms{};

	Parms.Sender = Sender;
	Parms.CanAimComponentState = CanAimComponentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ChamberAction
// (Final, Native, Public)

void AHumanCharacter::ChamberAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ChamberAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ChangeFireModeAction
// (Final, Native, Public)

void AHumanCharacter::ChangeFireModeAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ChangeFireModeAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.CheatToggleDebugAmmoReplication
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::CheatToggleDebugAmmoReplication()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CheatToggleDebugAmmoReplication");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientAskForUpdateWeaponAmmo
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientAskForUpdateWeaponAmmo(class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientAskForUpdateWeaponAmmo");

	Params::HumanCharacter_ClientAskForUpdateWeaponAmmo Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDeselectCurrentItem
// (Net, NetReliable, Native, Event, Public, NetClient)

void AHumanCharacter::ClientDeselectCurrentItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDeselectCurrentItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawBox
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FBoxCollider                     Box                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawBox(const struct FBoxCollider& Box, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawBox");

	Params::HumanCharacter_ClientDrawBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawBoxCustom
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawBoxCustom(const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, const float LifeTime, const float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawBoxCustom");

	Params::HumanCharacter_ClientDrawBoxCustom Parms{};

	Parms.Center = std::move(Center);
	Parms.Extent = std::move(Extent);
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.LifeTime = LifeTime;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawCapsule
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FCapsuleCollider                 Capsule                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawCapsule(const struct FCapsuleCollider& Capsule, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawCapsule");

	Params::HumanCharacter_ClientDrawCapsule Parms{};

	Parms.Capsule = std::move(Capsule);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawCapsuleCustom
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawCapsuleCustom(const struct FVector& Center, const float HalfHeight, const float Radius, const struct FQuat& Rotation, const struct FColor& Color, const float LifeTime, const float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawCapsuleCustom");

	Params::HumanCharacter_ClientDrawCapsuleCustom Parms{};

	Parms.Center = std::move(Center);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.LifeTime = LifeTime;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawDebugBox
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawDebugBox(const struct FVector& Location, const struct FVector& BoxExtent, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawDebugBox");

	Params::HumanCharacter_ClientDrawDebugBox Parms{};

	Parms.Location = std::move(Location);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawDebugLine
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Colour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawDebugLine(const struct FVector& Start, const struct FVector& End, float Time, const struct FColor& Colour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawDebugLine");

	Params::HumanCharacter_ClientDrawDebugLine Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Time = Time;
	Parms.Colour = std::move(Colour);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawLine
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawLine(const struct FVector& Start, const struct FVector& End, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawLine");

	Params::HumanCharacter_ClientDrawLine Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientDrawLineCustom
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientDrawLineCustom(const struct FVector& Start, const struct FVector& End, const struct FColor& Color, const float LifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientDrawLineCustom");

	Params::HumanCharacter_ClientDrawLineCustom Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Color = std::move(Color);
	Parms.LifeTime = LifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientLogLagswitchingStats
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bDisconnected                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToLagswitchProtection                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Strikes                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientLogLagswitchingStats(const bool bDisconnected, const float TimeToLagswitchProtection, const int32 Strikes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientLogLagswitchingStats");

	Params::HumanCharacter_ClientLogLagswitchingStats Parms{};

	Parms.bDisconnected = bDisconnected;
	Parms.TimeToLagswitchProtection = TimeToLagswitchProtection;
	Parms.Strikes = Strikes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientOnOtherPlayerHit
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItemClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        AffectedItems                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientOnOtherPlayerHit(float DamageAmount, EDamageType DamageType, class AHumanCharacter* Victim, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResult& HitResult, const TArray<TSubclassOf<class AItem>>& AffectedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientOnOtherPlayerHit");

	Params::HumanCharacter_ClientOnOtherPlayerHit Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.Victim = Victim;
	Parms.InstigatingItemClass = InstigatingItemClass;
	Parms.HitResult = std::move(HitResult);
	Parms.AffectedItems = std::move(AffectedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientOnShowHitMarkerOfColor
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   CrosshairScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientOnShowHitMarkerOfColor(float CrosshairScale, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientOnShowHitMarkerOfColor");

	Params::HumanCharacter_ClientOnShowHitMarkerOfColor Parms{};

	Parms.CrosshairScale = CrosshairScale;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientPlayStaggerSound
// (Net, NetReliable, Native, Event, Public, NetClient)

void AHumanCharacter::ClientPlayStaggerSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientPlayStaggerSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientShowDebugMessage
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientShowDebugMessage(const float Duration, const class FString& Message, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientShowDebugMessage");

	Params::HumanCharacter_ClientShowDebugMessage Parms{};

	Parms.Duration = Duration;
	Parms.Message = std::move(Message);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ClientUpdateWeaponsAmmo
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// TArray<struct FAmmoSyncMessage>         Messages                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanCharacter::ClientUpdateWeaponsAmmo(const TArray<struct FAmmoSyncMessage>& Messages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ClientUpdateWeaponsAmmo");

	Params::HumanCharacter_ClientUpdateWeaponsAmmo Parms{};

	Parms.Messages = std::move(Messages);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ConfirmLadderAttach
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class AWorldLadder*                     Ladder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ActorLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ConfirmLadderAttach(class AWorldLadder* Ladder, const struct FVector& ActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ConfirmLadderAttach");

	Params::HumanCharacter_ConfirmLadderAttach Parms{};

	Parms.Ladder = Ladder;
	Parms.ActorLocation = std::move(ActorLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.CrouchAction
// (Final, Native, Public)

void AHumanCharacter::CrouchAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CrouchAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.CrouchIgnoringMovement
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::CrouchIgnoringMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CrouchIgnoringMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.Die
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHumanCharacter::Die(float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "Die");

	Params::HumanCharacter_Die Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.DisableAimingAffectedByConcussion
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableAimingAffectedByConcussion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableAimingAffectedByConcussion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableControlRotationYaw
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableJump
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableMainStances
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableMainStances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableMainStances");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableMovement
// (Native, Public, BlueprintCallable)

void AHumanCharacter::DisableMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableMovementForDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::DisableMovementForDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableMovementForDuration");

	Params::HumanCharacter_DisableMovementForDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableProne
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DisableTheUseOfConsumables
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::DisableTheUseOfConsumables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DisableTheUseOfConsumables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DrawDebugHeadLocation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              Location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetRole                                CallerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::DrawDebugHeadLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DrawDebugHeadLocation");

	Params::HumanCharacter_DrawDebugHeadLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.CallerRole = CallerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DrawDebugMuzzleLocation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              Location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetRole                                CallerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::DrawDebugMuzzleLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DrawDebugMuzzleLocation");

	Params::HumanCharacter_DrawDebugMuzzleLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.CallerRole = CallerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DrawDebugTargetLocation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              Location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetRole                                CallerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::DrawDebugTargetLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DrawDebugTargetLocation");

	Params::HumanCharacter_DrawDebugTargetLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.CallerRole = CallerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.DrawMeleeDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasHit                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasAuthority                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::DrawMeleeDebug(const struct FVector& Start, const struct FVector& End, const bool bHasHit, const bool bHasAuthority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "DrawMeleeDebug");

	Params::HumanCharacter_DrawMeleeDebug Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.bHasHit = bHasHit;
	Parms.bHasAuthority = bHasAuthority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableAimingAffectedByConcussion
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableAimingAffectedByConcussion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableAimingAffectedByConcussion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableControlRotationYaw
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableJump
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableMainStances
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableMainStances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableMainStances");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableMovement
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableProne
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.EnableTheUseOfConsumables
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::EnableTheUseOfConsumables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "EnableTheUseOfConsumables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.FireAction
// (Final, Native, Public)

void AHumanCharacter::FireAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "FireAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.GetAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHumanAnimInstace*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHumanAnimInstace* AHumanCharacter::GetAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetAnimInstance");

	Params::HumanCharacter_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetSpecialDamageAmountForCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  EnemyTakingDamage                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentDamageAmount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::GetSpecialDamageAmountForCharacter(const class AHumanCharacter* EnemyTakingDamage, float CurrentDamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetSpecialDamageAmountForCharacter");

	Params::HumanCharacter_GetSpecialDamageAmountForCharacter Parms{};

	Parms.EnemyTakingDamage = EnemyTakingDamage;
	Parms.CurrentDamageAmount = CurrentDamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.HasThrown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AHumanCharacter::HasThrown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "HasThrown");

	Params::HumanCharacter_HasThrown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.HolsterAction
// (Final, Native, Public)

void AHumanCharacter::HolsterAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "HolsterAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.InWaterTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::InWaterTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "InWaterTick");

	Params::HumanCharacter_InWaterTick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.JumpAction
// (Final, Native, Public)

void AHumanCharacter::JumpAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "JumpAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastAddWound
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVector_NetQuantize              HitWorldPosition                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastAddWound(const struct FVector_NetQuantize& HitWorldPosition, class UPrimitiveComponent* HitComponent, class FName HitBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastAddWound");

	Params::HumanCharacter_MulticastAddWound Parms{};

	Parms.HitWorldPosition = std::move(HitWorldPosition);
	Parms.HitComponent = HitComponent;
	Parms.HitBoneName = HitBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastBeginAdrenalineBoost
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void AHumanCharacter::MulticastBeginAdrenalineBoost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastBeginAdrenalineBoost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastDie
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LastItemDamageCauserID                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastDie(float DamageAmount, const struct FHitResult& HitResult, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const int32 LastItemDamageCauserID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastDie");

	Params::HumanCharacter_MulticastDie Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitResult = std::move(HitResult);
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;
	Parms.LastItemDamageCauserID = LastItemDamageCauserID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastDisableControlRotationYaw
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AHumanCharacter::MulticastDisableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastDisableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastEnableControlRotationYaw
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AHumanCharacter::MulticastEnableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastEnableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastPlayGesture
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UAnimMontage*                     GestureToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastPlayGesture(class UAnimMontage* GestureToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastPlayGesture");

	Params::HumanCharacter_MulticastPlayGesture Parms{};

	Parms.GestureToPlay = GestureToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastSetCollision
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    NewCollision                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastSetCollision(bool NewCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastSetCollision");

	Params::HumanCharacter_MulticastSetCollision Parms{};

	Parms.NewCollision = NewCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastSetPlayerGroup
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FString                           NewGroup                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastSetPlayerGroup(const class FString& NewGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastSetPlayerGroup");

	Params::HumanCharacter_MulticastSetPlayerGroup Parms{};

	Parms.NewGroup = std::move(NewGroup);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastStaggerPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// float                                   StunDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastStaggerPlayer(float StunDuration, float Damage, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastStaggerPlayer");

	Params::HumanCharacter_MulticastStaggerPlayer Parms{};

	Parms.StunDuration = StunDuration;
	Parms.Damage = Damage;
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastStopGesture
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void AHumanCharacter::MulticastStopGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastStopGesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitResult                                              (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        Direction                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingActor                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        AffectedItems                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastTakeDamage(float DamageAmount, const struct FHitResultSimplified& HitResult, const struct FVector_NetQuantizeNormal& Direction, const class AHumanCharacter* InstigatingActor, const class AActor* DamageCauser, EDamageType DamageType, const TArray<TSubclassOf<class AItem>>& AffectedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastTakeDamage");

	Params::HumanCharacter_MulticastTakeDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitResult = std::move(HitResult);
	Parms.Direction = std::move(Direction);
	Parms.InstigatingActor = InstigatingActor;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageType = DamageType;
	Parms.AffectedItems = std::move(AffectedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.MulticastUpdateWeaponAmmo
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// struct FAmmoSyncMessage                 Message                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanCharacter::MulticastUpdateWeaponAmmo(const struct FAmmoSyncMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "MulticastUpdateWeaponAmmo");

	Params::HumanCharacter_MulticastUpdateWeaponAmmo Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnAfterRespawn
// (Event, Public, BlueprintEvent)

void AHumanCharacter::OnAfterRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnAfterRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanCharacter.OnItemChangedStart
// (Final, Native, Private)
// Parameters:
// class UGameplayActionsComponent*        GAC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            NewItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            OldItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnItemChangedStart(class UGameplayActionsComponent* GAC, class AItem* NewItem, class AItem* OldItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnItemChangedStart");

	Params::HumanCharacter_OnItemChangedStart Parms{};

	Parms.GAC = GAC;
	Parms.NewItem = NewItem;
	Parms.OldItem = OldItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnMeshChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnMeshChanged(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnMeshChanged");

	Params::HumanCharacter_OnMeshChanged Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnOtherPlayerHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItemClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        AffectedItems                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void AHumanCharacter::OnOtherPlayerHit(float DamageAmount, EDamageType DamageType, class AHumanCharacter* Victim, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResult& HitResult, const TArray<TSubclassOf<class AItem>>& AffectedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnOtherPlayerHit");

	Params::HumanCharacter_OnOtherPlayerHit Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.Victim = Victim;
	Parms.InstigatingItemClass = InstigatingItemClass;
	Parms.HitResult = std::move(HitResult);
	Parms.AffectedItems = std::move(AffectedItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.OnPlayerDied
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::OnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnPlayerDied");

	Params::HumanCharacter_OnPlayerDied Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitResult = std::move(HitResult);
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.OnPlayerEnterWater
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ImpactLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WaterDepthAtImpact                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WaterDepthInFront                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnPlayerEnterWater(const struct FVector& ImpactLocation, float WaterDepthAtImpact, float WaterDepthInFront)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnPlayerEnterWater");

	Params::HumanCharacter_OnPlayerEnterWater Parms{};

	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.WaterDepthAtImpact = WaterDepthAtImpact;
	Parms.WaterDepthInFront = WaterDepthInFront;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.OnPlayerExitWater
// (Event, Public, BlueprintEvent)

void AHumanCharacter::OnPlayerExitWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnPlayerExitWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanCharacter.OnRep_ArchetypeName
// (Final, Native, Private)

void AHumanCharacter::OnRep_ArchetypeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_ArchetypeName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_CompressedLookRotation
// (Final, Native, Private)

void AHumanCharacter::OnRep_CompressedLookRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_CompressedLookRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_DisableMovementClount
// (Final, Native, Public)
// Parameters:
// uint8                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnRep_DisableMovementClount(uint8 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_DisableMovementClount");

	Params::HumanCharacter_OnRep_DisableMovementClount Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_PlayerCameraDirection
// (Final, Native, Public)

void AHumanCharacter::OnRep_PlayerCameraDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_PlayerCameraDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_PlayerCameraStart
// (Final, Native, Public)

void AHumanCharacter::OnRep_PlayerCameraStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_PlayerCameraStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_PostChangeAttachedCharacters
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<class AHumanCharacter*>          OldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanCharacter::OnRep_PostChangeAttachedCharacters(const TArray<class AHumanCharacter*>& OldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_PostChangeAttachedCharacters");

	Params::HumanCharacter_OnRep_PostChangeAttachedCharacters Parms{};

	Parms.OldArray = std::move(OldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnRep_WaterOverlapped
// (Final, Native, Private)
// Parameters:
// class UWaterComponent*                  OldValue                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnRep_WaterOverlapped(class UWaterComponent* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnRep_WaterOverlapped");

	Params::HumanCharacter_OnRep_WaterOverlapped Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnShowHitMarkerOfColor
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   CrosshairScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::OnShowHitMarkerOfColor(float CrosshairScale, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnShowHitMarkerOfColor");

	Params::HumanCharacter_OnShowHitMarkerOfColor Parms{};

	Parms.CrosshairScale = CrosshairScale;
	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.OnStaminaDepleted
// (Native, Public)

void AHumanCharacter::OnStaminaDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnStaminaDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.OnTakeDamage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingActor                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItemClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitOptimised                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        AffectedItems                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void AHumanCharacter::OnTakeDamage(float DamageAmount, EDamageType DamageType, const class AHumanCharacter* InstigatingActor, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResultSimplified& HitOptimised, const TArray<TSubclassOf<class AItem>>& AffectedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnTakeDamage");

	Params::HumanCharacter_OnTakeDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingActor = InstigatingActor;
	Parms.InstigatingItemClass = InstigatingItemClass;
	Parms.HitOptimised = std::move(HitOptimised);
	Parms.AffectedItems = std::move(AffectedItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.OnTakeMeleeDamageOnClient
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  PlayerInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemCategory                           InstigatingItemCategory                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitOptimised                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHumanCharacter::OnTakeMeleeDamageOnClient(const class AHumanCharacter* PlayerInstigator, EItemCategory InstigatingItemCategory, const struct FHitResultSimplified& HitOptimised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "OnTakeMeleeDamageOnClient");

	Params::HumanCharacter_OnTakeMeleeDamageOnClient Parms{};

	Parms.PlayerInstigator = PlayerInstigator;
	Parms.InstigatingItemCategory = InstigatingItemCategory;
	Parms.HitOptimised = std::move(HitOptimised);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.PlayGesture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     GestureToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::PlayGesture(class UAnimMontage* GestureToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "PlayGesture");

	Params::HumanCharacter_PlayGesture Parms{};

	Parms.GestureToPlay = GestureToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.PlayStaggerSound
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsInstigator                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsVictim                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::PlayStaggerSound(const bool bIsInstigator, const bool bIsVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "PlayStaggerSound");

	Params::HumanCharacter_PlayStaggerSound Parms{};

	Parms.bIsInstigator = bIsInstigator;
	Parms.bIsVictim = bIsVictim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.ProcessExplosion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExplosionComponent*              ExplosionComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FExplosionEffect                 Explosion                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ProcessExplosion(class UExplosionComponent* ExplosionComponent, const struct FExplosionEffect& Explosion, const EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ProcessExplosion");

	Params::HumanCharacter_ProcessExplosion Parms{};

	Parms.ExplosionComponent = ExplosionComponent;
	Parms.Explosion = std::move(Explosion);
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ProneAction
// (Final, Native, Public)

void AHumanCharacter::ProneAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ProneAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.QuickMeleeAction
// (Final, Native, Public)

void AHumanCharacter::QuickMeleeAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "QuickMeleeAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ReceiveOnFire
// (Event, Public, BlueprintEvent)

void AHumanCharacter::ReceiveOnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ReceiveOnFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanCharacter.ReloadAction
// (Final, Native, Public)

void AHumanCharacter::ReloadAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ReloadAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ResetAnimInstance
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::ResetAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ResetAnimInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ResetInteract
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::ResetInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ResetInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.Respawn
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   RemainingLifeTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::Respawn(float RemainingLifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "Respawn");

	Params::HumanCharacter_Respawn Parms{};

	Parms.RemainingLifeTime = RemainingLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SelectWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponSlotType                         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SelectWeapon(EWeaponSlotType Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SelectWeapon");

	Params::HumanCharacter_SelectWeapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SendMovementDebugDataToServer
// (Net, Native, Event, Public, NetServer)
// Parameters:
// float                                   CurrentSpeed                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SendMovementDebugDataToServer(const float CurrentSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SendMovementDebugDataToServer");

	Params::HumanCharacter_SendMovementDebugDataToServer Parms{};

	Parms.CurrentSpeed = CurrentSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerAskForUpdateWeaponsAmmo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AHumanCharacter::ServerAskForUpdateWeaponsAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerAskForUpdateWeaponsAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerDisableControlRotationYaw
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerDisableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerDisableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerDisableMovement
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerDisableMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerDisableMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerEnableControlRotationYaw
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerEnableControlRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerEnableControlRotationYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerEnableHitRegistrationDebug
// (Final, Net, Native, Event, Private, NetServer)

void AHumanCharacter::ServerEnableHitRegistrationDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerEnableHitRegistrationDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerEnableMovement
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerEnableMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerEnableMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerPlayGesture
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UAnimMontage*                     GestureToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerPlayGesture(class UAnimMontage* GestureToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerPlayGesture");

	Params::HumanCharacter_ServerPlayGesture Parms{};

	Parms.GestureToPlay = GestureToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerReloadNotify
// (Net, NetReliable, Native, Event, Public, NetServer)

void AHumanCharacter::ServerReloadNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerReloadNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerRequestLadderAttach
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class AWorldLadder*                     Ladder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerRequestLadderAttach(class AWorldLadder* Ladder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerRequestLadderAttach");

	Params::HumanCharacter_ServerRequestLadderAttach Parms{};

	Parms.Ladder = Ladder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerSetAimingDebug
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerSetAimingDebug(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerSetAimingDebug");

	Params::HumanCharacter_ServerSetAimingDebug Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerSetAllowReload
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerSetAllowReload(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerSetAllowReload");

	Params::HumanCharacter_ServerSetAllowReload Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerSetArchetype
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FString                           InArchetypeName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerSetArchetype(const class FString& InArchetypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerSetArchetype");

	Params::HumanCharacter_ServerSetArchetype Parms{};

	Parms.InArchetypeName = std::move(InArchetypeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerSetInfiniteAmmo
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerSetInfiniteAmmo(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerSetInfiniteAmmo");

	Params::HumanCharacter_ServerSetInfiniteAmmo Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerSetInfiniteReload
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerSetInfiniteReload(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerSetInfiniteReload");

	Params::HumanCharacter_ServerSetInfiniteReload Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerStopGesture
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanCharacter::ServerStopGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerStopGesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerToggleInfiniteAmmo
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerToggleInfiniteAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerToggleInfiniteAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerToggleInfiniteReload
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AHumanCharacter::ServerToggleInfiniteReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerToggleInfiniteReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ServerUpdateWeaponAmmo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FAmmoSyncMessage                 Message                                                (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanCharacter::ServerUpdateWeaponAmmo(const struct FAmmoSyncMessage& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ServerUpdateWeaponAmmo");

	Params::HumanCharacter_ServerUpdateWeaponAmmo Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetADS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetADS(bool IsADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetADS");

	Params::HumanCharacter_SetADS Parms{};

	Parms.IsADS = IsADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetADSDesiredHold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetADSDesiredHold(bool IsADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetADSDesiredHold");

	Params::HumanCharacter_SetADSDesiredHold Parms{};

	Parms.IsADS = IsADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetADSDesiredTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetADSDesiredTrigger(bool IsADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetADSDesiredTrigger");

	Params::HumanCharacter_SetADSDesiredTrigger Parms{};

	Parms.IsADS = IsADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetADSThrowable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetADSThrowable(bool IsADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetADSThrowable");

	Params::HumanCharacter_SetADSThrowable Parms{};

	Parms.IsADS = IsADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetAimingDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetAimingDebug(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetAimingDebug");

	Params::HumanCharacter_SetAimingDebug Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetAllowFire
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAllowFire                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetAllowFire(bool bNewAllowFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetAllowFire");

	Params::HumanCharacter_SetAllowFire Parms{};

	Parms.bNewAllowFire = bNewAllowFire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetCharacterVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetCharacterVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetCharacterVisible");

	Params::HumanCharacter_SetCharacterVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetSprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Sprint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetSprint(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetSprint");

	Params::HumanCharacter_SetSprint Parms{};

	Parms.Sprint = Sprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetWantsToSprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Sprint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetWantsToSprint(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetWantsToSprint");

	Params::HumanCharacter_SetWantsToSprint Parms{};

	Parms.Sprint = Sprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetWantsToSprintHotFix
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Sprint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetWantsToSprintHotFix(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetWantsToSprintHotFix");

	Params::HumanCharacter_SetWantsToSprintHotFix Parms{};

	Parms.Sprint = Sprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetWeaponRaised
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsWeaponRaised                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetWeaponRaised(bool IsWeaponRaised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetWeaponRaised");

	Params::HumanCharacter_SetWeaponRaised Parms{};

	Parms.IsWeaponRaised = IsWeaponRaised;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SetWeightModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWeightModifier                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::SetWeightModifier(const float NewWeightModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SetWeightModifier");

	Params::HumanCharacter_SetWeightModifier Parms{};

	Parms.NewWeightModifier = NewWeightModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ShouldTakeDamageBP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::ShouldTakeDamageBP(class AHumanCharacter* InstigatingCharacter, const class AActor* DamageCauser, TSubclassOf<class AItem> ItemClass, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ShouldTakeDamageBP");

	Params::HumanCharacter_ShouldTakeDamageBP Parms{};

	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.DamageCauser = DamageCauser;
	Parms.ItemClass = ItemClass;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.ShowBulletIndicatorNative
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsPlayerHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitOptimised                                           (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHumanCharacter::ShowBulletIndicatorNative(bool bIsPlayerHit, EDamageType DamageType, const class AHumanCharacter* PlayerInstigator, const struct FVector& Origin, const struct FHitResultSimplified& HitOptimised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ShowBulletIndicatorNative");

	Params::HumanCharacter_ShowBulletIndicatorNative Parms{};

	Parms.bIsPlayerHit = bIsPlayerHit;
	Parms.DamageType = DamageType;
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.Origin = std::move(Origin);
	Parms.HitOptimised = std::move(HitOptimised);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SprintAction
// (Final, Native, Public)

void AHumanCharacter::SprintAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SprintAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StandAction
// (Final, Native, Public)

void AHumanCharacter::StandAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StandAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StartDiggingInteraction
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::StartDiggingInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StartDiggingInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopADSAction
// (Final, Native, Public)

void AHumanCharacter::StopADSAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopADSAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopChamberAction
// (Final, Native, Public)

void AHumanCharacter::StopChamberAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopChamberAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopDiggingInteraction
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::StopDiggingInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopDiggingInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopFireAction
// (Final, Native, Public)

void AHumanCharacter::StopFireAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopFireAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopGestureAction
// (Final, Native, Public)

void AHumanCharacter::StopGestureAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopGestureAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopJumpAction
// (Final, Native, Public)

void AHumanCharacter::StopJumpAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopJumpAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopReloadAction
// (Final, Native, Public)

void AHumanCharacter::StopReloadAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopReloadAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopSprintAction
// (Final, Native, Public)

void AHumanCharacter::StopSprintAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopSprintAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopThrowableAimingAction
// (Final, Native, Public)

void AHumanCharacter::StopThrowableAimingAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopThrowableAimingAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.StopUseAction
// (Final, Native, Public)

void AHumanCharacter::StopUseAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "StopUseAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.SwitchAction
// (Final, Native, Public)

void AHumanCharacter::SwitchAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "SwitchAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.TakeDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::TakeDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "TakeDamage");

	Params::HumanCharacter_TakeDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.ItemClass = ItemClass;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.TakeDamageOnClosestBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::TakeDamageOnClosestBone(float DamageAmount, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "TakeDamageOnClosestBone");

	Params::HumanCharacter_TakeDamageOnClosestBone Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.ItemClass = ItemClass;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ThrowableAimingAction
// (Final, Native, Public)

void AHumanCharacter::ThrowableAimingAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ThrowableAimingAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ToggleCrouch
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::ToggleCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ToggleCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ToggleCrouchAction
// (Final, Native, Public)

void AHumanCharacter::ToggleCrouchAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ToggleCrouchAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ToggleProne
// (Final, Native, Public, BlueprintCallable)

void AHumanCharacter::ToggleProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ToggleProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.ToggleProneAction
// (Final, Native, Public)

void AHumanCharacter::ToggleProneAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ToggleProneAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.UpdateAdrenalineDeprivationEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::UpdateAdrenalineDeprivationEffect(float Strength, float RemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "UpdateAdrenalineDeprivationEffect");

	Params::HumanCharacter_UpdateAdrenalineDeprivationEffect Parms{};

	Parms.Strength = Strength;
	Parms.RemainingTime = RemainingTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.UpdateStaggerEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::UpdateStaggerEffect(float Strength, float RemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "UpdateStaggerEffect");

	Params::HumanCharacter_UpdateStaggerEffect Parms{};

	Parms.Strength = Strength;
	Parms.RemainingTime = RemainingTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanCharacter.UseAction
// (Final, Native, Public)

void AHumanCharacter::UseAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "UseAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.VerifyHitOnServer
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class AHumanCharacter*                  Shooter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShootLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShootDirection                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BulletTravelTime                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ClientHitResult                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ClientDamage                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::VerifyHitOnServer(class AHumanCharacter* Shooter, class AHumanCharacter* Target, const struct FVector& ShootLocation, const struct FVector& ShootDirection, const float BulletTravelTime, const float Timestamp, const struct FHitResult& ClientHitResult, const float ClientDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "VerifyHitOnServer");

	Params::HumanCharacter_VerifyHitOnServer Parms{};

	Parms.Shooter = Shooter;
	Parms.Target = Target;
	Parms.ShootLocation = std::move(ShootLocation);
	Parms.ShootDirection = std::move(ShootDirection);
	Parms.BulletTravelTime = BulletTravelTime;
	Parms.Timestamp = Timestamp;
	Parms.ClientHitResult = std::move(ClientHitResult);
	Parms.ClientDamage = ClientDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.VerifyHitOnServerDebug
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class AHumanCharacter*                  Shooter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShootLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShootDirection                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BulletTravelTime                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ClientHitResult                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ClientDamage                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    ClientHitBodyCollidersRotations                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FCapsuleCollider>         ClientHitBodyCollidersCapsules                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanCharacter::VerifyHitOnServerDebug(class AHumanCharacter* Shooter, class AHumanCharacter* Target, const struct FVector& ShootLocation, const struct FVector& ShootDirection, const float BulletTravelTime, const float Timestamp, const struct FHitResult& ClientHitResult, const float ClientDamage, const TArray<struct FQuat>& ClientHitBodyCollidersRotations, const TArray<struct FCapsuleCollider>& ClientHitBodyCollidersCapsules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "VerifyHitOnServerDebug");

	Params::HumanCharacter_VerifyHitOnServerDebug Parms{};

	Parms.Shooter = Shooter;
	Parms.Target = Target;
	Parms.ShootLocation = std::move(ShootLocation);
	Parms.ShootDirection = std::move(ShootDirection);
	Parms.BulletTravelTime = BulletTravelTime;
	Parms.Timestamp = Timestamp;
	Parms.ClientHitResult = std::move(ClientHitResult);
	Parms.ClientDamage = ClientDamage;
	Parms.ClientHitBodyCollidersRotations = std::move(ClientHitBodyCollidersRotations);
	Parms.ClientHitBodyCollidersCapsules = std::move(ClientHitBodyCollidersCapsules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.AnimIsRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::AnimIsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "AnimIsRunning");

	Params::HumanCharacter_AnimIsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.ApplyOwnerSoundAttenuation
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::ApplyOwnerSoundAttenuation(class UAudioComponent* AudioComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ApplyOwnerSoundAttenuation");

	Params::HumanCharacter_ApplyOwnerSoundAttenuation Parms{};

	Parms.AudioComponent = AudioComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacter.AreCharactersInSameTeam
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AreInSameTeam                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AreSameCharacter                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::AreCharactersInSameTeam(class AHumanCharacter* OtherCharacter, bool* AreInSameTeam, bool* AreSameCharacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "AreCharactersInSameTeam");

	Params::HumanCharacter_AreCharactersInSameTeam Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AreInSameTeam != nullptr)
		*AreInSameTeam = Parms.AreInSameTeam;

	if (AreSameCharacter != nullptr)
		*AreSameCharacter = Parms.AreSameCharacter;
}


// Function Flame.HumanCharacter.CalculateBodyExposureToPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutFaceExposure                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutBodyExposure                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Precision                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxThickness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           IgnoreActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::CalculateBodyExposureToPoint(const struct FVector& Location, float* OutFaceExposure, float* OutBodyExposure, int32 Precision, float MaxThickness, class AActor* IgnoreActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CalculateBodyExposureToPoint");

	Params::HumanCharacter_CalculateBodyExposureToPoint Parms{};

	Parms.Location = std::move(Location);
	Parms.Precision = Precision;
	Parms.MaxThickness = MaxThickness;
	Parms.IgnoreActor = IgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFaceExposure != nullptr)
		*OutFaceExposure = Parms.OutFaceExposure;

	if (OutBodyExposure != nullptr)
		*OutBodyExposure = Parms.OutBodyExposure;
}


// Function Flame.HumanCharacter.CanAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanAim");

	Params::HumanCharacter_CanAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanClimbLadder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanClimbLadder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanClimbLadder");

	Params::HumanCharacter_CanClimbLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanProcessCustomizationChangesToCloud
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanProcessCustomizationChangesToCloud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanProcessCustomizationChangesToCloud");

	Params::HumanCharacter_CanProcessCustomizationChangesToCloud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanShowActionsInHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanShowActionsInHistory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanShowActionsInHistory");

	Params::HumanCharacter_CanShowActionsInHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanShowFiringTraces
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanShowFiringTraces() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanShowFiringTraces");

	Params::HumanCharacter_CanShowFiringTraces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.CanUseConsumables
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::CanUseConsumables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "CanUseConsumables");

	Params::HumanCharacter_CanUseConsumables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetAimAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector AHumanCharacter::GetAimAtLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetAimAtLocation");

	Params::HumanCharacter_GetAimAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetAimpointWeaponTarget
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector AHumanCharacter::GetAimpointWeaponTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetAimpointWeaponTarget");

	Params::HumanCharacter_GetAimpointWeaponTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetAllowReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::GetAllowReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetAllowReload");

	Params::HumanCharacter_GetAllowReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetBreathAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AHumanCharacter::GetBreathAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetBreathAudioComponent");

	Params::HumanCharacter_GetBreathAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetCharacterWeightSoundProperties
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   VolumeMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::GetCharacterWeightSoundProperties(float* VolumeMultiplier, float* PitchMultiplier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetCharacterWeightSoundProperties");

	Params::HumanCharacter_GetCharacterWeightSoundProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (VolumeMultiplier != nullptr)
		*VolumeMultiplier = Parms.VolumeMultiplier;

	if (PitchMultiplier != nullptr)
		*PitchMultiplier = Parms.PitchMultiplier;
}


// Function Flame.HumanCharacter.GetFootStepComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFootStepComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFootStepComponent* AHumanCharacter::GetFootStepComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetFootStepComponent");

	Params::HumanCharacter_GetFootStepComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetGenderClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AGender>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AGender> AHumanCharacter::GetGenderClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetGenderClass");

	Params::HumanCharacter_GetGenderClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetInfiniteAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::GetInfiniteAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetInfiniteAmmo");

	Params::HumanCharacter_GetInfiniteAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetInfiniteReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::GetInfiniteReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetInfiniteReload");

	Params::HumanCharacter_GetInfiniteReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetInventoryOperationsComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventoryOperationsComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryOperationsComponent* AHumanCharacter::GetInventoryOperationsComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetInventoryOperationsComponent");

	Params::HumanCharacter_GetInventoryOperationsComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetIsADSThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AHumanCharacter::GetIsADSThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetIsADSThrowable");

	Params::HumanCharacter_GetIsADSThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetMovementSoundProperties
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USoundBase*                       Sound                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::GetMovementSoundProperties(const class USoundBase* Sound, float* VolumeMultiplier, float* PitchMultiplier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetMovementSoundProperties");

	Params::HumanCharacter_GetMovementSoundProperties Parms{};

	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (VolumeMultiplier != nullptr)
		*VolumeMultiplier = Parms.VolumeMultiplier;

	if (PitchMultiplier != nullptr)
		*PitchMultiplier = Parms.PitchMultiplier;
}


// Function Flame.HumanCharacter.GetNetworkRole
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENetRole                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENetRole AHumanCharacter::GetNetworkRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetNetworkRole");

	Params::HumanCharacter_GetNetworkRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetPlayerCameraStartAndDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutCameraStart                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutCameraDirection                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::GetPlayerCameraStartAndDirection(struct FVector* OutCameraStart, struct FVector* OutCameraDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetPlayerCameraStartAndDirection");

	Params::HumanCharacter_GetPlayerCameraStartAndDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraStart != nullptr)
		*OutCameraStart = std::move(Parms.OutCameraStart);

	if (OutCameraDirection != nullptr)
		*OutCameraDirection = std::move(Parms.OutCameraDirection);
}


// Function Flame.HumanCharacter.GetProneForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHumanCharacter::GetProneForwardVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetProneForwardVector");

	Params::HumanCharacter_GetProneForwardVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetRemoteViewPitch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::GetRemoteViewPitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetRemoteViewPitch");

	Params::HumanCharacter_GetRemoteViewPitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetRemoteViewPitchSmooth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::GetRemoteViewPitchSmooth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetRemoteViewPitchSmooth");

	Params::HumanCharacter_GetRemoteViewPitchSmooth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetRoleText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENetRole                                NetRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AHumanCharacter::GetRoleText(ENetRole NetRole) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetRoleText");

	Params::HumanCharacter_GetRoleText Parms{};

	Parms.NetRole = NetRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetStaminaComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaminaComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaminaComponent* AHumanCharacter::GetStaminaComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetStaminaComponent");

	Params::HumanCharacter_GetStaminaComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStance                                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStance AHumanCharacter::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetStance");

	Params::HumanCharacter_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetVegetationComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVegetationComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVegetationComponent* AHumanCharacter::GetVegetationComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetVegetationComponent");

	Params::HumanCharacter_GetVegetationComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetWaterDetails
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIsInWater                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Depth                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Flow                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDepth                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanCharacter::GetWaterDetails(bool* bIsInWater, float* Depth, struct FVector* Flow, float* MaxDepth) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetWaterDetails");

	Params::HumanCharacter_GetWaterDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsInWater != nullptr)
		*bIsInWater = Parms.bIsInWater;

	if (Depth != nullptr)
		*Depth = Parms.Depth;

	if (Flow != nullptr)
		*Flow = std::move(Parms.Flow);

	if (MaxDepth != nullptr)
		*MaxDepth = Parms.MaxDepth;
}


// Function Flame.HumanCharacter.GetWeaponCollisionInsufficientDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::GetWeaponCollisionInsufficientDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetWeaponCollisionInsufficientDistance");

	Params::HumanCharacter_GetWeaponCollisionInsufficientDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.GetWeaponCollisionInsufficientHorizontalDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanCharacter::GetWeaponCollisionInsufficientHorizontalDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "GetWeaponCollisionInsufficientHorizontalDistance");

	Params::HumanCharacter_GetWeaponCollisionInsufficientHorizontalDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.HasUsedThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AHumanCharacter::HasUsedThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "HasUsedThrowable");

	Params::HumanCharacter_HasUsedThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsADS");

	Params::HumanCharacter_IsADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsAimingAffectedByConcussion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsAimingAffectedByConcussion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsAimingAffectedByConcussion");

	Params::HumanCharacter_IsAimingAffectedByConcussion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsAttacking");

	Params::HumanCharacter_IsAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsChambering
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsChambering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsChambering");

	Params::HumanCharacter_IsChambering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsChamberInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsChamberInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsChamberInProgress");

	Params::HumanCharacter_IsChamberInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsChangeFireModeInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsChangeFireModeInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsChangeFireModeInProgress");

	Params::HumanCharacter_IsChangeFireModeInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsCharacterInWater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsCharacterInWater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsCharacterInWater");

	Params::HumanCharacter_IsCharacterInWater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsClimbing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsClimbing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsClimbing");

	Params::HumanCharacter_IsClimbing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsClimbingLadder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsClimbingLadder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsClimbingLadder");

	Params::HumanCharacter_IsClimbingLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsCrouchInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsCrouchInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsCrouchInProgress");

	Params::HumanCharacter_IsCrouchInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsCyclingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsCyclingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsCyclingMode");

	Params::HumanCharacter_IsCyclingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsDebugAmmoReplicationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsDebugAmmoReplicationEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsDebugAmmoReplicationEnabled");

	Params::HumanCharacter_IsDebugAmmoReplicationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsFireInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsFireInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsFireInProgress");

	Params::HumanCharacter_IsFireInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsFiring");

	Params::HumanCharacter_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsFirstPersonADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsFirstPersonADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsFirstPersonADS");

	Params::HumanCharacter_IsFirstPersonADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsGestureInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsGestureInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsGestureInProgress");

	Params::HumanCharacter_IsGestureInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsHipFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsHipFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsHipFiring");

	Params::HumanCharacter_IsHipFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsHolsterInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsHolsterInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsHolsterInProgress");

	Params::HumanCharacter_IsHolsterInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsJumpInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsJumpInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsJumpInProgress");

	Params::HumanCharacter_IsJumpInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsPoseMirrored
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsPoseMirrored() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsPoseMirrored");

	Params::HumanCharacter_IsPoseMirrored Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsProneInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsProneInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsProneInProgress");

	Params::HumanCharacter_IsProneInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsProningInMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsProningInMotion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsProningInMotion");

	Params::HumanCharacter_IsProningInMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsQuickMeleeInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsQuickMeleeInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsQuickMeleeInProgress");

	Params::HumanCharacter_IsQuickMeleeInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsReloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsReloading");

	Params::HumanCharacter_IsReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsReloadInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsReloadInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsReloadInProgress");

	Params::HumanCharacter_IsReloadInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsSlidingDownLadder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsSlidingDownLadder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsSlidingDownLadder");

	Params::HumanCharacter_IsSlidingDownLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsSprinting");

	Params::HumanCharacter_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsSprintInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsSprintInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsSprintInProgress");

	Params::HumanCharacter_IsSprintInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsStandInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsStandInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsStandInProgress");

	Params::HumanCharacter_IsStandInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsSwitchInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsSwitchInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsSwitchInProgress");

	Params::HumanCharacter_IsSwitchInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsThirdPersonADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsThirdPersonADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsThirdPersonADS");

	Params::HumanCharacter_IsThirdPersonADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsTriggerDownAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsTriggerDownAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsTriggerDownAuthority");

	Params::HumanCharacter_IsTriggerDownAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsTriggerDownLocal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsTriggerDownLocal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsTriggerDownLocal");

	Params::HumanCharacter_IsTriggerDownLocal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsUseInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsUseInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsUseInProgress");

	Params::HumanCharacter_IsUseInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.IsVaulting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::IsVaulting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "IsVaulting");

	Params::HumanCharacter_IsVaulting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.ShouldScaleHeadDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::ShouldScaleHeadDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ShouldScaleHeadDown");

	Params::HumanCharacter_ShouldScaleHeadDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.ShouldShowCharacterAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::ShouldShowCharacterAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "ShouldShowCharacterAiming");

	Params::HumanCharacter_ShouldShowCharacterAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacter.WantsToSprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanCharacter::WantsToSprint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanCharacter", "WantsToSprint");

	Params::HumanCharacter_WantsToSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.OnHideMarker
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnHideMarker(class UInteractionItemComponent* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnHideMarker");

	Params::InteractionItemComponent_OnHideMarker Parms{};

	Parms.Sender = Sender;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionItemComponent.OnInteractionEnd
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnInteractionEnd(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnInteractionEnd");

	Params::InteractionItemComponent_OnInteractionEnd Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.OnInteractionStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnInteractionStart(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnInteractionStart");

	Params::InteractionItemComponent_OnInteractionStart Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.OnPreInteractionEnd
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Canceled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnPreInteractionEnd(class UInteractionItemComponent* Sender, class AActor* InteractingActor, bool Canceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnPreInteractionEnd");

	Params::InteractionItemComponent_OnPreInteractionEnd Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;
	Parms.Canceled = Canceled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.OnPreInteractionStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnPreInteractionStart(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnPreInteractionStart");

	Params::InteractionItemComponent_OnPreInteractionStart Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.OnShowMarker
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MarkerPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnShowMarker(class UInteractionItemComponent* Sender, const struct FVector& MarkerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnShowMarker");

	Params::InteractionItemComponent_OnShowMarker Parms{};

	Parms.Sender = Sender;
	Parms.MarkerPosition = std::move(MarkerPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionItemComponent.OnUpdateMarker
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MarkerPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::OnUpdateMarker(class UInteractionItemComponent* Sender, const struct FVector& MarkerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "OnUpdateMarker");

	Params::InteractionItemComponent_OnUpdateMarker Parms{};

	Parms.Sender = Sender;
	Parms.MarkerPosition = std::move(MarkerPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionItemComponent.ReInitializeSockets
// (Final, Native, Public, BlueprintCallable)

void UInteractionItemComponent::ReInitializeSockets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "ReInitializeSockets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "SetEnabled");

	Params::InteractionItemComponent_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.SetInteractionTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::SetInteractionTime(float NewTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "SetInteractionTime");

	Params::InteractionItemComponent_SetInteractionTime Parms{};

	Parms.NewTime = NewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.SetMarkerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::SetMarkerVisibility(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "SetMarkerVisibility");

	Params::InteractionItemComponent_SetMarkerVisibility Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.SetPlayEndInteractionAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    PlayAnimation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionItemComponent::SetPlayEndInteractionAnimation(bool PlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "SetPlayEndInteractionAnimation");

	Params::InteractionItemComponent_SetPlayEndInteractionAnimation Parms{};

	Parms.PlayAnimation = PlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionItemComponent.CanInteract
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  Human                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::CanInteract(class AHumanCharacter* Human) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "CanInteract");

	Params::InteractionItemComponent_CanInteract Parms{};

	Parms.Human = Human;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.CanShowMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  Human                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::CanShowMarker(class AHumanCharacter* Human) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "CanShowMarker");

	Params::InteractionItemComponent_CanShowMarker Parms{};

	Parms.Human = Human;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetInteractionAngleLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionItemComponent::GetInteractionAngleLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetInteractionAngleLimit");

	Params::InteractionItemComponent_GetInteractionAngleLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetInteractionDistanceLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionItemComponent::GetInteractionDistanceLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetInteractionDistanceLimit");

	Params::InteractionItemComponent_GetInteractionDistanceLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetInteractionLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionAngleLimit                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionAngleLimit UInteractionItemComponent::GetInteractionLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetInteractionLimit");

	Params::InteractionItemComponent_GetInteractionLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetInteractionTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionItemComponent::GetInteractionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetInteractionTime");

	Params::InteractionItemComponent_GetInteractionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetMarkerVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::GetMarkerVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetMarkerVisibility");

	Params::InteractionItemComponent_GetMarkerVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.GetNearestSocketPos
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  Human                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SocketPos                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::GetNearestSocketPos(class AHumanCharacter* Human, const struct FVector& ViewPos, struct FVector* SocketPos) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "GetNearestSocketPos");

	Params::InteractionItemComponent_GetNearestSocketPos Parms{};

	Parms.Human = Human;
	Parms.ViewPos = std::move(ViewPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SocketPos != nullptr)
		*SocketPos = std::move(Parms.SocketPos);

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.IsCompoundInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::IsCompoundInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "IsCompoundInteraction");

	Params::InteractionItemComponent_IsCompoundInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "IsEnabled");

	Params::InteractionItemComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.IsExclusivityLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanCharacter*                  Human                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::IsExclusivityLocked(class AHumanCharacter* Human) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "IsExclusivityLocked");

	Params::InteractionItemComponent_IsExclusivityLocked Parms{};

	Parms.Human = Human;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.IsExclusivityUsing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::IsExclusivityUsing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "IsExclusivityUsing");

	Params::InteractionItemComponent_IsExclusivityUsing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionItemComponent.PlayEndInteractionAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionItemComponent::PlayEndInteractionAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionItemComponent", "PlayEndInteractionAnimation");

	Params::InteractionItemComponent_PlayEndInteractionAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CameraManagerComponentBase.SetCameraState
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECameraPositionState                    NewState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponentBase::SetCameraState(const ECameraPositionState& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponentBase", "SetCameraState");

	Params::CameraManagerComponentBase_SetCameraState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponentBase.GetActiveCamera
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* UCameraManagerComponentBase::GetActiveCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponentBase", "GetActiveCamera");

	Params::CameraManagerComponentBase_GetActiveCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CameraManagerComponentBase.GetCameraState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraPositionState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECameraPositionState UCameraManagerComponentBase::GetCameraState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponentBase", "GetCameraState");

	Params::CameraManagerComponentBase_GetCameraState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CameraManagerComponentBase.GetShakeModifier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraManagerComponentBase::GetShakeModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponentBase", "GetShakeModifier");

	Params::CameraManagerComponentBase_GetShakeModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CameraManagerComponentBase.GetWaterSurfaceZ
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraManagerComponentBase::GetWaterSurfaceZ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponentBase", "GetWaterSurfaceZ");

	Params::CameraManagerComponentBase_GetWaterSurfaceZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CameraManagerComponent.AcquireHumanPlayerCharacter
// (Final, Native, Private)

void UCameraManagerComponent::AcquireHumanPlayerCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "AcquireHumanPlayerCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.DrawDebugCameraLocation
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetRole                                CallerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::DrawDebugCameraLocation(const struct FVector& Location, ENetRole CallerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "DrawDebugCameraLocation");

	Params::CameraManagerComponent_DrawDebugCameraLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.CallerRole = CallerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.InitADS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsADS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::InitADS(bool IsADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "InitADS");

	Params::CameraManagerComponent_InitADS Parms{};

	Parms.IsADS = IsADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnBuildingEnter
// (Final, Native, Private)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::OnBuildingEnter(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnBuildingEnter");

	Params::CameraManagerComponent_OnBuildingEnter Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnBuildingLeave
// (Final, Native, Private)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::OnBuildingLeave(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnBuildingLeave");

	Params::CameraManagerComponent_OnBuildingLeave Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnBuildingTypeEntered
// (Final, Native, Private)
// Parameters:
// EInteriorRoomType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::OnBuildingTypeEntered(EInteriorRoomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnBuildingTypeEntered");

	Params::CameraManagerComponent_OnBuildingTypeEntered Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnBuildingTypeLeave
// (Final, Native, Private)
// Parameters:
// EInteriorRoomType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::OnBuildingTypeLeave(EInteriorRoomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnBuildingTypeLeave");

	Params::CameraManagerComponent_OnBuildingTypeLeave Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnStableDuringClimb
// (Final, Native, Public)

void UCameraManagerComponent::OnStableDuringClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnStableDuringClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.OnStartClimb
// (Final, Native, Public)

void UCameraManagerComponent::OnStartClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "OnStartClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.ServerSetShoulder
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bShoulder                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraManagerComponent::ServerSetShoulder(bool bShoulder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "ServerSetShoulder");

	Params::CameraManagerComponent_ServerSetShoulder Parms{};

	Parms.bShoulder = bShoulder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CameraManagerComponent.UnblockADSByClimbOrVault
// (Final, Native, Private)

void UCameraManagerComponent::UnblockADSByClimbOrVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraManagerComponent", "UnblockADSByClimbOrVault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorRebuildDataStorage.AddFloatProperty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Identifier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorRebuildDataStorage::AddFloatProperty(class FName Identifier, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorRebuildDataStorage", "AddFloatProperty");

	Params::EditorRebuildDataStorage_AddFloatProperty Parms{};

	Parms.Identifier = Identifier;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorRebuildDataStorage.GetFloatProperty
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Identifier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorRebuildDataStorage::GetFloatProperty(class FName Identifier, float* OutValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorRebuildDataStorage", "GetFloatProperty");

	Params::EditorRebuildDataStorage_GetFloatProperty Parms{};

	Parms.Identifier = Identifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Flame.MenuWidget.OnResetToDefaultState
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UMenuWidget::OnResetToDefaultState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuWidget", "OnResetToDefaultState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MenuWidget.GetHUDElementVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UMenuWidget::GetHUDElementVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuWidget", "GetHUDElementVisibility");

	Params::MenuWidget_GetHUDElementVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MenuWidget.GetWidgetToFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UMenuWidget::GetWidgetToFocus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuWidget", "GetWidgetToFocus");

	Params::MenuWidget_GetWidgetToFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ModalWidget.DisableSetFocusBack
// (Final, Native, Public, BlueprintCallable)

void UModalWidget::DisableSetFocusBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModalWidget", "DisableSetFocusBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ModalWidget.SetFocusToModalWidget
// (Final, Native, Public, BlueprintCallable)

void UModalWidget::SetFocusToModalWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModalWidget", "SetFocusToModalWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ModalWidget.UpdatePreviousWidgetFocusPath
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UModalWidget::UpdatePreviousWidgetFocusPath(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModalWidget", "UpdatePreviousWidgetFocusPath");

	Params::ModalWidget_UpdatePreviousWidgetFocusPath Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ExtendedFoliageStaticMeshComp.GetFoleySoundProperties
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOverlapping                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousVolume                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousPitch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedFoliageStaticMeshComp::GetFoleySoundProperties(float DeltaTime, class AActor* Actor, bool bIsOverlapping, float PreviousVolume, float PreviousPitch, float* Volume, float* Pitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtendedFoliageStaticMeshComp", "GetFoleySoundProperties");

	Params::ExtendedFoliageStaticMeshComp_GetFoleySoundProperties Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Actor = Actor;
	Parms.bIsOverlapping = bIsOverlapping;
	Parms.PreviousVolume = PreviousVolume;
	Parms.PreviousPitch = PreviousPitch;

	UObject::ProcessEvent(Func, &Parms);

	if (Volume != nullptr)
		*Volume = Parms.Volume;

	if (Pitch != nullptr)
		*Pitch = Parms.Pitch;
}


// Function Flame.CurveGrenadeExplosionEffect.GetMaximumDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCurveGrenadeExplosionEffect::GetMaximumDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveGrenadeExplosionEffect", "GetMaximumDistance");

	Params::CurveGrenadeExplosionEffect_GetMaximumDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsStorage.OnRep_PostChange
// (Native, Protected)

void UWeaponsStorage::OnRep_PostChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponsStorage", "OnRep_PostChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.OnButtonClicked
// (Final, Native, Private)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSlot::OnButtonClicked(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnButtonClicked");

	Params::FlameSlot_OnButtonClicked Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.OnButtonFocused
// (Final, Native, Private)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSlot::OnButtonFocused(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnButtonFocused");

	Params::FlameSlot_OnButtonFocused Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.OnButtonUnfocused
// (Final, Native, Private)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSlot::OnButtonUnfocused(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnButtonUnfocused");

	Params::FlameSlot_OnButtonUnfocused Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.OnItemChanged
// (Event, Public, BlueprintEvent)

void UFlameSlot::OnItemChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnItemChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameSlot.OnLobbyStateChanged
// (Final, Native, Private)

void UFlameSlot::OnLobbyStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnLobbyStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.OnTryFocusSlot
// (Event, Public, BlueprintEvent)

void UFlameSlot::OnTryFocusSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "OnTryFocusSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameSlot.SetItemDescriptor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInvetoryItemDescriptor          InDescriptor                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFlameSlot::SetItemDescriptor(const struct FInvetoryItemDescriptor& InDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "SetItemDescriptor");

	Params::FlameSlot_SetItemDescriptor Parms{};

	Parms.InDescriptor = std::move(InDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.SetItemType
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSlot::SetItemType(TSubclassOf<class AItem> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "SetItemType");

	Params::FlameSlot_SetItemType Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.SetWeaponInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSlot::SetWeaponInstance(class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "SetWeaponInstance");

	Params::FlameSlot_SetWeaponInstance Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSlot.GetItemDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInvetoryItemDescriptor    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FInvetoryItemDescriptor UFlameSlot::GetItemDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "GetItemDescriptor");

	Params::FlameSlot_GetItemDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameSlot.GetItemObsolete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem* UFlameSlot::GetItemObsolete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "GetItemObsolete");

	Params::FlameSlot_GetItemObsolete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameSlot.GetItemType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItem>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItem> UFlameSlot::GetItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSlot", "GetItemType");

	Params::FlameSlot_GetItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipmentSlot.UpdateSlotIcon
// (Final, Native, Public, BlueprintCallable)

void UEquipmentSlot::UpdateSlotIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlot", "UpdateSlotIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipmentSlot.GetCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEquipmentSlot::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlot", "GetCount");

	Params::EquipmentSlot_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipmentSlot.GetSlotLimitation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEquipmentSlot::GetSlotLimitation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlot", "GetSlotLimitation");

	Params::EquipmentSlot_GetSlotLimitation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnalyticsFunctionLibrary.LoadAnalytics
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           File                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DocumentText                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnalyticsFileType                      FileType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnalyticsFunctionLibrary::LoadAnalytics(class FString* File, class FString* DocumentText, EAnalyticsFileType FileType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAnalyticsFunctionLibrary", "LoadAnalytics");

	Params::FlameAnalyticsFunctionLibrary_LoadAnalytics Parms{};

	Parms.FileType = FileType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (File != nullptr)
		*File = std::move(Parms.File);

	if (DocumentText != nullptr)
		*DocumentText = std::move(Parms.DocumentText);

	return Parms.ReturnValue;
}


// Function Flame.FlameAnalyticsFunctionLibrary.SaveAnalytics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnalyticsFileType                      FileType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnalyticsFunctionLibrary::SaveAnalytics(const class FString& File, const class FString& Text, EAnalyticsFileType FileType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAnalyticsFunctionLibrary", "SaveAnalytics");

	Params::FlameAnalyticsFunctionLibrary_SaveAnalytics Parms{};

	Parms.File = std::move(File);
	Parms.Text = std::move(Text);
	Parms.FileType = FileType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.DataProviderGetStructure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECloudStructureTypes                    StructureType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudDataStructureBase*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudDataStructureBase* UCloudDataStructures::DataProviderGetStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataStructures", "DataProviderGetStructure");

	Params::CloudDataStructures_DataProviderGetStructure Parms{};

	Parms.StructureType = StructureType;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.DataProviderLoadAllStructures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    SkipManualLoad                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataStructures::DataProviderLoadAllStructures(bool SkipManualLoad, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataStructures", "DataProviderLoadAllStructures");

	Params::CloudDataStructures_DataProviderLoadAllStructures Parms{};

	Parms.SkipManualLoad = SkipManualLoad;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.DataProviderLoadStructure
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECloudStructureTypes                    StructureType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataStructures::DataProviderLoadStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataStructures", "DataProviderLoadStructure");

	Params::CloudDataStructures_DataProviderLoadStructure Parms{};

	Parms.StructureType = StructureType;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.DataProviderUnLoadAllStructures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IncludeNonManual                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataStructures::DataProviderUnLoadAllStructures(bool IncludeNonManual, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataStructures", "DataProviderUnLoadAllStructures");

	Params::CloudDataStructures_DataProviderUnLoadAllStructures Parms{};

	Parms.IncludeNonManual = IncludeNonManual;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.DataProviderUnLoadStructure
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECloudStructureTypes                    StructureType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataStructures::DataProviderUnLoadStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataStructures", "DataProviderUnLoadStructure");

	Params::CloudDataStructures_DataProviderUnLoadStructure Parms{};

	Parms.StructureType = StructureType;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataStructures.GetStructure
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECloudStructureTypes                    StructureType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudDataStructureBase*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudDataStructureBase* UCloudDataStructures::GetStructure(ECloudStructureTypes StructureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudDataStructures", "GetStructure");

	Params::CloudDataStructures_GetStructure Parms{};

	Parms.StructureType = StructureType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderFindTableByAssetTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UDataTable>        AssetTable                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCloudDataTables::DataProviderFindTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderFindTableByAssetTable");

	Params::CloudDataTables_DataProviderFindTableByAssetTable Parms{};

	Parms.AssetTable = AssetTable;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderFindTableByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCloudDataTables::DataProviderFindTableByName(class FName TableName, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderFindTableByName");

	Params::CloudDataTables_DataProviderFindTableByName Parms{};

	Parms.TableName = TableName;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderGetTableState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataProviderTableState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataProviderTableState UCloudDataTables::DataProviderGetTableState(class FName TableName, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderGetTableState");

	Params::CloudDataTables_DataProviderGetTableState Parms{};

	Parms.TableName = TableName;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderLoadDataTableByAssetTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UDataTable>        AssetTable                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataTables::DataProviderLoadDataTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderLoadDataTableByAssetTable");

	Params::CloudDataTables_DataProviderLoadDataTableByAssetTable Parms{};

	Parms.AssetTable = AssetTable;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderLoadDataTableByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataTables::DataProviderLoadDataTableByName(class FName TableName, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderLoadDataTableByName");

	Params::CloudDataTables_DataProviderLoadDataTableByName Parms{};

	Parms.TableName = TableName;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderUnLoadDataTableByAssetTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UDataTable>        AssetTable                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataTables::DataProviderUnLoadDataTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderUnLoadDataTableByAssetTable");

	Params::CloudDataTables_DataProviderUnLoadDataTableByAssetTable Parms{};

	Parms.AssetTable = AssetTable;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.DataProviderUnLoadDataTableByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudDataTables::DataProviderUnLoadDataTableByName(class FName TableName, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudDataTables", "DataProviderUnLoadDataTableByName");

	Params::CloudDataTables_DataProviderUnLoadDataTableByName Parms{};

	Parms.TableName = TableName;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.FindTableByAssetTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UDataTable>        AssetTable                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCloudDataTables::FindTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudDataTables", "FindTableByAssetTable");

	Params::CloudDataTables_FindTableByAssetTable Parms{};

	Parms.AssetTable = AssetTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.FindTableByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UCloudDataTables::FindTableByName(class FName TableName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudDataTables", "FindTableByName");

	Params::CloudDataTables_FindTableByName Parms{};

	Parms.TableName = TableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudDataTables.GetDataTableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataProviderTableState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataProviderTableState UCloudDataTables::GetDataTableState(class FName TableName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudDataTables", "GetDataTableState");

	Params::CloudDataTables_GetDataTableState Parms{};

	Parms.TableName = TableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudGlobalFunctions.GetMapsCloudInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCloudGlobalFunctions::GetMapsCloudInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudGlobalFunctions", "GetMapsCloudInfo");

	Params::CloudGlobalFunctions_GetMapsCloudInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.CloudGlobalFunctions.GetMapsCloudInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FMapInfoCloud>            MapsInfo                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCloudGlobalFunctions::GetMapsCloudInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const TArray<struct FMapInfoCloud>& MapsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudGlobalFunctions", "GetMapsCloudInfoDelegate__DelegateSignature");

	Params::CloudGlobalFunctions_GetMapsCloudInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.MapsInfo = std::move(MapsInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.CloudNotificationSystem.BlueprintDeInit
// (Event, Public, BlueprintEvent)

void UCloudNotificationSystem::BlueprintDeInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "BlueprintDeInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.CloudNotificationSystem.BlueprintInit
// (Event, Public, BlueprintEvent)

void UCloudNotificationSystem::BlueprintInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "BlueprintInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.CloudNotificationSystem.GetGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFlameGameInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameInstance* UCloudNotificationSystem::GetGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "GetGameInstance");

	Params::CloudNotificationSystem_GetGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudNotificationSystem.ProcessCloudNotification
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudNotificationMessageEvent   NotificationMessageEvent                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCloudNotificationSystem::ProcessCloudNotification(const class FString& Userid, const struct FCloudNotificationMessageEvent& NotificationMessageEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "ProcessCloudNotification");

	Params::CloudNotificationSystem_ProcessCloudNotification Parms{};

	Parms.Userid = std::move(Userid);
	Parms.NotificationMessageEvent = std::move(NotificationMessageEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CloudNotificationSystem.ShowCloudNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudNotificationMessageEvent   NotificationMessageEvent                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCloudNotificationSystem::ShowCloudNotification(const class FString& Userid, const struct FCloudNotificationMessageEvent& NotificationMessageEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "ShowCloudNotification");

	Params::CloudNotificationSystem_ShowCloudNotification Parms{};

	Parms.Userid = std::move(Userid);
	Parms.NotificationMessageEvent = std::move(NotificationMessageEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CloudNotificationSystem.Tick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCloudNotificationSystem::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudNotificationSystem", "Tick");

	Params::CloudNotificationSystem_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.CloudRawDataUtils.GetDataAsJsonObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudRawDataInfo                Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UCloudRawDataUtils::GetDataAsJsonObject(const struct FCloudRawDataInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudRawDataUtils", "GetDataAsJsonObject");

	Params::CloudRawDataUtils_GetDataAsJsonObject Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudRawDataUtils.GetDataAsJsonValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudRawDataInfo                Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UCloudRawDataUtils::GetDataAsJsonValue(const struct FCloudRawDataInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudRawDataUtils", "GetDataAsJsonValue");

	Params::CloudRawDataUtils_GetDataAsJsonValue Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetCloudEnvironment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetCloudEnvironment(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetCloudEnvironment");

	Params::CloudSystem_GetCloudEnvironment Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetCloudFunctions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudGlobalFunctions*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudGlobalFunctions* UCloudSystem::GetCloudFunctions(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetCloudFunctions");

	Params::CloudSystem_GetCloudFunctions Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetCloudTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UCloudSystem::GetCloudTime(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetCloudTime");

	Params::CloudSystem_GetCloudTime Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetCloudVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetCloudVersion(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetCloudVersion");

	Params::CloudSystem_GetCloudVersion Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetUserAnalyticsId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetUserAnalyticsId(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetUserAnalyticsId");

	Params::CloudSystem_GetUserAnalyticsId Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetUserCloudId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetUserCloudId(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "GetUserCloudId");

	Params::CloudSystem_GetUserCloudId Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.InvalidCloudRequest
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCloudSystem::InvalidCloudRequest(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "InvalidCloudRequest");

	Params::CloudSystem_InvalidCloudRequest Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.RequestLogoutFromCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             DisconnectMessage                                      (Parm, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudSystem::RequestLogoutFromCloud(const class FText& DisconnectMessage, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "RequestLogoutFromCloud");

	Params::CloudSystem_RequestLogoutFromCloud Parms{};

	Parms.DisconnectMessage = std::move(DisconnectMessage);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.SendLogToCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECloudLogSeverity                       Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LogCategory                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudSystem::SendLogToCloud(ECloudLogSeverity Severity, const class FString& LogCategory, const class FString& Message, class UJsonObject* Data, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "SendLogToCloud");

	Params::CloudSystem_SendLogToCloud Parms{};

	Parms.Severity = Severity;
	Parms.LogCategory = std::move(LogCategory);
	Parms.Message = std::move(Message);
	Parms.Data = Data;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.SetCloudRequestResultLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   RequestId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudRequestResultLevel                NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCloudSystem::SetCloudRequestResultLevel(int32 RequestId, ECloudRequestResultLevel NewLevel, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudSystem", "SetCloudRequestResultLevel");

	Params::CloudSystem_SetCloudRequestResultLevel Parms{};

	Parms.RequestId = RequestId;
	Parms.NewLevel = NewLevel;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.CloudSystem.CloudSystemStatusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// ECloudManagerState                      OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudManagerState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCloudSystem::CloudSystemStatusChanged__DelegateSignature(ECloudManagerState OldState, ECloudManagerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudSystem", "CloudSystemStatusChanged__DelegateSignature");

	Params::CloudSystem_CloudSystemStatusChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.CloudSystem.GetCloudUserName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetCloudUserName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudSystem", "GetCloudUserName");

	Params::CloudSystem_GetCloudUserName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECloudManagerState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECloudManagerState UCloudSystem::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudSystem", "GetState");

	Params::CloudSystem_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetStateInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCloudManagerStateInfo           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudManagerStateInfo UCloudSystem::GetStateInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudSystem", "GetStateInfo");

	Params::CloudSystem_GetStateInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CloudSystem.GetStateStringFieldFromJson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCloudSystem::GetStateStringFieldFromJson(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloudSystem", "GetStateStringFieldFromJson");

	Params::CloudSystem_GetStateStringFieldFromJson Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.AddCommodity
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Commodity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnProbability                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommodityManagerDistributionAlgorithm  DistributionAlgorithm                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::AddCommodity(TSubclassOf<class AActor> Commodity, int32 MinCapacity, int32 MaxCapacity, float MinPriority, float MaxPriority, float SpawnProbability, ECommodityManagerDistributionAlgorithm DistributionAlgorithm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "AddCommodity");

	Params::CommoditySpawnManager_AddCommodity Parms{};

	Parms.Commodity = Commodity;
	Parms.MinCapacity = MinCapacity;
	Parms.MaxCapacity = MaxCapacity;
	Parms.MinPriority = MinPriority;
	Parms.MaxPriority = MaxPriority;
	Parms.SpawnProbability = SpawnProbability;
	Parms.DistributionAlgorithm = DistributionAlgorithm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.ClearCommodities
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACommoditySpawnManager::ClearCommodities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "ClearCommodities");

	Params::CommoditySpawnManager_ClearCommodities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.CommoditySpawnManager.CommoditiesSpawned__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACommoditySpawnManager::CommoditiesSpawned__DelegateSignature(bool Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "CommoditiesSpawned__DelegateSignature");

	Params::CommoditySpawnManager_CommoditiesSpawned__DelegateSignature Parms{};

	Parms.Result = Result;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.CommoditySpawnManager.RemoveCommodity
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::RemoveCommodity(int32 CommodityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "RemoveCommodity");

	Params::CommoditySpawnManager_RemoveCommodity Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityCapacity
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityCapacity(int32 CommodityIndex, int32 MinCapacity, int32 MaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityCapacity");

	Params::CommoditySpawnManager_SetCommodityCapacity Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinCapacity = MinCapacity;
	Parms.MaxCapacity = MaxCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityCapacityMaximum
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityCapacityMaximum(int32 CommodityIndex, int32 MaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityCapacityMaximum");

	Params::CommoditySpawnManager_SetCommodityCapacityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MaxCapacity = MaxCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityCapacityMinimum
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityCapacityMinimum(int32 CommodityIndex, int32 MinCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityCapacityMinimum");

	Params::CommoditySpawnManager_SetCommodityCapacityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinCapacity = MinCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityPriority
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityPriority(int32 CommodityIndex, float MinPriority, float MaxPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityPriority");

	Params::CommoditySpawnManager_SetCommodityPriority Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinPriority = MinPriority;
	Parms.MaxPriority = MaxPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityPriorityMaximum
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityPriorityMaximum(int32 CommodityIndex, float MaxPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityPriorityMaximum");

	Params::CommoditySpawnManager_SetCommodityPriorityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MaxPriority = MaxPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SetCommodityPriorityMinimum
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::SetCommodityPriorityMinimum(int32 CommodityIndex, float MinPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SetCommodityPriorityMinimum");

	Params::CommoditySpawnManager_SetCommodityPriorityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinPriority = MinPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.SpawnCommodities
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FManagerCommodityDescriptor>InCommodities                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    IncompleteData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACommoditySpawnManager::SpawnCommodities(const TArray<struct FManagerCommodityDescriptor>& InCommodities, bool IncompleteData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "SpawnCommodities");

	Params::CommoditySpawnManager_SpawnCommodities Parms{};

	Parms.InCommodities = std::move(InCommodities);
	Parms.IncompleteData = IncompleteData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommoditySpawnManager.GetCommodityCapacityMaximum
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACommoditySpawnManager::GetCommodityCapacityMaximum(int32 CommodityIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "GetCommodityCapacityMaximum");

	Params::CommoditySpawnManager_GetCommodityCapacityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.GetCommodityCapacityMinimum
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACommoditySpawnManager::GetCommodityCapacityMinimum(int32 CommodityIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "GetCommodityCapacityMinimum");

	Params::CommoditySpawnManager_GetCommodityCapacityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.GetCommodityPriorityMaximum
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::GetCommodityPriorityMaximum(int32 CommodityIndex, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "GetCommodityPriorityMaximum");

	Params::CommoditySpawnManager_GetCommodityPriorityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.GetCommodityPriorityMinimum
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACommoditySpawnManager::GetCommodityPriorityMinimum(int32 CommodityIndex, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "GetCommodityPriorityMinimum");

	Params::CommoditySpawnManager_GetCommodityPriorityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnManager.OnCommodityParamsModify
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TSubclassOf<class AActor>               CommodityType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnProbabilityIn                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMinIn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMaxIn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpawnProbabilityOut                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMinOut                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMaxOut                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACommoditySpawnManager::OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, float SpawnProbabilityIn, int32 CapacityMinIn, int32 CapacityMaxIn, int32 SubObjectsLimitMinIn, int32 SubObjectsLimitMaxIn, float* SpawnProbabilityOut, int32* CapacityMinOut, int32* CapacityMaxOut, int32* SubObjectsLimitMinOut, int32* SubObjectsLimitMaxOut) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnManager", "OnCommodityParamsModify");

	Params::CommoditySpawnManager_OnCommodityParamsModify Parms{};

	Parms.CommodityType = CommodityType;
	Parms.SpawnProbabilityIn = SpawnProbabilityIn;
	Parms.CapacityMinIn = CapacityMinIn;
	Parms.CapacityMaxIn = CapacityMaxIn;
	Parms.SubObjectsLimitMinIn = SubObjectsLimitMinIn;
	Parms.SubObjectsLimitMaxIn = SubObjectsLimitMaxIn;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnProbabilityOut != nullptr)
		*SpawnProbabilityOut = Parms.SpawnProbabilityOut;

	if (CapacityMinOut != nullptr)
		*CapacityMinOut = Parms.CapacityMinOut;

	if (CapacityMaxOut != nullptr)
		*CapacityMaxOut = Parms.CapacityMaxOut;

	if (SubObjectsLimitMinOut != nullptr)
		*SubObjectsLimitMinOut = Parms.SubObjectsLimitMinOut;

	if (SubObjectsLimitMaxOut != nullptr)
		*SubObjectsLimitMaxOut = Parms.SubObjectsLimitMaxOut;
}


// Function Flame.CommoditySpawnNode.OnCommodityParamsModify
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TSubclassOf<class AActor>               CommodityType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMinIn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMaxIn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMinOut                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubObjectsLimitMaxOut                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommoditySpawnNode::OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, int32 CapacityMinIn, int32 CapacityMaxIn, int32 SubObjectsLimitMinIn, int32 SubObjectsLimitMaxIn, int32* CapacityMinOut, int32* CapacityMaxOut, int32* SubObjectsLimitMinOut, int32* SubObjectsLimitMaxOut) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnNode", "OnCommodityParamsModify");

	Params::CommoditySpawnNode_OnCommodityParamsModify Parms{};

	Parms.CommodityType = CommodityType;
	Parms.CapacityMinIn = CapacityMinIn;
	Parms.CapacityMaxIn = CapacityMaxIn;
	Parms.SubObjectsLimitMinIn = SubObjectsLimitMinIn;
	Parms.SubObjectsLimitMaxIn = SubObjectsLimitMaxIn;

	UObject::ProcessEvent(Func, &Parms);

	if (CapacityMinOut != nullptr)
		*CapacityMinOut = Parms.CapacityMinOut;

	if (CapacityMaxOut != nullptr)
		*CapacityMaxOut = Parms.CapacityMaxOut;

	if (SubObjectsLimitMinOut != nullptr)
		*SubObjectsLimitMinOut = Parms.SubObjectsLimitMinOut;

	if (SubObjectsLimitMaxOut != nullptr)
		*SubObjectsLimitMaxOut = Parms.SubObjectsLimitMaxOut;
}


// Function Flame.FlameAssetManager.GetSoftClassReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             Reference                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UFlameAssetManager::GetSoftClassReference(TSoftClassPtr<class UClass> Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAssetManager", "GetSoftClassReference");

	Params::FlameAssetManager_GetSoftClassReference Parms{};

	Parms.Reference = Reference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.GetSoftReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           Reference                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UFlameAssetManager::GetSoftReference(TSoftObjectPtr<class UObject> Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAssetManager", "GetSoftReference");

	Params::FlameAssetManager_GetSoftReference Parms{};

	Parms.Reference = Reference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.LoadSoftClassReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             Reference                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UFlameAssetManager::LoadSoftClassReference(TSoftClassPtr<class UClass> Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAssetManager", "LoadSoftClassReference");

	Params::FlameAssetManager_LoadSoftClassReference Parms{};

	Parms.Reference = Reference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.LoadSoftReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           Reference                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlameAssetManager::LoadSoftReference(TSoftObjectPtr<class UObject> Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameAssetManager", "LoadSoftReference");

	Params::FlameAssetManager_LoadSoftReference Parms{};

	Parms.Reference = Reference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.LoadAndTrackSoftClassReference
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             AssetToLoad                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlameAssetManager::LoadAndTrackSoftClassReference(const TSoftClassPtr<class UClass>& AssetToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAssetManager", "LoadAndTrackSoftClassReference");

	Params::FlameAssetManager_LoadAndTrackSoftClassReference Parms{};

	Parms.AssetToLoad = AssetToLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.LoadAndTrackSoftReference
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           AssetToLoad                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlameAssetManager::LoadAndTrackSoftReference(const TSoftObjectPtr<class UObject>& AssetToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAssetManager", "LoadAndTrackSoftReference");

	Params::FlameAssetManager_LoadAndTrackSoftReference Parms{};

	Parms.AssetToLoad = AssetToLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAssetManager.StreamAsset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           AssetToStream                                          (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnAssetLoaded                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFlameAssetManager::StreamAsset(TSoftObjectPtr<class UObject> AssetToStream, const TDelegate<void()>& OnAssetLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAssetManager", "StreamAsset");

	Params::FlameAssetManager_StreamAsset Parms{};

	Parms.AssetToStream = AssetToStream;
	Parms.OnAssetLoaded = OnAssetLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameAssetManager.StreamAssets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TSoftObjectPtr<class UObject>>   AssetsToStream                                         (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnAssetLoaded                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFlameAssetManager::StreamAssets(const TArray<TSoftObjectPtr<class UObject>>& AssetsToStream, const TDelegate<void()>& OnAssetLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAssetManager", "StreamAssets");

	Params::FlameAssetManager_StreamAssets Parms{};

	Parms.AssetsToStream = std::move(AssetsToStream);
	Parms.OnAssetLoaded = OnAssetLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameAssetManager.TrackObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameAssetManager::TrackObject(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAssetManager", "TrackObject");

	Params::FlameAssetManager_TrackObject Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommoditySpawnPoint.AddCommodity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Commodity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::AddCommodity(TSubclassOf<class AActor> Commodity, int32 MinCapacity, int32 MaxCapacity, float MinPriority, float MaxPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "AddCommodity");

	Params::CommoditySpawnPoint_AddCommodity Parms{};

	Parms.Commodity = Commodity;
	Parms.MinCapacity = MinCapacity;
	Parms.MaxCapacity = MaxCapacity;
	Parms.MinPriority = MinPriority;
	Parms.MaxPriority = MaxPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.ClearCommodities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommoditySpawnPoint::ClearCommodities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "ClearCommodities");

	Params::CommoditySpawnPoint_ClearCommodities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.RemoveCommodity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::RemoveCommodity(int32 CommodityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "RemoveCommodity");

	Params::CommoditySpawnPoint_RemoveCommodity Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityCapacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityCapacity(int32 CommodityIndex, int32 MinCapacity, int32 MaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityCapacity");

	Params::CommoditySpawnPoint_SetCommodityCapacity Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinCapacity = MinCapacity;
	Parms.MaxCapacity = MaxCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityCapacityMaximum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityCapacityMaximum(int32 CommodityIndex, int32 MaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityCapacityMaximum");

	Params::CommoditySpawnPoint_SetCommodityCapacityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MaxCapacity = MaxCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityCapacityMinimum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCapacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityCapacityMinimum(int32 CommodityIndex, int32 MinCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityCapacityMinimum");

	Params::CommoditySpawnPoint_SetCommodityCapacityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinCapacity = MinCapacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityMapFromArray
// (Final, Native, Public)

void UCommoditySpawnPoint::SetCommodityMapFromArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityMapFromArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommoditySpawnPoint.SetCommodityPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityPriority(int32 CommodityIndex, float MinPriority, float MaxPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityPriority");

	Params::CommoditySpawnPoint_SetCommodityPriority Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinPriority = MinPriority;
	Parms.MaxPriority = MaxPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityPriorityMaximum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityPriorityMaximum(int32 CommodityIndex, float MaxPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityPriorityMaximum");

	Params::CommoditySpawnPoint_SetCommodityPriorityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MaxPriority = MaxPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.SetCommodityPriorityMinimum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::SetCommodityPriorityMinimum(int32 CommodityIndex, float MinPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "SetCommodityPriorityMinimum");

	Params::CommoditySpawnPoint_SetCommodityPriorityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;
	Parms.MinPriority = MinPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.GetCommodityCapacityMaximum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommoditySpawnPoint::GetCommodityCapacityMaximum(int32 CommodityIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "GetCommodityCapacityMaximum");

	Params::CommoditySpawnPoint_GetCommodityCapacityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.GetCommodityCapacityMinimum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommoditySpawnPoint::GetCommodityCapacityMinimum(int32 CommodityIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "GetCommodityCapacityMinimum");

	Params::CommoditySpawnPoint_GetCommodityCapacityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.GetCommodityPriorityMaximum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::GetCommodityPriorityMaximum(int32 CommodityIndex, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "GetCommodityPriorityMaximum");

	Params::CommoditySpawnPoint_GetCommodityPriorityMaximum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.GetCommodityPriorityMinimum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CommodityIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommoditySpawnPoint::GetCommodityPriorityMinimum(int32 CommodityIndex, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "GetCommodityPriorityMinimum");

	Params::CommoditySpawnPoint_GetCommodityPriorityMinimum Parms{};

	Parms.CommodityIndex = CommodityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function Flame.CommoditySpawnPoint.OnCommodityParamsModify
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TSubclassOf<class AActor>               CommodityType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMinOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CapacityMaxOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommoditySpawnPoint::OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, int32 CapacityMinIn, int32 CapacityMaxIn, int32* CapacityMinOut, int32* CapacityMaxOut) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommoditySpawnPoint", "OnCommodityParamsModify");

	Params::CommoditySpawnPoint_OnCommodityParamsModify Parms{};

	Parms.CommodityType = CommodityType;
	Parms.CapacityMinIn = CapacityMinIn;
	Parms.CapacityMaxIn = CapacityMaxIn;

	UObject::ProcessEvent(Func, &Parms);

	if (CapacityMinOut != nullptr)
		*CapacityMinOut = Parms.CapacityMinOut;

	if (CapacityMaxOut != nullptr)
		*CapacityMaxOut = Parms.CapacityMaxOut;
}


// Function Flame.CommonFunctions.AddComponentToActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  OutNewComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::AddComponentToActor(TSubclassOf<class UActorComponent> ComponentClass, class AActor* Actor, class UActorComponent** OutNewComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "AddComponentToActor");

	Params::CommonFunctions_AddComponentToActor Parms{};

	Parms.ComponentClass = ComponentClass;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewComponent != nullptr)
		*OutNewComponent = Parms.OutNewComponent;
}


// Function Flame.CommonFunctions.AddViewSlaveLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SlaveLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::AddViewSlaveLocation(const struct FVector& SlaveLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "AddViewSlaveLocation");

	Params::CommonFunctions_AddViewSlaveLocation Parms{};

	Parms.SlaveLocation = std::move(SlaveLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.AddViewSlaveLocationForDuration
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SlaveLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::AddViewSlaveLocationForDuration(const struct FVector& SlaveLocation, const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "AddViewSlaveLocationForDuration");

	Params::CommonFunctions_AddViewSlaveLocationForDuration Parms{};

	Parms.SlaveLocation = std::move(SlaveLocation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.CaptureSceneDeferred
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         CaptureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::CaptureSceneDeferred(class USceneCaptureComponent2D* CaptureComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "CaptureSceneDeferred");

	Params::CommonFunctions_CaptureSceneDeferred Parms{};

	Parms.CaptureComponent = CaptureComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.CubicInterpolation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTangent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndTangent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::CubicInterpolation(float Start, float StartTangent, float End, float EndTangent, float A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "CubicInterpolation");

	Params::CommonFunctions_CubicInterpolation Parms{};

	Parms.Start = Start;
	Parms.StartTangent = StartTangent;
	Parms.End = End;
	Parms.EndTangent = EndTangent;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.EnableMainViewRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::EnableMainViewRendering(class APlayerController* Controller, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "EnableMainViewRendering");

	Params::CommonFunctions_EnableMainViewRendering Parms{};

	Parms.Controller = Controller;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.EstimateSceneRenderTargetsSize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSizeX                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSizeY                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::EstimateSceneRenderTargetsSize(class UObject* WorldContextObject, int32* OutSizeX, int32* OutSizeY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "EstimateSceneRenderTargetsSize");

	Params::CommonFunctions_EstimateSceneRenderTargetsSize Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSizeX != nullptr)
		*OutSizeX = Parms.OutSizeX;

	if (OutSizeY != nullptr)
		*OutSizeY = Parms.OutSizeY;
}


// Function Flame.CommonFunctions.FindComponentBySocketName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USceneComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  OutComponentWithSocket                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::FindComponentBySocketName(const class AActor* Actor, class FName SocketName, TSubclassOf<class USceneComponent> ComponentClass, class USceneComponent** OutComponentWithSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "FindComponentBySocketName");

	Params::CommonFunctions_FindComponentBySocketName Parms{};

	Parms.Actor = Actor;
	Parms.SocketName = SocketName;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponentWithSocket != nullptr)
		*OutComponentWithSocket = Parms.OutComponentWithSocket;
}


// Function Flame.CommonFunctions.GetActiveTopLevelWindowPositionOnScreen
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCommonFunctions::GetActiveTopLevelWindowPositionOnScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetActiveTopLevelWindowPositionOnScreen");

	Params::CommonFunctions_GetActiveTopLevelWindowPositionOnScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetAllUsedChildClassTypes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ParentActorClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AActor>> UCommonFunctions::GetAllUsedChildClassTypes(const class UObject* WorldContextObject, TSubclassOf<class AActor> ParentActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetAllUsedChildClassTypes");

	Params::CommonFunctions_GetAllUsedChildClassTypes Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ParentActorClass = ParentActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetBuildConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCommonFunctions::GetBuildConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetBuildConfiguration");

	Params::CommonFunctions_GetBuildConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetBuildVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCommonFunctions::GetBuildVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetBuildVersion");

	Params::CommonFunctions_GetBuildVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UCommonFunctions::GetClassDefaultObject(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetClassDefaultObject");

	Params::CommonFunctions_GetClassDefaultObject Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetClassDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCommonFunctions::GetClassDisplayName(const class UObject* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetClassDisplayName");

	Params::CommonFunctions_GetClassDisplayName Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetCurveValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetCurveValue(class UCurveFloat* Curve, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetCurveValue");

	Params::CommonFunctions_GetCurveValue Parms{};

	Parms.Curve = Curve;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetFrameNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommonFunctions::GetFrameNumber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetFrameNumber");

	Params::CommonFunctions_GetFrameNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetLastRenderTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetLastRenderTime(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetLastRenderTime");

	Params::CommonFunctions_GetLastRenderTime Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetLastRenderTimeOnScreen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetLastRenderTimeOnScreen(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetLastRenderTimeOnScreen");

	Params::CommonFunctions_GetLastRenderTimeOnScreen Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetMainWindowPositionOnScreen
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCommonFunctions::GetMainWindowPositionOnScreen(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetMainWindowPositionOnScreen");

	Params::CommonFunctions_GetMainWindowPositionOnScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetNumStreamingTexturesForPrimitive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCommonFunctions::GetNumStreamingTexturesForPrimitive(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetNumStreamingTexturesForPrimitive");

	Params::CommonFunctions_GetNumStreamingTexturesForPrimitive Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetRelativeDistanceFromBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          PointToTest                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetRelativeDistanceFromBox(const struct FVector& PointToTest, const struct FVector& BoxExtent, bool bClamped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetRelativeDistanceFromBox");

	Params::CommonFunctions_GetRelativeDistanceFromBox Parms{};

	Parms.PointToTest = std::move(PointToTest);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.bClamped = bClamped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetRelativeDistanceFromCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          PointToTest                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetRelativeDistanceFromCapsule(const struct FVector& PointToTest, float HalfHeight, float Radius, bool bClamped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetRelativeDistanceFromCapsule");

	Params::CommonFunctions_GetRelativeDistanceFromCapsule Parms{};

	Parms.PointToTest = std::move(PointToTest);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.bClamped = bClamped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetRelativeDistanceFromSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          PointToTest                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetRelativeDistanceFromSphere(const struct FVector& PointToTest, float Radius, bool bClamped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetRelativeDistanceFromSphere");

	Params::CommonFunctions_GetRelativeDistanceFromSphere Parms{};

	Parms.PointToTest = std::move(PointToTest);
	Parms.Radius = Radius;
	Parms.bClamped = bClamped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.GetSceneCaptureShowOnlyComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USceneCaptureComponent2D*         CaptureComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      ShowOnlyComponents                                     (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCommonFunctions::GetSceneCaptureShowOnlyComponents(class USceneCaptureComponent2D* CaptureComponent, TArray<class UPrimitiveComponent*>* ShowOnlyComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetSceneCaptureShowOnlyComponents");

	Params::CommonFunctions_GetSceneCaptureShowOnlyComponents Parms{};

	Parms.CaptureComponent = CaptureComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ShowOnlyComponents != nullptr)
		*ShowOnlyComponents = std::move(Parms.ShowOnlyComponents);
}


// Function Flame.CommonFunctions.GetWorldLightingScenarioNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCommonFunctions::GetWorldLightingScenarioNames(const class UObject* WorldContextObject, TArray<class FString>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetWorldLightingScenarioNames");

	Params::CommonFunctions_GetWorldLightingScenarioNames Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function Flame.CommonFunctions.GetWorldTimeInSec
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCommonFunctions::GetWorldTimeInSec(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "GetWorldTimeInSec");

	Params::CommonFunctions_GetWorldTimeInSec Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.IsEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::IsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "IsEditor");

	Params::CommonFunctions_IsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.IsShipping
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::IsShipping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "IsShipping");

	Params::CommonFunctions_IsShipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.IsStreamingTextureForPrimitive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::IsStreamingTextureForPrimitive(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "IsStreamingTextureForPrimitive");

	Params::CommonFunctions_IsStreamingTextureForPrimitive Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.IsStreamingTextureForPrimitives
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UPrimitiveComponent*>      PrimitiveComponents                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::IsStreamingTextureForPrimitives(const TArray<class UPrimitiveComponent*>& PrimitiveComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "IsStreamingTextureForPrimitives");

	Params::CommonFunctions_IsStreamingTextureForPrimitives Parms{};

	Parms.PrimitiveComponents = std::move(PrimitiveComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.IsWorldDetailDropped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::IsWorldDetailDropped(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "IsWorldDetailDropped");

	Params::CommonFunctions_IsWorldDetailDropped Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.LoadSaveGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SaveGameName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USaveGame>            SaveGameClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UCommonFunctions::LoadSaveGame(const class FString& SaveGameName, int32 UserIdx, TSubclassOf<class USaveGame> SaveGameClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "LoadSaveGame");

	Params::CommonFunctions_LoadSaveGame Parms{};

	Parms.SaveGameName = std::move(SaveGameName);
	Parms.UserIdx = UserIdx;
	Parms.SaveGameClass = SaveGameClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.RandomPointInCapsule
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCommonFunctions::RandomPointInCapsule(float HalfHeight, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "RandomPointInCapsule");

	Params::CommonFunctions_RandomPointInCapsule Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.SetComponentNetAddressable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::SetComponentNetAddressable(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "SetComponentNetAddressable");

	Params::CommonFunctions_SetComponentNetAddressable Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.SetForceMipStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMipStreaming                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::SetForceMipStreaming(class UPrimitiveComponent* Component, bool bForceMipStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "SetForceMipStreaming");

	Params::CommonFunctions_SetForceMipStreaming Parms{};

	Parms.Component = Component;
	Parms.bForceMipStreaming = bForceMipStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.SetForceMipStreamingForActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMipStreaming                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::SetForceMipStreamingForActor(class AActor* Actor, bool bForceMipStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "SetForceMipStreamingForActor");

	Params::CommonFunctions_SetForceMipStreamingForActor Parms{};

	Parms.Actor = Actor;
	Parms.bForceMipStreaming = bForceMipStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.SetViewTargetWithBlendShelter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewTargetBlendFunction                BlendFunc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SlaveLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonFunctions::SetViewTargetWithBlendShelter(class APlayerController* Target, class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, const struct FVector& SlaveLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "SetViewTargetWithBlendShelter");

	Params::CommonFunctions_SetViewTargetWithBlendShelter Parms{};

	Parms.Target = Target;
	Parms.NewViewTarget = NewViewTarget;
	Parms.BlendTime = BlendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;
	Parms.SlaveLocation = std::move(SlaveLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CommonFunctions.StringToClipBoard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringToCopy                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommonFunctions::StringToClipBoard(const class FString& StringToCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "StringToClipBoard");

	Params::CommonFunctions_StringToClipBoard Parms{};

	Parms.StringToCopy = std::move(StringToCopy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CommonFunctions.TransformWorldSpaceToPreSkinnedLocalSpace
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCommonFunctions::TransformWorldSpaceToPreSkinnedLocalSpace(class FName BoneName, class UMeshComponent* Component, const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonFunctions", "TransformWorldSpaceToPreSkinnedLocalSpace");

	Params::CommonFunctions_TransformWorldSpaceToPreSkinnedLocalSpace Parms{};

	Parms.BoneName = BoneName;
	Parms.Component = Component;
	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetBoolValue
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOptionsElementValue             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsMenuWidget::GetBoolValue(const struct FOptionsElementValue& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuWidget", "GetBoolValue");

	Params::OptionsMenuWidget_GetBoolValue Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetFloatValue
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOptionsElementValue             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOptionsMenuWidget::GetFloatValue(const struct FOptionsElementValue& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuWidget", "GetFloatValue");

	Params::OptionsMenuWidget_GetFloatValue Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetIntValue
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOptionsElementValue             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOptionsMenuWidget::GetIntValue(const struct FOptionsElementValue& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuWidget", "GetIntValue");

	Params::OptionsMenuWidget_GetIntValue Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetNameValue
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOptionsElementValue             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UOptionsMenuWidget::GetNameValue(const struct FOptionsElementValue& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuWidget", "GetNameValue");

	Params::OptionsMenuWidget_GetNameValue Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetStringValue
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOptionsElementValue             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOptionsMenuWidget::GetStringValue(const struct FOptionsElementValue& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuWidget", "GetStringValue");

	Params::OptionsMenuWidget_GetStringValue Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.CommitValues
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FName, struct FOptionsElementValue>InValues                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplySettings                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuWidget::CommitValues(const TMap<class FName, struct FOptionsElementValue>& InValues, class USaveGame* SaveGame, bool ApplySettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "CommitValues");

	Params::OptionsMenuWidget_CommitValues Parms{};

	Parms.InValues = std::move(InValues);
	Parms.SaveGame = SaveGame;
	Parms.ApplySettings = ApplySettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuWidget.OnPageHidden
// (Event, Protected, BlueprintEvent)

void UOptionsMenuWidget::OnPageHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "OnPageHidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.OptionsMenuWidget.OnPageVisible
// (Event, Protected, BlueprintEvent)

void UOptionsMenuWidget::OnPageVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "OnPageVisible");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.OptionsMenuWidget.SetNewResolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InResX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InResY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWindowMode                             InWindowMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuWidget::SetNewResolution(int32 InResX, int32 InResY, EWindowMode InWindowMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "SetNewResolution");

	Params::OptionsMenuWidget_SetNewResolution Parms{};

	Parms.InResX = InResX;
	Parms.InResY = InResY;
	Parms.InWindowMode = InWindowMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuWidget.SetOptionsToDefault
// (Final, Native, Private, BlueprintCallable)

void UOptionsMenuWidget::SetOptionsToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "SetOptionsToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuWidget.GetAllOptionsElements
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UOptionsElementWidget*>    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UOptionsElementWidget*> UOptionsMenuWidget::GetAllOptionsElements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "GetAllOptionsElements");

	Params::OptionsMenuWidget_GetAllOptionsElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetAllPanelWidgets
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UPanelWidget*>             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPanelWidget*> UOptionsMenuWidget::GetAllPanelWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "GetAllPanelWidgets");

	Params::OptionsMenuWidget_GetAllPanelWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetPageName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UOptionsMenuWidget::GetPageName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "GetPageName");

	Params::OptionsMenuWidget_GetPageName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetRootFocusWidget
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UOptionsMenuWidget::GetRootFocusWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "GetRootFocusWidget");

	Params::OptionsMenuWidget_GetRootFocusWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuWidget.GetValues
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, struct FOptionsElementValue>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FOptionsElementValue> UOptionsMenuWidget::GetValues(class USaveGame* SaveGame) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsMenuWidget", "GetValues");

	Params::OptionsMenuWidget_GetValues Parms{};

	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FirstTimeOptions.OnConfirmPressed
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFirstTimeOptions::OnConfirmPressed(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirstTimeOptions", "OnConfirmPressed");

	Params::FirstTimeOptions_OnConfirmPressed Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AchievementsFunctions.GetCachedAchievements
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAchievementStruct>       AchievementsList                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAchievementsFunctions::GetCachedAchievements(class UObject* WorldContextObject, class APlayerController* PlayerController, TArray<struct FAchievementStruct>* AchievementsList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AchievementsFunctions", "GetCachedAchievements");

	Params::AchievementsFunctions_GetCachedAchievements Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AchievementsList != nullptr)
		*AchievementsList = std::move(Parms.AchievementsList);
}


// Function Flame.StatisticsFunctions.SaveStatisticsArrayToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Lines                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatisticsFunctions::SaveStatisticsArrayToFile(const TArray<class FString>& Lines, const class FString& Filename, const class FString& Directory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StatisticsFunctions", "SaveStatisticsArrayToFile");

	Params::StatisticsFunctions_SaveStatisticsArrayToFile Parms{};

	Parms.Lines = std::move(Lines);
	Parms.Filename = std::move(Filename);
	Parms.Directory = std::move(Directory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Condition.Check
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ActorInteracting                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCondition::Check(const class AActor* ActorInteracting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Condition", "Check");

	Params::Condition_Check Parms{};

	Parms.ActorInteracting = ActorInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameCheatManager.PlayerTransformToClipboard
// (Exec, Native, Public)

void UFlameCheatManager::PlayerTransformToClipboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameCheatManager", "PlayerTransformToClipboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameCheatManager.SetPlayerTransformFromClipboard
// (Exec, Native, Public)

void UFlameCheatManager::SetPlayerTransformFromClipboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameCheatManager", "SetPlayerTransformFromClipboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameCheatManager.SetPlayerTransformFromParams
// (Exec, Native, Public)
// Parameters:
// float                                   PosX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PosY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PosZ                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotZ                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotW                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameCheatManager::SetPlayerTransformFromParams(float PosX, float PosY, float PosZ, float RotX, float RotY, float RotZ, float RotW)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameCheatManager", "SetPlayerTransformFromParams");

	Params::FlameCheatManager_SetPlayerTransformFromParams Parms{};

	Parms.PosX = PosX;
	Parms.PosY = PosY;
	Parms.PosZ = PosZ;
	Parms.RotX = RotX;
	Parms.RotY = RotY;
	Parms.RotZ = RotZ;
	Parms.RotW = RotW;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.GetDefaultLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UConsoleEvents::GetDefaultLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleEvents", "GetDefaultLanguage");

	Params::ConsoleEvents_GetDefaultLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsoleEvents.CallPlatformLoginAsync
// (Final, Native, Public, BlueprintCallable)

void UConsoleEvents::CallPlatformLoginAsync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "CallPlatformLoginAsync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.CheckUserCrossPlayAsync
// (Final, Native, Public, BlueprintCallable)

void UConsoleEvents::CheckUserCrossPlayAsync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "CheckUserCrossPlayAsync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.CheckUserPlayOnlineAsync
// (Final, Native, Public, BlueprintCallable)

void UConsoleEvents::CheckUserPlayOnlineAsync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "CheckUserPlayOnlineAsync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.IsGameConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleEvents::IsGameConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "IsGameConnected");

	Params::ConsoleEvents_IsGameConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsoleEvents.IsGamepadConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleEvents::IsGamepadConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "IsGamepadConnected");

	Params::ConsoleEvents_IsGamepadConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.ConsoleEvents.OnCallPlatformLoginAsyncFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnCallPlatformLoginAsyncFinished__DelegateSignature(bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnCallPlatformLoginAsyncFinished__DelegateSignature");

	Params::ConsoleEvents_OnCallPlatformLoginAsyncFinished__DelegateSignature Parms{};

	Parms.bWasSuccessful = bWasSuccessful;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.ConsoleEvents.OnCheckUserCrossPlayAsyncFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    CanUserCrossPlay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnCheckUserCrossPlayAsyncFinished__DelegateSignature(bool CanUserCrossPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnCheckUserCrossPlayAsyncFinished__DelegateSignature");

	Params::ConsoleEvents_OnCheckUserCrossPlayAsyncFinished__DelegateSignature Parms{};

	Parms.CanUserCrossPlay = CanUserCrossPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.ConsoleEvents.OnCheckUserPlayOnlineFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsUserAllowedPlayOnline                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnCheckUserPlayOnlineFinished__DelegateSignature(bool IsUserAllowedPlayOnline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnCheckUserPlayOnlineFinished__DelegateSignature");

	Params::ConsoleEvents_OnCheckUserPlayOnlineFinished__DelegateSignature Parms{};

	Parms.IsUserAllowedPlayOnline = IsUserAllowedPlayOnline;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.ConsoleEvents.OnControllerDisconnected__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bIsConnection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Userid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnControllerDisconnected__DelegateSignature(bool bIsConnection, int32 Userid, int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnControllerDisconnected__DelegateSignature");

	Params::ConsoleEvents_OnControllerDisconnected__DelegateSignature Parms{};

	Parms.bIsConnection = bIsConnection;
	Parms.Userid = Userid;
	Parms.ControllerId = ControllerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsoleEvents.OnControllerDisconnectedMessageBoxClosed
// (Final, Native, Protected)
// Parameters:
// EMessageBoxAction                       Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnControllerDisconnectedMessageBoxClosed(EMessageBoxAction Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnControllerDisconnectedMessageBoxClosed");

	Params::ConsoleEvents_OnControllerDisconnectedMessageBoxClosed Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.ConsoleEvents.OnControllerReconnected__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   Userid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnControllerReconnected__DelegateSignature(int32 Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnControllerReconnected__DelegateSignature");

	Params::ConsoleEvents_OnControllerReconnected__DelegateSignature Parms{};

	Parms.Userid = Userid;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.ConsoleEvents.OnReviewCompleted__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUserReviewResult                Result                                                 (Parm, NativeAccessSpecifierPublic)

void UConsoleEvents::OnReviewCompleted__DelegateSignature(bool Success, int32 ErrorCode, const struct FUserReviewResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnReviewCompleted__DelegateSignature");

	Params::ConsoleEvents_OnReviewCompleted__DelegateSignature Parms{};

	Parms.Success = Success;
	Parms.ErrorCode = ErrorCode;
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.ConsoleEvents.OnUserLoginChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bLogin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameUserIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::OnUserLoginChanged__DelegateSignature(bool bLogin, int32 GameUserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OnUserLoginChanged__DelegateSignature");

	Params::ConsoleEvents_OnUserLoginChanged__DelegateSignature Parms{};

	Parms.bLogin = bLogin;
	Parms.GameUserIndex = GameUserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsoleEvents.OpenReviewScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleEvents::OpenReviewScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "OpenReviewScreen");

	Params::ConsoleEvents_OpenReviewScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsoleEvents.RestartGame
// (Final, Native, Public, BlueprintCallable)

void UConsoleEvents::RestartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "RestartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.ShowAccountPicker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ControllerIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleEvents::ShowAccountPicker(int32 ControllerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "ShowAccountPicker");

	Params::ConsoleEvents_ShowAccountPicker Parms{};

	Parms.ControllerIndex = ControllerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsoleEvents.CanUserCrossPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleEvents::CanUserCrossPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "CanUserCrossPlay");

	Params::ConsoleEvents_CanUserCrossPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsoleEvents.GetPlayerNickName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UConsoleEvents::GetPlayerNickName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "GetPlayerNickName");

	Params::ConsoleEvents_GetPlayerNickName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsoleEvents.IsUserLoggedIn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleEvents::IsUserLoggedIn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleEvents", "IsUserLoggedIn");

	Params::ConsoleEvents_IsUserLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.GetTargetUnderCursor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AConsumableItem::GetTargetUnderCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "GetTargetUnderCursor");

	Params::ConsumableItem_GetTargetUnderCursor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.IsTargetStillValid
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::IsTargetStillValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "IsTargetStillValid");

	Params::ConsumableItem_IsTargetStillValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.OnGotIntoHandsImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConsumableItem::OnGotIntoHandsImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "OnGotIntoHandsImplementable");

	Params::ConsumableItem_OnGotIntoHandsImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsumableItem.OnRep_ItemStateConsuming
// (Final, Native, Protected)
// Parameters:
// class UItemUseState*                    OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConsumableItem::OnRep_ItemStateConsuming(class UItemUseState* OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "OnRep_ItemStateConsuming");

	Params::ConsumableItem_OnRep_ItemStateConsuming Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsumableItem.OnUngotFromHandsImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConsumableItem::OnUngotFromHandsImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "OnUngotFromHandsImplementable");

	Params::ConsumableItem_OnUngotFromHandsImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsumableItem.OnUsedImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConsumableItem::OnUsedImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "OnUsedImplementable");

	Params::ConsumableItem_OnUsedImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsumableItem.CanBeUsedOnCertainTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::CanBeUsedOnCertainTarget(const class AActor* Target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "CanBeUsedOnCertainTarget");

	Params::ConsumableItem_CanBeUsedOnCertainTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.CanBeUsedOnTarget
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::CanBeUsedOnTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "CanBeUsedOnTarget");

	Params::ConsumableItem_CanBeUsedOnTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.GetCurrentTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AConsumableItem::GetCurrentTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "GetCurrentTarget");

	Params::ConsumableItem_GetCurrentTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.GetIsCraftable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::GetIsCraftable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "GetIsCraftable");

	Params::ConsumableItem_GetIsCraftable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.GetIsEquipableInShelter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::GetIsEquipableInShelter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "GetIsEquipableInShelter");

	Params::ConsumableItem_GetIsEquipableInShelter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.GetPlan
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AConsumablePlan> AConsumableItem::GetPlan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "GetPlan");

	Params::ConsumableItem_GetPlan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItem.IsUsageInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AConsumableItem::IsUsageInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "IsUsageInProgress");

	Params::ConsumableItem_IsUsageInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableItemComponent.OnGotIntoHandsImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsumableItemComponent::OnGotIntoHandsImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItemComponent", "OnGotIntoHandsImplementable");

	Params::ConsumableItemComponent_OnGotIntoHandsImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsumableItemComponent.OnUngotFromHandsImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsumableItemComponent::OnUngotFromHandsImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItemComponent", "OnUngotFromHandsImplementable");

	Params::ConsumableItemComponent_OnUngotFromHandsImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ConsumableItemComponent.OnUsedImplementable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  ParentCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsumableItemComponent::OnUsedImplementable(class AHumanCharacter* ParentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItemComponent", "OnUsedImplementable");

	Params::ConsumableItemComponent_OnUsedImplementable Parms{};

	Parms.ParentCharacter = ParentCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ContainerWidget.ContainsSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlameSlot*                       InFlameSlot                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContainerWidget::ContainsSlot(const class UFlameSlot* InFlameSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerWidget", "ContainsSlot");

	Params::ContainerWidget_ContainsSlot Parms{};

	Parms.InFlameSlot = InFlameSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ContainerWidget.GetFocusedSlot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlameSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameSlot* UContainerWidget::GetFocusedSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerWidget", "GetFocusedSlot");

	Params::ContainerWidget_GetFocusedSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ContainerWidget.GetSlotCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UContainerWidget::GetSlotCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerWidget", "GetSlotCount");

	Params::ContainerWidget_GetSlotCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ContainerWidget.GetSlots
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UFlameSlot*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UFlameSlot*> UContainerWidget::GetSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerWidget", "GetSlots");

	Params::ContainerWidget_GetSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DynamicContainerWidget.AddItemsDescriptors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemProvider*                    ItemProvider                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDynamicContainerWidget::AddItemsDescriptors(const class UItemProvider* ItemProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicContainerWidget", "AddItemsDescriptors");

	Params::DynamicContainerWidget_AddItemsDescriptors Parms{};

	Parms.ItemProvider = ItemProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DynamicContainerWidget.AddItemsDescriptorsFromArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FInvetoryItemDescriptor>  DescriptorArray                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDynamicContainerWidget::AddItemsDescriptorsFromArray(const TArray<struct FInvetoryItemDescriptor>& DescriptorArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicContainerWidget", "AddItemsDescriptorsFromArray");

	Params::DynamicContainerWidget_AddItemsDescriptorsFromArray Parms{};

	Parms.DescriptorArray = std::move(DescriptorArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DynamicContainerWidget.ClearSlots
// (Final, Native, Public, BlueprintCallable)

void UDynamicContainerWidget::ClearSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicContainerWidget", "ClearSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.DynamicContainerWidget.SetSlotClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFlameSlot>           InSlotClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicContainerWidget::SetSlotClass(TSubclassOf<class UFlameSlot> InSlotClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicContainerWidget", "SetSlotClass");

	Params::DynamicContainerWidget_SetSlotClass Parms{};

	Parms.InSlotClass = InSlotClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.DynamicContainerWidget.SetUserFocusToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicContainerWidget::SetUserFocusToSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicContainerWidget", "SetUserFocusToSlot");

	Params::DynamicContainerWidget_SetUserFocusToSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameListWidget.GetWidgetToFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UFlameListWidget::GetWidgetToFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameListWidget", "GetWidgetToFocus");

	Params::FlameListWidget_GetWidgetToFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameListWidget.UpdateUserFocusBP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UFlameListWidget::UpdateUserFocusBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameListWidget", "UpdateUserFocusBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameListWidget.UpdateUserFocusDefault
// (Final, Native, Public, BlueprintCallable)

void UFlameListWidget::UpdateUserFocusDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameListWidget", "UpdateUserFocusDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameListWidget.GetBPSlots
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UFlameSlot*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UFlameSlot*> UFlameListWidget::GetBPSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameListWidget", "GetBPSlots");

	Params::FlameListWidget_GetBPSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.Activate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UWheelSegment::Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "Activate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WheelSegment.OnDeselect
// (Event, Public, BlueprintEvent)

void UWheelSegment::OnDeselect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "OnDeselect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.WheelSegment.OnSelect
// (Event, Public, BlueprintEvent)

void UWheelSegment::OnSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "OnSelect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.WheelSegment.CanBeSelected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWheelSegment::CanBeSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "CanBeSelected");

	Params::WheelSegment_CanBeSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.GetAngularDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWheelSegment::GetAngularDistance(float InAngle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "GetAngularDistance");

	Params::WheelSegment_GetAngularDistance Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.GetContentPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   InWheelRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWheelSegment::GetContentPosition(float InWheelRadius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "GetContentPosition");

	Params::WheelSegment_GetContentPosition Parms{};

	Parms.InWheelRadius = InWheelRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.GetEquipIndicatorColor
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UWheelSegment::GetEquipIndicatorColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "GetEquipIndicatorColor");

	Params::WheelSegment_GetEquipIndicatorColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.GetWheelComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USelectionWheelComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USelectionWheelComponent* UWheelSegment::GetWheelComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "GetWheelComponent");

	Params::WheelSegment_GetWheelComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.IsAngleInSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWheelSegment::IsAngleInSegment(float InAngle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "IsAngleInSegment");

	Params::WheelSegment_IsAngleInSegment Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WheelSegment.IsSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWheelSegment::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WheelSegment", "IsSelected");

	Params::WheelSegment_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameHUD.HideLoadout
// (Final, Native, Public, BlueprintCallable)

void AFlameHUD::HideLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "HideLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameHUD.OnServerConnectionStateImproved
// (Final, Native, Protected)

void AFlameHUD::OnServerConnectionStateImproved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "OnServerConnectionStateImproved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameHUD.OnServerConnectionStateUpdated
// (Final, Native, Protected)
// Parameters:
// bool                                    bClientHasConnectionIssues                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFlameHUD::OnServerConnectionStateUpdated(bool bClientHasConnectionIssues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "OnServerConnectionStateUpdated");

	Params::FlameHUD_OnServerConnectionStateUpdated Parms{};

	Parms.bClientHasConnectionIssues = bClientHasConnectionIssues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameHUD.SetHUDVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFlameHUD::SetHUDVisibility(ESlateVisibility Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "SetHUDVisibility");

	Params::FlameHUD_SetHUDVisibility Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameHUD.ShowLoadout
// (Final, Native, Public, BlueprintCallable)

void AFlameHUD::ShowLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "ShowLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameHUD.ShouldInputAxisBeIgnored
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAxisName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlameHUD::ShouldInputAxisBeIgnored(class FName InAxisName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameHUD", "ShouldInputAxisBeIgnored");

	Params::FlameHUD_ShouldInputAxisBeIgnored Parms{};

	Parms.InAxisName = InAxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumableSegment.SetConsumableClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsumableSegment::SetConsumableClass(TSubclassOf<class AConsumableItem> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableSegment", "SetConsumableClass");

	Params::ConsumableSegment_SetConsumableClass Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ConsumablesFunctions.GetAllAttachedCharactersInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  OwnerCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAttachedCharacterInfo>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAttachedCharacterInfo> UConsumablesFunctions::GetAllAttachedCharactersInfo(const class AHumanCharacter* OwnerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsumablesFunctions", "GetAllAttachedCharactersInfo");

	Params::ConsumablesFunctions_GetAllAttachedCharactersInfo Parms{};

	Parms.OwnerCharacter = OwnerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumablesFunctions.GetAttachedCharacterInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  AttachedCharacter                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttachedCharacterInfo           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAttachedCharacterInfo UConsumablesFunctions::GetAttachedCharacterInfo(const class AHumanCharacter* AttachedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsumablesFunctions", "GetAttachedCharacterInfo");

	Params::ConsumablesFunctions_GetAttachedCharacterInfo Parms{};

	Parms.AttachedCharacter = AttachedCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumablesFunctions.GetInfoAboutAttachingTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  OwnerCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttachedCharacterInfo           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAttachedCharacterInfo UConsumablesFunctions::GetInfoAboutAttachingTarget(const class AHumanCharacter* OwnerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsumablesFunctions", "GetInfoAboutAttachingTarget");

	Params::ConsumablesFunctions_GetInfoAboutAttachingTarget Parms{};

	Parms.OwnerCharacter = OwnerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameplayStorage.OnLootStored
// (Event, Public, BlueprintEvent)
// Parameters:
// class AItem*                            Loot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayStorage::OnLootStored(class AItem* Loot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "OnLootStored");

	Params::GameplayStorage_OnLootStored Parms{};

	Parms.Loot = Loot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameplayStorage.OnLootStoredClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class AItemForBackpack>     LootClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayStorage::OnLootStoredClass(TSubclassOf<class AItemForBackpack> LootClass, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "OnLootStoredClass");

	Params::GameplayStorage_OnLootStoredClass Parms{};

	Parms.LootClass = LootClass;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameplayStorage.OnLootTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// class AItem*                            Loot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayStorage::OnLootTaken(class AItem* Loot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "OnLootTaken");

	Params::GameplayStorage_OnLootTaken Parms{};

	Parms.Loot = Loot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameplayStorage.OnLootTakenClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class AItemForBackpack>     LootClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayStorage::OnLootTakenClass(TSubclassOf<class AItemForBackpack> LootClass, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "OnLootTakenClass");

	Params::GameplayStorage_OnLootTakenClass Parms{};

	Parms.LootClass = LootClass;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameplayStorage.UnlinkAndDestroyAllStoredItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameplayStorage::UnlinkAndDestroyAllStoredItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "UnlinkAndDestroyAllStoredItems");

	Params::GameplayStorage_UnlinkAndDestroyAllStoredItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameplayStorage.OnLootChanged
// (Event, Public, BlueprintEvent, Const)

void AGameplayStorage::OnLootChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayStorage", "OnLootChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Lootable.LootDistrubuted
// (Event, Public, BlueprintEvent)

void ALootable::LootDistrubuted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lootable", "LootDistrubuted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Lootable.OnRep_LootDistributed
// (Final, Native, Private)

void ALootable::OnRep_LootDistributed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lootable", "OnRep_LootDistributed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Lootable.WasPlacedInEditor
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALootable::WasPlacedInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lootable", "WasPlacedInEditor");

	Params::Lootable_WasPlacedInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Grenade.MulticastNotifyExplosion
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// TArray<struct FExplosionEffect>         ExplosionEffects                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGrenade::MulticastNotifyExplosion(const TArray<struct FExplosionEffect>& ExplosionEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grenade", "MulticastNotifyExplosion");

	Params::Grenade_MulticastNotifyExplosion Parms{};

	Parms.ExplosionEffects = std::move(ExplosionEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Grenade.OnGrenadeExplode
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FExplosionEffect>         ExplosionEffects                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGrenade::OnGrenadeExplode(const TArray<struct FExplosionEffect>& ExplosionEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grenade", "OnGrenadeExplode");

	Params::Grenade_OnGrenadeExplode Parms{};

	Parms.ExplosionEffects = std::move(ExplosionEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Grenade.OnImpact
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGrenade::OnImpact(const struct FVector& HitLocation, const struct FVector& NormalImpulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grenade", "OnImpact");

	Params::Grenade_OnImpact Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.NormalImpulse = std::move(NormalImpulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.Grenade.OnThrow
// (Event, Public, BlueprintEvent)

void AGrenade::OnThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grenade", "OnThrow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.CraftingFunctions.BoostCraftingItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECraftingQueueType                      Queue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudCraftingBoosterPaymentType        PaymentType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::BoostCraftingItem(ECraftingQueueType Queue, ECloudCraftingBoosterPaymentType PaymentType, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "BoostCraftingItem");

	Params::CraftingFunctions_BoostCraftingItem Parms{};

	Parms.Queue = Queue;
	Parms.PaymentType = PaymentType;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CanBeCraft
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APlan>                Plan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::CanBeCraft(TSubclassOf<class APlan> Plan, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CanBeCraft");

	Params::CraftingFunctions_CanBeCraft Parms{};

	Parms.Plan = Plan;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CancelConsumableInQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::CancelConsumableInQueue(int32 Index_0, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CancelConsumableInQueue");

	Params::CraftingFunctions_CancelConsumableInQueue Parms{};

	Parms.Index_0 = Index_0;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CancelWeaponInQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::CancelWeaponInQueue(int32 Index_0, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CancelWeaponInQueue");

	Params::CraftingFunctions_CancelWeaponInQueue Parms{};

	Parms.Index_0 = Index_0;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CanCraftAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::CanCraftAmmo(TSubclassOf<class AAmmoItem> AmmoItemClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CanCraftAmmo");

	Params::CraftingFunctions_CanCraftAmmo Parms{};

	Parms.AmmoItemClass = AmmoItemClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CanCraftConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::CanCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CanCraftConsumable");

	Params::CraftingFunctions_CanCraftConsumable Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CanCraftWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::CanCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CanCraftWeapon");

	Params::CraftingFunctions_CanCraftWeapon Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CraftAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::CraftAmmo(TSubclassOf<class AAmmoItem> AmmoClass, int32 Count, class AStash* Stash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CraftAmmo");

	Params::CraftingFunctions_CraftAmmo Parms{};

	Parms.AmmoClass = AmmoClass;
	Parms.Count = Count;
	Parms.Stash = Stash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CraftConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBoosted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::CraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash, bool IsBoosted, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CraftConsumable");

	Params::CraftingFunctions_CraftConsumable Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;
	Parms.IsBoosted = IsBoosted;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.CraftWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBoosted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::CraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash, bool IsBoosted, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "CraftWeapon");

	Params::CraftingFunctions_CraftWeapon Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;
	Parms.IsBoosted = IsBoosted;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.DeconstructAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoForDeconstruct                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::DeconstructAmmo(TSubclassOf<class AAmmoItem> AmmoForDeconstruct, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "DeconstructAmmo");

	Params::CraftingFunctions_DeconstructAmmo Parms{};

	Parms.AmmoForDeconstruct = AmmoForDeconstruct;
	Parms.Count = Count;
	Parms.Stash = Stash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.DeconstructConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      OneConsumable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::DeconstructConsumable(TSubclassOf<class AConsumableItem> OneConsumable, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "DeconstructConsumable");

	Params::CraftingFunctions_DeconstructConsumable Parms{};

	Parms.OneConsumable = OneConsumable;
	Parms.Count = Count;
	Parms.Stash = Stash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.DeconstructPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APartItem>            PartForDeconstruct                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::DeconstructPart(TSubclassOf<class APartItem> PartForDeconstruct, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "DeconstructPart");

	Params::CraftingFunctions_DeconstructPart Parms{};

	Parms.PartForDeconstruct = PartForDeconstruct;
	Parms.Count = Count;
	Parms.Stash = Stash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.DeconstructWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              OneWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::DeconstructWeapon(TSubclassOf<class AWeapon> OneWeapon, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "DeconstructWeapon");

	Params::CraftingFunctions_DeconstructWeapon Parms{};

	Parms.OneWeapon = OneWeapon;
	Parms.Count = Count;
	Parms.Stash = Stash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAllUnlockedConsumablePlans
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AConsumablePlan>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AConsumablePlan>> UCraftingFunctions::GetAllUnlockedConsumablePlans(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAllUnlockedConsumablePlans");

	Params::CraftingFunctions_GetAllUnlockedConsumablePlans Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAllUnlockedWeaponPlans
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AWeaponPlan>>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AWeaponPlan>> UCraftingFunctions::GetAllUnlockedWeaponPlans(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAllUnlockedWeaponPlans");

	Params::CraftingFunctions_GetAllUnlockedWeaponPlans Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAmmoCraftingTimeInSec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetAmmoCraftingTimeInSec(TSubclassOf<class AAmmoItem> AmmoClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAmmoCraftingTimeInSec");

	Params::CraftingFunctions_GetAmmoCraftingTimeInSec Parms{};

	Parms.AmmoClass = AmmoClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAmmoIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIconSize                               Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCraftingFunctions::GetAmmoIcon(TSubclassOf<class AAmmoItem> AmmoClass, EIconSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAmmoIcon");

	Params::CraftingFunctions_GetAmmoIcon Parms{};

	Parms.AmmoClass = AmmoClass;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAmmoName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCraftingFunctions::GetAmmoName(TSubclassOf<class AAmmoItem> AmmoClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAmmoName");

	Params::CraftingFunctions_GetAmmoName Parms{};

	Parms.AmmoClass = AmmoClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetAmmoPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetAmmoPrice(TSubclassOf<class AAmmoItem> AmmoClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetAmmoPrice");

	Params::CraftingFunctions_GetAmmoPrice Parms{};

	Parms.AmmoClass = AmmoClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetBonusAmmoForWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetBonusAmmoForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetBonusAmmoForWeapon");

	Params::CraftingFunctions_GetBonusAmmoForWeapon Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetBonusAmmoForWeaponFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetBonusAmmoForWeaponFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetBonusAmmoForWeaponFromPlan");

	Params::CraftingFunctions_GetBonusAmmoForWeaponFromPlan Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableCostInParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumableCostInParts(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableCostInParts");

	Params::CraftingFunctions_GetConsumableCostInParts Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableCostInPartsFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumableCostInPartsFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableCostInPartsFromPlan");

	Params::CraftingFunctions_GetConsumableCostInPartsFromPlan Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableCraftingBoosterPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumableCraftingBoosterPrice(TSubclassOf<class AConsumableItem> ItemClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableCraftingBoosterPrice");

	Params::CraftingFunctions_GetConsumableCraftingBoosterPrice Parms{};

	Parms.ItemClass = ItemClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableCraftingQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudCraftingQueue              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudCraftingQueue UCraftingFunctions::GetConsumableCraftingQueue(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableCraftingQueue");

	Params::CraftingFunctions_GetConsumableCraftingQueue Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIconSize                               Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCraftingFunctions::GetConsumableIcon(TSubclassOf<class AConsumableItem> ConsumableClass, EIconSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableIcon");

	Params::CraftingFunctions_GetConsumableIcon Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableInQueueInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingItemStatus              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCraftingItemStatus UCraftingFunctions::GetConsumableInQueueInfo(int32 Index_0, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableInQueueInfo");

	Params::CraftingFunctions_GetConsumableInQueueInfo Parms{};

	Parms.Index_0 = Index_0;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumableName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCraftingFunctions::GetConsumableName(TSubclassOf<class AConsumableItem> ConsumableClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumableName");

	Params::CraftingFunctions_GetConsumableName Parms{};

	Parms.ConsumableClass = ConsumableClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePartCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePart>      ConsumablePartClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumablePartCount(TSubclassOf<class AConsumablePart> ConsumablePartClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePartCount");

	Params::CraftingFunctions_GetConsumablePartCount Parms{};

	Parms.ConsumablePartClass = ConsumablePartClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePartIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePart>      ConsumablePartClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIconSize                               Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCraftingFunctions::GetConsumablePartIcon(TSubclassOf<class AConsumablePart> ConsumablePartClass, EIconSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePartIcon");

	Params::CraftingFunctions_GetConsumablePartIcon Parms{};

	Parms.ConsumablePartClass = ConsumablePartClass;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePartName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePart>      ConsumablePartClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCraftingFunctions::GetConsumablePartName(TSubclassOf<class AConsumablePart> ConsumablePartClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePartName");

	Params::CraftingFunctions_GetConsumablePartName Parms{};

	Parms.ConsumablePartClass = ConsumablePartClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePartPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePart>      ConsumablePartClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumablePartPrice(TSubclassOf<class AConsumablePart> ConsumablePartClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePartPrice");

	Params::CraftingFunctions_GetConsumablePartPrice Parms{};

	Parms.ConsumablePartClass = ConsumablePartClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePartPriceForDeconstruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePart>      ConsumablePartClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingFunctions::GetConsumablePartPriceForDeconstruction(TSubclassOf<class AConsumablePart> ConsumablePartClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePartPriceForDeconstruction");

	Params::CraftingFunctions_GetConsumablePartPriceForDeconstruction Parms{};

	Parms.ConsumablePartClass = ConsumablePartClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AConsumablePlan>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AConsumablePlan> UCraftingFunctions::GetConsumablePlan(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePlan");

	Params::CraftingFunctions_GetConsumablePlan Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablePrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetConsumablePrice(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablePrice");

	Params::CraftingFunctions_GetConsumablePrice Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetConsumablesPlanParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AConsumablePart>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AConsumablePart>> UCraftingFunctions::GetConsumablesPlanParts(TSubclassOf<class AConsumablePlan> ConsumablePlanClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetConsumablesPlanParts");

	Params::CraftingFunctions_GetConsumablesPlanParts Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCostForBoostCraftingItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECraftingQueueType                      Queue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetCostForBoostCraftingItem(ECraftingQueueType Queue, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCostForBoostCraftingItem");

	Params::CraftingFunctions_GetCostForBoostCraftingItem Parms{};

	Parms.Queue = Queue;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCraftManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACraftingConfigManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACraftingConfigManager* UCraftingFunctions::GetCraftManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCraftManager");

	Params::CraftingFunctions_GetCraftManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingItemInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCraftingItemInfo UCraftingFunctions::GetCurrentCraftingAmmo(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingAmmo");

	Params::CraftingFunctions_GetCurrentCraftingAmmo Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingAmmoClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAmmoItem>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AAmmoItem> UCraftingFunctions::GetCurrentCraftingAmmoClass(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingAmmoClass");

	Params::CraftingFunctions_GetCurrentCraftingAmmoClass Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingConsumableClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AConsumableItem>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AConsumableItem> UCraftingFunctions::GetCurrentCraftingConsumableClass(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingConsumableClass");

	Params::CraftingFunctions_GetCurrentCraftingConsumableClass Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingConsumables
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingItemInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCraftingItemInfo UCraftingFunctions::GetCurrentCraftingConsumables(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingConsumables");

	Params::CraftingFunctions_GetCurrentCraftingConsumables Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingItemInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCraftingItemInfo UCraftingFunctions::GetCurrentCraftingWeapon(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingWeapon");

	Params::CraftingFunctions_GetCurrentCraftingWeapon Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetCurrentCraftingWeaponClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeapon> UCraftingFunctions::GetCurrentCraftingWeaponClass(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetCurrentCraftingWeaponClass");

	Params::CraftingFunctions_GetCurrentCraftingWeaponClass Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetItemFromCraftingQueue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudCraftingQueue              Queue                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItem> UCraftingFunctions::GetItemFromCraftingQueue(const struct FCloudCraftingQueue& Queue, const class UObject* WorldContextObject, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetItemFromCraftingQueue");

	Params::CraftingFunctions_GetItemFromCraftingQueue Parms{};

	Parms.Queue = std::move(Queue);
	Parms.WorldContextObject = WorldContextObject;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetItemsInConsumableCraftingQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCloudCraftedItem>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCloudCraftedItem> UCraftingFunctions::GetItemsInConsumableCraftingQueue(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetItemsInConsumableCraftingQueue");

	Params::CraftingFunctions_GetItemsInConsumableCraftingQueue Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetItemsInWeaponsCraftingQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCloudCraftedItem>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCloudCraftedItem> UCraftingFunctions::GetItemsInWeaponsCraftingQueue(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetItemsInWeaponsCraftingQueue");

	Params::CraftingFunctions_GetItemsInWeaponsCraftingQueue Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForConsumable(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForConsumable");

	Params::CraftingFunctions_GetNeededLevelForConsumable Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForConsumableFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForConsumableFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForConsumableFromPlan");

	Params::CraftingFunctions_GetNeededLevelForConsumableFromPlan Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForCraftConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForCraftConsumable");

	Params::CraftingFunctions_GetNeededLevelForCraftConsumable Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForCraftWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForCraftWeapon");

	Params::CraftingFunctions_GetNeededLevelForCraftWeapon Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForWeapon");

	Params::CraftingFunctions_GetNeededLevelForWeapon Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetNeededLevelForWeaponFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetNeededLevelForWeaponFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetNeededLevelForWeaponFromPlan");

	Params::CraftingFunctions_GetNeededLevelForWeaponFromPlan Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetRemainingAmmoCraftingTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UCraftingFunctions::GetRemainingAmmoCraftingTime(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetRemainingAmmoCraftingTime");

	Params::CraftingFunctions_GetRemainingAmmoCraftingTime Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetRemainingConsumablesCraftingTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UCraftingFunctions::GetRemainingConsumablesCraftingTime(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetRemainingConsumablesCraftingTime");

	Params::CraftingFunctions_GetRemainingConsumablesCraftingTime Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetRemainingCraftingTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ECraftingQueueType                      Queue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UCraftingFunctions::GetRemainingCraftingTime(ECraftingQueueType Queue, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetRemainingCraftingTime");

	Params::CraftingFunctions_GetRemainingCraftingTime Parms{};

	Parms.Queue = Queue;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetRemainingWeaponCraftingTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UCraftingFunctions::GetRemainingWeaponCraftingTime(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetRemainingWeaponCraftingTime");

	Params::CraftingFunctions_GetRemainingWeaponCraftingTime Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftConsumableFromMaterialInSec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftConsumableFromMaterialInSec(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftConsumableFromMaterialInSec");

	Params::CraftingFunctions_GetTimeToCraftConsumableFromMaterialInSec Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftConsumableFromPartsInSec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftConsumableFromPartsInSec(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftConsumableFromPartsInSec");

	Params::CraftingFunctions_GetTimeToCraftConsumableFromPartsInSec Parms{};

	Parms.ConsumableClass = ConsumableClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftConsumableFromPartsInSecFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftConsumableFromPartsInSecFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftConsumableFromPartsInSecFromPlan");

	Params::CraftingFunctions_GetTimeToCraftConsumableFromPartsInSecFromPlan Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftWeaponFromMaterialInSec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftWeaponFromMaterialInSec(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftWeaponFromMaterialInSec");

	Params::CraftingFunctions_GetTimeToCraftWeaponFromMaterialInSec Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftWeaponFromPartsInSec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftWeaponFromPartsInSec(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftWeaponFromPartsInSec");

	Params::CraftingFunctions_GetTimeToCraftWeaponFromPartsInSec Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetTimeToCraftWeaponFromPartsInSecFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetTimeToCraftWeaponFromPartsInSecFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetTimeToCraftWeaponFromPartsInSecFromPlan");

	Params::CraftingFunctions_GetTimeToCraftWeaponFromPartsInSecFromPlan Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponCostInParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponCostInParts(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponCostInParts");

	Params::CraftingFunctions_GetWeaponCostInParts Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponCostInPartsFromPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponCostInPartsFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponCostInPartsFromPlan");

	Params::CraftingFunctions_GetWeaponCostInPartsFromPlan Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponCraftingBoosterPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponCraftingBoosterPrice(TSubclassOf<class AWeapon> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponCraftingBoosterPrice");

	Params::CraftingFunctions_GetWeaponCraftingBoosterPrice Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponCraftingQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudCraftingQueue              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudCraftingQueue UCraftingFunctions::GetWeaponCraftingQueue(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponCraftingQueue");

	Params::CraftingFunctions_GetWeaponCraftingQueue Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIconSize                               Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCraftingFunctions::GetWeaponIcon(TSubclassOf<class AWeapon> WeaponClass, EIconSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponIcon");

	Params::CraftingFunctions_GetWeaponIcon Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponInQueueInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCraftingItemStatus              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCraftingItemStatus UCraftingFunctions::GetWeaponInQueueInfo(int32 Index_0, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponInQueueInfo");

	Params::CraftingFunctions_GetWeaponInQueueInfo Parms{};

	Parms.Index_0 = Index_0;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCraftingFunctions::GetWeaponName(TSubclassOf<class AWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponName");

	Params::CraftingFunctions_GetWeaponName Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPartCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPart>          WeaponPartClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponPartCount(TSubclassOf<class AWeaponPart> WeaponPartClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPartCount");

	Params::CraftingFunctions_GetWeaponPartCount Parms{};

	Parms.WeaponPartClass = WeaponPartClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPartIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPart>          WeaponPartClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIconSize                               Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCraftingFunctions::GetWeaponPartIcon(TSubclassOf<class AWeaponPart> WeaponPartClass, EIconSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPartIcon");

	Params::CraftingFunctions_GetWeaponPartIcon Parms{};

	Parms.WeaponPartClass = WeaponPartClass;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPartName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPart>          WeaponPartClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCraftingFunctions::GetWeaponPartName(TSubclassOf<class AWeaponPart> WeaponPartClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPartName");

	Params::CraftingFunctions_GetWeaponPartName Parms{};

	Parms.WeaponPartClass = WeaponPartClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPartPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPart>          WeaponPartClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponPartPrice(TSubclassOf<class AWeaponPart> WeaponPartClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPartPrice");

	Params::CraftingFunctions_GetWeaponPartPrice Parms{};

	Parms.WeaponPartClass = WeaponPartClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPartPriceForDeconstruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPart>          WeaponPartClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCraftingFunctions::GetWeaponPartPriceForDeconstruction(TSubclassOf<class AWeaponPart> WeaponPartClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPartPriceForDeconstruction");

	Params::CraftingFunctions_GetWeaponPartPriceForDeconstruction Parms{};

	Parms.WeaponPartClass = WeaponPartClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponPlan>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeaponPlan> UCraftingFunctions::GetWeaponPlan(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPlan");

	Params::CraftingFunctions_GetWeaponPlan Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPlanParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AWeaponPart>>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AWeaponPart>> UCraftingFunctions::GetWeaponPlanParts(TSubclassOf<class AWeaponPlan> WeaponPlanClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPlanParts");

	Params::CraftingFunctions_GetWeaponPlanParts Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.GetWeaponPrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCraftingFunctions::GetWeaponPrice(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "GetWeaponPrice");

	Params::CraftingFunctions_GetWeaponPrice Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.HasLevelForCraftConsumable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::HasLevelForCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "HasLevelForCraftConsumable");

	Params::CraftingFunctions_HasLevelForCraftConsumable Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.HasLevelForCraftWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::HasLevelForCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "HasLevelForCraftWeapon");

	Params::CraftingFunctions_HasLevelForCraftWeapon Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.IsConsumableCraftable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::IsConsumableCraftable(TSubclassOf<class AConsumableItem> ConsumablePlanClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "IsConsumableCraftable");

	Params::CraftingFunctions_IsConsumableCraftable Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.IsConsumableEquipableFromShelter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::IsConsumableEquipableFromShelter(TSubclassOf<class AConsumableItem> ConsumablePlanClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "IsConsumableEquipableFromShelter");

	Params::CraftingFunctions_IsConsumableEquipableFromShelter Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.IsConsumablePlanUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumablePlan>      ConsumablePlanClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::IsConsumablePlanUnlocked(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "IsConsumablePlanUnlocked");

	Params::CraftingFunctions_IsConsumablePlanUnlocked Parms{};

	Parms.ConsumablePlanClass = ConsumablePlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.IsWeaponPlanUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponPlan>          WeaponPlanClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCraftingFunctions::IsWeaponPlanUnlocked(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "IsWeaponPlanUnlocked");

	Params::CraftingFunctions_IsWeaponPlanUnlocked Parms{};

	Parms.WeaponPlanClass = WeaponPlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingFunctions.UnlockPlan
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APlan>                PlanClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UCraftingFunctions::UnlockPlan(TSubclassOf<class APlan> PlanClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CraftingFunctions", "UnlockPlan");

	Params::CraftingFunctions_UnlockPlan Parms{};

	Parms.PlanClass = PlanClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HasItemInterface.ClearItem
// (Native, Public, BlueprintCallable)

void IHasItemInterface::ClearItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasItemInterface", "ClearItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HasItemInterface.SetItemInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class AItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHasItemInterface::SetItemInstance(class AItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasItemInterface", "SetItemInstance");

	Params::HasItemInterface_SetItemInstance Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HasItemInterface.SetItemType
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHasItemInterface::SetItemType(TSubclassOf<class AItem> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasItemInterface", "SetItemType");

	Params::HasItemInterface_SetItemType Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HasItemInterface.GetItemObsolete
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem* IHasItemInterface::GetItemObsolete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasItemInterface", "GetItemObsolete");

	Params::HasItemInterface_GetItemObsolete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HasItemInterface.GetItemType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItem>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItem> IHasItemInterface::GetItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasItemInterface", "GetItemType");

	Params::HasItemInterface_GetItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingTimerManager.GetCurrentTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ACraftingTimerManager::GetCurrentTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingTimerManager", "GetCurrentTime");

	Params::CraftingTimerManager_GetCurrentTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CraftingTimerManager.GetLastUpdateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ACraftingTimerManager::GetLastUpdateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CraftingTimerManager", "GetLastUpdateTime");

	Params::CraftingTimerManager_GetLastUpdateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CurrencyWidget.OnValueChanged
// (Event, Public, BlueprintEvent)

void UCurrencyWidget::OnValueChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurrencyWidget", "OnValueChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Mannequin.ClearGestureSFX
// (Final, Native, Public, BlueprintCallable)

void AMannequin::ClearGestureSFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mannequin", "ClearGestureSFX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Mannequin.GetPlayerCurrentOutfitVariantSlots
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FCustomizationSlotVariant>PairsToOverride                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FCustomizationSlotVariant>OutVariantSlotsPairs                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bOutSucess                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMannequin::GetPlayerCurrentOutfitVariantSlots(TArray<struct FCustomizationSlotVariant>& PairsToOverride, TArray<struct FCustomizationSlotVariant>* OutVariantSlotsPairs, bool* bOutSucess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mannequin", "GetPlayerCurrentOutfitVariantSlots");

	Params::Mannequin_GetPlayerCurrentOutfitVariantSlots Parms{};

	Parms.PairsToOverride = std::move(PairsToOverride);

	UObject::ProcessEvent(Func, &Parms);

	PairsToOverride = std::move(Parms.PairsToOverride);

	if (OutVariantSlotsPairs != nullptr)
		*OutVariantSlotsPairs = std::move(Parms.OutVariantSlotsPairs);

	if (bOutSucess != nullptr)
		*bOutSucess = Parms.bOutSucess;
}


// Function Flame.Mannequin.InitFromCharacterNative
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  SourceCharacter                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMannequin::InitFromCharacterNative(const class AHumanCharacter* SourceCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mannequin", "InitFromCharacterNative");

	Params::Mannequin_InitFromCharacterNative Parms{};

	Parms.SourceCharacter = SourceCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameScalableGridWidget.SetWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameScalableGridWidget::SetWidth(int32 InWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameScalableGridWidget", "SetWidth");

	Params::FlameScalableGridWidget_SetWidth Parms{};

	Parms.InWidth = InWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CurveMeleeArc.GetVectorValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveMeleeArc::GetVectorValue(float InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveMeleeArc", "GetVectorValue");

	Params::CurveMeleeArc_GetVectorValue Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CurveMovementSpeed.GetVectorValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveMovementSpeed::GetVectorValue(float InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveMovementSpeed", "GetVectorValue");

	Params::CurveMovementSpeed_GetVectorValue Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CurveSlopeSpeed.GetVectorValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveSlopeSpeed::GetVectorValue(float InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSlopeSpeed", "GetVectorValue");

	Params::CurveSlopeSpeed_GetVectorValue Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomInputFilter.CheckFilter
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AHumanPlayerController*           TargetController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputFilterResult                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputFilterResult ACustomInputFilter::CheckFilter(const class AHumanPlayerController* TargetController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomInputFilter", "CheckFilter");

	Params::CustomInputFilter_CheckFilter Parms{};

	Parms.TargetController = TargetController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameSpectatorPawn.DrawDebugLocation
// (Net, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFlameSpectatorPawn::DrawDebugLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectatorPawn", "DrawDebugLocation");

	Params::FlameSpectatorPawn_DrawDebugLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpectatorPawn.OnRep_ServerTarget
// (Final, Native, Protected)

void AFlameSpectatorPawn::OnRep_ServerTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectatorPawn", "OnRep_ServerTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpectatorPawn.OnServerTargetChanged
// (Event, Protected, BlueprintEvent)

void AFlameSpectatorPawn::OnServerTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectatorPawn", "OnServerTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameSpectatorPawn.OnTargetChanged
// (Native, Event, Protected, BlueprintEvent)

void AFlameSpectatorPawn::OnTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectatorPawn", "OnTargetChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CustomInputRule.CustomReactOnInput
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AHumanPlayerController*           TargetController                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputRule                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputRule ACustomInputRule::CustomReactOnInput(const class AHumanPlayerController* TargetController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomInputRule", "CustomReactOnInput");

	Params::CustomInputRule_CustomReactOnInput Parms{};

	Parms.TargetController = TargetController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameSave.SaveGameToSlotByPlatform
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFlameGameInstance*               FlameGameInstance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGameObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameGameSave*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameSave* UFlameGameSave::SaveGameToSlotByPlatform(class UFlameGameInstance* FlameGameInstance, class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameSave", "SaveGameToSlotByPlatform");

	Params::FlameGameSave_SaveGameToSlotByPlatform Parms{};

	Parms.FlameGameInstance = FlameGameInstance;
	Parms.SaveGameObject = SaveGameObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameSave.ReceivedSaveResults
// (Final, Native, Private)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameSave::ReceivedSaveResults(const class FString& SlotName, const int32 UserIndex, bool bSucceeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameSave", "ReceivedSaveResults");

	Params::FlameGameSave_ReceivedSaveResults Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;
	Parms.bSucceeded = bSucceeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryItemProvider.SetItemStorageComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentStorageComponent*       Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryItemProvider::SetItemStorageComponent(const class UEquipmentStorageComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemProvider", "SetItemStorageComponent");

	Params::InventoryItemProvider_SetItemStorageComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryItemProvider.SetPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InController                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryItemProvider::SetPlayerController(const class APlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemProvider", "SetPlayerController");

	Params::InventoryItemProvider_SetPlayerController Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.ActivateParticleSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         PS                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  Template                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ActivateParticleSystem(class UParticleSystemComponent* PS, class UParticleSystem* Template)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ActivateParticleSystem");

	Params::Weapon_ActivateParticleSystem Parms{};

	Parms.PS = PS;
	Parms.Template = Template;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.GetSoundAttachementComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AWeapon::GetSoundAttachementComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetSoundAttachementComponent");

	Params::Weapon_GetSoundAttachementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.LoadAmmoFromBag
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::LoadAmmoFromBag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "LoadAmmoFromBag");

	Params::Weapon_LoadAmmoFromBag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.MulticastPlayFireEffects
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bConsumedAmmo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::MulticastPlayFireEffects(bool bConsumedAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "MulticastPlayFireEffects");

	Params::Weapon_MulticastPlayFireEffects Parms{};

	Parms.bConsumedAmmo = bConsumedAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.MulticastPlayMeleeEffects
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::MulticastPlayMeleeEffects(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "MulticastPlayMeleeEffects");

	Params::Weapon_MulticastPlayMeleeEffects Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.OnRep_CurrentMuzzle
// (Final, Native, Private)

void AWeapon::OnRep_CurrentMuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_CurrentMuzzle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.OnRep_Skin
// (Final, Native, Private)
// Parameters:
// TSubclassOf<class AItemSkin>            OldSkinClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::OnRep_Skin(TSubclassOf<class AItemSkin> OldSkinClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_Skin");

	Params::Weapon_OnRep_Skin Parms{};

	Parms.OldSkinClass = OldSkinClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.OnRep_WeaponStateChamberRound
// (Final, Native, Private)

void AWeapon::OnRep_WeaponStateChamberRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_WeaponStateChamberRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.OnRep_WeaponStateFiring
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class UWeaponStateFiring*>       OldState                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AWeapon::OnRep_WeaponStateFiring(TArray<class UWeaponStateFiring*>* OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_WeaponStateFiring");

	Params::Weapon_OnRep_WeaponStateFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldState != nullptr)
		*OldState = std::move(Parms.OldState);
}


// Function Flame.Weapon.OnRep_WeaponStateMeleeAttack
// (Final, Native, Private)

void AWeapon::OnRep_WeaponStateMeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_WeaponStateMeleeAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.OnRep_WeaponStateReload
// (Final, Native, Private)

void AWeapon::OnRep_WeaponStateReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_WeaponStateReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.PlayReloadSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::PlayReloadSound(class USoundBase* SoundToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "PlayReloadSound");

	Params::Weapon_PlayReloadSound Parms{};

	Parms.SoundToPlay = SoundToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.ReceiveFireShot
// (Event, Public, BlueprintEvent)

void AWeapon::ReceiveFireShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ReceiveFireShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Weapon.ReceiveMeleeHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWeapon::ReceiveMeleeHit(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ReceiveMeleeHit");

	Params::Weapon_ReceiveMeleeHit Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.Weapon.ReloadTimeEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWeapon::ReloadTimeEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ReloadTimeEmpty");

	Params::Weapon_ReloadTimeEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.ReloadTimeFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWeapon::ReloadTimeFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ReloadTimeFull");

	Params::Weapon_ReloadTimeFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.SetPreviousFireMode
// (Final, Native, Public, BlueprintCallable)

void AWeapon::SetPreviousFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "SetPreviousFireMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.SetSkinBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItemSkin>            NewSkinClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::SetSkinBP(TSubclassOf<class AItemSkin> NewSkinClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "SetSkinBP");

	Params::Weapon_SetSkinBP Parms{};

	Parms.NewSkinClass = NewSkinClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.StopMelee
// (Native, Public, BlueprintCallable)

void AWeapon::StopMelee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "StopMelee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.SwapADSModels
// (Final, Native, Public)

void AWeapon::SwapADSModels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "SwapADSModels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Weapon.UpdateSocketsOverridesAfterOwnerChange
// (Event, Public, BlueprintEvent)

void AWeapon::UpdateSocketsOverridesAfterOwnerChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "UpdateSocketsOverridesAfterOwnerChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Weapon.CanAcceptReplicatedAmmo
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::CanAcceptReplicatedAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "CanAcceptReplicatedAmmo");

	Params::Weapon_CanAcceptReplicatedAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.CanReload
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::CanReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "CanReload");

	Params::Weapon_CanReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetAimPointComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAimPointComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAimPointComponent* AWeapon::GetAimPointComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetAimPointComponent");

	Params::Weapon_GetAimPointComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetCurrentWeaponFireMode
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponFireType                         OutType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::GetCurrentWeaponFireMode(EWeaponFireType* OutType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetCurrentWeaponFireMode");

	Params::Weapon_GetCurrentWeaponFireMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutType != nullptr)
		*OutType = Parms.OutType;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetExtraSkinGeometryMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AWeapon::GetExtraSkinGeometryMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetExtraSkinGeometryMesh");

	Params::Weapon_GetExtraSkinGeometryMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetInventoryType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponInventoryType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponInventoryType AWeapon::GetInventoryType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetInventoryType");

	Params::Weapon_GetInventoryType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetMaterialInfoImplementation
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FFlameSkinMaterialInfo           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FFlameSkinMaterialInfo AWeapon::GetMaterialInfoImplementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetMaterialInfoImplementation");

	Params::Weapon_GetMaterialInfoImplementation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetParentDebugString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AWeapon::GetParentDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetParentDebugString");

	Params::Weapon_GetParentDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetPlan
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AWeaponPlan>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeaponPlan> AWeapon::GetPlan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetPlan");

	Params::Weapon_GetPlan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetShellImpactMaterialIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AWeapon::GetShellImpactMaterialIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetShellImpactMaterialIndex");

	Params::Weapon_GetShellImpactMaterialIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetShellImpactSound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* AWeapon::GetShellImpactSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetShellImpactSound");

	Params::Weapon_GetShellImpactSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetSightData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWeaponSightConfiguration  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FWeaponSightConfiguration AWeapon::GetSightData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetSightData");

	Params::Weapon_GetSightData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetSkeletalMeshLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class USkeletalMesh>     ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class USkeletalMesh> AWeapon::GetSkeletalMeshLink() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetSkeletalMeshLink");

	Params::Weapon_GetSkeletalMeshLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetSkin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItemSkin>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItemSkin> AWeapon::GetSkin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetSkin");

	Params::Weapon_GetSkin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetSupportedAmmoType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AAmmoItem>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AAmmoItem> AWeapon::GetSupportedAmmoType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetSupportedAmmoType");

	Params::Weapon_GetSupportedAmmoType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetWeaponData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFirearmWeaponConfigurationReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FFirearmWeaponConfiguration AWeapon::GetWeaponData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetWeaponData");

	Params::Weapon_GetWeaponData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.GetWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponType AWeapon::GetWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetWeaponType");

	Params::Weapon_GetWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.IsPrimaryWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::IsPrimaryWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsPrimaryWeapon");

	Params::Weapon_IsPrimaryWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Weapon.IsSecondaryWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::IsSecondaryWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsSecondaryWeapon");

	Params::Weapon_IsSecondaryWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizableItemProvider.SetFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InFilter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizableItemProvider::SetFilter(int32 InFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizableItemProvider", "SetFilter");

	Params::CustomizableItemProvider_SetFilter Parms{};

	Parms.InFilter = InFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MarketplaceComponent.BlockCurrencyForItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductSku                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalPrice                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PriceListGeneration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMarketplaceComponent::BlockCurrencyForItem(const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku, int32 Quantity, int32 TotalPrice, int32 PriceListGeneration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "BlockCurrencyForItem");

	Params::MarketplaceComponent_BlockCurrencyForItem Parms{};

	Parms.Player = Player;
	Parms.MatchCloudId = std::move(MatchCloudId);
	Parms.ProductSku = std::move(ProductSku);
	Parms.Quantity = Quantity;
	Parms.TotalPrice = TotalPrice;
	Parms.PriceListGeneration = PriceListGeneration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MarketplaceComponent.BlockCurrencyForItemDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductSku                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarketplaceComponent::BlockCurrencyForItemDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "BlockCurrencyForItemDelegate__DelegateSignature");

	Params::MarketplaceComponent_BlockCurrencyForItemDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.MatchCloudId = std::move(MatchCloudId);
	Parms.ProductSku = std::move(ProductSku);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MarketplaceComponent.GetPriceList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMarketplaceComponent::GetPriceList(const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "GetPriceList");

	Params::MarketplaceComponent_GetPriceList Parms{};

	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MarketplaceComponent.GetPriceListDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudPriceList                  PriceList                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMarketplaceComponent::GetPriceListDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudPriceList& PriceList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "GetPriceListDelegate__DelegateSignature");

	Params::MarketplaceComponent_GetPriceListDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.PriceList = std::move(PriceList);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MarketplaceComponent.GetUserBalance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMarketplaceComponent::GetUserBalance(const class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "GetUserBalance");

	Params::MarketplaceComponent_GetUserBalance Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MarketplaceComponent.GetUserBalanceDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserBalance                Balance                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMarketplaceComponent::GetUserBalanceDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const struct FCloudUserBalance& Balance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "GetUserBalanceDelegate__DelegateSignature");

	Params::MarketplaceComponent_GetUserBalanceDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.Balance = std::move(Balance);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MarketplaceComponent.UnBlockCurrencyForItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductSku                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMarketplaceComponent::UnBlockCurrencyForItem(const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "UnBlockCurrencyForItem");

	Params::MarketplaceComponent_UnBlockCurrencyForItem Parms{};

	Parms.Player = Player;
	Parms.MatchCloudId = std::move(MatchCloudId);
	Parms.ProductSku = std::move(ProductSku);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MarketplaceComponent.UnBlockCurrencyForItemDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductSku                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarketplaceComponent::UnBlockCurrencyForItemDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarketplaceComponent", "UnBlockCurrencyForItemDelegate__DelegateSignature");

	Params::MarketplaceComponent_UnBlockCurrencyForItemDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.MatchCloudId = std::move(MatchCloudId);
	Parms.ProductSku = std::move(ProductSku);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LobbyComponent.GetBoosterEnumFromSKU
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           BoosterSKU                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ValidityCheck                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EBoosterTypes                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EBoosterTypes ULobbyComponent::GetBoosterEnumFromSKU(const class FString& BoosterSKU, bool* ValidityCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyComponent", "GetBoosterEnumFromSKU");

	Params::LobbyComponent_GetBoosterEnumFromSKU Parms{};

	Parms.BoosterSKU = std::move(BoosterSKU);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ValidityCheck != nullptr)
		*ValidityCheck = Parms.ValidityCheck;

	return Parms.ReturnValue;
}


// Function Flame.LobbyComponent.GetBoosterSKU
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBoosterTypes                           Booster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString ULobbyComponent::GetBoosterSKU(EBoosterTypes Booster) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyComponent", "GetBoosterSKU");

	Params::LobbyComponent_GetBoosterSKU Parms{};

	Parms.Booster = Booster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LobbyComponent.GetUsedBoosterTicketCount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EBoosterTypes                           Booster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 ULobbyComponent::GetUsedBoosterTicketCount(EBoosterTypes Booster) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyComponent", "GetUsedBoosterTicketCount");

	Params::LobbyComponent_GetUsedBoosterTicketCount Parms{};

	Parms.Booster = Booster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FootprintManager.AddFootPrint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DecalSize                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OrientationCoef                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FrameIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* AFootprintManager::AddFootPrint(const struct FVector& Location, const struct FVector& Normal, const struct FVector& Direction, const struct FVector& DecalSize, float OrientationCoef, int32 FrameIdx, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootprintManager", "AddFootPrint");

	Params::FootprintManager_AddFootPrint Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.Direction = std::move(Direction);
	Parms.DecalSize = std::move(DecalSize);
	Parms.OrientationCoef = OrientationCoef;
	Parms.FrameIdx = FrameIdx;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MatchmakingStatus.OnCancelHold
// (Final, Native, Protected)

void UMatchmakingStatus::OnCancelHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnCancelHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.OnCancelReleased
// (Final, Native, Protected)

void UMatchmakingStatus::OnCancelReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnCancelReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.OnHide
// (Event, Protected, BlueprintEvent)

void UMatchmakingStatus::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MatchmakingStatus.OnMatchmakingCancelled
// (Event, Protected, BlueprintEvent)

void UMatchmakingStatus::OnMatchmakingCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnMatchmakingCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MatchmakingStatus.OnMenuClosed
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuWidget*                      MenuWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::OnMenuClosed(class UMenuWidget* MenuWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnMenuClosed");

	Params::MatchmakingStatus_OnMenuClosed Parms{};

	Parms.MenuWidget = MenuWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchmakingStatus.OnMenuOpened
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuWidget*                      MenuWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::OnMenuOpened(class UMenuWidget* MenuWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnMenuOpened");

	Params::MatchmakingStatus_OnMenuOpened Parms{};

	Parms.MenuWidget = MenuWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchmakingStatus.OnPlayerCancelledMatchmaking
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::OnPlayerCancelledMatchmaking(const struct FUniqueNetIdRepl& NetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnPlayerCancelledMatchmaking");

	Params::MatchmakingStatus_OnPlayerCancelledMatchmaking Parms{};

	Parms.NetId = std::move(NetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.OnPlayerStartedMatchmaking
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::OnPlayerStartedMatchmaking(const struct FUniqueNetIdRepl& NetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnPlayerStartedMatchmaking");

	Params::MatchmakingStatus_OnPlayerStartedMatchmaking Parms{};

	Parms.NetId = std::move(NetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.OnServerFound
// (Event, Protected, BlueprintEvent)

void UMatchmakingStatus::OnServerFound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnServerFound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MatchmakingStatus.OnShow
// (Event, Protected, BlueprintEvent)

void UMatchmakingStatus::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MatchmakingStatus.OnStateChanged
// (Event, Protected, BlueprintEvent)

void UMatchmakingStatus::OnStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "OnStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MatchmakingStatus.ServerFound
// (Final, Native, Public, BlueprintCallable)

void UMatchmakingStatus::ServerFound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "ServerFound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.SetLevelName
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InLevelName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::SetLevelName(const class FName& InLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "SetLevelName");

	Params::MatchmakingStatus_SetLevelName Parms{};

	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.SetMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchmakingStatus::SetMessage(const class FText& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "SetMessage");

	Params::MatchmakingStatus_SetMessage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchmakingStatusState                 InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::SetState(EMatchmakingStatusState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "SetState");

	Params::MatchmakingStatus_SetState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MatchmakingStatus.ShowElapsedTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInShowElapsedTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakingStatus::ShowElapsedTime(bool bInShowElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingStatus", "ShowElapsedTime");

	Params::MatchmakingStatus_ShowElapsedTime Parms{};

	Parms.bInShowElapsedTime = bInShowElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpringArmComponent.ClearTargetArmPercentage
// (Final, Native, Public, BlueprintCallable)

void UFlameSpringArmComponent::ClearTargetArmPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "ClearTargetArmPercentage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpringArmComponent.SetArmPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSpringArmComponent::SetArmPercentage(float Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "SetArmPercentage");

	Params::FlameSpringArmComponent_SetArmPercentage Parms{};

	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpringArmComponent.SetMaxRelativeZSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxRelativeZ                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewSmoothness                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransitionSpeed                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSpringArmComponent::SetMaxRelativeZSettings(const float NewMaxRelativeZ, const float NewSmoothness, const float TransitionSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "SetMaxRelativeZSettings");

	Params::FlameSpringArmComponent_SetMaxRelativeZSettings Parms{};

	Parms.NewMaxRelativeZ = NewMaxRelativeZ;
	Parms.NewSmoothness = NewSmoothness;
	Parms.TransitionSpeed = TransitionSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpringArmComponent.SetTargetArmPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TargetArmPercentage                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameSpringArmComponent::SetTargetArmPercentage(const float TargetArmPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "SetTargetArmPercentage");

	Params::FlameSpringArmComponent_SetTargetArmPercentage Parms{};

	Parms.TargetArmPercentage = TargetArmPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpringArmComponent.GetArmPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlameSpringArmComponent::GetArmPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "GetArmPercentage");

	Params::FlameSpringArmComponent_GetArmPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameSpringArmComponent.HasRecentHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameSpringArmComponent::HasRecentHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpringArmComponent", "HasRecentHit");

	Params::FlameSpringArmComponent_HasRecentHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.ApplyCustomizationOnMannequin
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMannequin*                       TargetMannequin                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationContainer          SourceCustomizationsArray                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationFunctions::ApplyCustomizationOnMannequin(class AHumanPlayerController* Player, class AMannequin* TargetMannequin, const struct FCustomizationContainer& SourceCustomizationsArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "ApplyCustomizationOnMannequin");

	Params::CustomizationFunctions_ApplyCustomizationOnMannequin Parms{};

	Parms.Player = Player;
	Parms.TargetMannequin = TargetMannequin;
	Parms.SourceCustomizationsArray = std::move(SourceCustomizationsArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.CaptureTextureFromRenderTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         SceneCapture                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TextureName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCustomizationFunctions::CaptureTextureFromRenderTarget(class USceneCaptureComponent2D* SceneCapture, const class FString& TextureName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "CaptureTextureFromRenderTarget");

	Params::CustomizationFunctions_CaptureTextureFromRenderTarget Parms{};

	Parms.SceneCapture = SceneCapture;
	Parms.TextureName = std::move(TextureName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.ClearCustomizationSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationFunctions::ClearCustomizationSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "ClearCustomizationSlot");

	Params::CustomizationFunctions_ClearCustomizationSlot Parms{};

	Parms.Player = Player;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CustomizationFunctions.GetAllCustomizations
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomization>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomization>> UCustomizationFunctions::GetAllCustomizations(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetAllCustomizations");

	Params::CustomizationFunctions_GetAllCustomizations Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetClothesComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryCustomizationComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryCustomizationComponent* UCustomizationFunctions::GetClothesComponent(const class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetClothesComponent");

	Params::CustomizationFunctions_GetClothesComponent Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetCustomizationInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationInfo               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizationInfo UCustomizationFunctions::GetCustomizationInfo(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationInfo");

	Params::CustomizationFunctions_GetCustomizationInfo Parms{};

	Parms.Player = Player;
	Parms.Customization = Customization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetCustomizationInSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationPair               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCustomizationPair UCustomizationFunctions::GetCustomizationInSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationInSlot");

	Params::CustomizationFunctions_GetCustomizationInSlot Parms{};

	Parms.Player = Player;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetCustomizationMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UCustomizationFunctions::GetCustomizationMesh(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationMesh");

	Params::CustomizationFunctions_GetCustomizationMesh Parms{};

	Parms.Player = Player;
	Parms.Customization = Customization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetCustomizationPreview
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMannequin*                       TargetMannequin                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationVariant>Variant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationFunctions::GetCustomizationPreview(class AHumanPlayerController* Player, class AMannequin* TargetMannequin, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationPreview");

	Params::CustomizationFunctions_GetCustomizationPreview Parms{};

	Parms.Player = Player;
	Parms.TargetMannequin = TargetMannequin;
	Parms.Slot = Slot;
	Parms.Customization = Customization;
	Parms.Variant = Variant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CustomizationFunctions.GetCustomizationsByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomization>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomization>> UCustomizationFunctions::GetCustomizationsByClass(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationsByClass");

	Params::CustomizationFunctions_GetCustomizationsByClass Parms{};

	Parms.Player = Player;
	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetCustomizationVariantsForBundle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationVariantBundle>Bundle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomizationVariant>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomizationVariant>> UCustomizationFunctions::GetCustomizationVariantsForBundle(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationVariantBundle> Bundle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetCustomizationVariantsForBundle");

	Params::CustomizationFunctions_GetCustomizationVariantsForBundle Parms{};

	Parms.Player = Player;
	Parms.Bundle = Bundle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetGender
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACustomizationVariant>ArchetypeVariant                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AGender>              Gender                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFemale                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationFunctions::GetGender(TSubclassOf<class ACustomizationVariant> ArchetypeVariant, TSubclassOf<class AGender>* Gender, bool* IsFemale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetGender");

	Params::CustomizationFunctions_GetGender Parms{};

	Parms.ArchetypeVariant = ArchetypeVariant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Gender != nullptr)
		*Gender = Parms.Gender;

	if (IsFemale != nullptr)
		*IsFemale = Parms.IsFemale;
}


// Function Flame.CustomizationFunctions.GetHighlightedCustomizations
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomization>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomization>> UCustomizationFunctions::GetHighlightedCustomizations(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetHighlightedCustomizations");

	Params::CustomizationFunctions_GetHighlightedCustomizations Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetOwnedCustomizations
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomization>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomization>> UCustomizationFunctions::GetOwnedCustomizations(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetOwnedCustomizations");

	Params::CustomizationFunctions_GetOwnedCustomizations Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetOwnedCustomizationVariants
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomizationVariant>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomizationVariant>> UCustomizationFunctions::GetOwnedCustomizationVariants(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetOwnedCustomizationVariants");

	Params::CustomizationFunctions_GetOwnedCustomizationVariants Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.GetWardrobeComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UShelterCustomizationComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShelterCustomizationComponent* UCustomizationFunctions::GetWardrobeComponent(const class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "GetWardrobeComponent");

	Params::CustomizationFunctions_GetWardrobeComponent Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.IsCustomizationCompatibleWithSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationFunctions::IsCustomizationCompatibleWithSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationSlot> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "IsCustomizationCompatibleWithSlot");

	Params::CustomizationFunctions_IsCustomizationCompatibleWithSlot Parms{};

	Parms.Player = Player;
	Parms.Customization = Customization;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.IsCustomizationSlotAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationFunctions::IsCustomizationSlotAvailable(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "IsCustomizationSlotAvailable");

	Params::CustomizationFunctions_IsCustomizationSlotAvailable Parms{};

	Parms.Player = Player;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.LinkedCustomizationsInNeededSlots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomization>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomization>> UCustomizationFunctions::LinkedCustomizationsInNeededSlots(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "LinkedCustomizationsInNeededSlots");

	Params::CustomizationFunctions_LinkedCustomizationsInNeededSlots Parms{};

	Parms.Player = Player;
	Parms.Customization = Customization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.NeededSlotsForCustomization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class ACustomizationSlot>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class ACustomizationSlot>> UCustomizationFunctions::NeededSlotsForCustomization(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "NeededSlotsForCustomization");

	Params::CustomizationFunctions_NeededSlotsForCustomization Parms{};

	Parms.Player = Player;
	Parms.Customization = Customization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationFunctions.SetCustomizationToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationVariant>Variant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationFunctions::SetCustomizationToSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "SetCustomizationToSlot");

	Params::CustomizationFunctions_SetCustomizationToSlot Parms{};

	Parms.Player = Player;
	Parms.Slot = Slot;
	Parms.Customization = Customization;
	Parms.Variant = Variant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CustomizationFunctions.SetGestureToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationVariant>Variant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationFunctions::SetGestureToSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomizationVariant> Variant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "SetGestureToSlot");

	Params::CustomizationFunctions_SetGestureToSlot Parms{};

	Parms.Player = Player;
	Parms.Slot = Slot;
	Parms.Variant = Variant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CustomizationFunctions.SetMeshFromCustomizationToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomisationMeshComponent*      TargetComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Customization                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationVariant>Variant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationFunctions::SetMeshFromCustomizationToComponent(class AHumanPlayerController* Player, class UCustomisationMeshComponent* TargetComponent, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomizationFunctions", "SetMeshFromCustomizationToComponent");

	Params::CustomizationFunctions_SetMeshFromCustomizationToComponent Parms{};

	Parms.Player = Player;
	Parms.TargetComponent = TargetComponent;
	Parms.Customization = Customization;
	Parms.Variant = Variant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationHair.GetMeshForGenderAndOverlapCustomization
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AGender>              Gender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomization>       Headgear                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ACustomizationHair::GetMeshForGenderAndOverlapCustomization(TSubclassOf<class AGender> Gender, TSubclassOf<class ACustomization> Headgear) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationHair", "GetMeshForGenderAndOverlapCustomization");

	Params::CustomizationHair_GetMeshForGenderAndOverlapCustomization Parms{};

	Parms.Gender = Gender;
	Parms.Headgear = Headgear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipmentStorageComponent.BlueprintStoreObject
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AItem*                            OneItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentStorageComponent::BlueprintStoreObject(class AItem* OneItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentStorageComponent", "BlueprintStoreObject");

	Params::EquipmentStorageComponent_BlueprintStoreObject Parms{};

	Parms.OneItem = OneItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipmentStorageComponent.OnRep_PostChangeItems
// (Final, Native, Protected)
// Parameters:
// class UItemsList*                       OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentStorageComponent::OnRep_PostChangeItems(class UItemsList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentStorageComponent", "OnRep_PostChangeItems");

	Params::EquipmentStorageComponent_OnRep_PostChangeItems Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipmentStorageComponent.OnRep_PostChangeWeapons
// (Final, Native, Protected)
// Parameters:
// class UWeaponsStorage*                  OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentStorageComponent::OnRep_PostChangeWeapons(class UWeaponsStorage* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentStorageComponent", "OnRep_PostChangeWeapons");

	Params::EquipmentStorageComponent_OnRep_PostChangeWeapons Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LootOnGroundComponent.ClearItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULootOnGroundComponent::ClearItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootOnGroundComponent", "ClearItems");

	Params::LootOnGroundComponent_ClearItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationSlot.IsMandatory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACustomizationSlot::IsMandatory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlot", "IsMandatory");

	Params::CustomizationSlot_IsMandatory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GamepadIconWidget.ConsumeActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamepadIconWidget::ConsumeActions(const bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "ConsumeActions");

	Params::GamepadIconWidget_ConsumeActions Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.NativeOnActionHold
// (Native, Protected)

void UGamepadIconWidget::NativeOnActionHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "NativeOnActionHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.NativeOnActionPressed
// (Native, Protected)

void UGamepadIconWidget::NativeOnActionPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "NativeOnActionPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.NativeOnActionReleased
// (Native, Protected)

void UGamepadIconWidget::NativeOnActionReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "NativeOnActionReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.NativeOnDisabled
// (Native, Protected)

void UGamepadIconWidget::NativeOnDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "NativeOnDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.NativeOnEnabled
// (Native, Protected)

void UGamepadIconWidget::NativeOnEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "NativeOnEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.OnActionHold
// (Event, Public, BlueprintEvent)

void UGamepadIconWidget::OnActionHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "OnActionHold");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.GamepadIconWidget.OnActionPressed
// (Event, Public, BlueprintEvent)

void UGamepadIconWidget::OnActionPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "OnActionPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.GamepadIconWidget.OnActionReleased
// (Event, Public, BlueprintEvent)

void UGamepadIconWidget::OnActionReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "OnActionReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.GamepadIconWidget.SetHoldTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamepadIconWidget::SetHoldTime(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "SetHoldTime");

	Params::GamepadIconWidget_SetHoldTime Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.SetIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputIcon                              InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsHoldable                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamepadIconWidget::SetIcon(const EInputIcon InIcon, const bool bInIsHoldable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "SetIcon");

	Params::GamepadIconWidget_SetIcon Parms{};

	Parms.InIcon = InIcon;
	Parms.bInIsHoldable = bInIsHoldable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadIconWidget.UpdateIconMaterial
// (Native, Event, Public, BlueprintEvent)

void UGamepadIconWidget::UpdateIconMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadIconWidget", "UpdateIconMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GamepadChoiceWidget.GetSelectedIndex
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGamepadChoiceWidget::GetSelectedIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadChoiceWidget", "GetSelectedIndex");

	Params::GamepadChoiceWidget_GetSelectedIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.FirstPersonFunctions.ConvertWorldToFirstPerson
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo                 ViewInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFirstPersonFunctions::ConvertWorldToFirstPerson(const struct FVector& WorldPos, const struct FMinimalViewInfo& ViewInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FirstPersonFunctions", "ConvertWorldToFirstPerson");

	Params::FirstPersonFunctions_ConvertWorldToFirstPerson Parms{};

	Parms.WorldPos = std::move(WorldPos);
	Parms.ViewInfo = std::move(ViewInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameMenuTeamScreen.OnSkipTutorial
// (Final, Native, Protected)

void UGameMenuTeamScreen::OnSkipTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuTeamScreen", "OnSkipTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameMenuTeamScreen.OnStartMatchmaking
// (Final, Native, Protected)

void UGameMenuTeamScreen::OnStartMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuTeamScreen", "OnStartMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameMenuTeamScreen.OnStartTutorial
// (Final, Native, Protected)

void UGameMenuTeamScreen::OnStartTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuTeamScreen", "OnStartTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameMenuTeamScreen.IsInviteAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMenuTeamScreen::IsInviteAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuTeamScreen", "IsInviteAllowed");

	Params::GameMenuTeamScreen_IsInviteAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GameStoreOffers.GameStoreOffersStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EGameStoreOffersState                   OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameStoreOffersState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreOffers::GameStoreOffersStateChanged__DelegateSignature(EGameStoreOffersState OldState, EGameStoreOffersState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GameStoreOffersStateChanged__DelegateSignature");

	Params::GameStoreOffers_GameStoreOffersStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameStoreOffers.OnPlatformStoreOffersChanges
// (Final, Native, Protected)
// Parameters:
// EPlatformStoreOffersState               OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformStoreOffersState               NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreOffers::OnPlatformStoreOffersChanges(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "OnPlatformStoreOffersChanges");

	Params::GameStoreOffers_OnPlatformStoreOffersChanges Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameStoreOffers.StartDownloadOfOffers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameStoreOffers::StartDownloadOfOffers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "StartDownloadOfOffers");

	Params::GameStoreOffers_StartDownloadOfOffers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreOffers.GetGameStoreData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameStoreData             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreData UGameStoreOffers::GetGameStoreData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GetGameStoreData");

	Params::GameStoreOffers_GetGameStoreData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreOffers.GetGameStoreProductInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameStoreProductId              ProductId                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ProductFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreProductInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductInfo UGameStoreOffers::GetGameStoreProductInfo(const struct FGameStoreProductId& ProductId, bool* ProductFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GetGameStoreProductInfo");

	Params::GameStoreOffers_GetGameStoreProductInfo Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductFound != nullptr)
		*ProductFound = Parms.ProductFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreOffers.GetGameStoreProductInfoById
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ProductId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ProductFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreProductInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductInfo UGameStoreOffers::GetGameStoreProductInfoById(const class FString& ProductId, bool* ProductFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GetGameStoreProductInfoById");

	Params::GameStoreOffers_GetGameStoreProductInfoById Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductFound != nullptr)
		*ProductFound = Parms.ProductFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreOffers.GetGameStoreSlotInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           StoreName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StoreFound                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreInfo             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreInfo UGameStoreOffers::GetGameStoreSlotInfo(const class FString& StoreName, bool* StoreFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GetGameStoreSlotInfo");

	Params::GameStoreOffers_GetGameStoreSlotInfo Parms{};

	Parms.StoreName = std::move(StoreName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StoreFound != nullptr)
		*StoreFound = Parms.StoreFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreOffers.GetOffersManagerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameStoreOffersState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameStoreOffersState UGameStoreOffers::GetOffersManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreOffers", "GetOffersManagerState");

	Params::GameStoreOffers_GetOffersManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationVariant.GetArchetypeMaterialOverrides
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationArchetype>Archetype                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizatinMaterials           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomizatinMaterials ACustomizationVariant::GetArchetypeMaterialOverrides(TSubclassOf<class ACustomizationArchetype> Archetype) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationVariant", "GetArchetypeMaterialOverrides");

	Params::CustomizationVariant_GetArchetypeMaterialOverrides Parms{};

	Parms.Archetype = Archetype;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationVariant.GetCustomizationBundle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationVariantBundle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomizationVariantBundle> ACustomizationVariant::GetCustomizationBundle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationVariant", "GetCustomizationBundle");

	Params::CustomizationVariant_GetCustomizationBundle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationVariant.GetCustomizationClass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomization>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomization> ACustomizationVariant::GetCustomizationClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationVariant", "GetCustomizationClass");

	Params::CustomizationVariant_GetCustomizationClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationVariant.GetSoundTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESoundTextureType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESoundTextureType ACustomizationVariant::GetSoundTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationVariant", "GetSoundTexture");

	Params::CustomizationVariant_GetSoundTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationVariant.GetVoiceModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVoiceModifierType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVoiceModifierType ACustomizationVariant::GetVoiceModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationVariant", "GetVoiceModifier");

	Params::CustomizationVariant_GetVoiceModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationGestureVariant.GetAnimationMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ACustomizationGestureVariant::GetAnimationMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGestureVariant", "GetAnimationMontage");

	Params::CustomizationGestureVariant_GetAnimationMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CustomizationGestureVariant.GetShelterPreviewStaticPose
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* ACustomizationGestureVariant::GetShelterPreviewStaticPose() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGestureVariant", "GetShelterPreviewStaticPose");

	Params::CustomizationGestureVariant_GetShelterPreviewStaticPose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GameStoreSellingPoints.GameStoreSellingPointsStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EGameStoreSellingPointsState            OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameStoreSellingPointsState            NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreSellingPoints::GameStoreSellingPointsStateChanged__DelegateSignature(EGameStoreSellingPointsState OldState, EGameStoreSellingPointsState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GameStoreSellingPointsStateChanged__DelegateSignature");

	Params::GameStoreSellingPoints_GameStoreSellingPointsStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameStoreSellingPoints.GetSellingPointsFilteredDebug
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        NowTime                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSortedSellingpoints             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSortedSellingpoints UGameStoreSellingPoints::GetSellingPointsFilteredDebug(class AHumanPlayerController* Player, const struct FDateTime& NowTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GetSellingPointsFilteredDebug");

	Params::GameStoreSellingPoints_GetSellingPointsFilteredDebug Parms{};

	Parms.Player = Player;
	Parms.NowTime = std::move(NowTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSellingPoints.GetSellingPointsFilteredOwnedAndActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSortedSellingpoints             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSortedSellingpoints UGameStoreSellingPoints::GetSellingPointsFilteredOwnedAndActive(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GetSellingPointsFilteredOwnedAndActive");

	Params::GameStoreSellingPoints_GetSellingPointsFilteredOwnedAndActive Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSellingPoints.StartDownloadOfSellingPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameStoreSellingPoints::StartDownloadOfSellingPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "StartDownloadOfSellingPoints");

	Params::GameStoreSellingPoints_StartDownloadOfSellingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSellingPoints.GetGameSellingPointInfoForItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItem>                Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ProductFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreSellingPointInfo ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FGameStoreSellingPointInfo UGameStoreSellingPoints::GetGameSellingPointInfoForItem(const TSubclassOf<class AItem> Item, bool* ProductFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GetGameSellingPointInfoForItem");

	Params::GameStoreSellingPoints_GetGameSellingPointInfoForItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductFound != nullptr)
		*ProductFound = Parms.ProductFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSellingPoints.GetSellingPointsData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameStoreSellingPointsDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreSellingPointsData UGameStoreSellingPoints::GetSellingPointsData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GetSellingPointsData");

	Params::GameStoreSellingPoints_GetSellingPointsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSellingPoints.GetSellingPointsManagerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameStoreSellingPointsState            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameStoreSellingPointsState UGameStoreSellingPoints::GetSellingPointsManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSellingPoints", "GetSellingPointsManagerState");

	Params::GameStoreSellingPoints_GetSellingPointsManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UpdateableWidget.OnModelUpdate
// (Event, Public, BlueprintEvent)

void UUpdateableWidget::OnModelUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpdateableWidget", "OnModelUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.UpdateableWidget.OnViewUpdate
// (Event, Public, BlueprintEvent)

void UUpdateableWidget::OnViewUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpdateableWidget", "OnViewUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.UpdateableWidget.ResetSelection
// (Final, Native, Protected, BlueprintCallable)

void UUpdateableWidget::ResetSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpdateableWidget", "ResetSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UpdateableWidget.UpdateView
// (Final, Native, Public, BlueprintCallable)

void UUpdateableWidget::UpdateView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpdateableWidget", "UpdateView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UpdateableWidget.IsViewUpdateNecessary
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUpdateableWidget::IsViewUpdateNecessary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpdateableWidget", "IsViewUpdateNecessary");

	Params::UpdateableWidget_IsViewUpdateNecessary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DataProvider.GetCloudStructures
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudDataStructures*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudDataStructures* UDataProvider::GetCloudStructures(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataProvider", "GetCloudStructures");

	Params::DataProvider_GetCloudStructures Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DataProvider.GetCloudTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudDataTables*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudDataTables* UDataProvider::GetCloudTables(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataProvider", "GetCloudTables");

	Params::DataProvider_GetCloudTables Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DataProvider.GetDataProvider
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataProvider*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataProvider* UDataProvider::GetDataProvider(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataProvider", "GetDataProvider");

	Params::DataProvider_GetDataProvider Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.DataProvider.DataProviderStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EDataProviderState                      OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataProviderState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataProvider::DataProviderStateChanged__DelegateSignature(EDataProviderState OldState, EDataProviderState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataProvider", "DataProviderStateChanged__DelegateSignature");

	Params::DataProvider_DataProviderStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.DataProvider.GetDataVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDataProvider::GetDataVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataProvider", "GetDataVersion");

	Params::DataProvider_GetDataVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DataProvider.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDataProviderState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataProviderState UDataProvider::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DataProvider", "GetState");

	Params::DataProvider_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerListWidget.AddPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::AddPlayer(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "AddPlayer");

	Params::PlayerListWidget_AddPlayer Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.NativeOnPlayerClicked
// (Final, Native, Protected)
// Parameters:
// class UListButtonWidget*                ListButtonWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::NativeOnPlayerClicked(class UListButtonWidget* ListButtonWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "NativeOnPlayerClicked");

	Params::PlayerListWidget_NativeOnPlayerClicked Parms{};

	Parms.ListButtonWidget = ListButtonWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.NativeOnPlayerFocused
// (Final, Native, Protected)
// Parameters:
// class UListButtonWidget*                ListButtonWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::NativeOnPlayerFocused(class UListButtonWidget* ListButtonWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "NativeOnPlayerFocused");

	Params::PlayerListWidget_NativeOnPlayerFocused Parms{};

	Parms.ListButtonWidget = ListButtonWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.OnPlayerAdded
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UPlayerInfoWidget*                AddedWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::OnPlayerAdded(class UPlayerInfoWidget* AddedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "OnPlayerAdded");

	Params::PlayerListWidget_OnPlayerAdded Parms{};

	Parms.AddedWidget = AddedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.RemoveAllPlayers
// (Final, Native, Public, BlueprintCallable)

void UPlayerListWidget::RemoveAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "RemoveAllPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.RemovePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::RemovePlayer(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "RemovePlayer");

	Params::PlayerListWidget_RemovePlayer Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerListWidget.GetFocusedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FUniqueNetIdRepl           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FUniqueNetIdRepl UPlayerListWidget::GetFocusedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "GetFocusedPlayer");

	Params::PlayerListWidget_GetFocusedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerListWidget.GetPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerListWidget::GetPlayerCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "GetPlayerCount");

	Params::PlayerListWidget_GetPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupMemberListWidget.OnPlayerChangedState
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClientGroupState                       OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClientGroupState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupMemberListWidget::OnPlayerChangedState(const struct FUniqueNetIdRepl& NetId, EClientGroupState OldState, EClientGroupState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupMemberListWidget", "OnPlayerChangedState");

	Params::GroupMemberListWidget_OnPlayerChangedState Parms{};

	Parms.NetId = std::move(NetId);
	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupMemberListWidget.OnPlayerJoined
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupMemberListWidget::OnPlayerJoined(const struct FUniqueNetIdRepl& NetId, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupMemberListWidget", "OnPlayerJoined");

	Params::GroupMemberListWidget_OnPlayerJoined Parms{};

	Parms.NetId = std::move(NetId);
	Parms.GroupId = std::move(GroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupMemberListWidget.OnPlayerLeft
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupMemberListWidget::OnPlayerLeft(const struct FUniqueNetIdRepl& NetId, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupMemberListWidget", "OnPlayerLeft");

	Params::GroupMemberListWidget_OnPlayerLeft Parms{};

	Parms.NetId = std::move(NetId);
	Parms.GroupId = std::move(GroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupMemberListWidget.Update
// (Final, Native, Public, BlueprintCallable)

void UGroupMemberListWidget::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupMemberListWidget", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Gate.CancelTravel
// (Final, Native, Public, BlueprintCallable)

void AGate::CancelTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Gate", "CancelTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Gate.Travel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGate::Travel(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Gate", "Travel");

	Params::Gate_Travel Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.ActivateSelectedSegment
// (Final, Native, Public, BlueprintCallable)

void USelectionWheel::ActivateSelectedSegment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ActivateSelectedSegment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.ActivateWheel
// (Final, Native, Public)

void USelectionWheel::ActivateWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ActivateWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.CloseWheel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void USelectionWheel::CloseWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CloseWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.CreateConsumableSegments
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UWheelSegment*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWheelSegment*> USelectionWheel::CreateConsumableSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CreateConsumableSegments");

	Params::SelectionWheel_CreateConsumableSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.CreateDevSegments
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UWheelSegment*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWheelSegment*> USelectionWheel::CreateDevSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CreateDevSegments");

	Params::SelectionWheel_CreateDevSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.CreateGestureSegments
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UWheelSegment*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWheelSegment*> USelectionWheel::CreateGestureSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CreateGestureSegments");

	Params::SelectionWheel_CreateGestureSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.CreateToolSegments
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UWheelSegment*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWheelSegment*> USelectionWheel::CreateToolSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CreateToolSegments");

	Params::SelectionWheel_CreateToolSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.CreateWeaponSegments
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// TArray<class UWheelSegment*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWheelSegment*> USelectionWheel::CreateWeaponSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "CreateWeaponSegments");

	Params::SelectionWheel_CreateWeaponSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.ProcessDesktopAxisWheel
// (Final, Native, Protected)

void USelectionWheel::ProcessDesktopAxisWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ProcessDesktopAxisWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.ProcessDesktopAxisWheelQuadrant
// (Final, Native, Protected)

void USelectionWheel::ProcessDesktopAxisWheelQuadrant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ProcessDesktopAxisWheelQuadrant");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.ProcessInputAxisX
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::ProcessInputAxisX(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ProcessInputAxisX");

	Params::SelectionWheel_ProcessInputAxisX Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.ProcessInputAxisY
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::ProcessInputAxisY(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "ProcessInputAxisY");

	Params::SelectionWheel_ProcessInputAxisY Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.SelectSegment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::SelectSegment(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "SelectSegment");

	Params::SelectionWheel_SelectSegment Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.SetDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::SetDescription(const class FText& InDescription, ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "SetDescription");

	Params::SelectionWheel_SetDescription Parms{};

	Parms.InDescription = std::move(InDescription);
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.SetEquippedItemIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::SetEquippedItemIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "SetEquippedItemIndex");

	Params::SelectionWheel_SetEquippedItemIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.SetSmallDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheel::SetSmallDescription(const class FText& InDescription, ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "SetSmallDescription");

	Params::SelectionWheel_SetSmallDescription Parms{};

	Parms.InDescription = std::move(InDescription);
	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheel.GetAngleOffset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USelectionWheel::GetAngleOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "GetAngleOffset");

	Params::SelectionWheel_GetAngleOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.GetWheelComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USelectionWheelComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USelectionWheelComponent* USelectionWheel::GetWheelComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "GetWheelComponent");

	Params::SelectionWheel_GetWheelComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheel.GetWheelSegments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UWheelSegment*>      ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UWheelSegment*> USelectionWheel::GetWheelSegments() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheel", "GetWheelSegments");

	Params::SelectionWheel_GetWheelSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.DirectionRestrictedInteractionComponent.RemoveEnforcedInteractionAngle
// (Final, Native, Public, BlueprintCallable)

void UDirectionRestrictedInteractionComponent::RemoveEnforcedInteractionAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionRestrictedInteractionComponent", "RemoveEnforcedInteractionAngle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.DirectionRestrictedInteractionComponent.SetEnforcedInteractionAngle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DotRestriction                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionRestrictedInteractionComponent::SetEnforcedInteractionAngle(const struct FVector& Direction, const float DotRestriction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionRestrictedInteractionComponent", "SetEnforcedInteractionAngle");

	Params::DirectionRestrictedInteractionComponent_SetEnforcedInteractionAngle Parms{};

	Parms.Direction = std::move(Direction);
	Parms.DotRestriction = DotRestriction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementCheckbox.OnCheckStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsElementCheckbox::OnCheckStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementCheckbox", "OnCheckStateChanged");

	Params::OptionsElementCheckbox_OnCheckStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsElementCheckbox.ToggleState
// (Final, Native, Private)

void UOptionsElementCheckbox::ToggleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsElementCheckbox", "ToggleState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EditorActor.PostRebuildBuildings
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TMap<class FName, float>                Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AEditorActor::PostRebuildBuildings(const TMap<class FName, float>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorActor", "PostRebuildBuildings");

	Params::EditorActor_PostRebuildBuildings Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.EditorActor.PreRebuildBuildings
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEditorRebuildDataStorage*        Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorActor::PreRebuildBuildings(class UEditorRebuildDataStorage* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorActor", "PreRebuildBuildings");

	Params::EditorActor_PreRebuildBuildings Parms{};

	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.EditorActor.GenerateEditorActorIdentifier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AEditorActor::GenerateEditorActorIdentifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorActor", "GenerateEditorActorIdentifier");

	Params::EditorActor_GenerateEditorActorIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EditorActor.GetRebuildReferencedTags
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TSet<class FName>                       OutNames                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AEditorActor::GetRebuildReferencedTags(TSet<class FName>& OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorActor", "GetRebuildReferencedTags");

	Params::EditorActor_GetRebuildReferencedTags Parms{};

	Parms.OutNames = std::move(OutNames);

	UObject::ProcessEvent(Func, &Parms);

	OutNames = std::move(Parms.OutNames);
}


// Function Flame.ThrowableConsumable.CalculateAimingArc
// (Native, Event, Public, BlueprintEvent)

void AThrowableConsumable::CalculateAimingArc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "CalculateAimingArc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ThrowableConsumable.ClientOnUsed
// (Net, NetReliable, Native, Event, Public, NetClient)

void AThrowableConsumable::ClientOnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "ClientOnUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ThrowableConsumable.CreateArcBP
// (Event, Public, BlueprintEvent)

void AThrowableConsumable::CreateArcBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "CreateArcBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ThrowableConsumable.DestroyArcBP
// (Event, Public, BlueprintEvent)

void AThrowableConsumable::DestroyArcBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "DestroyArcBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ThrowableConsumable.HideArcManually
// (Final, Native, Public, BlueprintCallable)

void AThrowableConsumable::HideArcManually()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "HideArcManually");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ThrowableConsumable.OnAimingChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ShowArc                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowableConsumable::OnAimingChanged(const bool ShowArc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "OnAimingChanged");

	Params::ThrowableConsumable_OnAimingChanged Parms{};

	Parms.ShowArc = ShowArc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ThrowableConsumable.OnThrown
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ThrownActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowableConsumable::OnThrown(class AActor* ThrownActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "OnThrown");

	Params::ThrowableConsumable_OnThrown Parms{};

	Parms.ThrownActor = ThrownActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ThrowableConsumable.UpdateThrowParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    WasAiming                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowableConsumable::UpdateThrowParams(bool WasAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "UpdateThrowParams");

	Params::ThrowableConsumable_UpdateThrowParams Parms{};

	Parms.WasAiming = WasAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ThrowableConsumable.GetThrowStrength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float AThrowableConsumable::GetThrowStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableConsumable", "GetThrowStrength");

	Params::ThrowableConsumable_GetThrowStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.PlatformTools.GetUserAuthToken__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FUniqueNetIdRepl                 LocalUserId                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserAuthToken                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformTools::GetUserAuthToken__DelegateSignature(const struct FUniqueNetIdRepl& LocalUserId, const class FString& UserAuthToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "GetUserAuthToken__DelegateSignature");

	Params::PlatformTools_GetUserAuthToken__DelegateSignature Parms{};

	Parms.LocalUserId = std::move(LocalUserId);
	Parms.UserAuthToken = std::move(UserAuthToken);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlatformTools.OpenSystemUserProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 RequestorId                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 ProfileToShowId                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformTools::OpenSystemUserProfile(const struct FUniqueNetIdRepl& RequestorId, const struct FUniqueNetIdRepl& ProfileToShowId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "OpenSystemUserProfile");

	Params::PlatformTools_OpenSystemUserProfile Parms{};

	Parms.RequestorId = std::move(RequestorId);
	Parms.ProfileToShowId = std::move(ProfileToShowId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.PlatformTools.SystemUserProfileClosed__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UPlatformTools::SystemUserProfileClosed__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "SystemUserProfileClosed__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.PlatformTools.GetEnvironmentTypeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformTools::GetEnvironmentTypeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "GetEnvironmentTypeName");

	Params::PlatformTools_GetEnvironmentTypeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformTools.GetSandboxName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformTools::GetSandboxName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "GetSandboxName");

	Params::PlatformTools_GetSandboxName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformTools.GetUserAuthToken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ProfileId                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformTools::GetUserAuthToken(const struct FUniqueNetIdRepl& ProfileId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "GetUserAuthToken");

	Params::PlatformTools_GetUserAuthToken Parms{};

	Parms.ProfileId = std::move(ProfileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformTools.GetUserHash
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformTools::GetUserHash(int32 ControllerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "GetUserHash");

	Params::PlatformTools_GetUserHash Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformTools.IsLicenseActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformTools::IsLicenseActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "IsLicenseActive");

	Params::PlatformTools_IsLicenseActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformTools.IsRunningTrial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformTools::IsRunningTrial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformTools", "IsRunningTrial");

	Params::PlatformTools_IsRunningTrial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipWeaponModalWidget.OnActionClosePressed
// (Final, Native, Protected)

void UEquipWeaponModalWidget::OnActionClosePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "OnActionClosePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipWeaponModalWidget.OnActionConfirmPressed
// (Final, Native, Protected)

void UEquipWeaponModalWidget::OnActionConfirmPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "OnActionConfirmPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipWeaponModalWidget.SetAmmoToCraftCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipWeaponModalWidget::SetAmmoToCraftCount(int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "SetAmmoToCraftCount");

	Params::EquipWeaponModalWidget_SetAmmoToCraftCount Parms{};

	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipWeaponModalWidget.SetAmmoToEquipCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipWeaponModalWidget::SetAmmoToEquipCount(int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "SetAmmoToEquipCount");

	Params::EquipWeaponModalWidget_SetAmmoToEquipCount Parms{};

	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.EquipWeaponModalWidget.GetAmmoClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AAmmoItem>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AAmmoItem> UEquipWeaponModalWidget::GetAmmoClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "GetAmmoClass");

	Params::EquipWeaponModalWidget_GetAmmoClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipWeaponModalWidget.GetAmmoToCraftCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEquipWeaponModalWidget::GetAmmoToCraftCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "GetAmmoToCraftCount");

	Params::EquipWeaponModalWidget_GetAmmoToCraftCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipWeaponModalWidget.GetAmmoToEquipCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEquipWeaponModalWidget::GetAmmoToEquipCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "GetAmmoToEquipCount");

	Params::EquipWeaponModalWidget_GetAmmoToEquipCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EquipWeaponModalWidget.GetWeaponToEquip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UEquipWeaponModalWidget::GetWeaponToEquip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipWeaponModalWidget", "GetWeaponToEquip");

	Params::EquipWeaponModalWidget_GetWeaponToEquip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.EventSystem.BlueprintInit
// (Event, Public, BlueprintEvent)

void UEventSystem::BlueprintInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystem", "BlueprintInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ExplosionComponent.CalculateExposure
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InstigatingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToBeDestroyed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ExplosionLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxThickness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UExplosionComponent::CalculateExposure(class AActor* InstigatingActor, class AActor* ActorToBeDestroyed, const struct FVector& ExplosionLocation, float MaxThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "CalculateExposure");

	Params::ExplosionComponent_CalculateExposure Parms{};

	Parms.InstigatingActor = InstigatingActor;
	Parms.ActorToBeDestroyed = ActorToBeDestroyed;
	Parms.ExplosionLocation = std::move(ExplosionLocation);
	Parms.MaxThickness = MaxThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExplosionComponent.Explode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   MaxExplosionRadius                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FExplosionEffect>         ExplosionEffect                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExplosionComponent::Explode(float MaxExplosionRadius, TArray<struct FExplosionEffect>* ExplosionEffect, const EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "Explode");

	Params::ExplosionComponent_Explode Parms{};

	Parms.MaxExplosionRadius = MaxExplosionRadius;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ExplosionEffect != nullptr)
		*ExplosionEffect = std::move(Parms.ExplosionEffect);
}


// Function Flame.ExplosionComponent.MulticastNotifyExplosion
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<struct FExplosionEffect>         ExplosionEffects                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UExplosionComponent::MulticastNotifyExplosion(const TArray<struct FExplosionEffect>& ExplosionEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "MulticastNotifyExplosion");

	Params::ExplosionComponent_MulticastNotifyExplosion Parms{};

	Parms.ExplosionEffects = std::move(ExplosionEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ExplosionComponent.OnExplosionComponentExplode
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FExplosionEffect>         ExplosionEffects                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UExplosionComponent::OnExplosionComponentExplode(const TArray<struct FExplosionEffect>& ExplosionEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "OnExplosionComponentExplode");

	Params::ExplosionComponent_OnExplosionComponentExplode Parms{};

	Parms.ExplosionEffects = std::move(ExplosionEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ExplosionComponent.ProccessExplosion
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExplosionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatorController                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExplosionComponent::ProccessExplosion(const struct FVector& Location, float ExplosionRadius, class AController* InstigatorController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "ProccessExplosion");

	Params::ExplosionComponent_ProccessExplosion Parms{};

	Parms.Location = std::move(Location);
	Parms.ExplosionRadius = ExplosionRadius;
	Parms.InstigatorController = InstigatorController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ExplosionComponent.ProcessExplosionInteractions
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InstigatingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ExplosionLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxExplosionRadius                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UExplosionComponent::ProcessExplosionInteractions(class AActor* InstigatingActor, const struct FVector& ExplosionLocation, float MaxExplosionRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "ProcessExplosionInteractions");

	Params::ExplosionComponent_ProcessExplosionInteractions Parms{};

	Parms.InstigatingActor = InstigatingActor;
	Parms.ExplosionLocation = std::move(ExplosionLocation);
	Parms.MaxExplosionRadius = MaxExplosionRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExplosionComponent.GetExplosionLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UExplosionComponent::GetExplosionLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosionComponent", "GetExplosionLocation");

	Params::ExplosionComponent_GetExplosionLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.GreaterEqualStringString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedStandardLibraryFunctions::GreaterEqualStringString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "GreaterEqualStringString");

	Params::ExtendedStandardLibraryFunctions_GreaterEqualStringString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.GreaterStringString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedStandardLibraryFunctions::GreaterStringString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "GreaterStringString");

	Params::ExtendedStandardLibraryFunctions_GreaterStringString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.LessEqualStringString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedStandardLibraryFunctions::LessEqualStringString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "LessEqualStringString");

	Params::ExtendedStandardLibraryFunctions_LessEqualStringString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.LessStringString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExtendedStandardLibraryFunctions::LessStringString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "LessStringString");

	Params::ExtendedStandardLibraryFunctions_LessStringString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.MaxString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UExtendedStandardLibraryFunctions::MaxString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "MaxString");

	Params::ExtendedStandardLibraryFunctions_MaxString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.MinString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UExtendedStandardLibraryFunctions::MinString(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "MinString");

	Params::ExtendedStandardLibraryFunctions_MinString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           ByteArray                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UExtendedStandardLibraryFunctions::SortByteArray(const TArray<uint8>& ByteArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortByteArray");

	Params::ExtendedStandardLibraryFunctions_SortByteArray Parms{};

	Parms.ByteArray = std::move(ByteArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortByteArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           ByteArray                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortByteArrayDirectly(TArray<uint8>& ByteArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortByteArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortByteArrayDirectly Parms{};

	Parms.ByteArray = std::move(ByteArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ByteArray = std::move(Parms.ByteArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortClassArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TSubclassOf<class UObject>>      ClassArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)>Comparator                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UObject>>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UObject>> UExtendedStandardLibraryFunctions::SortClassArray(const TArray<TSubclassOf<class UObject>>& ClassArray, TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)> Comparator, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortClassArray");

	Params::ExtendedStandardLibraryFunctions_SortClassArray Parms{};

	Parms.ClassArray = std::move(ClassArray);
	Parms.Comparator = Comparator;
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortClassArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class UObject>>      ClassArray                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)>Comparator                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortClassArrayDirectly(TArray<TSubclassOf<class UObject>>& ClassArray, TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)> Comparator, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortClassArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortClassArrayDirectly Parms{};

	Parms.ClassArray = std::move(ClassArray);
	Parms.Comparator = Comparator;
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ClassArray = std::move(Parms.ClassArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortDateTimeArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FDateTime>                DateTimeArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDateTime>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDateTime> UExtendedStandardLibraryFunctions::SortDateTimeArray(const TArray<struct FDateTime>& DateTimeArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortDateTimeArray");

	Params::ExtendedStandardLibraryFunctions_SortDateTimeArray Parms{};

	Parms.DateTimeArray = std::move(DateTimeArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortDateTimeArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDateTime>                DateTimeArray                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortDateTimeArrayDirectly(TArray<struct FDateTime>& DateTimeArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortDateTimeArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortDateTimeArrayDirectly Parms{};

	Parms.DateTimeArray = std::move(DateTimeArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DateTimeArray = std::move(Parms.DateTimeArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           FloatArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UExtendedStandardLibraryFunctions::SortFloatArray(const TArray<float>& FloatArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortFloatArray");

	Params::ExtendedStandardLibraryFunctions_SortFloatArray Parms{};

	Parms.FloatArray = std::move(FloatArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortFloatArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           FloatArray                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortFloatArrayDirectly(TArray<float>& FloatArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortFloatArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortFloatArrayDirectly Parms{};

	Parms.FloatArray = std::move(FloatArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FloatArray = std::move(Parms.FloatArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortIntegerArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           IntegerArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UExtendedStandardLibraryFunctions::SortIntegerArray(const TArray<int32>& IntegerArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortIntegerArray");

	Params::ExtendedStandardLibraryFunctions_SortIntegerArray Parms{};

	Parms.IntegerArray = std::move(IntegerArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortIntegerArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           IntegerArray                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortIntegerArrayDirectly(TArray<int32>& IntegerArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortIntegerArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortIntegerArrayDirectly Parms{};

	Parms.IntegerArray = std::move(IntegerArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	IntegerArray = std::move(Parms.IntegerArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortObjectArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UObject*>                  ObjectArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)>Comparator                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UExtendedStandardLibraryFunctions::SortObjectArray(const TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortObjectArray");

	Params::ExtendedStandardLibraryFunctions_SortObjectArray Parms{};

	Parms.ObjectArray = std::move(ObjectArray);
	Parms.Comparator = Comparator;
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortObjectArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  ObjectArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)>Comparator                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortObjectArrayDirectly(TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortObjectArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortObjectArrayDirectly Parms{};

	Parms.ObjectArray = std::move(ObjectArray);
	Parms.Comparator = Comparator;
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectArray = std::move(Parms.ObjectArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortStringArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   StringArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UExtendedStandardLibraryFunctions::SortStringArray(const TArray<class FString>& StringArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortStringArray");

	Params::ExtendedStandardLibraryFunctions_SortStringArray Parms{};

	Parms.StringArray = std::move(StringArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortStringArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   StringArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortStringArrayDirectly(TArray<class FString>& StringArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortStringArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortStringArrayDirectly Parms{};

	Parms.StringArray = std::move(StringArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	StringArray = std::move(Parms.StringArray);
}


// Function Flame.ExtendedStandardLibraryFunctions.SortTimespanArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTimespan>                TimespanArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTimespan>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTimespan> UExtendedStandardLibraryFunctions::SortTimespanArray(const TArray<struct FTimespan>& TimespanArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortTimespanArray");

	Params::ExtendedStandardLibraryFunctions_SortTimespanArray Parms{};

	Parms.TimespanArray = std::move(TimespanArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ExtendedStandardLibraryFunctions.SortTimespanArrayDirectly
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTimespan>                TimespanArray                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Reversed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExtendedStandardLibraryFunctions::SortTimespanArrayDirectly(TArray<struct FTimespan>& TimespanArray, const bool Reversed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExtendedStandardLibraryFunctions", "SortTimespanArrayDirectly");

	Params::ExtendedStandardLibraryFunctions_SortTimespanArrayDirectly Parms{};

	Parms.TimespanArray = std::move(TimespanArray);
	Parms.Reversed = Reversed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TimespanArray = std::move(Parms.TimespanArray);
}


// Function Flame.WaterComponent.OnActorBeginOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterComponent::OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "OnActorBeginOverlap");

	Params::WaterComponent_OnActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WaterComponent.OnActorEndOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterComponent::OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "OnActorEndOverlap");

	Params::WaterComponent_OnActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WaterComponent.SetStartEndLocations
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterComponent::SetStartEndLocations(const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "SetStartEndLocations");

	Params::WaterComponent_SetStartEndLocations Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WaterComponent.SetSurfaceHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SurfaceHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterComponent::SetSurfaceHeight(float SurfaceHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "SetSurfaceHeight");

	Params::WaterComponent_SetSurfaceHeight Parms{};

	Parms.SurfaceHeight = SurfaceHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WaterComponent.SetWaterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWaterType                              Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterComponent::SetWaterType(const EWaterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "SetWaterType");

	Params::WaterComponent_SetWaterType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WaterComponent.GetDepth
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          InPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWaterComponent::GetDepth(const struct FVector& InPoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "GetDepth");

	Params::WaterComponent_GetDepth Parms{};

	Parms.InPoint = std::move(InPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WaterComponent.GetMaxDepthAtPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWaterComponent::GetMaxDepthAtPoint(const struct FVector& Point) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "GetMaxDepthAtPoint");

	Params::WaterComponent_GetMaxDepthAtPoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WaterComponent.GetSurfacePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWaterComponent::GetSurfacePoint(const struct FVector& Point) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterComponent", "GetSurfacePoint");

	Params::WaterComponent_GetSurfacePoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAchievementsSystem.CacheAchievements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAchievementsSystem::CacheAchievements(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAchievementsSystem", "CacheAchievements");

	Params::FlameAchievementsSystem_CacheAchievements Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAchievementsSystem.GetCachedAchievementProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchievementFound                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameAchievementsSystem::GetCachedAchievementProgress(class APlayerController* PlayerController, class FName AchievementName, bool* bAchievementFound, float* Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAchievementsSystem", "GetCachedAchievementProgress");

	Params::FlameAchievementsSystem_GetCachedAchievementProgress Parms{};

	Parms.PlayerController = PlayerController;
	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchievementFound != nullptr)
		*bAchievementFound = Parms.bAchievementFound;

	if (Progress != nullptr)
		*Progress = Parms.Progress;
}


// Function Flame.FlameAchievementsSystem.IsAchievementSystemValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAchievementsSystem::IsAchievementSystemValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAchievementsSystem", "IsAchievementSystemValid");

	Params::FlameAchievementsSystem_IsAchievementSystemValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAchievementsSystem.ResetAchievements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAchievementsSystem::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAchievementsSystem", "ResetAchievements");

	Params::FlameAchievementsSystem_ResetAchievements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAchievementsSystem.WriteAchievementProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAchievementsSystem::WriteAchievementProgress(class APlayerController* PlayerController, class FName AchievementName, float Progress, int32 UserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAchievementsSystem", "WriteAchievementProgress");

	Params::FlameAchievementsSystem_WriteAchievementProgress Parms{};

	Parms.PlayerController = PlayerController;
	Parms.AchievementName = AchievementName;
	Parms.Progress = Progress;
	Parms.UserTag = UserTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAIController.GetPerceptionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlameAIController::GetPerceptionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAIController", "GetPerceptionActive");

	Params::FlameAIController_GetPerceptionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAIController.IsEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlameAIController::IsEnemy(const class AActor* Other) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAIController", "IsEnemy");

	Params::FlameAIController_IsEnemy Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.AnimDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::AnimDone(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "AnimDone");

	Params::FlameAnimInstance_AnimDone Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.AnimRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Remaining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::AnimRemaining(int32 MachineIndex, int32 StateIndex, float Remaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "AnimRemaining");

	Params::FlameAnimInstance_AnimRemaining Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;
	Parms.Remaining = Remaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.IsLowerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELowerBodyState                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::IsLowerState(ELowerBodyState Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "IsLowerState");

	Params::FlameAnimInstance_IsLowerState Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.IsStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EStance                                 Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::IsStance(EStance Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "IsStance");

	Params::FlameAnimInstance_IsStance Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.IsUpperState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUpperBodyState                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::IsUpperState(EUpperBodyState Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "IsUpperState");

	Params::FlameAnimInstance_IsUpperState Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.NotLowerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELowerBodyState                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::NotLowerState(ELowerBodyState Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "NotLowerState");

	Params::FlameAnimInstance_NotLowerState Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.NotStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EStance                                 Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::NotStance(EStance Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "NotStance");

	Params::FlameAnimInstance_NotStance Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.NotUpperState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUpperBodyState                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameAnimInstance::NotUpperState(EUpperBodyState Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "NotUpperState");

	Params::FlameAnimInstance_NotUpperState Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameAnimInstance.PrintDiagnostic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    AllowPreview                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameAnimInstance::PrintDiagnostic(bool AllowPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameAnimInstance", "PrintDiagnostic");

	Params::FlameAnimInstance_PrintDiagnostic Parms{};

	Parms.AllowPreview = AllowPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMap.IsMatchmakingAllowed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterMap::IsMatchmakingAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMap", "IsMatchmakingAllowed");

	Params::ShelterMap_IsMatchmakingAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetAchievementsSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameAchievementsSystem*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameAchievementsSystem* UFlameGameInstance::GetAchievementsSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetAchievementsSystem");

	Params::FlameGameInstance_GetAchievementsSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetAssetManagerSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameAssetManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameAssetManager* UFlameGameInstance::GetAssetManagerSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetAssetManagerSystem");

	Params::FlameGameInstance_GetAssetManagerSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetBattlePassSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBattlePassSystem*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBattlePassSystem* UFlameGameInstance::GetBattlePassSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetBattlePassSystem");

	Params::FlameGameInstance_GetBattlePassSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetChallengeManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AChallengeManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AChallengeManager* UFlameGameInstance::GetChallengeManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetChallengeManager");

	Params::FlameGameInstance_GetChallengeManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetCloudSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudSystem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudSystem* UFlameGameInstance::GetCloudSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetCloudSystem");

	Params::FlameGameInstance_GetCloudSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetConsoleEvents
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConsoleEvents*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConsoleEvents* UFlameGameInstance::GetConsoleEvents(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetConsoleEvents");

	Params::FlameGameInstance_GetConsoleEvents Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetCurrentNintendoSwitchOperationMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ENintendoSwitchOperationMode            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENintendoSwitchOperationMode UFlameGameInstance::GetCurrentNintendoSwitchOperationMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetCurrentNintendoSwitchOperationMode");

	Params::FlameGameInstance_GetCurrentNintendoSwitchOperationMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetEventSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventSystem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventSystem* UFlameGameInstance::GetEventSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetEventSystem");

	Params::FlameGameInstance_GetEventSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetFlameGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameGameInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameInstance* UFlameGameInstance::GetFlameGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetFlameGameInstance");

	Params::FlameGameInstance_GetFlameGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetGameStoreSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameStoreSystem*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameStoreSystem* UFlameGameInstance::GetGameStoreSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetGameStoreSystem");

	Params::FlameGameInstance_GetGameStoreSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetGroupSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGroupSystem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGroupSystem* UFlameGameInstance::GetGroupSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetGroupSystem");

	Params::FlameGameInstance_GetGroupSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetHumanPlayerControllerByControllerId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHumanPlayerController* UFlameGameInstance::GetHumanPlayerControllerByControllerId(int32 ID, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetHumanPlayerControllerByControllerId");

	Params::FlameGameInstance_GetHumanPlayerControllerByControllerId Parms{};

	Parms.ID = ID;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLeaderboardSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULeaderboardSystem*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULeaderboardSystem* UFlameGameInstance::GetLeaderboardSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetLeaderboardSystem");

	Params::FlameGameInstance_GetLeaderboardSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetMapsManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMapsManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapsManager* UFlameGameInstance::GetMapsManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetMapsManager");

	Params::FlameGameInstance_GetMapsManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetPlatformStoreSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformStoreSystem*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformStoreSystem* UFlameGameInstance::GetPlatformStoreSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetPlatformStoreSystem");

	Params::FlameGameInstance_GetPlatformStoreSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetPlatformTools
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformTools*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformTools* UFlameGameInstance::GetPlatformTools(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetPlatformTools");

	Params::FlameGameInstance_GetPlatformTools Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetPoolingManagerSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameObjectPoolManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameObjectPoolManager* UFlameGameInstance::GetPoolingManagerSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetPoolingManagerSystem");

	Params::FlameGameInstance_GetPoolingManagerSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetRichPresence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URichPresence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URichPresence* UFlameGameInstance::GetRichPresence(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetRichPresence");

	Params::FlameGameInstance_GetRichPresence Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetServerAuthorityConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerAuthorityConfig*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UServerAuthorityConfig* UFlameGameInstance::GetServerAuthorityConfig(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetServerAuthorityConfig");

	Params::FlameGameInstance_GetServerAuthorityConfig Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetSteamTools
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformToolsSteam*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformToolsSteam* UFlameGameInstance::GetSteamTools(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetSteamTools");

	Params::FlameGameInstance_GetSteamTools Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetUserControllerId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFlameGameInstance::GetUserControllerId(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "GetUserControllerId");

	Params::FlameGameInstance_GetUserControllerId Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.InitDataProvider
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::InitDataProvider(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "InitDataProvider");

	Params::FlameGameInstance_InitDataProvider Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.IsAutotestRunning
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::IsAutotestRunning(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "IsAutotestRunning");

	Params::FlameGameInstance_IsAutotestRunning Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.LoginToCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::LoginToCloud(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "LoginToCloud");

	Params::FlameGameInstance_LoginToCloud Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.LogOutFromCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudManagerLogoutReason               ELogoutReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::LogOutFromCloud(const class UObject* WorldContextObject, ECloudManagerLogoutReason ELogoutReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameInstance", "LogOutFromCloud");

	Params::FlameGameInstance_LogOutFromCloud Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ELogoutReason = ELogoutReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.AchievementsReset
// (Final, Exec, Native, Public)

void UFlameGameInstance::AchievementsReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "AchievementsReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.AchievementsSetProgress
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::AchievementsSetProgress(class FName AchievementName, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "AchievementsSetProgress");

	Params::FlameGameInstance_AchievementsSetProgress Parms{};

	Parms.AchievementName = AchievementName;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ApplyBenchmarkResult
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ApplyBenchmarkResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ApplyBenchmarkResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ApplyShouldRecompileSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOptionsSaveGame*                 OptionSaveGame                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::ApplyShouldRecompileSettings(class UOptionsSaveGame* OptionSaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ApplyShouldRecompileSettings");

	Params::FlameGameInstance_ApplyShouldRecompileSettings Parms{};

	Parms.OptionSaveGame = OptionSaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.CancelMatchmaking
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::CancelMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "CancelMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ChangeAxisMappingData
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ChangeAxisMappingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ChangeAxisMappingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ChangeDisplayMonitor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MonitorNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::ChangeDisplayMonitor(int32 MonitorNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ChangeDisplayMonitor");

	Params::FlameGameInstance_ChangeDisplayMonitor Parms{};

	Parms.MonitorNumber = MonitorNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.CheckFPSEnabled
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CreateNew                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::CheckFPSEnabled(int32 ZOrder, bool CreateNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "CheckFPSEnabled");

	Params::FlameGameInstance_CheckFPSEnabled Parms{};

	Parms.ZOrder = ZOrder;
	Parms.CreateNew = CreateNew;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FlameGameInstance.CheckInputModification
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::CheckInputModification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "CheckInputModification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ClearOptionsSaveGame
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ClearOptionsSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ClearOptionsSaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ComputeClientPings
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ComputeClientPings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ComputeClientPings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.DebugAudioLocations
// (Final, Exec, Native, Public)

void UFlameGameInstance::DebugAudioLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "DebugAudioLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.DebugAudioParameters
// (Final, Exec, Native, Public)

void UFlameGameInstance::DebugAudioParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "DebugAudioParameters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.DelayMinimize
// (Event, Public, BlueprintEvent)

void UFlameGameInstance::DelayMinimize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "DelayMinimize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameGameInstance.EnableMinimizeAfterDuration
// (Event, Public, BlueprintEvent)

void UFlameGameInstance::EnableMinimizeAfterDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "EnableMinimizeAfterDuration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameGameInstance.FadeOutLoadingSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeOutTimeOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::FadeOutLoadingSound(float FadeOutTimeOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "FadeOutLoadingSound");

	Params::FlameGameInstance_FadeOutLoadingSound Parms{};

	Parms.FadeOutTimeOverride = FadeOutTimeOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.FlushQueuedOptionsSaveGameToDisk
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::FlushQueuedOptionsSaveGameToDisk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "FlushQueuedOptionsSaveGameToDisk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.GetCachedUserSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameUserSettings*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameUserSettings* UFlameGameInstance::GetCachedUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetCachedUserSettings");

	Params::FlameGameInstance_GetCachedUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetCPUBrandName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetCPUBrandName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetCPUBrandName");

	Params::FlameGameInstance_GetCPUBrandName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetCPUCores
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFlameGameInstance::GetCPUCores()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetCPUCores");

	Params::FlameGameInstance_GetCPUCores Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetCPUVendorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetCPUVendorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetCPUVendorName");

	Params::FlameGameInstance_GetCPUVendorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetDefaultOptionsSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOptionsSaveGame*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOptionsSaveGame* UFlameGameInstance::GetDefaultOptionsSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetDefaultOptionsSaveGame");

	Params::FlameGameInstance_GetDefaultOptionsSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetGPUBrandName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetGPUBrandName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetGPUBrandName");

	Params::FlameGameInstance_GetGPUBrandName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLastInputMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EInputMode                        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EInputMode UFlameGameInstance::GetLastInputMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLastInputMode");

	Params::FlameGameInstance_GetLastInputMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLoadingSound
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   TimeToTravel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTime                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutDelay                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* UFlameGameInstance::GetLoadingSound(float TimeToTravel, const class FName& LevelName, float* FadeInTime, float* FadeOutTime, float* FadeOutDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLoadingSound");

	Params::FlameGameInstance_GetLoadingSound Parms{};

	Parms.TimeToTravel = TimeToTravel;
	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (FadeInTime != nullptr)
		*FadeInTime = Parms.FadeInTime;

	if (FadeOutTime != nullptr)
		*FadeOutTime = Parms.FadeOutTime;

	if (FadeOutDelay != nullptr)
		*FadeOutDelay = Parms.FadeOutDelay;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetNumMonitors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFlameGameInstance::GetNumMonitors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetNumMonitors");

	Params::FlameGameInstance_GetNumMonitors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetOptionsSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UFlameGameInstance::GetOptionsSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetOptionsSaveGame");

	Params::FlameGameInstance_GetOptionsSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetPerformanceModeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::GetPerformanceModeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetPerformanceModeEnabled");

	Params::FlameGameInstance_GetPerformanceModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetWindowMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFlameGameInstance::GetWindowMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetWindowMode");

	Params::FlameGameInstance_GetWindowMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GroupInvite
// (Final, Exec, Native, Public)

void UFlameGameInstance::GroupInvite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GroupInvite");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.GroupLeave
// (Final, Exec, Native, Public)

void UFlameGameInstance::GroupLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GroupLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.GroupSimulate
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GroupSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::GroupSimulate(const class FString& GroupId, int32 GroupSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GroupSimulate");

	Params::FlameGameInstance_GroupSimulate Parms{};

	Parms.GroupId = std::move(GroupId);
	Parms.GroupSize = GroupSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.HasPSONumPrecompilesActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::HasPSONumPrecompilesActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "HasPSONumPrecompilesActive");

	Params::FlameGameInstance_HasPSONumPrecompilesActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.HasPSONumPrecompilesRemaining
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::HasPSONumPrecompilesRemaining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "HasPSONumPrecompilesRemaining");

	Params::FlameGameInstance_HasPSONumPrecompilesRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.InitChallengeManager
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::InitChallengeManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "InitChallengeManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.InitPostDataReadySystems
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::InitPostDataReadySystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "InitPostDataReadySystems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.InitSettingsProfileSystems
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::InitSettingsProfileSystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "InitSettingsProfileSystems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.IsOnSteamDeck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::IsOnSteamDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "IsOnSteamDeck");

	Params::FlameGameInstance_IsOnSteamDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.IsPerfModeSupported
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::IsPerfModeSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "IsPerfModeSupported");

	Params::FlameGameInstance_IsPerfModeSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.IsRunningSteam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::IsRunningSteam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "IsRunningSteam");

	Params::FlameGameInstance_IsRunningSteam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.IsWindowModeBorderless
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::IsWindowModeBorderless()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "IsWindowModeBorderless");

	Params::FlameGameInstance_IsWindowModeBorderless Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.LLMMemReport
// (Final, Exec, Native, Public)

void UFlameGameInstance::LLMMemReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "LLMMemReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.MinimizeWindow
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::MinimizeWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "MinimizeWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnCheckUserCrossPlayFinished
// (Final, Native, Private)
// Parameters:
// bool                                    CanUserCrossPlay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnCheckUserCrossPlayFinished(bool CanUserCrossPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnCheckUserCrossPlayFinished");

	Params::FlameGameInstance_OnCheckUserCrossPlayFinished Parms{};

	Parms.CanUserCrossPlay = CanUserCrossPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnCloudSystemStateChanged
// (Final, Native, Private)
// Parameters:
// ECloudManagerState                      OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudManagerState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnCloudSystemStateChanged(ECloudManagerState OldState, ECloudManagerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnCloudSystemStateChanged");

	Params::FlameGameInstance_OnCloudSystemStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnDataProviderStateChanged
// (Final, Native, Private)
// Parameters:
// EDataProviderState                      OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataProviderState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnDataProviderStateChanged(EDataProviderState OldState, EDataProviderState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnDataProviderStateChanged");

	Params::FlameGameInstance_OnDataProviderStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnNetworkFailure
// (Final, Native, Private)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNetDriver*                       NetDriver                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnNetworkFailure(class UWorld* InWorld, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnNetworkFailure");

	Params::FlameGameInstance_OnNetworkFailure Parms{};

	Parms.InWorld = InWorld;
	Parms.NetDriver = NetDriver;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnPlatformStoreOverlayActivated
// (Final, Native, Public)
// Parameters:
// bool                                    bIsActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnPlatformStoreOverlayActivated(bool bIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnPlatformStoreOverlayActivated");

	Params::FlameGameInstance_OnPlatformStoreOverlayActivated Parms{};

	Parms.bIsActive = bIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnPostLoadMap
// (Final, Native, Private)
// Parameters:
// class UWorld*                           NewWorld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnPostLoadMap(class UWorld* NewWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnPostLoadMap");

	Params::FlameGameInstance_OnPostLoadMap Parms{};

	Parms.NewWorld = NewWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.OnTravelFailure
// (Final, Native, Private)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelFailure                          FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::OnTravelFailure(class UWorld* InWorld, ETravelFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "OnTravelFailure");

	Params::FlameGameInstance_OnTravelFailure Parms{};

	Parms.InWorld = InWorld;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.PCControlsChanged
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::PCControlsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "PCControlsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.PerfModeChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::PerfModeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "PerfModeChanged");

	Params::FlameGameInstance_PerfModeChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.PlayLoadingSound
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::PlayLoadingSound(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "PlayLoadingSound");

	Params::FlameGameInstance_PlayLoadingSound Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ProcessPSOCacheWait
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ProcessPSOCacheWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ProcessPSOCacheWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ReloadOptionsSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipReset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::ReloadOptionsSaveGame(bool bSkipReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ReloadOptionsSaveGame");

	Params::FlameGameInstance_ReloadOptionsSaveGame Parms{};

	Parms.bSkipReset = bSkipReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.RunHardwareTestCache
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::RunHardwareTestCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "RunHardwareTestCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.RunPSOCachingProcess
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::RunPSOCachingProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "RunPSOCachingProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetLastMatchID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewMatchID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::SetLastMatchID(const class FString& NewMatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetLastMatchID");

	Params::FlameGameInstance_SetLastMatchID Parms{};

	Parms.NewMatchID = std::move(NewMatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetLastMatchMakingMatchID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::SetLastMatchMakingMatchID(const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetLastMatchMakingMatchID");

	Params::FlameGameInstance_SetLastMatchMakingMatchID Parms{};

	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetNumberOfPlayedGames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NumberOfPlayedGames                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::SetNumberOfPlayedGames(int32 NumberOfPlayedGames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetNumberOfPlayedGames");

	Params::FlameGameInstance_SetNumberOfPlayedGames Parms{};

	Parms.NumberOfPlayedGames = NumberOfPlayedGames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetOptionsMenuShutdown
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SetOptionsMenuShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetOptionsMenuShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetPerformanceMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::SetPerformanceMode(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetPerformanceMode");

	Params::FlameGameInstance_SetPerformanceMode Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetPSOCacheBackground
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SetPSOCacheBackground()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetPSOCacheBackground");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetPSOCacheData
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SetPSOCacheData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetPSOCacheData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetPSOCacheFast
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SetPSOCacheFast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetPSOCacheFast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SetPSOCacheSave
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SetPSOCacheSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SetPSOCacheSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ShowGameWindow
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ShowGameWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ShowGameWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ShowGroupSystemInfo
// (Final, Exec, Native, Public)

void UFlameGameInstance::ShowGroupSystemInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ShowGroupSystemInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ShowLocalPlayers
// (Final, Exec, Native, Public)

void UFlameGameInstance::ShowLocalPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ShowLocalPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ShowResolution
// (Final, Exec, Native, Public)

void UFlameGameInstance::ShowResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ShowResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.Shutdown
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::Shutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "Shutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SimulateOnPlatformStoreOverlayDeActivated
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SimulateOnPlatformStoreOverlayDeActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SimulateOnPlatformStoreOverlayDeActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.SkipPSOCachingProcess
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::SkipPSOCachingProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SkipPSOCachingProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.StartLoadingSoundFadeOutCountdown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeOutDelayTimeOverride                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTimeOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::StartLoadingSoundFadeOutCountdown(float FadeOutDelayTimeOverride, float FadeOutTimeOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "StartLoadingSoundFadeOutCountdown");

	Params::FlameGameInstance_StartLoadingSoundFadeOutCountdown Parms{};

	Parms.FadeOutDelayTimeOverride = FadeOutDelayTimeOverride;
	Parms.FadeOutTimeOverride = FadeOutTimeOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.StartMatchmaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameMode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceParty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameInstance::StartMatchmaking(const class FString& Map, const class FString& GameMode, bool bForceParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "StartMatchmaking");

	Params::FlameGameInstance_StartMatchmaking Parms{};

	Parms.Map = std::move(Map);
	Parms.GameMode = std::move(GameMode);
	Parms.bForceParty = bForceParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.StopLoadingSoundFadeOutCountdown
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::StopLoadingSoundFadeOutCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "StopLoadingSoundFadeOutCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.ToggleFullScreen
// (Final, Native, Public, BlueprintCallable)

void UFlameGameInstance::ToggleFullScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "ToggleFullScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGameInstance.CanBeCanceledMatchmaking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::CanBeCanceledMatchmaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "CanBeCanceledMatchmaking");

	Params::FlameGameInstance_CanBeCanceledMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetAllFormattedVersions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFlameGameInstance::GetAllFormattedVersions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetAllFormattedVersions");

	Params::FlameGameInstance_GetAllFormattedVersions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetAssetManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlameAssetManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameAssetManager* UFlameGameInstance::GetAssetManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetAssetManager");

	Params::FlameGameInstance_GetAssetManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetFormattedVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFlameGameInstance::GetFormattedVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetFormattedVersion");

	Params::FlameGameInstance_GetFormattedVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetFormattedVersionForUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFlameGameInstance::GetFormattedVersionForUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetFormattedVersionForUI");

	Params::FlameGameInstance_GetFormattedVersionForUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLastGameModeAlias
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetLastGameModeAlias() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLastGameModeAlias");

	Params::FlameGameInstance_GetLastGameModeAlias Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLastMatchID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetLastMatchID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLastMatchID");

	Params::FlameGameInstance_GetLastMatchID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLastMatchMakingMatchID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetLastMatchMakingMatchID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLastMatchMakingMatchID");

	Params::FlameGameInstance_GetLastMatchMakingMatchID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetLoadingSoundAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UFlameGameInstance::GetLoadingSoundAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetLoadingSoundAudioComponent");

	Params::FlameGameInstance_GetLoadingSoundAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.GetMatchmakingGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlameGameInstance::GetMatchmakingGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "GetMatchmakingGameMode");

	Params::FlameGameInstance_GetMatchmakingGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.LoadPlayerOptionsSaveGameFromDisk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UFlameGameInstance::LoadPlayerOptionsSaveGameFromDisk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "LoadPlayerOptionsSaveGameFromDisk");

	Params::FlameGameInstance_LoadPlayerOptionsSaveGameFromDisk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.MatchmakingInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::MatchmakingInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "MatchmakingInProgress");

	Params::FlameGameInstance_MatchmakingInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.SafeSyncDeleteGameFromSlot
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::SafeSyncDeleteGameFromSlot(const class FString& SlotName, const int32 UserIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SafeSyncDeleteGameFromSlot");

	Params::FlameGameInstance_SafeSyncDeleteGameFromSlot Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.SafeSyncLoadGameFromSlot
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UFlameGameInstance::SafeSyncLoadGameFromSlot(const class FString& SlotName, const int32 UserIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SafeSyncLoadGameFromSlot");

	Params::FlameGameInstance_SafeSyncLoadGameFromSlot Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameInstance.SafeSyncSaveGameToSlot
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USaveGame*                        SaveGameObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameGameInstance::SafeSyncSaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameInstance", "SafeSyncSaveGameToSlot");

	Params::FlameGameInstance_SafeSyncSaveGameToSlot Parms{};

	Parms.SaveGameObject = SaveGameObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuManager.AddElementToStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UOptionsElementWidget*            Element                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::AddElementToStack(class UOptionsElementWidget* Element, bool bIsPending, class FName Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "AddElementToStack");

	Params::OptionsMenuManager_AddElementToStack Parms{};

	Parms.Element = Element;
	Parms.bIsPending = bIsPending;
	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuManager.AddManuallyToStack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Identifier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOptionsElementValue             Values                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsPending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::AddManuallyToStack(class FName Identifier, const struct FOptionsElementValue& Values, bool bIsPending, class FName Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "AddManuallyToStack");

	Params::OptionsMenuManager_AddManuallyToStack Parms{};

	Parms.Identifier = Identifier;
	Parms.Values = std::move(Values);
	Parms.bIsPending = bIsPending;
	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuManager.ApplyStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOptionsMenuWidget*               OptionsMenuWidget                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::ApplyStack(class FName Page, class UOptionsMenuWidget* OptionsMenuWidget, class USaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "ApplyStack");

	Params::OptionsMenuManager_ApplyStack Parms{};

	Parms.Page = Page;
	Parms.OptionsMenuWidget = OptionsMenuWidget;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuManager.ClearStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::ClearStack(class FName Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "ClearStack");

	Params::OptionsMenuManager_ClearStack Parms{};

	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuManager.HasStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsMenuManager::HasStack(class FName Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "HasStack");

	Params::OptionsMenuManager_HasStack Parms{};

	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsMenuManager.RemoveWidgetReferences
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::RemoveWidgetReferences(class FName Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "RemoveWidgetReferences");

	Params::OptionsMenuManager_RemoveWidgetReferences Parms{};

	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsMenuManager.RevertStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOptionsMenuWidget*               OptionsMenuWidget                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsMenuManager::RevertStack(class FName Page, class UOptionsMenuWidget* OptionsMenuWidget, class USaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsMenuManager", "RevertStack");

	Params::OptionsMenuManager_RevertStack Parms{};

	Parms.Page = Page;
	Parms.OptionsMenuWidget = OptionsMenuWidget;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameGridWidget.SetGridDimensions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GridWidth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGridWidget::SetGridDimensions(int32 GridWidth, int32 GridHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGridWidget", "SetGridDimensions");

	Params::FlameGridWidget_SetGridDimensions Parms{};

	Parms.GridWidth = GridWidth;
	Parms.GridHeight = GridHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.QRDisplayer.GenerateQrCode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UQRDisplayer::GenerateQrCode(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QRDisplayer", "GenerateQrCode");

	Params::QRDisplayer_GenerateQrCode Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameInputKeySelector.GetSelectorTextDesiredSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UFlameInputKeySelector::GetSelectorTextDesiredSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "GetSelectorTextDesiredSize");

	Params::FlameInputKeySelector_GetSelectorTextDesiredSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.FlameInputKeySelector.OnIsSelectingKeyChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UFlameInputKeySelector::OnIsSelectingKeyChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "OnIsSelectingKeyChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.FlameInputKeySelector.OnKeySelected__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FInputChord                      SelectedKey_0                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::OnKeySelected__DelegateSignature(const struct FInputChord& SelectedKey_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "OnKeySelected__DelegateSignature");

	Params::FlameInputKeySelector_OnKeySelected__DelegateSignature Parms{};

	Parms.SelectedKey_0 = std::move(SelectedKey_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FlameInputKeySelector.SetAdditionalKeyText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InAdditionalKeyText                                    (Parm, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetAdditionalKeyText(const class FText& InAdditionalKeyText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetAdditionalKeyText");

	Params::FlameInputKeySelector_SetAdditionalKeyText Parms{};

	Parms.InAdditionalKeyText = std::move(InAdditionalKeyText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetAllowGamepadKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowGamepadKeys                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetAllowGamepadKeys(bool bInAllowGamepadKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetAllowGamepadKeys");

	Params::FlameInputKeySelector_SetAllowGamepadKeys Parms{};

	Parms.bInAllowGamepadKeys = bInAllowGamepadKeys;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetAllowModifierKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowModifierKeys                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetAllowModifierKeys(bool bInAllowModifierKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetAllowModifierKeys");

	Params::FlameInputKeySelector_SetAllowModifierKeys Parms{};

	Parms.bInAllowModifierKeys = bInAllowModifierKeys;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetEscapeKeys
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FKey>                     InKeys                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetEscapeKeys(const TArray<struct FKey>& InKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetEscapeKeys");

	Params::FlameInputKeySelector_SetEscapeKeys Parms{};

	Parms.InKeys = std::move(InKeys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetKeySelectionText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InKeySelectionText                                     (Parm, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetKeySelectionText(const class FText& InKeySelectionText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetKeySelectionText");

	Params::FlameInputKeySelector_SetKeySelectionText Parms{};

	Parms.InKeySelectionText = std::move(InKeySelectionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetNoKeySpecifiedText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InNoKeySpecifiedText                                   (Parm, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetNoKeySpecifiedText(const class FText& InNoKeySpecifiedText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetNoKeySpecifiedText");

	Params::FlameInputKeySelector_SetNoKeySpecifiedText Parms{};

	Parms.InNoKeySpecifiedText = std::move(InNoKeySpecifiedText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetSelectedKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputChord                      InSelectedKey                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetSelectedKey(const struct FInputChord& InSelectedKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetSelectedKey");

	Params::FlameInputKeySelector_SetSelectedKey Parms{};

	Parms.InSelectedKey = std::move(InSelectedKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SetTextBlockVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        InVisibility                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameInputKeySelector::SetTextBlockVisibility(const ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SetTextBlockVisibility");

	Params::FlameInputKeySelector_SetTextBlockVisibility Parms{};

	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.SynchronizeProperties
// (Native, Public, BlueprintCallable)

void UFlameInputKeySelector::SynchronizeProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "SynchronizeProperties");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameInputKeySelector.GetIsSelectingKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameInputKeySelector::GetIsSelectingKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameInputKeySelector", "GetIsSelectingKey");

	Params::FlameInputKeySelector_GetIsSelectingKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OnboardingLoginRewardsComponent.ClaimOnboardingLoginRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnboardingLoginRewardsComponent::ClaimOnboardingLoginRewards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnboardingLoginRewardsComponent", "ClaimOnboardingLoginRewards");

	Params::OnboardingLoginRewardsComponent_ClaimOnboardingLoginRewards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnboardingLoginRewardsComponent.ClaimOnboardingLoginRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudClaimOnboardingLoginRewardsResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnboardingLoginRewardsComponent::ClaimOnboardingLoginRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudClaimOnboardingLoginRewardsResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnboardingLoginRewardsComponent", "ClaimOnboardingLoginRewardsDelegate__DelegateSignature");

	Params::OnboardingLoginRewardsComponent_ClaimOnboardingLoginRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnboardingLoginRewardsComponent.GetOnboardingLoginRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnboardingLoginRewardsComponent::GetOnboardingLoginRewards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnboardingLoginRewardsComponent", "GetOnboardingLoginRewards");

	Params::OnboardingLoginRewardsComponent_GetOnboardingLoginRewards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnboardingLoginRewardsComponent.GetOnboardingLoginRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetOnboardingLoginRewardsResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnboardingLoginRewardsComponent::GetOnboardingLoginRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetOnboardingLoginRewardsResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnboardingLoginRewardsComponent", "GetOnboardingLoginRewardsDelegate__DelegateSignature");

	Params::OnboardingLoginRewardsComponent_GetOnboardingLoginRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FlameLocomotionInstance.IsSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESpeedMode                              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlameLocomotionInstance::IsSpeed(ESpeedMode Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameLocomotionInstance", "IsSpeed");

	Params::FlameLocomotionInstance_IsSpeed Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlamePoolObject.OnPoolDespawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IFlamePoolObject::OnPoolDespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlamePoolObject", "OnPoolDespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlamePoolObject.OnPoolSpawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IFlamePoolObject::OnPoolSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlamePoolObject", "OnPoolSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameObjectPoolManager.Create
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlameObjectPoolManager::Create(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameObjectPoolManager", "Create");

	Params::FlameObjectPoolManager_Create Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameObjectPoolManager.Get
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlameObjectPoolManager::Get(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameObjectPoolManager", "Get");

	Params::FlameObjectPoolManager_Get Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameObjectPoolManager.OnWorldCleanup
// (Final, Native, Private)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSessionEnded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCleanupResources                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameObjectPoolManager::OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameObjectPoolManager", "OnWorldCleanup");

	Params::FlameObjectPoolManager_OnWorldCleanup Parms{};

	Parms.World = World;
	Parms.bSessionEnded = bSessionEnded;
	Parms.bCleanupResources = bCleanupResources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameObjectPoolManager.PutBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameObjectPoolManager::PutBack(class UObject* Object, float LifeSpan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameObjectPoolManager", "PutBack");

	Params::FlameObjectPoolManager_PutBack Parms{};

	Parms.Object = Object;
	Parms.LifeSpan = LifeSpan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OnlineRawDataComponent.ClearCloudRawKeyData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::ClearCloudRawKeyData(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "ClearCloudRawKeyData");

	Params::OnlineRawDataComponent_ClearCloudRawKeyData Parms{};

	Parms.Player = Player;
	Parms.CategoryName = std::move(CategoryName);
	Parms.KeyName = std::move(KeyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.ClearCloudRawKeyDataDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::ClearCloudRawKeyDataDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "ClearCloudRawKeyDataDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_ClearCloudRawKeyDataDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineRawDataComponent.GetCloudAllRawDataForUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::GetCloudAllRawDataForUser(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudAllRawDataForUser");

	Params::OnlineRawDataComponent_GetCloudAllRawDataForUser Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.GetCloudAllRawDataForUserDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetAllRawDataForUserResult Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::GetCloudAllRawDataForUserDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetAllRawDataForUserResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudAllRawDataForUserDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_GetCloudAllRawDataForUserDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineRawDataComponent.GetCloudRawDataAllUsers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::GetCloudRawDataAllUsers(const class FString& CategoryName, const class FString& KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataAllUsers");

	Params::OnlineRawDataComponent_GetCloudRawDataAllUsers Parms{};

	Parms.CategoryName = std::move(CategoryName);
	Parms.KeyName = std::move(KeyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.GetCloudRawDataAllUsersDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetRawDataAllUsersResult   Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::GetCloudRawDataAllUsersDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataAllUsersResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataAllUsersDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_GetCloudRawDataAllUsersDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineRawDataComponent.GetCloudRawDataAllUsersOrdered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGetAllRawDataOrder                     Order                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SortValue                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::GetCloudRawDataAllUsersOrdered(const class FString& CategoryName, const class FString& KeyName, EGetAllRawDataOrder Order, const class FString& SortValue, int32 PageIndex, int32 PageSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataAllUsersOrdered");

	Params::OnlineRawDataComponent_GetCloudRawDataAllUsersOrdered Parms{};

	Parms.CategoryName = std::move(CategoryName);
	Parms.KeyName = std::move(KeyName);
	Parms.Order = Order;
	Parms.SortValue = std::move(SortValue);
	Parms.PageIndex = PageIndex;
	Parms.PageSize = PageSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.GetCloudRawDataAllUsersOrderedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetRawDataAllUsersOrderedResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::GetCloudRawDataAllUsersOrderedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataAllUsersOrderedResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataAllUsersOrderedDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_GetCloudRawDataAllUsersOrderedDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineRawDataComponent.GetCloudRawDataKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::GetCloudRawDataKey(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataKey");

	Params::OnlineRawDataComponent_GetCloudRawDataKey Parms{};

	Parms.Player = Player;
	Parms.CategoryName = std::move(CategoryName);
	Parms.KeyName = std::move(KeyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.GetCloudRawDataKeyDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetRawDataKeyResult        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::GetCloudRawDataKeyDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataKeyResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "GetCloudRawDataKeyDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_GetCloudRawDataKeyDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineRawDataComponent.SetCloudRawDataKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineRawDataComponent::SetCloudRawDataKey(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName, const class UJsonValue* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "SetCloudRawDataKey");

	Params::OnlineRawDataComponent_SetCloudRawDataKey Parms{};

	Parms.Player = Player;
	Parms.CategoryName = std::move(CategoryName);
	Parms.KeyName = std::move(KeyName);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineRawDataComponent.SetCloudRawDataKeyDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudRawDataInfo                Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineRawDataComponent::SetCloudRawDataKeyDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudRawDataInfo& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineRawDataComponent", "SetCloudRawDataKeyDelegate__DelegateSignature");

	Params::OnlineRawDataComponent_SetCloudRawDataKeyDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OptionsSaveGame.GetGlobalSafeZoneScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOptionsSaveGame::GetGlobalSafeZoneScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OptionsSaveGame", "GetGlobalSafeZoneScale");

	Params::OptionsSaveGame_GetGlobalSafeZoneScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsSaveGame.ApplyMouseSettings
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSaveGame::ApplyMouseSettings(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "ApplyMouseSettings");

	Params::OptionsSaveGame_ApplyMouseSettings Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsSaveGame.ClearAllKeyBindings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsRightHanded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSaveGame::ClearAllKeyBindings(bool IsRightHanded, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "ClearAllKeyBindings");

	Params::OptionsSaveGame_ClearAllKeyBindings Parms{};

	Parms.IsRightHanded = IsRightHanded;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsSaveGame.GetQualitySettingsLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOptionsSaveGame::GetQualitySettingsLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "GetQualitySettingsLevel");

	Params::OptionsSaveGame_GetQualitySettingsLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsSaveGame.SaveKeyBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRightHanded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key1                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key2                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSaveGame::SaveKeyBinding(class FName Name_0, bool IsRightHanded, const struct FKey& Key1, const struct FKey& Key2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "SaveKeyBinding");

	Params::OptionsSaveGame_SaveKeyBinding Parms{};

	Parms.Name_0 = Name_0;
	Parms.IsRightHanded = IsRightHanded;
	Parms.Key1 = std::move(Key1);
	Parms.Key2 = std::move(Key2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OptionsSaveGame.GetGameSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameSaveSettings          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameSaveSettings UOptionsSaveGame::GetGameSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "GetGameSettings");

	Params::OptionsSaveGame_GetGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OptionsSaveGame.GetVideoSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVideoSaveSettings         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FVideoSaveSettings UOptionsSaveGame::GetVideoSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSaveGame", "GetVideoSettings");

	Params::OptionsSaveGame_GetVideoSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameLoad.LoadGameFromSlotByPlatform
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFlameGameInstance*               FlameGameInstance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameGameLoad*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameLoad* UFlameGameLoad::LoadGameFromSlotByPlatform(class UFlameGameInstance* FlameGameInstance, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlameGameLoad", "LoadGameFromSlotByPlatform");

	Params::FlameGameLoad_LoadGameFromSlotByPlatform Parms{};

	Parms.FlameGameInstance = FlameGameInstance;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FlameGameLoad.ReceivedLoadResults
// (Final, Native, Private)
// Parameters:
// class USaveGame*                        SaveGameObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlameGameLoad::ReceivedLoadResults(class USaveGame* SaveGameObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameGameLoad", "ReceivedLoadResults");

	Params::FlameGameLoad_ReceivedLoadResults Parms{};

	Parms.SaveGameObject = SaveGameObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.FlameSpectator.OnSpectateTargetChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFlameSpectator::OnSpectateTargetChanged(class AHumanCharacter* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectator", "OnSpectateTargetChanged");

	Params::FlameSpectator_OnSpectateTargetChanged Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FlameSpectator.OnSpectateTargetRemoved
// (Event, Public, BlueprintEvent)

void AFlameSpectator::OnSpectateTargetRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectator", "OnSpectateTargetRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FlameSpectator.ReceiveTravel
// (Event, Public, BlueprintEvent)

void AFlameSpectator::ReceiveTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlameSpectator", "ReceiveTravel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FootStepComponent.OnFootStep
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootStepLegIndex                       FootStepLegIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootStepMovementType                   FootStepMovementType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootStepComponent::OnFootStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EFootStepLegIndex FootStepLegIndex, EFootStepMovementType FootStepMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnFootStep");

	Params::FootStepComponent_OnFootStep Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.FootStepLegIndex = FootStepLegIndex;
	Parms.FootStepMovementType = FootStepMovementType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FootStepComponent.OnLadderStep
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELadderStepLimbIndex                    LadderStepLimbIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootStepComponent::OnLadderStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EPhysicalSurface SurfaceType, ELadderStepLimbIndex LadderStepLimbIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnLadderStep");

	Params::FootStepComponent_OnLadderStep Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.SurfaceType = SurfaceType;
	Parms.LadderStepLimbIndex = LadderStepLimbIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.FootStepComponent.OnPlayerEnterWater
// (Event, Public, BlueprintEvent)

void UFootStepComponent::OnPlayerEnterWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnPlayerEnterWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FootStepComponent.OnPlayerExitWater
// (Event, Public, BlueprintEvent)

void UFootStepComponent::OnPlayerExitWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnPlayerExitWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FootStepComponent.OnPlayerInWaterTick
// (Event, Public, BlueprintEvent)

void UFootStepComponent::OnPlayerInWaterTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnPlayerInWaterTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.FootStepComponent.OnProneStep
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProneStepLimbIndex                     ProneStepLimbIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootStepComponent::OnProneStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EProneStepLimbIndex ProneStepLimbIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootStepComponent", "OnProneStep");

	Params::FootStepComponent_OnProneStep Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.ProneStepLimbIndex = ProneStepLimbIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.CloseItemPreviewScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                InPreviewedItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::CloseItemPreviewScreen(TSubclassOf<class AItem> InPreviewedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "CloseItemPreviewScreen");

	Params::ShelterStash_CloseItemPreviewScreen Parms{};

	Parms.InPreviewedItem = InPreviewedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.EmptyBackpackToStash
// (Final, Native, Public, BlueprintCallable)

void UShelterStash::EmptyBackpackToStash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "EmptyBackpackToStash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.EnterSubmenu
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FStashViewContext                InContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UShelterStash::EnterSubmenu(const struct FStashViewContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "EnterSubmenu");

	Params::ShelterStash_EnterSubmenu Parms{};

	Parms.InContext = std::move(InContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.LeaveSubmenu
// (Final, Native, Public, BlueprintCallable)

void UShelterStash::LeaveSubmenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "LeaveSubmenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.OnEquipWeaponAfterSwapClosed
// (Final, Native, Protected)
// Parameters:
// class UFlameWidget*                     FlameWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnEquipWeaponAfterSwapClosed(class UFlameWidget* FlameWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnEquipWeaponAfterSwapClosed");

	Params::ShelterStash_OnEquipWeaponAfterSwapClosed Parms{};

	Parms.FlameWidget = FlameWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.OnEquipWeaponClosed
// (Final, Native, Protected)
// Parameters:
// class UFlameWidget*                     FlameWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnEquipWeaponClosed(class UFlameWidget* FlameWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnEquipWeaponClosed");

	Params::ShelterStash_OnEquipWeaponClosed Parms{};

	Parms.FlameWidget = FlameWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.OnItemPreviewClosed
// (Event, Protected, BlueprintEvent)
// Parameters:
// TSubclassOf<class AItem>                InPreviewedItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnItemPreviewClosed(TSubclassOf<class AItem> InPreviewedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnItemPreviewClosed");

	Params::ShelterStash_OnItemPreviewClosed Parms{};

	Parms.InPreviewedItem = InPreviewedItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.OnItemPreviewOpened
// (Event, Protected, BlueprintEvent)
// Parameters:
// TSubclassOf<class AItem>                InItemToPreview                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnItemPreviewOpened(TSubclassOf<class AItem> InItemToPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnItemPreviewOpened");

	Params::ShelterStash_OnItemPreviewOpened Parms{};

	Parms.InItemToPreview = InItemToPreview;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.OnLocked
// (Event, Public, BlueprintEvent)

void UShelterStash::OnLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnLocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ShelterStash.OnSubmenuEntered
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FStashViewContext                InContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UShelterStash::OnSubmenuEntered(const struct FStashViewContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnSubmenuEntered");

	Params::ShelterStash_OnSubmenuEntered Parms{};

	Parms.InContext = std::move(InContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.OnSubmenuLeft
// (Event, Protected, BlueprintEvent)
// Parameters:
// EInventoryView                          InView                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnSubmenuLeft(EInventoryView InView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnSubmenuLeft");

	Params::ShelterStash_OnSubmenuLeft Parms{};

	Parms.InView = InView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.OnSwapWeaponsClosed
// (Final, Native, Protected)
// Parameters:
// class UFlameWidget*                     FlameWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnSwapWeaponsClosed(class UFlameWidget* FlameWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnSwapWeaponsClosed");

	Params::ShelterStash_OnSwapWeaponsClosed Parms{};

	Parms.FlameWidget = FlameWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.OnUnlocked
// (Event, Public, BlueprintEvent)

void UShelterStash::OnUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ShelterStash.OnViewChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EInventoryView                          InView                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OnViewChanged(EInventoryView InView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OnViewChanged");

	Params::ShelterStash_OnViewChanged Parms{};

	Parms.InView = InView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterStash.OpenItemPreviewScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                InItemToPreview                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::OpenItemPreviewScreen(TSubclassOf<class AItem> InItemToPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "OpenItemPreviewScreen");

	Params::ShelterStash_OpenItemPreviewScreen Parms{};

	Parms.InItemToPreview = InItemToPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.SelectFlameSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFlameSlot*                       InFlameSlot                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputIcon                              InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::SelectFlameSlot(class UFlameSlot* InFlameSlot, EInputIcon InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "SelectFlameSlot");

	Params::ShelterStash_SelectFlameSlot Parms{};

	Parms.InFlameSlot = InFlameSlot;
	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.SetView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventoryView                          View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStash::SetView(EInventoryView View)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "SetView");

	Params::ShelterStash_SetView Parms{};

	Parms.View = View;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStash.IsLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterStash::IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "IsLocked");

	Params::ShelterStash_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterStash.ShouldOpenEquipWeaponModalWidget
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class AWeapon*                          InWeaponToEquip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterStash::ShouldOpenEquipWeaponModalWidget(class AWeapon* InWeaponToEquip) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStash", "ShouldOpenEquipWeaponModalWidget");

	Params::ShelterStash_ShouldOpenEquipWeaponModalWidget Parms{};

	Parms.InWeaponToEquip = InWeaponToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FriendInfo.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFriendInfo::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendInfo", "GetDisplayName");

	Params::FriendInfo_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FriendInfo.GetRealName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFriendInfo::GetRealName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendInfo", "GetRealName");

	Params::FriendInfo_GetRealName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.FriendInfo.GetUserAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           AttrName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutAttrValue                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFriendInfo::GetUserAttribute(const class FString& AttrName, class FString* OutAttrValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendInfo", "GetUserAttribute");

	Params::FriendInfo_GetUserAttribute Parms{};

	Parms.AttrName = std::move(AttrName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAttrValue != nullptr)
		*OutAttrValue = std::move(Parms.OutAttrValue);

	return Parms.ReturnValue;
}


// Function Flame.FriendInfo.GetUserId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl UFriendInfo::GetUserId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendInfo", "GetUserId");

	Params::FriendInfo_GetUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameControlSpawnComponent.GetSpawnPointLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameControlSpawnComponent::GetSpawnPointLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameControlSpawnComponent", "GetSpawnPointLocation");

	Params::GameControlSpawnComponent_GetSpawnPointLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.CheckEncroachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           FoundPlayerStart                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeFlame::CheckEncroachment(class AActor* FoundPlayerStart, class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "CheckEncroachment");

	Params::GameModeFlame_CheckEncroachment Parms{};

	Parms.FoundPlayerStart = FoundPlayerStart;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetMatchStartAfter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeFlame::GetMatchStartAfter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetMatchStartAfter");

	Params::GameModeFlame_GetMatchStartAfter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetOrCreateSpectatorManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASpectatorManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpectatorManager* AGameModeFlame::GetOrCreateSpectatorManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetOrCreateSpectatorManager");

	Params::GameModeFlame_GetOrCreateSpectatorManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetPlayerCanRestart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeFlame::GetPlayerCanRestart(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetPlayerCanRestart");

	Params::GameModeFlame_GetPlayerCanRestart Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetTeammates
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AHumanPlayerController*>   OutControllerList                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AGameModeFlame::GetTeammates(class AHumanPlayerController* Player, TArray<class AHumanPlayerController*>* OutControllerList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetTeammates");

	Params::GameModeFlame_GetTeammates Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutControllerList != nullptr)
		*OutControllerList = std::move(Parms.OutControllerList);
}


// Function Flame.GameModeFlame.OnLeftMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::OnLeftMatch(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "OnLeftMatch");

	Params::GameModeFlame_OnLeftMatch Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.OnMatchInfoMatchStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::OnMatchInfoMatchStarted(const struct FCloudRequestResult& RequestResult, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "OnMatchInfoMatchStarted");

	Params::GameModeFlame_OnMatchInfoMatchStarted Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.OnPlayerDied
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeFlame::OnPlayerDied(class AHumanCharacter* Player, class AHumanCharacter* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "OnPlayerDied");

	Params::GameModeFlame_OnPlayerDied Parms{};

	Parms.Player = Player;
	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.OnPlayerRespawned
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::OnPlayerRespawned(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "OnPlayerRespawned");

	Params::GameModeFlame_OnPlayerRespawned Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.OnSpectatorHasNobodyToSpectate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::OnSpectatorHasNobodyToSpectate(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "OnSpectatorHasNobodyToSpectate");

	Params::GameModeFlame_OnSpectatorHasNobodyToSpectate Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.PlayerSendToShelter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::PlayerSendToShelter(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "PlayerSendToShelter");

	Params::GameModeFlame_PlayerSendToShelter Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.PlayerSendToShelterWithDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeFlame::PlayerSendToShelterWithDelay(class AHumanPlayerController* Player, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "PlayerSendToShelterWithDelay");

	Params::GameModeFlame_PlayerSendToShelterWithDelay Parms{};

	Parms.Player = Player;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameModeFlame.PreparePrimaryStartsForPlayers
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeFlame::PreparePrimaryStartsForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "PreparePrimaryStartsForPlayers");

	Params::GameModeFlame_PreparePrimaryStartsForPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.SelectNextPrimaryStartForPlayer
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStartFlame*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStartFlame* AGameModeFlame::SelectNextPrimaryStartForPlayer(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "SelectNextPrimaryStartForPlayer");

	Params::GameModeFlame_SelectNextPrimaryStartForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.ShouldStartMatchBP
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeFlame::ShouldStartMatchBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "ShouldStartMatchBP");

	Params::GameModeFlame_ShouldStartMatchBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetInactivePlayerStates
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APlayerState*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerState*> AGameModeFlame::GetInactivePlayerStates() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetInactivePlayerStates");

	Params::GameModeFlame_GetInactivePlayerStates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameModeFlame.GetMaxPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeFlame::GetMaxPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeFlame", "GetMaxPlayers");

	Params::GameModeFlame_GetMaxPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GamepadActionWidget.SetActionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UGamepadActionWidget::SetActionName(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamepadActionWidget", "SetActionName");

	Params::GamepadActionWidget_SetActionName Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponEquipmentSlot.UpdateWeaponName
// (Final, Native, Public, BlueprintCallable)

void UWeaponEquipmentSlot::UpdateWeaponName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponEquipmentSlot", "UpdateWeaponName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameStateFlame.OnRep_MatchId
// (Final, Native, Private)

void AGameStateFlame::OnRep_MatchId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "OnRep_MatchId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameStateFlame.FindInactivePlayerInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 InNetId                                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInactivePlayerInfo              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInactivePlayerInfo AGameStateFlame::FindInactivePlayerInfo(const struct FUniqueNetIdRepl& InNetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "FindInactivePlayerInfo");

	Params::GameStateFlame_FindInactivePlayerInfo Parms{};

	Parms.InNetId = std::move(InNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStateFlame.GetCloudMatchSettingsInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FCloudMatchSettingsInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudMatchSettingsInfo AGameStateFlame::GetCloudMatchSettingsInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "GetCloudMatchSettingsInfo");

	Params::GameStateFlame_GetCloudMatchSettingsInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStateFlame.GetPlatformFromPlayerId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsActive                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlamePlatform                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFlamePlatform AGameStateFlame::GetPlatformFromPlayerId(int32 PlayerId, bool* bIsActive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "GetPlatformFromPlayerId");

	Params::GameStateFlame_GetPlatformFromPlayerId Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsActive != nullptr)
		*bIsActive = Parms.bIsActive;

	return Parms.ReturnValue;
}


// Function Flame.GameStateFlame.GetRemainingStartAfterSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameStateFlame::GetRemainingStartAfterSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "GetRemainingStartAfterSeconds");

	Params::GameStateFlame_GetRemainingStartAfterSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStateFlame.GetUniqueNetIdFromPlayerId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsActive                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl AGameStateFlame::GetUniqueNetIdFromPlayerId(int32 PlayerId, bool* bIsActive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateFlame", "GetUniqueNetIdFromPlayerId");

	Params::GameStateFlame_GetUniqueNetIdFromPlayerId Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsActive != nullptr)
		*bIsActive = Parms.bIsActive;

	return Parms.ReturnValue;
}


// Function Flame.ProfilePictureCache.GetOrQueryProfilePicture
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 NetId                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2DDynamic*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2DDynamic* UProfilePictureCache::GetOrQueryProfilePicture(const struct FUniqueNetIdRepl& NetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureCache", "GetOrQueryProfilePicture");

	Params::ProfilePictureCache_GetOrQueryProfilePicture Parms{};

	Parms.NetId = std::move(NetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProfilePictureCache.OnQueryCompleted
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerNetId                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2DDynamic*                ProfilePicture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureCache::OnQueryCompleted(const struct FUniqueNetIdRepl& PlayerNetId, class UTexture2DDynamic* ProfilePicture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureCache", "OnQueryCompleted");

	Params::ProfilePictureCache_OnQueryCompleted Parms{};

	Parms.PlayerNetId = std::move(PlayerNetId);
	Parms.ProfilePicture = ProfilePicture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.GameStoreProducts.GameStoreProductsStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EGameStoreProductsState                 OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameStoreProductsState                 NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreProducts::GameStoreProductsStateChanged__DelegateSignature(EGameStoreProductsState OldState, EGameStoreProductsState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "GameStoreProductsStateChanged__DelegateSignature");

	Params::GameStoreProducts_GameStoreProductsStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameStoreProducts.OnPlatformStoreOffersChanges
// (Final, Native, Protected)
// Parameters:
// EPlatformStoreOffersState               OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformStoreOffersState               NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreProducts::OnPlatformStoreOffersChanges(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "OnPlatformStoreOffersChanges");

	Params::GameStoreProducts_OnPlatformStoreOffersChanges Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameStoreProducts.StartDownloadOfProducts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameStoreProducts::StartDownloadOfProducts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "StartDownloadOfProducts");

	Params::GameStoreProducts_StartDownloadOfProducts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreProducts.GetGameStoreProductInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameStoreProductId              ProductId                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ProductFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreProductInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductInfo UGameStoreProducts::GetGameStoreProductInfo(const struct FGameStoreProductId& ProductId, bool* ProductFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "GetGameStoreProductInfo");

	Params::GameStoreProducts_GetGameStoreProductInfo Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductFound != nullptr)
		*ProductFound = Parms.ProductFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreProducts.GetGameStoreProductInfoById
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ProductId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ProductFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameStoreProductInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductInfo UGameStoreProducts::GetGameStoreProductInfoById(const class FString& ProductId, bool* ProductFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "GetGameStoreProductInfoById");

	Params::GameStoreProducts_GetGameStoreProductInfoById Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductFound != nullptr)
		*ProductFound = Parms.ProductFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreProducts.GetProductList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameStoreProductInfoList  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductInfoList UGameStoreProducts::GetProductList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "GetProductList");

	Params::GameStoreProducts_GetProductList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreProducts.GetProductsManagerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameStoreProductsState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameStoreProductsState UGameStoreProducts::GetProductsManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreProducts", "GetProductsManagerState");

	Params::GameStoreProducts_GetProductsManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GameStorePurchases.GameStorePurchasesStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EGameStorePurchasesState                OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameStorePurchasesState                NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStorePurchases::GameStorePurchasesStateChanged__DelegateSignature(EGameStorePurchasesState OldState, EGameStorePurchasesState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStorePurchases", "GameStorePurchasesStateChanged__DelegateSignature");

	Params::GameStorePurchases_GameStorePurchasesStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameStorePurchases.StartDownloadOfPurchaseList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameStorePurchases::StartDownloadOfPurchaseList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStorePurchases", "StartDownloadOfPurchaseList");

	Params::GameStorePurchases_StartDownloadOfPurchaseList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStorePurchases.FindPurchasedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FGameStoreProductId              ProductId                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ItemFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameStorePurchaseItemInfo       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameStorePurchaseItemInfo UGameStorePurchases::FindPurchasedItem(const struct FGameStoreProductId& ProductId, bool* ItemFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStorePurchases", "FindPurchasedItem");

	Params::GameStorePurchases_FindPurchasedItem Parms{};

	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemFound != nullptr)
		*ItemFound = Parms.ItemFound;

	return Parms.ReturnValue;
}


// Function Flame.GameStorePurchases.GetGameStoreData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameStorePurchasesInfo    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStorePurchasesInfo UGameStorePurchases::GetGameStoreData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStorePurchases", "GetGameStoreData");

	Params::GameStorePurchases_GetGameStoreData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStorePurchases.GetPurchasesManagerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameStorePurchasesState                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameStorePurchasesState UGameStorePurchases::GetPurchasesManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStorePurchases", "GetPurchasesManagerState");

	Params::GameStorePurchases_GetPurchasesManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterUIFunctions.IsCraftable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AItem>                InItemClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckQueue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterUIFunctions::IsCraftable(TSubclassOf<class AItem> InItemClass, const class APlayerController* InPlayerController, bool bCheckQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterUIFunctions", "IsCraftable");

	Params::ShelterUIFunctions_IsCraftable Parms{};

	Parms.InItemClass = InItemClass;
	Parms.InPlayerController = InPlayerController;
	Parms.bCheckQueue = bCheckQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.GetGameStoreInvalidPurchaseRequestId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameStoreSystem::GetGameStoreInvalidPurchaseRequestId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStoreSystem", "GetGameStoreInvalidPurchaseRequestId");

	Params::GameStoreSystem_GetGameStoreInvalidPurchaseRequestId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.GetGameStoreOffersManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameStoreOffers*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameStoreOffers* UGameStoreSystem::GetGameStoreOffersManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStoreSystem", "GetGameStoreOffersManager");

	Params::GameStoreSystem_GetGameStoreOffersManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.GetGameStoreProductsManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameStoreProducts*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameStoreProducts* UGameStoreSystem::GetGameStoreProductsManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStoreSystem", "GetGameStoreProductsManager");

	Params::GameStoreSystem_GetGameStoreProductsManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.GetGameStorePurchasesManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameStorePurchases*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameStorePurchases* UGameStoreSystem::GetGameStorePurchasesManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStoreSystem", "GetGameStorePurchasesManager");

	Params::GameStoreSystem_GetGameStorePurchasesManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.GetGameStoreSellingPointsManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameStoreSellingPoints*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameStoreSellingPoints* UGameStoreSystem::GetGameStoreSellingPointsManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStoreSystem", "GetGameStoreSellingPointsManager");

	Params::GameStoreSystem_GetGameStoreSellingPointsManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GameStoreSystem.OnGameStorePurchase__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// EGameStorePurchaseType                  PurchaseType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 InUserId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PurchaseRequestId                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameStoreProductId              RequestedProductId                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudRequestResult              Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameStorePurchaseResult         PurchaseResult                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PurchaseListRefreshed                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameStoreSystem::OnGameStorePurchase__DelegateSignature(EGameStorePurchaseType PurchaseType, const struct FUniqueNetIdRepl& InUserId, const int32 PurchaseRequestId, const struct FGameStoreProductId& RequestedProductId, const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult, const bool PurchaseListRefreshed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSystem", "OnGameStorePurchase__DelegateSignature");

	Params::GameStoreSystem_OnGameStorePurchase__DelegateSignature Parms{};

	Parms.PurchaseType = PurchaseType;
	Parms.InUserId = std::move(InUserId);
	Parms.PurchaseRequestId = PurchaseRequestId;
	Parms.RequestedProductId = std::move(RequestedProductId);
	Parms.Result = std::move(Result);
	Parms.PurchaseResult = std::move(PurchaseResult);
	Parms.PurchaseListRefreshed = PurchaseListRefreshed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GameStoreSystem.OnPurchaseSignaledToCloud
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCloudRequestResult              Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameStorePurchaseResult         PurchaseResult                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameStoreSystem::OnPurchaseSignaledToCloud(const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSystem", "OnPurchaseSignaledToCloud");

	Params::GameStoreSystem_OnPurchaseSignaledToCloud Parms{};

	Parms.Result = std::move(Result);
	Parms.PurchaseResult = std::move(PurchaseResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GameStoreSystem.RefreshStoreRequest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameStoreTransactionSource             PurchaseSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameStoreSystem::RefreshStoreRequest(const struct FUniqueNetIdRepl& InUserId, EGameStoreTransactionSource PurchaseSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSystem", "RefreshStoreRequest");

	Params::GameStoreSystem_RefreshStoreRequest Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.PurchaseSource = PurchaseSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GameStoreSystem.StartPurchaseRequest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameStoreProductInfo            Product                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGameStoreTransactionSource             PurchaseSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MicrotransactionDescription                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameStoreSystem::StartPurchaseRequest(const struct FUniqueNetIdRepl& InUserId, const struct FGameStoreProductInfo& Product, EGameStoreTransactionSource PurchaseSource, const class FString& MicrotransactionDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStoreSystem", "StartPurchaseRequest");

	Params::GameStoreSystem_StartPurchaseRequest Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.Product = std::move(Product);
	Parms.PurchaseSource = PurchaseSource;
	Parms.MicrotransactionDescription = std::move(MicrotransactionDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TemporaryToolComponent.OnRep_PostChangeTool
// (Final, Native, Protected)
// Parameters:
// class ATool*                            LastTool                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTemporaryToolComponent::OnRep_PostChangeTool(class ATool* LastTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TemporaryToolComponent", "OnRep_PostChangeTool");

	Params::TemporaryToolComponent_OnRep_PostChangeTool Parms{};

	Parms.LastTool = LastTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TemporaryToolComponent.RequestToolEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATool*                            ToolToEquip                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTemporaryToolComponent::RequestToolEquip(const class ATool* ToolToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TemporaryToolComponent", "RequestToolEquip");

	Params::TemporaryToolComponent_RequestToolEquip Parms{};

	Parms.ToolToEquip = ToolToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TemporaryToolComponent.RequestToolUnequip
// (Final, Native, Public, BlueprintCallable)

void UTemporaryToolComponent::RequestToolUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TemporaryToolComponent", "RequestToolUnequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TemporaryToolComponent.ServerAskForEquipTool
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ATool*                            ToolToEquip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTemporaryToolComponent::ServerAskForEquipTool(class ATool* ToolToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TemporaryToolComponent", "ServerAskForEquipTool");

	Params::TemporaryToolComponent_ServerAskForEquipTool Parms{};

	Parms.ToolToEquip = ToolToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TemporaryToolComponent.GetCurrentTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATool*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATool* UTemporaryToolComponent::GetCurrentTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TemporaryToolComponent", "GetCurrentTool");

	Params::TemporaryToolComponent_GetCurrentTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GestureSegment.SetGestureSlotClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACustomizationSlotGesture>InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGestureSegment::SetGestureSlotClass(TSubclassOf<class ACustomizationSlotGesture> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GestureSegment", "SetGestureSlotClass");

	Params::GestureSegment_SetGestureSlotClass Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GestureSegment.GetAnimationMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UGestureSegment::GetAnimationMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GestureSegment", "GetAnimationMontage");

	Params::GestureSegment_GetAnimationMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.NewEvent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ESpectateEvent                          Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           SubjectMind                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Fallback                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpectatorManager::NewEvent(ESpectateEvent Event, class AHumanPlayerController* SubjectMind, class AActor* Parameter, const struct FTransform& Fallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "NewEvent");

	Params::SpectatorManager_NewEvent Parms{};

	Parms.Event = Event;
	Parms.SubjectMind = SubjectMind;
	Parms.Parameter = Parameter;
	Parms.Fallback = std::move(Fallback);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.OnPlayerDied
// (Final, Native, Public)
// Parameters:
// class AHumanCharacter*                  DeceasedBody                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  KillerBody                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::OnPlayerDied(class AHumanCharacter* DeceasedBody, class AHumanCharacter* KillerBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "OnPlayerDied");

	Params::SpectatorManager_OnPlayerDied Parms{};

	Parms.DeceasedBody = DeceasedBody;
	Parms.KillerBody = KillerBody;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.OnPlayerLeft
// (Final, Native, Public)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::OnPlayerLeft(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "OnPlayerLeft");

	Params::SpectatorManager_OnPlayerLeft Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.OnPlayerRespawned
// (Final, Native, Public)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::OnPlayerRespawned(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "OnPlayerRespawned");

	Params::SpectatorManager_OnPlayerRespawned Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.OnUnableToSpectate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           SubjectMind                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::OnUnableToSpectate(class AHumanPlayerController* SubjectMind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "OnUnableToSpectate");

	Params::SpectatorManager_OnUnableToSpectate Parms{};

	Parms.SubjectMind = SubjectMind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.ProcessSpectatorEvent
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// ESpectateEvent                          Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Fallback                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ASpectatorManager::ProcessSpectatorEvent(ESpectateEvent Event, class AActor* Parameter, const struct FTransform& Fallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "ProcessSpectatorEvent");

	Params::SpectatorManager_ProcessSpectatorEvent Parms{};

	Parms.Event = Event;
	Parms.Parameter = Parameter;
	Parms.Fallback = std::move(Fallback);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.RegisterPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  PlayerMind                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::RegisterPlayer(class AHumanCharacter* PlayerMind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "RegisterPlayer");

	Params::SpectatorManager_RegisterPlayer Parms{};

	Parms.PlayerMind = PlayerMind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.RegisterPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::RegisterPlayerController(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "RegisterPlayerController");

	Params::SpectatorManager_RegisterPlayerController Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.ReplaceTargets
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  OldHumanCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OldTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FSpectatorState                  NewTarget                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASpectatorManager::ReplaceTargets(class AHumanCharacter* OldHumanCharacter, class AActor* OldActor, const struct FTransform& OldTransform, const struct FSpectatorState& NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "ReplaceTargets");

	Params::SpectatorManager_ReplaceTargets Parms{};

	Parms.OldHumanCharacter = OldHumanCharacter;
	Parms.OldActor = OldActor;
	Parms.OldTransform = std::move(OldTransform);
	Parms.NewTarget = std::move(NewTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.ReplaceTargetsWithRecommendation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::ReplaceTargetsWithRecommendation(class AActor* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "ReplaceTargetsWithRecommendation");

	Params::SpectatorManager_ReplaceTargetsWithRecommendation Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.StopSpectating
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpectatorManager::StopSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "StopSpectating");

	Params::SpectatorManager_StopSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.SuggestSpectatorTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpectatorManager::SuggestSpectatorTarget(class AHumanCharacter* Character, class AActor* Actor, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "SuggestSpectatorTarget");

	Params::SpectatorManager_SuggestSpectatorTarget Parms{};

	Parms.Character = Character;
	Parms.Actor = Actor;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.UnregisterPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::UnregisterPlayerController(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "UnregisterPlayerController");

	Params::SpectatorManager_UnregisterPlayerController Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorManager.CanBodySpectateTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFlameSpectatorPawn*              SelfBody                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpectatorManager::CanBodySpectateTarget(class AFlameSpectatorPawn* SelfBody, class AActor* Target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "CanBodySpectateTarget");

	Params::SpectatorManager_CanBodySpectateTarget Parms{};

	Parms.SelfBody = SelfBody;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.CanMindSpectateTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AHumanPlayerController*           SelfMind                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpectatorManager::CanMindSpectateTarget(const class AHumanPlayerController* SelfMind, const class AActor* Target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "CanMindSpectateTarget");

	Params::SpectatorManager_CanMindSpectateTarget Parms{};

	Parms.SelfMind = SelfMind;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SpectatorManager.GetSpectatorCandidatesFromRules
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpectatorRules                  Rules                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpectatorManager::GetSpectatorCandidatesFromRules(class AHumanPlayerController* Controller, const struct FSpectatorRules& Rules, TArray<class AActor*>* OutActors, class AActor* Param) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorManager", "GetSpectatorCandidatesFromRules");

	Params::SpectatorManager_GetSpectatorCandidatesFromRules Parms{};

	Parms.Controller = Controller;
	Parms.Rules = std::move(Rules);
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Flame.TutorialAIManager.CleanupAndRespawnCurrentAIs
// (Final, Native, Public, BlueprintCallable)

void ATutorialAIManager::CleanupAndRespawnCurrentAIs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "CleanupAndRespawnCurrentAIs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.InitializeAIOnBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AHumanAICharacter*                AI                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTutorialAIInitializationData    InitializationDataForBP                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATutorialAIManager::InitializeAIOnBP(class AHumanAICharacter* AI, const struct FTutorialAIInitializationData& InitializationDataForBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "InitializeAIOnBP");

	Params::TutorialAIManager_InitializeAIOnBP Parms{};

	Parms.AI = AI;
	Parms.InitializationDataForBP = std::move(InitializationDataForBP);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.TutorialAIManager.OnActionSequenceOverlapped
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATutorialAIManager::OnActionSequenceOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "OnActionSequenceOverlapped");

	Params::TutorialAIManager_OnActionSequenceOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.OnAIDied
// (Final, Native, Private)
// Parameters:
// class AHumanCharacter*                  DiedCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  KillerCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialAIManager::OnAIDied(class AHumanCharacter* DiedCharacter, class AHumanCharacter* KillerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "OnAIDied");

	Params::TutorialAIManager_OnAIDied Parms{};

	Parms.DiedCharacter = DiedCharacter;
	Parms.KillerCharacter = KillerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.OnIdleShootingOverlapped
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATutorialAIManager::OnIdleShootingOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "OnIdleShootingOverlapped");

	Params::TutorialAIManager_OnIdleShootingOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.OnPursuitSceneFinishOverlapped
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATutorialAIManager::OnPursuitSceneFinishOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "OnPursuitSceneFinishOverlapped");

	Params::TutorialAIManager_OnPursuitSceneFinishOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.OnPursuitSceneOverlapped
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATutorialAIManager::OnPursuitSceneOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "OnPursuitSceneOverlapped");

	Params::TutorialAIManager_OnPursuitSceneOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.StartActionSequenceOverride
// (Final, Native, Public, BlueprintCallable)

void ATutorialAIManager::StartActionSequenceOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "StartActionSequenceOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TutorialAIManager.GetCurrentTutorialAIManagerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETutorialAIState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETutorialAIState ATutorialAIManager::GetCurrentTutorialAIManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialAIManager", "GetCurrentTutorialAIManagerState");

	Params::TutorialAIManager_GetCurrentTutorialAIManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.CreateSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SessionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::CreateSession(const class FString& SessionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "CreateSession");

	Params::GroupSystem_CreateSession Parms{};

	Parms.SessionName = std::move(SessionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupSystem.GetMemberList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FUniqueNetIdRepl, struct FClientStateSync>Members                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroupSystem::GetMemberList(TMap<struct FUniqueNetIdRepl, struct FClientStateSync>* Members)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetMemberList");

	Params::GroupSystem_GetMemberList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Members != nullptr)
		*Members = std::move(Parms.Members);

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.Invite
// (Final, Native, Public, BlueprintCallable)

void UGroupSystem::Invite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "Invite");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupSystem.Leave
// (Final, Native, Public, BlueprintCallable)

void UGroupSystem::Leave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "Leave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupSystem.OnPlayerFailedJoinGroup
// (Final, Native, Public)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::OnPlayerFailedJoinGroup(const struct FUniqueNetIdRepl& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "OnPlayerFailedJoinGroup");

	Params::GroupSystem_OnPlayerFailedJoinGroup Parms{};

	Parms.Userid = std::move(Userid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupSystem.OnPlayerJoinedGroup
// (Final, Native, Public)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::OnPlayerJoinedGroup(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "OnPlayerJoinedGroup");

	Params::GroupSystem_OnPlayerJoinedGroup Parms{};

	Parms.Userid = std::move(Userid);
	Parms.GroupId = std::move(GroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.GroupSystem.OnPlayerLeftGroup
// (Final, Native, Public)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::OnPlayerLeftGroup(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "OnPlayerLeftGroup");

	Params::GroupSystem_OnPlayerLeftGroup Parms{};

	Parms.Userid = std::move(Userid);
	Parms.GroupId = std::move(GroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.GroupSystem.PlayerCancelMatchmakingDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerCancelMatchmakingDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerCancelMatchmakingDelegate__DelegateSignature");

	Params::GroupSystem_PlayerCancelMatchmakingDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.GroupSystem.PlayerFailedJoinGroupDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerFailedJoinGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerFailedJoinGroupDelegate__DelegateSignature");

	Params::GroupSystem_PlayerFailedJoinGroupDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.GroupSystem.PlayerJoinedGroupDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerJoinedGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerJoinedGroupDelegate__DelegateSignature");

	Params::GroupSystem_PlayerJoinedGroupDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);
	Parms.GroupId = std::move(GroupId);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.GroupSystem.PlayerLeavedGroupDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerLeavedGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerLeavedGroupDelegate__DelegateSignature");

	Params::GroupSystem_PlayerLeavedGroupDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);
	Parms.GroupId = std::move(GroupId);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.GroupSystem.PlayerStartMatchmakingDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerStartMatchmakingDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerStartMatchmakingDelegate__DelegateSignature");

	Params::GroupSystem_PlayerStartMatchmakingDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.GroupSystem.PlayerStateChangedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClientGroupState                       OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClientGroupState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroupSystem::PlayerStateChangedDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, EClientGroupState OldState, EClientGroupState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "PlayerStateChangedDelegate__DelegateSignature");

	Params::GroupSystem_PlayerStateChangedDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);
	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GroupSystem.QueryBlockedPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroupSystem::QueryBlockedPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "QueryBlockedPlayers");

	Params::GroupSystem_QueryBlockedPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GroupSystem.QueryBlockedPlayersDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUpdateFriendsListResult         Result                                                 (Parm, NativeAccessSpecifierPublic)

void UGroupSystem::QueryBlockedPlayersDelegate__DelegateSignature(const struct FUpdateFriendsListResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "QueryBlockedPlayersDelegate__DelegateSignature");

	Params::GroupSystem_QueryBlockedPlayersDelegate__DelegateSignature Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GroupSystem.UpdateFriendsList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroupSystem::UpdateFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "UpdateFriendsList");

	Params::GroupSystem_UpdateFriendsList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.GroupSystem.UpdateFriendsListDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FUpdateFriendsListResult         Result                                                 (Parm, NativeAccessSpecifierPublic)

void UGroupSystem::UpdateFriendsListDelegate__DelegateSignature(const struct FUpdateFriendsListResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "UpdateFriendsListDelegate__DelegateSignature");

	Params::GroupSystem_UpdateFriendsListDelegate__DelegateSignature Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.GroupSystem.GetBlockedPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<struct FUniqueNetIdRepl, class UFriendInfo*>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FUniqueNetIdRepl, class UFriendInfo*> UGroupSystem::GetBlockedPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetBlockedPlayers");

	Params::GroupSystem_GetBlockedPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.GetFriendsList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<struct FUniqueNetIdRepl, class UFriendInfo*>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FUniqueNetIdRepl, class UFriendInfo*> UGroupSystem::GetFriendsList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetFriendsList");

	Params::GroupSystem_GetFriendsList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.GetGroupSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGroupSystem::GetGroupSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetGroupSize");

	Params::GroupSystem_GetGroupSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.GetGroupUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGroupSystem::GetGroupUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetGroupUniqueId");

	Params::GroupSystem_GetGroupUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.GroupSystem.GetLocalUserUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl UGroupSystem::GetLocalUserUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroupSystem", "GetLocalUserUniqueId");

	Params::GroupSystem_GetLocalUserUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetBaseAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformStoreOfferInfo::GetBaseAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetBaseAmount");

	Params::PlatformStoreOfferInfo_GetBaseAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetBonusAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformStoreOfferInfo::GetBonusAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetBonusAmount");

	Params::PlatformStoreOfferInfo_GetBonusAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetCurrencyCode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformStoreOfferInfo::GetCurrencyCode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetCurrencyCode");

	Params::PlatformStoreOfferInfo_GetCurrencyCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetDescription");

	Params::PlatformStoreOfferInfo_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetDisplayPrice
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetDisplayPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetDisplayPrice");

	Params::PlatformStoreOfferInfo_GetDisplayPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetGameStoreProductId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameStoreProductId        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameStoreProductId UPlatformStoreOfferInfo::GetGameStoreProductId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetGameStoreProductId");

	Params::PlatformStoreOfferInfo_GetGameStoreProductId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetLongDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetLongDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetLongDescription");

	Params::PlatformStoreOfferInfo_GetLongDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetNumericPrice
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformStoreOfferInfo::GetNumericPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetNumericPrice");

	Params::PlatformStoreOfferInfo_GetNumericPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetPriceText
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetPriceText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetPriceText");

	Params::PlatformStoreOfferInfo_GetPriceText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetProductId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformStoreOfferInfo::GetProductId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetProductId");

	Params::PlatformStoreOfferInfo_GetProductId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetRegularPrice
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformStoreOfferInfo::GetRegularPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetRegularPrice");

	Params::PlatformStoreOfferInfo_GetRegularPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetRegularPriceText
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetRegularPriceText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetRegularPriceText");

	Params::PlatformStoreOfferInfo_GetRegularPriceText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UPlatformStoreOfferInfo::GetTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetTags");

	Params::PlatformStoreOfferInfo_GetTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetTaxMessage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetTaxMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetTaxMessage");

	Params::PlatformStoreOfferInfo_GetTaxMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.GetTitle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlatformStoreOfferInfo::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "GetTitle");

	Params::PlatformStoreOfferInfo_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOfferInfo.IsPurchaseable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreOfferInfo::IsPurchaseable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOfferInfo", "IsPurchaseable");

	Params::PlatformStoreOfferInfo_IsPurchaseable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnimationMirrorData.SetHumanMappedMirrorBones
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FHumanMirrorMap>          MirrorData                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class USkeleton*                        Skeleton                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMirrorData::SetHumanMappedMirrorBones(const TArray<struct FHumanMirrorMap>& MirrorData, const class USkeleton* Skeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "SetHumanMappedMirrorBones");

	Params::AnimationMirrorData_SetHumanMappedMirrorBones Parms{};

	Parms.MirrorData = std::move(MirrorData);
	Parms.Skeleton = Skeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AnimationMirrorData.SetMirrorMappedBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             bone_name                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Mirror_bone_name                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMirrorDir                              Mirror_axis                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMirrorDir                              Right_axis                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMirrorData::SetMirrorMappedBone(const class FName bone_name, const class FName Mirror_bone_name, const EMirrorDir Mirror_axis, const EMirrorDir Right_axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "SetMirrorMappedBone");

	Params::AnimationMirrorData_SetMirrorMappedBone Parms{};

	Parms.bone_name = bone_name;
	Parms.Mirror_bone_name = Mirror_bone_name;
	Parms.Mirror_axis = Mirror_axis;
	Parms.Right_axis = Right_axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AnimationMirrorData.SetMirrorMappedData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     PMirrorData                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<EMirrorDir>                      PMirrorAxisData                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<EMirrorDir>                      PRightAxisData                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationMirrorData::SetMirrorMappedData(const TArray<class FName>& PMirrorData, const TArray<EMirrorDir>& PMirrorAxisData, const TArray<EMirrorDir>& PRightAxisData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "SetMirrorMappedData");

	Params::AnimationMirrorData_SetMirrorMappedData Parms{};

	Parms.PMirrorData = std::move(PMirrorData);
	Parms.PMirrorAxisData = std::move(PMirrorAxisData);
	Parms.PRightAxisData = std::move(PRightAxisData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AnimationMirrorData.SetPelvisBoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             bone_name                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMirrorData::SetPelvisBoneName(const class FName bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "SetPelvisBoneName");

	Params::AnimationMirrorData_SetPelvisBoneName Parms{};

	Parms.bone_name = bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AnimationMirrorData.GetBoneMirrorAxisDataStructure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<EMirrorDir>                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EMirrorDir> UAnimationMirrorData::GetBoneMirrorAxisDataStructure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "GetBoneMirrorAxisDataStructure");

	Params::AnimationMirrorData_GetBoneMirrorAxisDataStructure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnimationMirrorData.GetBoneMirrorDataStructure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UAnimationMirrorData::GetBoneMirrorDataStructure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "GetBoneMirrorDataStructure");

	Params::AnimationMirrorData_GetBoneMirrorDataStructure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnimationMirrorData.GetBoneRightAxisDataStructure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<EMirrorDir>                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EMirrorDir> UAnimationMirrorData::GetBoneRightAxisDataStructure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "GetBoneRightAxisDataStructure");

	Params::AnimationMirrorData_GetBoneRightAxisDataStructure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnimationMirrorData.GetMirrorMappedBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             bone_name                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimationMirrorData::GetMirrorMappedBone(const class FName bone_name) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "GetMirrorMappedBone");

	Params::AnimationMirrorData_GetMirrorMappedBone Parms{};

	Parms.bone_name = bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.AnimationMirrorData.GetPelvisBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimationMirrorData::GetPelvisBoneName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMirrorData", "GetPelvisBoneName");

	Params::AnimationMirrorData_GetPelvisBoneName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.ClearVoiceModifierOverride
// (Final, Native, Public, BlueprintCallable)

void UInventoryCustomizationComponent::ClearVoiceModifierOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "ClearVoiceModifierOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryCustomizationComponent.InheritDefaults
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryCustomizationComponent* Source                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryCustomizationComponent::InheritDefaults(const class UInventoryCustomizationComponent* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "InheritDefaults");

	Params::InventoryCustomizationComponent_InheritDefaults Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryCustomizationComponent.InheritSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryCustomizationComponent* Source                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryCustomizationComponent::InheritSlots(const class UInventoryCustomizationComponent* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "InheritSlots");

	Params::InventoryCustomizationComponent_InheritSlots Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryCustomizationComponent.OnRep_PostChange
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FCustomizationPairWithSlot>OldCustomizations                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryCustomizationComponent::OnRep_PostChange(const TArray<struct FCustomizationPairWithSlot>& OldCustomizations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "OnRep_PostChange");

	Params::InventoryCustomizationComponent_OnRep_PostChange Parms{};

	Parms.OldCustomizations = std::move(OldCustomizations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryCustomizationComponent.SetVoiceModifierOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVoiceModifierType                      VoiceMod                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryCustomizationComponent::SetVoiceModifierOverride(EVoiceModifierType VoiceMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "SetVoiceModifierOverride");

	Params::InventoryCustomizationComponent_SetVoiceModifierOverride Parms{};

	Parms.VoiceMod = VoiceMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryCustomizationComponent.GetArchetype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationArchetype>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomizationArchetype> UInventoryCustomizationComponent::GetArchetype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetArchetype");

	Params::InventoryCustomizationComponent_GetArchetype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetArchetypeVariant
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationVariant>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomizationVariant> UInventoryCustomizationComponent::GetArchetypeVariant() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetArchetypeVariant");

	Params::InventoryCustomizationComponent_GetArchetypeVariant Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetBagSoundTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESoundTextureType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESoundTextureType UInventoryCustomizationComponent::GetBagSoundTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetBagSoundTexture");

	Params::InventoryCustomizationComponent_GetBagSoundTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetCustomizationInSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomizationSlot>   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationPair               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCustomizationPair UInventoryCustomizationComponent::GetCustomizationInSlot(TSubclassOf<class ACustomizationSlot> Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetCustomizationInSlot");

	Params::InventoryCustomizationComponent_GetCustomizationInSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AGender>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AGender> UInventoryCustomizationComponent::GetGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetGender");

	Params::InventoryCustomizationComponent_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetMajorSlotForCustomization
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ACustomization>       OneCustomization                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACustomizationSlot>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ACustomizationSlot> UInventoryCustomizationComponent::GetMajorSlotForCustomization(TSubclassOf<class ACustomization> OneCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetMajorSlotForCustomization");

	Params::InventoryCustomizationComponent_GetMajorSlotForCustomization Parms{};

	Parms.OneCustomization = OneCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetUniformSoundTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESoundTextureType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESoundTextureType UInventoryCustomizationComponent::GetUniformSoundTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetUniformSoundTexture");

	Params::InventoryCustomizationComponent_GetUniformSoundTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryCustomizationComponent.GetVoiceModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVoiceModifierType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVoiceModifierType UInventoryCustomizationComponent::GetVoiceModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryCustomizationComponent", "GetVoiceModifier");

	Params::InventoryCustomizationComponent_GetVoiceModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.AddTempHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::AddTempHealth(const float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "AddTempHealth");

	Params::HealthComponent_AddTempHealth Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.AddTrueHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::AddTrueHealth(const float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "AddTrueHealth");

	Params::HealthComponent_AddTrueHealth Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.ApplyDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::ApplyDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ApplyDamage");

	Params::HealthComponent_ApplyDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.ItemClass = ItemClass;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.ApplyHeal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HealAmount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthType                             HealingType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::ApplyHeal(const float HealAmount, const EHealthType HealingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ApplyHeal");

	Params::HealthComponent_ApplyHeal Parms{};

	Parms.HealAmount = HealAmount;
	Parms.HealingType = HealingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.ClientEndDownState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UHealthComponent::ClientEndDownState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ClientEndDownState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.ClientStartDownState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UHealthComponent::ClientStartDownState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ClientStartDownState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.ClientStartStunnedState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UHealthComponent::ClientStartStunnedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ClientStartStunnedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.KillPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                InstigatingItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::KillPlayer(EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "KillPlayer");

	Params::HealthComponent_KillPlayer Parms{};

	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.ResetComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::ResetComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ResetComponent");

	Params::HealthComponent_ResetComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.ResetDeathThreshold
// (Final, Native, Public, BlueprintCallable)

void UHealthComponent::ResetDeathThreshold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ResetDeathThreshold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.ResetMaxHealth
// (Final, Native, Public, BlueprintCallable)

void UHealthComponent::ResetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "ResetMaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.SetDeathThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxDamage                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetDeathThreshold(const float NewMaxDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetDeathThreshold");

	Params::HealthComponent_SetDeathThreshold Parms{};

	Parms.NewMaxDamage = NewMaxDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.SetInvincibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewInvincibility                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::SetInvincibility(const bool NewInvincibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetInvincibility");

	Params::HealthComponent_SetInvincibility Parms{};

	Parms.NewInvincibility = NewInvincibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.SetMaxHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxHealth                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetMaxHealth(const float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetMaxHealth");

	Params::HealthComponent_SetMaxHealth Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.SetTempHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTempHealth                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetTempHealth(const float NewTempHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetTempHealth");

	Params::HealthComponent_SetTempHealth Parms{};

	Parms.NewTempHealth = NewTempHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.SetTemporaryInvincibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetTemporaryInvincibility(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetTemporaryInvincibility");

	Params::HealthComponent_SetTemporaryInvincibility Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.SetTrueHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTrueHealth                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetTrueHealth(const float NewTrueHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetTrueHealth");

	Params::HealthComponent_SetTrueHealth Parms{};

	Parms.NewTrueHealth = NewTrueHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponent.GetDeathThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetDeathThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDeathThreshold");

	Params::HealthComponent_GetDeathThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetDownedHealthFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetDownedHealthFraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDownedHealthFraction");

	Params::HealthComponent_GetDownedHealthFraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetDownedHealthFractionInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetDownedHealthFractionInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDownedHealthFractionInitial");

	Params::HealthComponent_GetDownedHealthFractionInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetDownedHealthPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetDownedHealthPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDownedHealthPercentage");

	Params::HealthComponent_GetDownedHealthPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetDownedHealthPercentageInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetDownedHealthPercentageInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetDownedHealthPercentageInitial");

	Params::HealthComponent_GetDownedHealthPercentageInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealth");

	Params::HealthComponent_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealthFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthFraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthFraction");

	Params::HealthComponent_GetHealthFraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealthFractionInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthFractionInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthFractionInitial");

	Params::HealthComponent_GetHealthFractionInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealthPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthPercentage");

	Params::HealthComponent_GetHealthPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealthPercentageInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthPercentageInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthPercentageInitial");

	Params::HealthComponent_GetHealthPercentageInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHealthStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IncludeSpecialStates                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHealthStatus                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthStatus UHealthComponent::GetHealthStatus(bool IncludeSpecialStates) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthStatus");

	Params::HealthComponent_GetHealthStatus Parms{};

	Parms.IncludeSpecialStates = IncludeSpecialStates;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetHeavilyWoundedThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHeavilyWoundedThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHeavilyWoundedThreshold");

	Params::HealthComponent_GetHeavilyWoundedThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetInitialDeathThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetInitialDeathThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetInitialDeathThreshold");

	Params::HealthComponent_GetInitialDeathThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetInitialMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetInitialMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetInitialMaxHealth");

	Params::HealthComponent_GetInitialMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetInvincibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::GetInvincibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetInvincibility");

	Params::HealthComponent_GetInvincibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetIsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::GetIsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetIsDead");

	Params::HealthComponent_GetIsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetIsDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::GetIsDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetIsDown");

	Params::HealthComponent_GetIsDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetIsIncapacitated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::GetIsIncapacitated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetIsIncapacitated");

	Params::HealthComponent_GetIsIncapacitated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetIsStunned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::GetIsStunned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetIsStunned");

	Params::HealthComponent_GetIsStunned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetMaxHealth");

	Params::HealthComponent_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetTempHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetTempHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetTempHealth");

	Params::HealthComponent_GetTempHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetTempHealthFractionInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetTempHealthFractionInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetTempHealthFractionInitial");

	Params::HealthComponent_GetTempHealthFractionInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetTrueHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetTrueHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetTrueHealth");

	Params::HealthComponent_GetTrueHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponent.GetTrueHealthFractionInitial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetTrueHealthFractionInitial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetTrueHealthFractionInitial");

	Params::HealthComponent_GetTrueHealthFractionInitial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponentSimple.ApplyDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponentSimple::ApplyDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AHumanCharacter* InstigatingCharacter, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "ApplyDamage");

	Params::HealthComponentSimple_ApplyDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponentSimple.SetHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewHealth                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponentSimple::SetHealth(const float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "SetHealth");

	Params::HealthComponentSimple_SetHealth Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponentSimple.SetIsDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewIsDead                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponentSimple::SetIsDead(const bool NewIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "SetIsDead");

	Params::HealthComponentSimple_SetIsDead Parms{};

	Parms.NewIsDead = NewIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponentSimple.SetMaxHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxHealth                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponentSimple::SetMaxHealth(const float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "SetMaxHealth");

	Params::HealthComponentSimple_SetMaxHealth Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HealthComponentSimple.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponentSimple::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "GetHealth");

	Params::HealthComponentSimple_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponentSimple.GetIsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponentSimple::GetIsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "GetIsDead");

	Params::HealthComponentSimple_GetIsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HealthComponentSimple.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponentSimple::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponentSimple", "GetMaxHealth");

	Params::HealthComponentSimple_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LinkedWeapons.AddWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEventHandlerMode                       Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULinkedWeapons::AddWeapon(class AWeapon* Weapon, EEventHandlerMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkedWeapons", "AddWeapon");

	Params::LinkedWeapons_AddWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LinkedWeapons.FindWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponSlotType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponSlotType ULinkedWeapons::FindWeapon(const class AWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkedWeapons", "FindWeapon");

	Params::LinkedWeapons_FindWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LinkedWeapons.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* ULinkedWeapons::GetWeapon(EWeaponSlotType SlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkedWeapons", "GetWeapon");

	Params::LinkedWeapons_GetWeapon Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HintWidget.SetHintText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHintWidget::SetHintText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HintWidget", "SetHintText");

	Params::HintWidget_SetHintText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HintWidget.SetHintTexts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<EFlamePlatform, class FText>       InTexts                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHintWidget::SetHintTexts(const TMap<EFlamePlatform, class FText>& InTexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HintWidget", "SetHintTexts");

	Params::HintWidget_SetHintTexts Parms{};

	Parms.InTexts = std::move(InTexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HUDWidget.Show
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShowHUD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDWidget::Show(bool bShowHUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDWidget", "Show");

	Params::HUDWidget_Show Parms{};

	Parms.bShowHUD = bShowHUD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanAICharacter.IsCharacterInSight
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  EnemyCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckShootable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutInSight                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutShootable                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutShootableLocation                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanAICharacter::IsCharacterInSight(class AHumanCharacter* EnemyCharacter, bool CheckShootable, bool* OutInSight, bool* OutShootable, struct FVector* OutShootableLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAICharacter", "IsCharacterInSight");

	Params::HumanAICharacter_IsCharacterInSight Parms{};

	Parms.EnemyCharacter = EnemyCharacter;
	Parms.CheckShootable = CheckShootable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInSight != nullptr)
		*OutInSight = Parms.OutInSight;

	if (OutShootable != nullptr)
		*OutShootable = Parms.OutShootable;

	if (OutShootableLocation != nullptr)
		*OutShootableLocation = std::move(Parms.OutShootableLocation);
}


// Function Flame.AimingMetaData.SetHandLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimingMetaData::SetHandLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimingMetaData", "SetHandLocation");

	Params::AimingMetaData_SetHandLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AimingMetaData.SetSpineLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimingMetaData::SetSpineLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimingMetaData", "SetSpineLocation");

	Params::AimingMetaData_SetSpineLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PersistentItemArmor.GetDurabilityRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APersistentItemArmor::GetDurabilityRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentItemArmor", "GetDurabilityRatio");

	Params::PersistentItemArmor_GetDurabilityRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.BP_ItemInHandsChanged
// (Event, Public, BlueprintEvent)

void UHumanAnimInstace::BP_ItemInHandsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "BP_ItemInHandsChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.BP_StopMapGesture
// (Event, Public, BlueprintEvent)

void UHumanAnimInstace::BP_StopMapGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "BP_StopMapGesture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.CanUseLeftHandIK
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanAnimInstace::CanUseLeftHandIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "CanUseLeftHandIK");

	Params::HumanAnimInstace_CanUseLeftHandIK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.CanUseLeftHandIK_BP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanAnimInstace::CanUseLeftHandIK_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "CanUseLeftHandIK_BP");

	Params::HumanAnimInstace_CanUseLeftHandIK_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.ChangeEquipSection
// (Final, Native, Public)
// Parameters:
// int32                                   NextSectionID                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::ChangeEquipSection(const int32 NextSectionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ChangeEquipSection");

	Params::HumanAnimInstace_ChangeEquipSection Parms{};

	Parms.NextSectionID = NextSectionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.ChangeGender
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsaMale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::ChangeGender(bool bIsaMale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ChangeGender");

	Params::HumanAnimInstace_ChangeGender Parms{};

	Parms.bIsaMale = bIsaMale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanAnimInstace.ChangePlayRateOnSectionChange
// (Final, Native, Public)
// Parameters:
// float                                   PlayRate                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::ChangePlayRateOnSectionChange(const float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ChangePlayRateOnSectionChange");

	Params::HumanAnimInstace_ChangePlayRateOnSectionChange Parms{};

	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.CheatResetRootYaw
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::CheatResetRootYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "CheatResetRootYaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.DisableHandIK
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::DisableHandIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "DisableHandIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.EnableHandIK
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::EnableHandIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "EnableHandIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.EnableRegularFullBody
// (Final, Native, Public)
// Parameters:
// bool                                    bEnableIK                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::EnableRegularFullBody(const bool bEnableIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "EnableRegularFullBody");

	Params::HumanAnimInstace_EnableRegularFullBody Parms{};

	Parms.bEnableIK = bEnableIK;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.EndClimb
// (Final, Native, Public)

void UHumanAnimInstace::EndClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "EndClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.EndWeaponAction
// (Final, Native, Public)
// Parameters:
// bool                                    bEnableIK                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::EndWeaponAction(const bool bEnableIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "EndWeaponAction");

	Params::HumanAnimInstace_EndWeaponAction Parms{};

	Parms.bEnableIK = bEnableIK;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.ForceOrientToYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OrientationYaw                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::ForceOrientToYaw(const float OrientationYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ForceOrientToYaw");

	Params::HumanAnimInstace_ForceOrientToYaw Parms{};

	Parms.OrientationYaw = OrientationYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.IsaToolConsumable
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AItem*                            ItemInHands                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanAnimInstace::IsaToolConsumable(class AItem* ItemInHands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "IsaToolConsumable");

	Params::HumanAnimInstace_IsaToolConsumable Parms{};

	Parms.ItemInHands = ItemInHands;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.ItemChange
// (Final, Native, Public)
// Parameters:
// class UGameplayActionsComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            OldItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            NewItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::ItemChange(class UGameplayActionsComponent* Sender, class AItem* OldItem, class AItem* NewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ItemChange");

	Params::HumanAnimInstace_ItemChange Parms{};

	Parms.Sender = Sender;
	Parms.OldItem = OldItem;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.MatchStartTimerAnim
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::MatchStartTimerAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "MatchStartTimerAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.NotifyIsAiming_BP
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UHumanAnimInstace::NotifyIsAiming_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "NotifyIsAiming_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.NotifyStoppedAiming_BP
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UHumanAnimInstace::NotifyStoppedAiming_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "NotifyStoppedAiming_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.OrientToYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OrientationYaw                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::OrientToYaw(const float OrientationYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "OrientToYaw");

	Params::HumanAnimInstace_OrientToYaw Parms{};

	Parms.OrientationYaw = OrientationYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.PlayMapGesture
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::PlayMapGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "PlayMapGesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.PutAwayMap
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::PutAwayMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "PutAwayMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.ResetTheNotifyKeys
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::ResetTheNotifyKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "ResetTheNotifyKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetAimingDisabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetAimingDisabled(const bool Disabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetAimingDisabled");

	Params::HumanAnimInstace_SetAimingDisabled Parms{};

	Parms.Disabled = Disabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetAnimations
// (Final, Native, Private, BlueprintCallable)

void UHumanAnimInstace::SetAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetAnimCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHumanAnimCollection*             AnimColleciton                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetAnimCollection(const class UHumanAnimCollection* AnimColleciton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetAnimCollection");

	Params::HumanAnimInstace_SetAnimCollection Parms{};

	Parms.AnimColleciton = AnimColleciton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetDefaultAnimCollection
// (Event, Public, BlueprintEvent)

void UHumanAnimInstace::SetDefaultAnimCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetDefaultAnimCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.SetDoAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAdditive                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetDoAdditive(const bool bAdditive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetDoAdditive");

	Params::HumanAnimInstace_SetDoAdditive Parms{};

	Parms.bAdditive = bAdditive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetHandEffector
// (Final, Native, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Effector                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasEffector                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UpdateNeeded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetHandEffector(struct FTransform* Effector, const class FName SocketName, bool* HasEffector, bool* UpdateNeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetHandEffector");

	Params::HumanAnimInstace_SetHandEffector Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Effector != nullptr)
		*Effector = std::move(Parms.Effector);

	if (HasEffector != nullptr)
		*HasEffector = Parms.HasEffector;

	if (UpdateNeeded != nullptr)
		*UpdateNeeded = Parms.UpdateNeeded;
}


// Function Flame.HumanAnimInstace.SetIK
// (Final, Native, Private, BlueprintCallable)

void UHumanAnimInstace::SetIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetIKValues
// (Event, Protected, BlueprintEvent)

void UHumanAnimInstace::SetIKValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetIKValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.SetLeftHandIK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOn                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimationNotifyIKViewType              AnimationNotifyIKViewType                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetLeftHandIK(const bool bIsOn, const EAnimationNotifyIKViewType AnimationNotifyIKViewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetLeftHandIK");

	Params::HumanAnimInstace_SetLeftHandIK Parms{};

	Parms.bIsOn = bIsOn;
	Parms.AnimationNotifyIKViewType = AnimationNotifyIKViewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetRightHandIK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOn                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimationNotifyIKViewType              AnimationNotifyIKViewType                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetRightHandIK(const bool bIsOn, const EAnimationNotifyIKViewType AnimationNotifyIKViewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetRightHandIK");

	Params::HumanAnimInstace_SetRightHandIK Parms{};

	Parms.bIsOn = bIsOn;
	Parms.AnimationNotifyIKViewType = AnimationNotifyIKViewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetStaminaAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStaminaAdd                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetStaminaAdditive(const bool bStaminaAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetStaminaAdditive");

	Params::HumanAnimInstace_SetStaminaAdditive Parms{};

	Parms.bStaminaAdd = bStaminaAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.SetWeaponSK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOn                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::SetWeaponSK(const bool bIsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "SetWeaponSK");

	Params::HumanAnimInstace_SetWeaponSK Parms{};

	Parms.bIsOn = bIsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StartLinkedInteraction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCompoundActionCollection        InteractionCollection                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    DisableWeapon                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StopInteractionAlways                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StartLinkedInteraction(const struct FCompoundActionCollection& InteractionCollection, const bool DisableWeapon, const bool StopInteractionAlways)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StartLinkedInteraction");

	Params::HumanAnimInstace_StartLinkedInteraction Parms{};

	Parms.InteractionCollection = std::move(InteractionCollection);
	Parms.DisableWeapon = DisableWeapon;
	Parms.StopInteractionAlways = StopInteractionAlways;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StartOneShotInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     InteractionMontage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StartOneShotInteraction(class UAnimMontage* InteractionMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StartOneShotInteraction");

	Params::HumanAnimInstace_StartOneShotInteraction Parms{};

	Parms.InteractionMontage = InteractionMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StartSlideLadder
// (Final, Native, Public)

void UHumanAnimInstace::StartSlideLadder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StartSlideLadder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StartWeaponAction_BP
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StartWeaponAction_BP(const float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StartWeaponAction_BP");

	Params::HumanAnimInstace_StartWeaponAction_BP Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanAnimInstace.StopAnyAction_BP
// (Event, Protected, BlueprintEvent)

void UHumanAnimInstace::StopAnyAction_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopAnyAction_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanAnimInstace.StopClimbingLadder
// (Final, Native, Public)

void UHumanAnimInstace::StopClimbingLadder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopClimbingLadder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopGesture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StopGesture(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopGesture");

	Params::HumanAnimInstace_StopGesture Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopGestureHead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StopGestureHead(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopGestureHead");

	Params::HumanAnimInstace_StopGestureHead Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopInteraction
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::StopInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopMapGesture
// (Final, Native, Public, BlueprintCallable)

void UHumanAnimInstace::StopMapGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopMapGesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopSlideLadder
// (Final, Native, Public)

void UHumanAnimInstace::StopSlideLadder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopSlideLadder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopTransition
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     CurrentTransitionMontage                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StopTransition(class UAnimMontage* CurrentTransitionMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopTransition");

	Params::HumanAnimInstace_StopTransition Parms{};

	Parms.CurrentTransitionMontage = CurrentTransitionMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.StopUsingItem
// (Final, Native, Public)
// Parameters:
// class AHumanCharacter*                  SenderCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            OneConsumable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemActionFinishedState                Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::StopUsingItem(class AHumanCharacter* SenderCharacter, class AItem* OneConsumable, EItemActionFinishedState Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "StopUsingItem");

	Params::HumanAnimInstace_StopUsingItem Parms{};

	Parms.SenderCharacter = SenderCharacter;
	Parms.OneConsumable = OneConsumable;
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.UsingItem
// (Final, Native, Public)
// Parameters:
// class AHumanCharacter*                  SenderCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            UsingItem_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NeededTimeForInteraction                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanAnimInstace::UsingItem(class AHumanCharacter* SenderCharacter, class AItem* UsingItem_0, float NeededTimeForInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "UsingItem");

	Params::HumanAnimInstace_UsingItem Parms{};

	Parms.SenderCharacter = SenderCharacter;
	Parms.UsingItem_0 = UsingItem_0;
	Parms.NeededTimeForInteraction = NeededTimeForInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanAnimInstace.GetRootForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UHumanAnimInstace::GetRootForwardVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "GetRootForwardVector");

	Params::HumanAnimInstace_GetRootForwardVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.LocomotionIdle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanAnimInstace::LocomotionIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "LocomotionIdle");

	Params::HumanAnimInstace_LocomotionIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.MapPullOutLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHumanAnimInstace::MapPullOutLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "MapPullOutLength");

	Params::HumanAnimInstace_MapPullOutLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanAnimInstace.MapPutAwayLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHumanAnimInstace::MapPutAwayLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanAnimInstace", "MapPutAwayLength");

	Params::HumanAnimInstace_MapPutAwayLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCommon.Dbg_CycleCameraShoulder
// (Final, Native, Static, Public, BlueprintCallable)

void UHumanCommon::Dbg_CycleCameraShoulder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCommon", "Dbg_CycleCameraShoulder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCommon.Dbg_ToggleForceUnarmedAnim
// (Final, Native, Static, Public, BlueprintCallable)

void UHumanCommon::Dbg_ToggleForceUnarmedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCommon", "Dbg_ToggleForceUnarmedAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanCharacterFunctions.ApplyCharacterDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHumanCharacterInfo              SourceDescriptor                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::ApplyCharacterDescriptor(class AHumanCharacter* TargetCharacter, const struct FHumanCharacterInfo& SourceDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "ApplyCharacterDescriptor");

	Params::HumanCharacterFunctions_ApplyCharacterDescriptor Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.SourceDescriptor = std::move(SourceDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.ApplyLoadoutInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLoadoutInfo                     SourceDescriptor                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::ApplyLoadoutInfo(class AHumanCharacter* TargetCharacter, const struct FLoadoutInfo& SourceDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "ApplyLoadoutInfo");

	Params::HumanCharacterFunctions_ApplyLoadoutInfo Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.SourceDescriptor = std::move(SourceDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.ComputeLoadoutsDiff
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLoadoutInfo                     ReceivedLoadout                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLoadoutInfo                     CurrentLoadout                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLoadoutDiff                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLoadoutDiff UHumanCharacterFunctions::ComputeLoadoutsDiff(const struct FLoadoutInfo& ReceivedLoadout, const struct FLoadoutInfo& CurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "ComputeLoadoutsDiff");

	Params::HumanCharacterFunctions_ComputeLoadoutsDiff Parms{};

	Parms.ReceivedLoadout = std::move(ReceivedLoadout);
	Parms.CurrentLoadout = std::move(CurrentLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.CreateCharacterDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AHumanCharacter*                  FromCharacter                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHumanCharacterInfo              TargetDescriptor                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::CreateCharacterDescriptor(const class AHumanCharacter* FromCharacter, struct FHumanCharacterInfo* TargetDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "CreateCharacterDescriptor");

	Params::HumanCharacterFunctions_CreateCharacterDescriptor Parms{};

	Parms.FromCharacter = FromCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TargetDescriptor != nullptr)
		*TargetDescriptor = std::move(Parms.TargetDescriptor);

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.GetCurrentWeaponStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UHumanCharacterFunctions::GetCurrentWeaponStatus(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "GetCurrentWeaponStatus");

	Params::HumanCharacterFunctions_GetCurrentWeaponStatus Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.GetMachineStatusForUpperBody
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMachineStatus                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMachineStatus UHumanCharacterFunctions::GetMachineStatusForUpperBody(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "GetMachineStatusForUpperBody");

	Params::HumanCharacterFunctions_GetMachineStatusForUpperBody Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.LoadAllWeaponsFromBag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::LoadAllWeaponsFromBag(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "LoadAllWeaponsFromBag");

	Params::HumanCharacterFunctions_LoadAllWeaponsFromBag Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.RemoveMagazinesFromAllWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::RemoveMagazinesFromAllWeapons(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "RemoveMagazinesFromAllWeapons");

	Params::HumanCharacterFunctions_RemoveMagazinesFromAllWeapons Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.UnloadAllWeaponsToBag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanCharacterFunctions::UnloadAllWeaponsToBag(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "UnloadAllWeaponsToBag");

	Params::HumanCharacterFunctions_UnloadAllWeaponsToBag Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanCharacterFunctions.WhatIsMissingInLoadout
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLoadoutInfo                     RequestedLoadout                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLoadoutInfo                     CurrentLoadout                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLoadoutInfo                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLoadoutInfo UHumanCharacterFunctions::WhatIsMissingInLoadout(const struct FLoadoutInfo& RequestedLoadout, const struct FLoadoutInfo& CurrentLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanCharacterFunctions", "WhatIsMissingInLoadout");

	Params::HumanCharacterFunctions_WhatIsMissingInLoadout Parms{};

	Parms.RequestedLoadout = std::move(RequestedLoadout);
	Parms.CurrentLoadout = std::move(CurrentLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NotificationSystem.AddNotification
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UNotificationBase*                InNotification                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationSystem::AddNotification(class UNotificationBase* InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationSystem", "AddNotification");

	Params::NotificationSystem_AddNotification Parms{};

	Parms.InNotification = InNotification;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationSystem.OnPreLoadMap
// (Final, Native, Protected)
// Parameters:
// class FString                           InMapName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationSystem::OnPreLoadMap(const class FString& InMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationSystem", "OnPreLoadMap");

	Params::NotificationSystem_OnPreLoadMap Parms{};

	Parms.InMapName = std::move(InMapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.CheatResetProneSphere
// (Final, Native, Public, BlueprintCallable)

void UHumanMovementComponent::CheatResetProneSphere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "CheatResetProneSphere");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.ClientSetIsStaggered
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    Staggered                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanMovementComponent::ClientSetIsStaggered(bool Staggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "ClientSetIsStaggered");

	Params::HumanMovementComponent_ClientSetIsStaggered Parms{};

	Parms.Staggered = Staggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.DoCurveDisplacement
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UAnimSequence*                    Sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WorldYaw                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanMovementComponent::DoCurveDisplacement(const class UAnimSequence* Sequence, float WorldYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "DoCurveDisplacement");

	Params::HumanMovementComponent_DoCurveDisplacement Parms{};

	Parms.Sequence = Sequence;
	Parms.WorldYaw = WorldYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.DoStagger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StaggerSeverity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WorldYaw                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanMovementComponent::DoStagger(int32 StaggerSeverity, float WorldYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "DoStagger");

	Params::HumanMovementComponent_DoStagger Parms{};

	Parms.StaggerSeverity = StaggerSeverity;
	Parms.WorldYaw = WorldYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanMovementComponent.LagSwitch_RevertToServerLocation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          ServerLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ServerRotation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UHumanMovementComponent::LagSwitch_RevertToServerLocation(const struct FVector& ServerLocation, const struct FRotator& ServerRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "LagSwitch_RevertToServerLocation");

	Params::HumanMovementComponent_LagSwitch_RevertToServerLocation Parms{};

	Parms.ServerLocation = std::move(ServerLocation);
	Parms.ServerRotation = std::move(ServerRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.MulticastStartClimbOrVault
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          PreppedLoc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreppedVel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanMovementComponent::MulticastStartClimbOrVault(const struct FVector& PreppedLoc, const struct FVector& PreppedVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "MulticastStartClimbOrVault");

	Params::HumanMovementComponent_MulticastStartClimbOrVault Parms{};

	Parms.PreppedLoc = std::move(PreppedLoc);
	Parms.PreppedVel = std::move(PreppedVel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.OnRep_SimLadderClimb
// (Final, Native, Private)

void UHumanMovementComponent::OnRep_SimLadderClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "OnRep_SimLadderClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.OnRep_SimLadderMount_bExitMount
// (Final, Native, Private)

void UHumanMovementComponent::OnRep_SimLadderMount_bExitMount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "OnRep_SimLadderMount_bExitMount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.RequestStanceChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStance                                 NewStance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanMovementComponent::RequestStanceChange(EStance NewStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "RequestStanceChange");

	Params::HumanMovementComponent_RequestStanceChange Parms{};

	Parms.NewStance = NewStance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanMovementComponent.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStance                                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStance UHumanMovementComponent::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "GetStance");

	Params::HumanMovementComponent_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanMovementComponent.IsStaggered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanMovementComponent::IsStaggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanMovementComponent", "IsStaggered");

	Params::HumanMovementComponent_IsStaggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.ADS
// (Final, Native, Private)

void AHumanPlayerController::ADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ADS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Chamber
// (Final, Native, Private)

void AHumanPlayerController::Chamber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Chamber");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ChangeFireMode
// (Final, Native, Private)

void AHumanPlayerController::ChangeFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ChangeFireMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ChangeWeaponSkin
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AWeapon*                          TargetWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemSkin>            NewSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ChangeWeaponSkin(class AWeapon* TargetWeapon, TSubclassOf<class AItemSkin> NewSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ChangeWeaponSkin");

	Params::HumanPlayerController_ChangeWeaponSkin Parms{};

	Parms.TargetWeapon = TargetWeapon;
	Parms.NewSkin = NewSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CheatAddConsumable
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CheatAddConsumable(TSubclassOf<class AConsumableItem> ConsumableClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CheatAddConsumable");

	Params::HumanPlayerController_CheatAddConsumable Parms{};

	Parms.ConsumableClass = ConsumableClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CheatAddWeapon
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              OneWeaponClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CheatAddWeapon(TSubclassOf<class AWeapon> OneWeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CheatAddWeapon");

	Params::HumanPlayerController_CheatAddWeapon Parms{};

	Parms.OneWeaponClass = OneWeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CheatServer
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CheatServer(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CheatServer");

	Params::HumanPlayerController_CheatServer Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CheatServerRunCommand
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CheatServerRunCommand(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CheatServerRunCommand");

	Params::HumanPlayerController_CheatServerRunCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientCreateSessionForRandom
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           GroupId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientCreateSessionForRandom(const class FString& GroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientCreateSessionForRandom");

	Params::HumanPlayerController_ClientCreateSessionForRandom Parms{};

	Parms.GroupId = std::move(GroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientJoinSessionForRandom
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           GroupSessionId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientJoinSessionForRandom(const class FString& GroupSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientJoinSessionForRandom");

	Params::HumanPlayerController_ClientJoinSessionForRandom Parms{};

	Parms.GroupSessionId = std::move(GroupSessionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientSetSpawnRotation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientSetSpawnRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientSetSpawnRotation");

	Params::HumanPlayerController_ClientSetSpawnRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientSetSpectatorCamera
// (Net, NetReliable, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// struct FVector                          CameraLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CameraRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientSetSpectatorCamera");

	Params::HumanPlayerController_ClientSetSpectatorCamera Parms{};

	Parms.CameraLocation = std::move(CameraLocation);
	Parms.CameraRotation = std::move(CameraRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientSetUserIdToken
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           IdToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientSetUserIdToken(const class FString& IdToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientSetUserIdToken");

	Params::HumanPlayerController_ClientSetUserIdToken Parms{};

	Parms.IdToken = std::move(IdToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ClientUpdateWorldTime
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// float                                   ClientTimestamp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerTimestamp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ClientUpdateWorldTime(float ClientTimestamp, float ServerTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ClientUpdateWorldTime");

	Params::HumanPlayerController_ClientUpdateWorldTime Parms{};

	Parms.ClientTimestamp = ClientTimestamp;
	Parms.ServerTimestamp = ServerTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.HumanPlayerController.CloudUserIdSetDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CloudUserIdSetDelegate__DelegateSignature(const class FString& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CloudUserIdSetDelegate__DelegateSignature");

	Params::HumanPlayerController_CloudUserIdSetDelegate__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.CollectCraftedItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   QueueId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::CollectCraftedItems(int32 QueueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CollectCraftedItems");

	Params::HumanPlayerController_CollectCraftedItems Parms{};

	Parms.QueueId = QueueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.ConsumableMenu
// (Final, Native, Private)

void AHumanPlayerController::ConsumableMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ConsumableMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CreateGlint
// (Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*                  AttachComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::CreateGlint(class USceneComponent* AttachComponent, float Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CreateGlint");

	Params::HumanPlayerController_CreateGlint Parms{};

	Parms.AttachComponent = AttachComponent;
	Parms.Size = Size;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.Crouch
// (Final, Native, Private)

void AHumanPlayerController::Crouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Crouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.DebugTestShelterFunc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::DebugTestShelterFunc(TSubclassOf<class AShelterSlot> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "DebugTestShelterFunc");

	Params::HumanPlayerController_DebugTestShelterFunc Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.EquipLastConsumable
// (Final, Native, Private)

void AHumanPlayerController::EquipLastConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "EquipLastConsumable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.EquipLastWeapon
// (Final, Native, Private)

void AHumanPlayerController::EquipLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "EquipLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.EquipMap
// (Final, Native, Private)

void AHumanPlayerController::EquipMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "EquipMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Fire
// (Final, Native, Private)

void AHumanPlayerController::Fire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Fire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Gesture
// (Final, Native, Private)

void AHumanPlayerController::Gesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Gesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.GestureMenu
// (Final, Native, Private)

void AHumanPlayerController::GestureMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GestureMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.GetAssignedSkinsFromCloud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::GetAssignedSkinsFromCloud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetAssignedSkinsFromCloud");

	Params::HumanPlayerController_GetAssignedSkinsFromCloud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCurrentLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLoadoutInfo                     OutLoadout                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::GetCurrentLoadout(struct FLoadoutInfo* OutLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCurrentLoadout");

	Params::HumanPlayerController_GetCurrentLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLoadout != nullptr)
		*OutLoadout = std::move(Parms.OutLoadout);

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetLastLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLoadoutInfo                     OutLoadout                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::GetLastLoadout(struct FLoadoutInfo* OutLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetLastLoadout");

	Params::HumanPlayerController_GetLastLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLoadout != nullptr)
		*OutLoadout = std::move(Parms.OutLoadout);

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetPlayerGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPlayerGroupInfo*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerGroupInfo* AHumanPlayerController::GetPlayerGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetPlayerGroup");

	Params::HumanPlayerController_GetPlayerGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.HoldBreath
// (Final, Native, Private)

void AHumanPlayerController::HoldBreath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "HoldBreath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Holster
// (Final, Native, Private)

void AHumanPlayerController::Holster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Holster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Interact
// (Final, Native, Private)

void AHumanPlayerController::Interact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Interact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.InteractAction
// (Final, Native, Public)

void AHumanPlayerController::InteractAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "InteractAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Jump
// (Final, Native, Private)

void AHumanPlayerController::Jump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Jump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Menu
// (Final, Native, Private)

void AHumanPlayerController::Menu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Menu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.MenuAction
// (Final, Native, Public)

void AHumanPlayerController::MenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "MenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.MoveCharacterToCurrentPosition
// (Final, Native, Private)

void AHumanPlayerController::MoveCharacterToCurrentPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "MoveCharacterToCurrentPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.MoveCharacterToCurrentPositionAction
// (Final, Native, Public)

void AHumanPlayerController::MoveCharacterToCurrentPositionAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "MoveCharacterToCurrentPositionAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnEnterBuildingVolume
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnEnterBuildingVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnEnterBuildingVolume");

	Params::HumanPlayerController_OnEnterBuildingVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnEnterBuildingVolumeByActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnEnterBuildingVolumeByActor(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnEnterBuildingVolumeByActor");

	Params::HumanPlayerController_OnEnterBuildingVolumeByActor Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnGameStorePurchaseCompleted
// (Final, Native, Public, HasOutParams)
// Parameters:
// EGameStorePurchaseType                  PurchaseType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 Userid                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PurchaseRequestId                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameStoreProductId              RequestedProductId                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudRequestResult              Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameStorePurchaseResult         PurchaseResult                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PurchaseListRefreshed                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnGameStorePurchaseCompleted(EGameStorePurchaseType PurchaseType, const struct FUniqueNetIdRepl& Userid, const int32 PurchaseRequestId, const struct FGameStoreProductId& RequestedProductId, const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult, const bool PurchaseListRefreshed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnGameStorePurchaseCompleted");

	Params::HumanPlayerController_OnGameStorePurchaseCompleted Parms{};

	Parms.PurchaseType = PurchaseType;
	Parms.Userid = std::move(Userid);
	Parms.PurchaseRequestId = PurchaseRequestId;
	Parms.RequestedProductId = std::move(RequestedProductId);
	Parms.Result = std::move(Result);
	Parms.PurchaseResult = std::move(PurchaseResult);
	Parms.PurchaseListRefreshed = PurchaseListRefreshed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnInputActionProcessed
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           ActionName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnInputActionProcessed(const class FString& ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnInputActionProcessed");

	Params::HumanPlayerController_OnInputActionProcessed Parms{};

	Parms.ActionName = std::move(ActionName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.OnLeaveBuildingVolume
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnLeaveBuildingVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnLeaveBuildingVolume");

	Params::HumanPlayerController_OnLeaveBuildingVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnLeaveBuildingVolumeByActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnLeaveBuildingVolumeByActor(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnLeaveBuildingVolumeByActor");

	Params::HumanPlayerController_OnLeaveBuildingVolumeByActor Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnOpenShelterUIAction
// (Event, Public, BlueprintEvent)

void AHumanPlayerController::OnOpenShelterUIAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnOpenShelterUIAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanPlayerController.OnPlayerMenuAction
// (Event, Public, BlueprintEvent)

void AHumanPlayerController::OnPlayerMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnPlayerMenuAction");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.HumanPlayerController.OnPlayerStateFirstSync__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AHumanPlayerController*           HumanController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanPlayerState*                HumanPlayerState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnPlayerStateFirstSync__DelegateSignature(class AHumanPlayerController* HumanController, class AHumanPlayerState* HumanPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnPlayerStateFirstSync__DelegateSignature");

	Params::HumanPlayerController_OnPlayerStateFirstSync__DelegateSignature Parms{};

	Parms.HumanController = HumanController;
	Parms.HumanPlayerState = HumanPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.OnRep_ClothesLoaded
// (Final, Native, Private)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnRep_ClothesLoaded(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnRep_ClothesLoaded");

	Params::HumanPlayerController_OnRep_ClothesLoaded Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnRep_InventoryLoaded
// (Final, Native, Private)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnRep_InventoryLoaded(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnRep_InventoryLoaded");

	Params::HumanPlayerController_OnRep_InventoryLoaded Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OnSpawnBPActorFromConsole
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ObjectClass                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnSpawnBPActorFromConsole(const class FString& ObjectName, const class UClass* ObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnSpawnBPActorFromConsole");

	Params::HumanPlayerController_OnSpawnBPActorFromConsole Parms{};

	Parms.ObjectName = std::move(ObjectName);
	Parms.ObjectClass = ObjectClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.OnSpawnSMActorFromConsole
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMeshObject                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::OnSpawnSMActorFromConsole(const class FString& ObjectName, const class UStaticMesh* StaticMeshObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OnSpawnSMActorFromConsole");

	Params::HumanPlayerController_OnSpawnSMActorFromConsole Parms{};

	Parms.ObjectName = std::move(ObjectName);
	Parms.StaticMeshObject = StaticMeshObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.OpenDevMenu
// (Final, Native, Private)

void AHumanPlayerController::OpenDevMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OpenDevMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OpenGameMenu
// (Final, Native, Private)

void AHumanPlayerController::OpenGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OpenGameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OpenGameMenuAction
// (Final, Native, Private)

void AHumanPlayerController::OpenGameMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OpenGameMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OpenShelterUI
// (Final, Native, Private)

void AHumanPlayerController::OpenShelterUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OpenShelterUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.OpenShelterUIAction
// (Final, Native, Private)

void AHumanPlayerController::OpenShelterUIAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "OpenShelterUIAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.PhysxShowCollisions
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::PhysxShowCollisions(float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "PhysxShowCollisions");

	Params::HumanPlayerController_PhysxShowCollisions Parms{};

	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Ping
// (Final, Native, Private)

void AHumanPlayerController::Ping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Ping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.PlayerMenu
// (Final, Native, Private)

void AHumanPlayerController::PlayerMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "PlayerMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.PlayerMenuAction
// (Final, Native, Private)

void AHumanPlayerController::PlayerMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "PlayerMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ProcessInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InputActionName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ProcessInputAction(const class FString& InputActionName, class AItem* Parameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ProcessInputAction");

	Params::HumanPlayerController_ProcessInputAction Parms{};

	Parms.InputActionName = std::move(InputActionName);
	Parms.Parameter = Parameter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Prone
// (Final, Native, Private)

void AHumanPlayerController::Prone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Prone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.PushActionToStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ActionName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::PushActionToStack(const class FString& ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "PushActionToStack");

	Params::HumanPlayerController_PushActionToStack Parms{};

	Parms.ActionName = std::move(ActionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.QueryLoadoutAndClothes
// (Final, Native, Private, BlueprintCallable)

void AHumanPlayerController::QueryLoadoutAndClothes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "QueryLoadoutAndClothes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.QueryStash
// (Final, Native, Private, BlueprintCallable)

void AHumanPlayerController::QueryStash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "QueryStash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.QuickMelee
// (Final, Native, Private)

void AHumanPlayerController::QuickMelee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "QuickMelee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.HumanPlayerController.ReceivedShelterCloudEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudShelterEventList           Events                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerController::ReceivedShelterCloudEvent__DelegateSignature(const struct FCloudShelterEventList& Events)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ReceivedShelterCloudEvent__DelegateSignature");

	Params::HumanPlayerController_ReceivedShelterCloudEvent__DelegateSignature Parms{};

	Parms.Events = std::move(Events);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.ReleaseFireTrigger
// (Final, Native, Private)

void AHumanPlayerController::ReleaseFireTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ReleaseFireTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Reload
// (Final, Native, Private)

void AHumanPlayerController::Reload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Reload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.RemoveActionFromStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AHumanPlayerController::RemoveActionFromStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "RemoveActionFromStack");

	Params::HumanPlayerController_RemoveActionFromStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.ReportPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReportedUserId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::ReportPlayer(const class FString& ReportedUserId, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ReportPlayer");

	Params::HumanPlayerController_ReportPlayer Parms{};

	Parms.ReportedUserId = std::move(ReportedUserId);
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.HumanPlayerController.ReportPlayerDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerController::ReportPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ReportPlayerDelegate__DelegateSignature");

	Params::HumanPlayerController_ReportPlayerDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.ResetCamera
// (Final, Native, Private)

void AHumanPlayerController::ResetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ResetCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ResetCloudState
// (Final, Native, Public, BlueprintCallable)

void AHumanPlayerController::ResetCloudState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ResetCloudState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.HumanPlayerController.ResponseFromCloud__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerController::ResponseFromCloud__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ResponseFromCloud__DelegateSignature");

	Params::HumanPlayerController_ResponseFromCloud__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerController.ScripterSpecialHold
// (Event, Public, BlueprintEvent)

void AHumanPlayerController::ScripterSpecialHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ScripterSpecialHold");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanPlayerController.ScripterSpecialPress
// (Event, Public, BlueprintEvent)

void AHumanPlayerController::ScripterSpecialPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ScripterSpecialPress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanPlayerController.ScripterSpecialRelease
// (Event, Public, BlueprintEvent)

void AHumanPlayerController::ScripterSpecialRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ScripterSpecialRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.HumanPlayerController.SelectConsumableClass
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class AConsumableItem>      StoredConsumable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SelectConsumableClass(TSubclassOf<class AConsumableItem> StoredConsumable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SelectConsumableClass");

	Params::HumanPlayerController_SelectConsumableClass Parms{};

	Parms.StoredConsumable = StoredConsumable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SelectValidWeapon
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EWeaponSlotType                         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SelectValidWeapon(EWeaponSlotType Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SelectValidWeapon");

	Params::HumanPlayerController_SelectValidWeapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SelectWeapon
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EWeaponSlotType                         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SelectWeapon(EWeaponSlotType Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SelectWeapon");

	Params::HumanPlayerController_SelectWeapon Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SendToServerCollectedHeartbeatData
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FClientHeartBeatInfo             Data                                                   (Parm, NativeAccessSpecifierPublic)

void AHumanPlayerController::SendToServerCollectedHeartbeatData(const struct FClientHeartBeatInfo& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SendToServerCollectedHeartbeatData");

	Params::HumanPlayerController_SendToServerCollectedHeartbeatData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerAskQueryLoadoutAndClothes
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerAskQueryLoadoutAndClothes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerAskQueryLoadoutAndClothes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerAskQueryStash
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerAskQueryStash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerAskQueryStash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerChangeWeaponSkin
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class AWeapon*                          TargetWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemSkin>            NewSkin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerChangeWeaponSkin(class AWeapon* TargetWeapon, TSubclassOf<class AItemSkin> NewSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerChangeWeaponSkin");

	Params::HumanPlayerController_ServerChangeWeaponSkin Parms{};

	Parms.TargetWeapon = TargetWeapon;
	Parms.NewSkin = NewSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerCheatAddConsumable
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class AConsumableItem>      ConsumableClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerCheatAddConsumable(TSubclassOf<class AConsumableItem> ConsumableClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerCheatAddConsumable");

	Params::HumanPlayerController_ServerCheatAddConsumable Parms{};

	Parms.ConsumableClass = ConsumableClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerCheatAddWeapon
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class AWeapon>              OneWeaponClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerCheatAddWeapon(TSubclassOf<class AWeapon> OneWeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerCheatAddWeapon");

	Params::HumanPlayerController_ServerCheatAddWeapon Parms{};

	Parms.OneWeaponClass = OneWeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerClientIsReadyForGroupCheck
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AHumanPlayerController::ServerClientIsReadyForGroupCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerClientIsReadyForGroupCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerInteract
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerMoveCharacterToCurrentPosition
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerMoveCharacterToCurrentPosition(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerMoveCharacterToCurrentPosition");

	Params::HumanPlayerController_ServerMoveCharacterToCurrentPosition Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerNetStatsRecording
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AHumanPlayerController::ServerNetStatsRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerNetStatsRecording");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerRepossesPawn
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerRepossesPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerRepossesPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerRequestWorldTime
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// float                                   ClientTimestamp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerRequestWorldTime(float ClientTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerRequestWorldTime");

	Params::HumanPlayerController_ServerRequestWorldTime Parms{};

	Parms.ClientTimestamp = ClientTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerReturnSessionForRandom
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           GroupSessionId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerReturnSessionForRandom(const class FString& GroupSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerReturnSessionForRandom");

	Params::HumanPlayerController_ServerReturnSessionForRandom Parms{};

	Parms.GroupSessionId = std::move(GroupSessionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerSetAimAssistSettings
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FAimAssistSettings               Settings                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerSetAimAssistSettings(const struct FAimAssistSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerSetAimAssistSettings");

	Params::HumanPlayerController_ServerSetAimAssistSettings Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerSetMachineMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EMachineMode                            NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerSetMachineMode(EMachineMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerSetMachineMode");

	Params::HumanPlayerController_ServerSetMachineMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerSetMiscInputSettings
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FMiscInputSettings               Settings                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerSetMiscInputSettings(const struct FMiscInputSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerSetMiscInputSettings");

	Params::HumanPlayerController_ServerSetMiscInputSettings Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerSetTriggerDown
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ServerSetTriggerDown(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerSetTriggerDown");

	Params::HumanPlayerController_ServerSetTriggerDown Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerStopInteract
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerStopInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerStopInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ServerToggleSpectator
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AHumanPlayerController::ServerToggleSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ServerToggleSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetAimingDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetAimingDebug(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetAimingDebug");

	Params::HumanPlayerController_SetAimingDebug Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetControlSettingsFromSaveGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOptionsSaveGame*                 OptionsSaveGame                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetControlSettingsFromSaveGame(const class UOptionsSaveGame* OptionsSaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetControlSettingsFromSaveGame");

	Params::HumanPlayerController_SetControlSettingsFromSaveGame Parms{};

	Parms.OptionsSaveGame = OptionsSaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetCurrentViewForControlRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CurrentViewForControlRotation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetCurrentViewForControlRotation(bool CurrentViewForControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetCurrentViewForControlRotation");

	Params::HumanPlayerController_SetCurrentViewForControlRotation Parms{};

	Parms.CurrentViewForControlRotation = CurrentViewForControlRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetLoadoutPresetToCloud
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLoadoutInfo                     Loadout                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::SetLoadoutPresetToCloud(const struct FLoadoutInfo& Loadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetLoadoutPresetToCloud");

	Params::HumanPlayerController_SetLoadoutPresetToCloud Parms{};

	Parms.Loadout = std::move(Loadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SetSkinsForSever
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FCloudUserWeaponSkinsInfo        Skins                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetSkinsForSever(const struct FCloudUserWeaponSkinsInfo& Skins)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetSkinsForSever");

	Params::HumanPlayerController_SetSkinsForSever Parms{};

	Parms.Skins = std::move(Skins);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetSpawnRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetSpawnRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetSpawnRotation");

	Params::HumanPlayerController_SetSpawnRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SetUSeSameCloudData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    UseSame                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetUSeSameCloudData(bool UseSame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetUSeSameCloudData");

	Params::HumanPlayerController_SetUSeSameCloudData Parms{};

	Parms.UseSame = UseSame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ShowGlint
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UGlintComponent*                  AttachComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::ShowGlint(class UGlintComponent* AttachComponent, uint8 Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ShowGlint");

	Params::HumanPlayerController_ShowGlint Parms{};

	Parms.AttachComponent = AttachComponent;
	Parms.Intensity = Intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SpawnBPActorFromConsole
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SpawnBPActorFromConsole(const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpawnBPActorFromConsole");

	Params::HumanPlayerController_SpawnBPActorFromConsole Parms{};

	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SpawnSMActorFromConsole
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SpawnSMActorFromConsole(const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpawnSMActorFromConsole");

	Params::HumanPlayerController_SpawnSMActorFromConsole Parms{};

	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SpectateNextPlayerAction
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::SpectateNextPlayerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectateNextPlayerAction");

	Params::HumanPlayerController_SpectateNextPlayerAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SpectatePreviousPlayer
// (Final, Native, Private)

void AHumanPlayerController::SpectatePreviousPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectatePreviousPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SpectatePreviousPlayerAction
// (Final, Native, Public)

void AHumanPlayerController::SpectatePreviousPlayerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectatePreviousPlayerAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SpectateStartMovingUpAction
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::SpectateStartMovingUpAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectateStartMovingUpAction");

	Params::HumanPlayerController_SpectateStartMovingUpAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SpectateStopMovingUpAction
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::SpectateStopMovingUpAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectateStopMovingUpAction");

	Params::HumanPlayerController_SpectateStopMovingUpAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SpectateToggleAfterBurnerAction
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::SpectateToggleAfterBurnerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectateToggleAfterBurnerAction");

	Params::HumanPlayerController_SpectateToggleAfterBurnerAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SpectatorMoveUp
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SpectatorMoveUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SpectatorMoveUp");

	Params::HumanPlayerController_SpectatorMoveUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Sprint
// (Final, Native, Private)

void AHumanPlayerController::Sprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Sprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Stand
// (Final, Native, Private)

void AHumanPlayerController::Stand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Stand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopADS
// (Final, Native, Private)

void AHumanPlayerController::StopADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopADS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopChamber
// (Final, Native, Private)

void AHumanPlayerController::StopChamber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopChamber");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopFire
// (Final, Native, Private)

void AHumanPlayerController::StopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopGesture
// (Final, Native, Private)

void AHumanPlayerController::StopGesture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopGesture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopInteract
// (Final, Native, Private)

void AHumanPlayerController::StopInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopInteractAction
// (Final, Native, Public)

void AHumanPlayerController::StopInteractAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopInteractAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopJump
// (Final, Native, Private)

void AHumanPlayerController::StopJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopReload
// (Final, Native, Private)

void AHumanPlayerController::StopReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopSprint
// (Final, Native, Private)

void AHumanPlayerController::StopSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopSprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopThrowableAiming
// (Final, Native, Private)

void AHumanPlayerController::StopThrowableAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopThrowableAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.StopUse
// (Final, Native, Public)

void AHumanPlayerController::StopUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "StopUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SwapPerspective
// (Final, Native, Private)

void AHumanPlayerController::SwapPerspective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SwapPerspective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.SwapShoulder
// (Final, Native, Private)

void AHumanPlayerController::SwapShoulder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SwapShoulder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Switch
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AItem*                            StoredItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::Switch(class AItem* StoredItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Switch");

	Params::HumanPlayerController_Switch Parms{};

	Parms.StoredItem = StoredItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ThrowableAiming
// (Final, Native, Private)

void AHumanPlayerController::ThrowableAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ThrowableAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleCrouch
// (Final, Native, Private)

void AHumanPlayerController::ToggleCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleMachineMode
// (Final, Native, Public, BlueprintCallable)

void AHumanPlayerController::ToggleMachineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleMachineMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleNetStatsRecording
// (Final, Exec, Native, Public, BlueprintCallable)

void AHumanPlayerController::ToggleNetStatsRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleNetStatsRecording");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleProne
// (Final, Native, Private)

void AHumanPlayerController::ToggleProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleSpectate
// (Final, Native, Private)

void AHumanPlayerController::ToggleSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleSpectateAction
// (Final, Native, Public)

void AHumanPlayerController::ToggleSpectateAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleSpectateAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleSpectatorCollisions
// (Final, Native, Private)

void AHumanPlayerController::ToggleSpectatorCollisions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleSpectatorCollisions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToggleSpectatorCollisionsAction
// (Final, Native, Public)

void AHumanPlayerController::ToggleSpectatorCollisionsAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToggleSpectatorCollisionsAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ToolMenu
// (Final, Native, Private)

void AHumanPlayerController::ToolMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ToolMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.Use
// (Final, Native, Public)

void AHumanPlayerController::Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.WeaponMenu
// (Final, Native, Private)

void AHumanPlayerController::WeaponMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "WeaponMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.CanAcceptOperations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::CanAcceptOperations() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CanAcceptOperations");

	Params::HumanPlayerController_CanAcceptOperations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.CanBoostShelterImprovemement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AHumanPlayerController::CanBoostShelterImprovemement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "CanBoostShelterImprovemement");

	Params::HumanPlayerController_CanBoostShelterImprovemement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetAllOpenedWidgets
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UFlameWidget>         InWidgetClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFlameWidget*>             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UFlameWidget*> AHumanPlayerController::GetAllOpenedWidgets(TSubclassOf<class UFlameWidget> InWidgetClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetAllOpenedWidgets");

	Params::HumanPlayerController_GetAllOpenedWidgets Parms{};

	Parms.InWidgetClass = InWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetAnalyticsUserId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AHumanPlayerController::GetAnalyticsUserId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetAnalyticsUserId");

	Params::HumanPlayerController_GetAnalyticsUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCachedAimInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D AHumanPlayerController::GetCachedAimInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCachedAimInput");

	Params::HumanPlayerController_GetCachedAimInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCachedAimInputMultiplier
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AHumanPlayerController::GetCachedAimInputMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCachedAimInputMultiplier");

	Params::HumanPlayerController_GetCachedAimInputMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCachedMovementInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D AHumanPlayerController::GetCachedMovementInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCachedMovementInput");

	Params::HumanPlayerController_GetCachedMovementInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCloudUserId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AHumanPlayerController::GetCloudUserId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCloudUserId");

	Params::HumanPlayerController_GetCloudUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCraftingTimerManager
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACraftingTimerManager*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACraftingTimerManager* AHumanPlayerController::GetCraftingTimerManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCraftingTimerManager");

	Params::HumanPlayerController_GetCraftingTimerManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCurrentLookUpInputValue
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetCurrentLookUpInputValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCurrentLookUpInputValue");

	Params::HumanPlayerController_GetCurrentLookUpInputValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCurrentMoveForwardInputValue
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetCurrentMoveForwardInputValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCurrentMoveForwardInputValue");

	Params::HumanPlayerController_GetCurrentMoveForwardInputValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCurrentMoveRightInputValue
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetCurrentMoveRightInputValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCurrentMoveRightInputValue");

	Params::HumanPlayerController_GetCurrentMoveRightInputValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetCurrentTurnInputValue
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetCurrentTurnInputValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetCurrentTurnInputValue");

	Params::HumanPlayerController_GetCurrentTurnInputValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetGameScenario
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EGameScenario                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameScenario AHumanPlayerController::GetGameScenario() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetGameScenario");

	Params::HumanPlayerController_GetGameScenario Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetHubGateState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::GetHubGateState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetHubGateState");

	Params::HumanPlayerController_GetHubGateState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetHumanCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHumanPlayerCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHumanPlayerCharacter* AHumanPlayerController::GetHumanCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetHumanCharacter");

	Params::HumanPlayerController_GetHumanCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetMiscInputSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMiscInputSettings         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMiscInputSettings AHumanPlayerController::GetMiscInputSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetMiscInputSettings");

	Params::HumanPlayerController_GetMiscInputSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetNetworkLastReceive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetNetworkLastReceive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetNetworkLastReceive");

	Params::HumanPlayerController_GetNetworkLastReceive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetServerWorldTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetServerWorldTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetServerWorldTime");

	Params::HumanPlayerController_GetServerWorldTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetServerWorldTimeDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerController::GetServerWorldTimeDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetServerWorldTimeDelta");

	Params::HumanPlayerController_GetServerWorldTimeDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetShelterBuilder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UShelterCraftingList*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShelterCraftingList* AHumanPlayerController::GetShelterBuilder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetShelterBuilder");

	Params::HumanPlayerController_GetShelterBuilder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetShelterTimerManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AShelterTimerManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AShelterTimerManager* AHumanPlayerController::GetShelterTimerManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetShelterTimerManager");

	Params::HumanPlayerController_GetShelterTimerManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetStash
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AStash*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStash* AHumanPlayerController::GetStash() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetStash");

	Params::HumanPlayerController_GetStash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetTokenString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AHumanPlayerController::GetTokenString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetTokenString");

	Params::HumanPlayerController_GetTokenString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.GetWidgetUnderMouse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* AHumanPlayerController::GetWidgetUnderMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "GetWidgetUnderMouse");

	Params::HumanPlayerController_GetWidgetUnderMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsAnyMenuOpen
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsAnyMenuOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsAnyMenuOpen");

	Params::HumanPlayerController_IsAnyMenuOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsCloudInventoryAndStuffInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsCloudInventoryAndStuffInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsCloudInventoryAndStuffInitialized");

	Params::HumanPlayerController_IsCloudInventoryAndStuffInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsCloudUserIdSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsCloudUserIdSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsCloudUserIdSet");

	Params::HumanPlayerController_IsCloudUserIdSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsInsideBuilding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsInsideBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsInsideBuilding");

	Params::HumanPlayerController_IsInsideBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsInteractInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsInteractInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsInteractInProgress");

	Params::HumanPlayerController_IsInteractInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsMenuInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::IsMenuInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsMenuInProgress");

	Params::HumanPlayerController_IsMenuInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.IsUserCloudInfoUpToDate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AHumanPlayerController::IsUserCloudInfoUpToDate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "IsUserCloudInfoUpToDate");

	Params::HumanPlayerController_IsUserCloudInfoUpToDate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerController.SetHubGateState
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    GateState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerController::SetHubGateState(bool GateState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "SetHubGateState");

	Params::HumanPlayerController_SetHubGateState Parms{};

	Parms.GateState = GateState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerController.ShouldIgnoreInputAxis
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAxisName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerController::ShouldIgnoreInputAxis(class FName InAxisName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerController", "ShouldIgnoreInputAxis");

	Params::HumanPlayerController_ShouldIgnoreInputAxis Parms{};

	Parms.InAxisName = InAxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerControllerFunctionsFunctions.CanProcessInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           OneController                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHumanPlayerControllerFunctionsFunctions::CanProcessInputAction(const class AHumanPlayerController* OneController, class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HumanPlayerControllerFunctionsFunctions", "CanProcessInputAction");

	Params::HumanPlayerControllerFunctionsFunctions_CanProcessInputAction Parms{};

	Parms.OneController = OneController;
	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.ClearPostProcessingEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               PostProcessMaterial                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::ClearPostProcessingEffect(class UMaterialInterface* PostProcessMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "ClearPostProcessingEffect");

	Params::HumanPlayerCharacter_ClearPostProcessingEffect Parms{};

	Parms.PostProcessMaterial = PostProcessMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.ConsumableMenuAction
// (Final, Native, Public)

void AHumanPlayerCharacter::ConsumableMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "ConsumableMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.CreateOrGetPostProcessingEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               PostProcessMaterial                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AHumanPlayerCharacter::CreateOrGetPostProcessingEffect(class UMaterialInterface* PostProcessMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "CreateOrGetPostProcessingEffect");

	Params::HumanPlayerCharacter_CreateOrGetPostProcessingEffect Parms{};

	Parms.PostProcessMaterial = PostProcessMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.EquipLastConsumableAction
// (Final, Native, Public)

void AHumanPlayerCharacter::EquipLastConsumableAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "EquipLastConsumableAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.EquipMapAction
// (Final, Native, Public)

void AHumanPlayerCharacter::EquipMapAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "EquipMapAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.GestureAction
// (Final, Native, Public)

void AHumanPlayerCharacter::GestureAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GestureAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.GestureMenuAction
// (Final, Native, Public)

void AHumanPlayerCharacter::GestureMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GestureMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.HoldBreathAction
// (Final, Native, Public)

void AHumanPlayerCharacter::HoldBreathAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "HoldBreathAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.InitiateTinnitusEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   EffectStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::InitiateTinnitusEffect(float EffectStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "InitiateTinnitusEffect");

	Params::HumanPlayerCharacter_InitiateTinnitusEffect Parms{};

	Parms.EffectStrength = EffectStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerCharacter.MoveForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::MoveForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "MoveForward");

	Params::HumanPlayerCharacter_MoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.MoveRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::MoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "MoveRight");

	Params::HumanPlayerCharacter_MoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.OnPingPressed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AHumanPlayerCharacter::OnPingPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "OnPingPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.OpenDevMenuAction
// (Final, Native, Public)

void AHumanPlayerCharacter::OpenDevMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "OpenDevMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.OpenSelectionWheel
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESelectionWheelType                     WheelType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::OpenSelectionWheel(const ESelectionWheelType& WheelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "OpenSelectionWheel");

	Params::HumanPlayerCharacter_OpenSelectionWheel Parms{};

	Parms.WheelType = WheelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.PingAction
// (Final, Native, Public)

void AHumanPlayerCharacter::PingAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "PingAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.ResetCameraAction
// (Final, Native, Public)

void AHumanPlayerCharacter::ResetCameraAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "ResetCameraAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.SelectLastWheelItem
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESelectionWheelType                     WheelType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::SelectLastWheelItem(const ESelectionWheelType& WheelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "SelectLastWheelItem");

	Params::HumanPlayerCharacter_SelectLastWheelItem Parms{};

	Parms.WheelType = WheelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.ShowGrenadeIndicator
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGrenade*                         Grenade                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::ShowGrenadeIndicator(class AGrenade* Grenade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "ShowGrenadeIndicator");

	Params::HumanPlayerCharacter_ShowGrenadeIndicator Parms{};

	Parms.Grenade = Grenade;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerCharacter.SwapPerspectiveAction
// (Final, Native, Public)

void AHumanPlayerCharacter::SwapPerspectiveAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "SwapPerspectiveAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.SwapShoulderAction
// (Final, Native, Public)

void AHumanPlayerCharacter::SwapShoulderAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "SwapShoulderAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.TickConcussionEffect
// (Final, Native, Protected)

void AHumanPlayerCharacter::TickConcussionEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "TickConcussionEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.TickFlashbangEffect
// (Final, Native, Protected)

void AHumanPlayerCharacter::TickFlashbangEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "TickFlashbangEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.UpdateConcussionEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::UpdateConcussionEffect(float Strength, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "UpdateConcussionEffect");

	Params::HumanPlayerCharacter_UpdateConcussionEffect Parms{};

	Parms.Strength = Strength;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerCharacter.UpdateFlashbangEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerCharacter::UpdateFlashbangEffect(float Strength, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "UpdateFlashbangEffect");

	Params::HumanPlayerCharacter_UpdateFlashbangEffect Parms{};

	Parms.Strength = Strength;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.HumanPlayerCharacter.WeaponMenuAction
// (Final, Native, Public)

void AHumanPlayerCharacter::WeaponMenuAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "WeaponMenuAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerCharacter.GetLookUpValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerCharacter::GetLookUpValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetLookUpValue");

	Params::HumanPlayerCharacter_GetLookUpValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetMapTool
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMapTool*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMapTool* AHumanPlayerCharacter::GetMapTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetMapTool");

	Params::HumanPlayerCharacter_GetMapTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetMapToolClass
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AMapTool>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AMapTool> AHumanPlayerCharacter::GetMapToolClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetMapToolClass");

	Params::HumanPlayerCharacter_GetMapToolClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetMoveForwardValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerCharacter::GetMoveForwardValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetMoveForwardValue");

	Params::HumanPlayerCharacter_GetMoveForwardValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetMoveRightValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerCharacter::GetMoveRightValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetMoveRightValue");

	Params::HumanPlayerCharacter_GetMoveRightValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetSelectionWheelComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USelectionWheelComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USelectionWheelComponent* AHumanPlayerCharacter::GetSelectionWheelComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetSelectionWheelComponent");

	Params::HumanPlayerCharacter_GetSelectionWheelComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerCharacter.GetTurnValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHumanPlayerCharacter::GetTurnValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerCharacter", "GetTurnValue");

	Params::HumanPlayerCharacter_GetTurnValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.MulticastReceivedActionsOnClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FInputActionMachineState         Desc                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerState::MulticastReceivedActionsOnClients(const struct FInputActionMachineState& Desc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "MulticastReceivedActionsOnClients");

	Params::HumanPlayerState_MulticastReceivedActionsOnClients Parms{};

	Parms.Desc = std::move(Desc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.OnRep_IsReadyInLobby
// (Final, Native, Protected)

void AHumanPlayerState::OnRep_IsReadyInLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "OnRep_IsReadyInLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.OnRep_PlayerPlatform
// (Final, Native, Private)

void AHumanPlayerState::OnRep_PlayerPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "OnRep_PlayerPlatform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.OnRep_PostChangeLobbyLoadout
// (Final, Native, Public)

void AHumanPlayerState::OnRep_PostChangeLobbyLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "OnRep_PostChangeLobbyLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.OnRep_PostChangeStash
// (Final, Native, Public)
// Parameters:
// class AStash*                           OldStash                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanPlayerState::OnRep_PostChangeStash(class AStash* OldStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "OnRep_PostChangeStash");

	Params::HumanPlayerState_OnRep_PostChangeStash Parms{};

	Parms.OldStash = OldStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.ServerProcessAction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FInputActionMachineState         Desc                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AHumanPlayerState::ServerProcessAction(const struct FInputActionMachineState& Desc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "ServerProcessAction");

	Params::HumanPlayerState_ServerProcessAction Parms{};

	Parms.Desc = std::move(Desc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.HumanPlayerState.GetPlayerPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFlamePlatform                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFlamePlatform AHumanPlayerState::GetPlayerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "GetPlayerPlatform");

	Params::HumanPlayerState_GetPlayerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.GetPlayerUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl AHumanPlayerState::GetPlayerUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "GetPlayerUniqueId");

	Params::HumanPlayerState_GetPlayerUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.GetStash
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AStash*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStash* AHumanPlayerState::GetStash() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "GetStash");

	Params::HumanPlayerState_GetStash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.GetWardrobe
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UShelterCustomizationComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShelterCustomizationComponent* AHumanPlayerState::GetWardrobe() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "GetWardrobe");

	Params::HumanPlayerState_GetWardrobe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.HasBoosterCrate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerState::HasBoosterCrate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "HasBoosterCrate");

	Params::HumanPlayerState_HasBoosterCrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.HasBoosterInsurance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerState::HasBoosterInsurance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "HasBoosterInsurance");

	Params::HumanPlayerState_HasBoosterInsurance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.HumanPlayerState.HasBoosterLoot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHumanPlayerState::HasBoosterLoot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanPlayerState", "HasBoosterLoot");

	Params::HumanPlayerState_HasBoosterLoot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.AddConsumptionForCurrentItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EConsumptionSource                      Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Consumption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::AddConsumptionForCurrentItem(EConsumptionSource Source, float Consumption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "AddConsumptionForCurrentItem");

	Params::StaminaComponent_AddConsumptionForCurrentItem Parms{};

	Parms.Source = Source;
	Parms.Consumption = Consumption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.AddPermanentDamageToStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PercentageOfMaxStaminaToRemove                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::AddPermanentDamageToStamina(float PercentageOfMaxStaminaToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "AddPermanentDamageToStamina");

	Params::StaminaComponent_AddPermanentDamageToStamina Parms{};

	Parms.PercentageOfMaxStaminaToRemove = PercentageOfMaxStaminaToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.AddToConsumptionSources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConsumptionSource                      Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Consumption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::AddToConsumptionSources(const class FString& Item, EConsumptionSource Source, float Consumption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "AddToConsumptionSources");

	Params::StaminaComponent_AddToConsumptionSources Parms{};

	Parms.Item = std::move(Item);
	Parms.Source = Source;
	Parms.Consumption = Consumption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.AdrenalineBoostActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::AdrenalineBoostActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "AdrenalineBoostActive");

	Params::StaminaComponent_AdrenalineBoostActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.AdrenalineDeprivationActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::AdrenalineDeprivationActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "AdrenalineDeprivationActive");

	Params::StaminaComponent_AdrenalineDeprivationActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.ClearStaminaConsumptionMap
// (Final, Native, Public, BlueprintCallable)

void UStaminaComponent::ClearStaminaConsumptionMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ClearStaminaConsumptionMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ClientAddStaminaEffect
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::ClientAddStaminaEffect(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ClientAddStaminaEffect");

	Params::StaminaComponent_ClientAddStaminaEffect Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ClientRemoveStaminaEffectsOfIndex
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::ClientRemoveStaminaEffectsOfIndex(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ClientRemoveStaminaEffectsOfIndex");

	Params::StaminaComponent_ClientRemoveStaminaEffectsOfIndex Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ClientResetComponent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UStaminaComponent::ClientResetComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ClientResetComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ConsumePercentageOfStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConsumptionSource                      Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::ConsumePercentageOfStamina(float Percentage, EConsumptionSource Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ConsumePercentageOfStamina");

	Params::StaminaComponent_ConsumePercentageOfStamina Parms{};

	Parms.Percentage = Percentage;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ConsumeStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConsumptionSource                      Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::ConsumeStamina(float Amount, EConsumptionSource Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ConsumeStamina");

	Params::StaminaComponent_ConsumeStamina Parms{};

	Parms.Amount = Amount;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.GetConsumptionByItemAndSource
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConsumptionSource                      Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutConsumption                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::GetConsumptionByItemAndSource(const class FString& Item, EConsumptionSource Source, float* OutConsumption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetConsumptionByItemAndSource");

	Params::StaminaComponent_GetConsumptionByItemAndSource Parms{};

	Parms.Item = std::move(Item);
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConsumption != nullptr)
		*OutConsumption = Parms.OutConsumption;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.OnDamageByBearTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PercentageOfMaxStaminaToRemove                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::OnDamageByBearTrap(float PercentageOfMaxStaminaToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnDamageByBearTrap");

	Params::StaminaComponent_OnDamageByBearTrap Parms{};

	Parms.PercentageOfMaxStaminaToRemove = PercentageOfMaxStaminaToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.OnDeath
// (Event, Public, BlueprintEvent)

void UStaminaComponent::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.StaminaComponent.OnDepleteStamina
// (Native, Event, Protected, BlueprintEvent)

void UStaminaComponent::OnDepleteStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnDepleteStamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.OnEffectRemoved
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EffectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::OnEffectRemoved(class FName EffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnEffectRemoved");

	Params::StaminaComponent_OnEffectRemoved Parms{};

	Parms.EffectName = EffectName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaComponent.OnStaminaStartedRegenerating
// (Native, Event, Protected, BlueprintEvent)

void UStaminaComponent::OnStaminaStartedRegenerating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnStaminaStartedRegenerating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.PlayStaminaEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::PlayStaminaEffect(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "PlayStaminaEffect");

	Params::StaminaComponent_PlayStaminaEffect Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.RemoveAllEfectsOfName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::RemoveAllEfectsOfName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "RemoveAllEfectsOfName");

	Params::StaminaComponent_RemoveAllEfectsOfName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.ResetComponent
// (Final, Native, Public, BlueprintCallable)

void UStaminaComponent::ResetComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "ResetComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.SetCheatInfiniteSprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInfinite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::SetCheatInfiniteSprint(bool bInfinite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "SetCheatInfiniteSprint");

	Params::StaminaComponent_SetCheatInfiniteSprint Parms{};

	Parms.bInfinite = bInfinite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.StartHoldBreath
// (Native, Public, BlueprintCallable)

void UStaminaComponent::StartHoldBreath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "StartHoldBreath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.StopHoldBreath
// (Native, Public, BlueprintCallable)

void UStaminaComponent::StopHoldBreath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "StopHoldBreath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.StopHoldBreathForced
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::StopHoldBreathForced(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "StopHoldBreathForced");

	Params::StaminaComponent_StopHoldBreathForced Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaComponent.CanStartHoldBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::CanStartHoldBreath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "CanStartHoldBreath");

	Params::StaminaComponent_CanStartHoldBreath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.CanStartSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::CanStartSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "CanStartSprinting");

	Params::StaminaComponent_CanStartSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.GetMaximumStaminaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetMaximumStaminaValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetMaximumStaminaValue");

	Params::StaminaComponent_GetMaximumStaminaValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.GetSprintingThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetSprintingThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetSprintingThreshold");

	Params::StaminaComponent_GetSprintingThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.GetStaminaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetStaminaValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetStaminaValue");

	Params::StaminaComponent_GetStaminaValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.IsExhausted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::IsExhausted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "IsExhausted");

	Params::StaminaComponent_IsExhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.IsHoldBreathOverriden
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   OutBreathLevel                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::IsHoldBreathOverriden(int32* OutBreathLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "IsHoldBreathOverriden");

	Params::StaminaComponent_IsHoldBreathOverriden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBreathLevel != nullptr)
		*OutBreathLevel = Parms.OutBreathLevel;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.IsHoldingBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::IsHoldingBreath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "IsHoldingBreath");

	Params::StaminaComponent_IsHoldingBreath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaComponent.IsStaminaEffectPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaminaComponent::IsStaminaEffectPlaying(class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "IsStaminaEffectPlaying");

	Params::StaminaComponent_IsStaminaEffectPlaying Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaBreathingComponent.DoCoughBreath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CoughingTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::DoCoughBreath(float CoughingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "DoCoughBreath");

	Params::StaminaBreathingComponent_DoCoughBreath Parms{};

	Parms.CoughingTime = CoughingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaBreathingComponent.OnBreathCallback
// (Final, Native, Protected)

void UStaminaBreathingComponent::OnBreathCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnBreathCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaBreathingComponent.OnBreatheCough
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::OnBreatheCough(const struct FBreathProperties& BreathProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnBreatheCough");

	Params::StaminaBreathingComponent_OnBreatheCough Parms{};

	Parms.BreathProperties = std::move(BreathProperties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaBreathingComponent.OnBreatheIn
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::OnBreatheIn(const struct FBreathProperties& BreathProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnBreatheIn");

	Params::StaminaBreathingComponent_OnBreatheIn Parms{};

	Parms.BreathProperties = std::move(BreathProperties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaBreathingComponent.OnBreatheOut
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::OnBreatheOut(const struct FBreathProperties& BreathProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnBreatheOut");

	Params::StaminaBreathingComponent_OnBreatheOut Parms{};

	Parms.BreathProperties = std::move(BreathProperties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaBreathingComponent.OnHoldBreathEnd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::OnHoldBreathEnd(const struct FBreathProperties& BreathProperties, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnHoldBreathEnd");

	Params::StaminaBreathingComponent_OnHoldBreathEnd Parms{};

	Parms.BreathProperties = std::move(BreathProperties);
	Parms.bForced = bForced;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaBreathingComponent.OnHoldBreathStart
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::OnHoldBreathStart(const struct FBreathProperties& BreathProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "OnHoldBreathStart");

	Params::StaminaBreathingComponent_OnHoldBreathStart Parms{};

	Parms.BreathProperties = std::move(BreathProperties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.StaminaBreathingComponent.PlayBreathSound
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaBreathingComponent::PlayBreathSound(class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "PlayBreathSound");

	Params::StaminaBreathingComponent_PlayBreathSound Parms{};

	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaBreathingComponent.StartBreath
// (Final, Native, Public, BlueprintCallable)

void UStaminaBreathingComponent::StartBreath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "StartBreath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaBreathingComponent.StopBreath
// (Final, Native, Public, BlueprintCallable)

void UStaminaBreathingComponent::StopBreath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "StopBreath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StaminaBreathingComponent.GetBreathProperties
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBreathType                             NewBreathType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBreathType                             PreviousBreathType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBreathProperties                PreviousBreathProperties                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBreathProperties                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBreathProperties UStaminaBreathingComponent::GetBreathProperties(float DeltaTime, EBreathType NewBreathType, EBreathType PreviousBreathType, const struct FBreathProperties& PreviousBreathProperties) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "GetBreathProperties");

	Params::StaminaBreathingComponent_GetBreathProperties Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.NewBreathType = NewBreathType;
	Parms.PreviousBreathType = PreviousBreathType;
	Parms.PreviousBreathProperties = std::move(PreviousBreathProperties);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.StaminaBreathingComponent.GetBreathSoundVolume
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// EBreathType                             BreathType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBreathProperties                BreathProperties                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Is1PersonView                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaBreathingComponent::GetBreathSoundVolume(EBreathType BreathType, const struct FBreathProperties& BreathProperties, bool Is1PersonView) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "GetBreathSoundVolume");

	Params::StaminaBreathingComponent_GetBreathSoundVolume Parms{};

	Parms.BreathType = BreathType;
	Parms.BreathProperties = std::move(BreathProperties);
	Parms.Is1PersonView = Is1PersonView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StaminaBreathingComponent.GetBreathType
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// EBreathType                             PreviousBreathType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBreathProperties                PreviousBreathProperties                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EBreathType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBreathType UStaminaBreathingComponent::GetBreathType(EBreathType PreviousBreathType, const struct FBreathProperties& PreviousBreathProperties) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaBreathingComponent", "GetBreathType");

	Params::StaminaBreathingComponent_GetBreathType Parms{};

	Parms.PreviousBreathType = PreviousBreathType;
	Parms.PreviousBreathProperties = std::move(PreviousBreathProperties);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.ChallengeManager.BlueprintInit
// (Event, Public, BlueprintEvent)

void AChallengeManager::BlueprintInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChallengeManager", "BlueprintInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ChallengePrerequisite.IsPrerequisiteMet
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemCategory                           ItemCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChallengeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AChallengePrerequisite::IsPrerequisiteMet(TSubclassOf<class AItem> ItemType, int32 Number, EItemCategory ItemCategory, class FName ChallengeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChallengePrerequisite", "IsPrerequisiteMet");

	Params::ChallengePrerequisite_IsPrerequisiteMet Parms{};

	Parms.ItemType = ItemType;
	Parms.Number = Number;
	Parms.ItemCategory = ItemCategory;
	Parms.ChallengeName = ChallengeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CharacterHitZoneComponent.AddHitZoneComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterHitZone                       Zone                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterHitZoneComponent::AddHitZoneComponent(ECharacterHitZone Zone, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterHitZoneComponent", "AddHitZoneComponent");

	Params::CharacterHitZoneComponent_AddHitZoneComponent Parms{};

	Parms.Zone = Zone;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CharacterHitZoneComponent.GetComponentZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterHitZone                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterHitZone UCharacterHitZoneComponent::GetComponentZone(class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterHitZoneComponent", "GetComponentZone");

	Params::CharacterHitZoneComponent_GetComponentZone Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineDebugComponent.GetCurrentItemStateInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineDebugComponent::GetCurrentItemStateInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineDebugComponent", "GetCurrentItemStateInfo");

	Params::StateMachineDebugComponent_GetCurrentItemStateInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineDebugComponent.GetCurrentStateOnServerInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineDebugComponent::GetCurrentStateOnServerInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineDebugComponent", "GetCurrentStateOnServerInfo");

	Params::StateMachineDebugComponent_GetCurrentStateOnServerInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineDebugComponent.GetStatesHistoryLocal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineDebugComponent::GetStatesHistoryLocal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineDebugComponent", "GetStatesHistoryLocal");

	Params::StateMachineDebugComponent_GetStatesHistoryLocal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineDebugComponent.GetStatesHistoryOnServer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineDebugComponent::GetStatesHistoryOnServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineDebugComponent", "GetStatesHistoryOnServer");

	Params::StateMachineDebugComponent_GetStatesHistoryOnServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LobbyBaseMenuWidget.GetActivatedAmountCPP
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EBoosterTypes                           Booster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULobbyBaseMenuWidget::GetActivatedAmountCPP(EBoosterTypes Booster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "GetActivatedAmountCPP");

	Params::LobbyBaseMenuWidget_GetActivatedAmountCPP Parms{};

	Parms.Booster = Booster;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.LobbyBaseMenuWidget.LeaveLobby
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULobbyBaseMenuWidget::LeaveLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "LeaveLobby");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.LobbyBaseMenuWidget.LockLobby
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULobbyBaseMenuWidget::LockLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "LockLobby");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.LobbyBaseMenuWidget.RefreshReadyUI
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ReadyIDs                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyBaseMenuWidget::RefreshReadyUI(const TArray<int32>& ReadyIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "RefreshReadyUI");

	Params::LobbyBaseMenuWidget_RefreshReadyUI Parms{};

	Parms.ReadyIDs = std::move(ReadyIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LobbyBaseMenuWidget.SetBoosterState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBoosterTypes                           Booster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OrderedCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalActiveCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TicketsUsed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyBaseMenuWidget::SetBoosterState(EBoosterTypes Booster, int32 OrderedCount, int32 TotalActiveCount, int32 MaxCount, int32 TicketsUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "SetBoosterState");

	Params::LobbyBaseMenuWidget_SetBoosterState Parms{};

	Parms.Booster = Booster;
	Parms.OrderedCount = OrderedCount;
	Parms.TotalActiveCount = TotalActiveCount;
	Parms.MaxCount = MaxCount;
	Parms.TicketsUsed = TicketsUsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LobbyBaseMenuWidget.SetRemainingTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyBaseMenuWidget::SetRemainingTime(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "SetRemainingTime");

	Params::LobbyBaseMenuWidget_SetRemainingTime Parms{};

	Parms.Seconds = Seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LobbyBaseMenuWidget.SetRemainingTimeEncounter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyBaseMenuWidget::SetRemainingTimeEncounter(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "SetRemainingTimeEncounter");

	Params::LobbyBaseMenuWidget_SetRemainingTimeEncounter Parms{};

	Parms.Seconds = Seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LobbyBaseMenuWidget.UpdateHCs
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULobbyBaseMenuWidget::UpdateHCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyBaseMenuWidget", "UpdateHCs");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.CheatFunctions.CollectActionsInProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCheatFunctions::CollectActionsInProgress(const class AHumanCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "CollectActionsInProgress");

	Params::CheatFunctions_CollectActionsInProgress Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CheatFunctions.GetStateMachine
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AHumanCharacter*                  Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStateMachineComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStateMachineComponent* UCheatFunctions::GetStateMachine(const class AHumanCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "GetStateMachine");

	Params::CheatFunctions_GetStateMachine Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CheatFunctions.GetTransformFromClipboard
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCheatFunctions::GetTransformFromClipboard(struct FTransform* Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "GetTransformFromClipboard");

	Params::CheatFunctions_GetTransformFromClipboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	return Parms.ReturnValue;
}


// Function Flame.CheatFunctions.InterruptAllStates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatFunctions::InterruptAllStates(const class AHumanCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "InterruptAllStates");

	Params::CheatFunctions_InterruptAllStates Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CheatFunctions.PlayerTransformToClipboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatFunctions::PlayerTransformToClipboard(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "PlayerTransformToClipboard");

	Params::CheatFunctions_PlayerTransformToClipboard Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CheatFunctions.SetPlayerTransformFromClipboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatFunctions::SetPlayerTransformFromClipboard(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "SetPlayerTransformFromClipboard");

	Params::CheatFunctions_SetPlayerTransformFromClipboard Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.CheatFunctions.SetTransformToClipboard
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCheatFunctions::SetTransformToClipboard(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CheatFunctions", "SetTransformToClipboard");

	Params::CheatFunctions_SetTransformToClipboard Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonClicked
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListButtonWidget::OnButtonClicked(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonClicked");

	Params::ListButtonWidget_OnButtonClicked Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonFocused
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListButtonWidget::OnButtonFocused(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonFocused");

	Params::ListButtonWidget_OnButtonFocused Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonHovered
// (Final, Native, Protected)

void UListButtonWidget::OnButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonPressed
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListButtonWidget::OnButtonPressed(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonPressed");

	Params::ListButtonWidget_OnButtonPressed Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonReleased
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListButtonWidget::OnButtonReleased(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonReleased");

	Params::ListButtonWidget_OnButtonReleased Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonUnfocused
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListButtonWidget::OnButtonUnfocused(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonUnfocused");

	Params::ListButtonWidget_OnButtonUnfocused Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ListButtonWidget.OnButtonUnhovered
// (Final, Native, Protected)

void UListButtonWidget::OnButtonUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListButtonWidget", "OnButtonUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InGameNewsSystem.GetNews
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FNewsUIData>              OutNews                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInGameNewsSystem::GetNews(TArray<struct FNewsUIData>* OutNews)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameNewsSystem", "GetNews");

	Params::InGameNewsSystem_GetNews Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNews != nullptr)
		*OutNews = std::move(Parms.OutNews);
}


// Function Flame.InGameNewsSystem.NeedsToBeDisplayed
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FNewsDto                         News                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameNewsSystem::NeedsToBeDisplayed(const struct FNewsDto& News)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameNewsSystem", "NeedsToBeDisplayed");

	Params::InGameNewsSystem_NeedsToBeDisplayed Parms{};

	Parms.News = std::move(News);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.InGameNewsSystem.RemoveNotFoundNewsFromSaveFile
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FNewsDto>                 News                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInGameNewsSystem::RemoveNotFoundNewsFromSaveFile(const TArray<struct FNewsDto>& News)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameNewsSystem", "RemoveNotFoundNewsFromSaveFile");

	Params::InGameNewsSystem_RemoveNotFoundNewsFromSaveFile Parms{};

	Parms.News = std::move(News);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InGameNewsSystem.IsInGameNewsSystemReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameNewsSystem::IsInGameNewsSystemReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameNewsSystem", "IsInGameNewsSystemReady");

	Params::InGameNewsSystem_IsInGameNewsSystemReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InputActionHintWidget.SetContent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EInputIcon>                      InIcons                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInputActionHintWidget::SetContent(const class FText& InMessage, const TArray<EInputIcon>& InIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionHintWidget", "SetContent");

	Params::InputActionHintWidget_SetContent Parms{};

	Parms.InMessage = std::move(InMessage);
	Parms.InIcons = std::move(InIcons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.ExternalStartHoldTimer
// (Final, Native, Protected, BlueprintCallable)

void UInputActionWidget::ExternalStartHoldTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "ExternalStartHoldTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.ExternalStopHoldTimer
// (Final, Native, Protected, BlueprintCallable)

void UInputActionWidget::ExternalStopHoldTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "ExternalStopHoldTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.HasActionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputActionWidget::HasActionName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "HasActionName");

	Params::InputActionWidget_HasActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InputActionWidget.NativeOnActionHold
// (Native, Protected)

void UInputActionWidget::NativeOnActionHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "NativeOnActionHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.NativeOnActionPressed
// (Native, Protected)

void UInputActionWidget::NativeOnActionPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "NativeOnActionPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.NativeOnActionReleased
// (Native, Protected)

void UInputActionWidget::NativeOnActionReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "NativeOnActionReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.NativeOnDisabled
// (Native, Protected)

void UInputActionWidget::NativeOnDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "NativeOnDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.NativeOnEnabled
// (Native, Protected)

void UInputActionWidget::NativeOnEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "NativeOnEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.OnActionHold
// (Event, Protected, BlueprintEvent)

void UInputActionWidget::OnActionHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionHold");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnActionHoldEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnActionHoldEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionHoldEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.InputActionWidget.OnActionPressed
// (Event, Protected, BlueprintEvent)

void UInputActionWidget::OnActionPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnActionPressedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnActionPressedEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionPressedEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.InputActionWidget.OnActionReleased
// (Event, Protected, BlueprintEvent)

void UInputActionWidget::OnActionReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnActionReleasedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnActionReleasedEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnActionReleasedEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnClickedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnClickedEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnClickedEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnDisabledEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnDisabledEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnDisabledEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnEnabledEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnEnabledEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnEnabledEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.InputActionWidget.OnInputIconChangedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInputActionWidget::OnInputIconChangedEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnInputIconChangedEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.InputActionWidget.OnMouseClicked
// (Event, Protected, BlueprintEvent)

void UInputActionWidget::OnMouseClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "OnMouseClicked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.InputActionWidget.SetActionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UInputActionWidget::SetActionName(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetActionName");

	Params::InputActionWidget_SetActionName Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetConsumeActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetConsumeActions(const bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetConsumeActions");

	Params::InputActionWidget_SetConsumeActions Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetHoldTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetHoldTime(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetHoldTime");

	Params::InputActionWidget_SetHoldTime Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetInputIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputIcon                              InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsHoldable                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetInputIcon(const EInputIcon InIcon, const bool bInIsHoldable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetInputIcon");

	Params::InputActionWidget_SetInputIcon Parms{};

	Parms.InIcon = InIcon;
	Parms.bInIsHoldable = bInIsHoldable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetSoundOnHold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       InSoundOnHold                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetSoundOnHold(class USoundBase* InSoundOnHold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetSoundOnHold");

	Params::InputActionWidget_SetSoundOnHold Parms{};

	Parms.InSoundOnHold = InSoundOnHold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetSoundOnPress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       InSoundOnPress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetSoundOnPress(class USoundBase* InSoundOnPress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetSoundOnPress");

	Params::InputActionWidget_SetSoundOnPress Parms{};

	Parms.InSoundOnPress = InSoundOnPress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetSoundOnRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       InSoundOnRelease                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetSoundOnRelease(class USoundBase* InSoundOnRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetSoundOnRelease");

	Params::InputActionWidget_SetSoundOnRelease Parms{};

	Parms.InSoundOnRelease = InSoundOnRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.SetWindowsInputIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputIcon                              InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsWideImage                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputActionWidget::SetWindowsInputIcon(const EInputIcon InIcon, const bool bInIsWideImage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "SetWindowsInputIcon");

	Params::InputActionWidget_SetWindowsInputIcon Parms{};

	Parms.InIcon = InIcon;
	Parms.bInIsWideImage = bInIsWideImage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.TriggerButtonPress
// (Final, Native, Public, BlueprintCallable)

void UInputActionWidget::TriggerButtonPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "TriggerButtonPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.UpdateProgress
// (Final, Native, Private)

void UInputActionWidget::UpdateProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "UpdateProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputActionWidget.WindowsInputTypeChanged
// (Final, Native, Public, BlueprintCallable)

void UInputActionWidget::WindowsInputTypeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidget", "WindowsInputTypeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PingManager.GetPingManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPingManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPingManager* UPingManager::GetPingManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PingManager", "GetPingManager");

	Params::PingManager_GetPingManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PingManager.IsPingOfServersComputed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPingManager::IsPingOfServersComputed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingManager", "IsPingOfServersComputed");

	Params::PingManager_IsPingOfServersComputed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InputActionWidgetExtended.HasActionInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputActionWidgetExtended::HasActionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidgetExtended", "HasActionInfo");

	Params::InputActionWidgetExtended_HasActionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InputActionWidgetExtended.SetActionInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UInputActionWidgetExtended::SetActionInfo(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputActionWidgetExtended", "SetActionInfo");

	Params::InputActionWidgetExtended_SetActionInfo Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InputChoiceWidget.GetSelectedIndex
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInputChoiceWidget::GetSelectedIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputChoiceWidget", "GetSelectedIndex");

	Params::InputChoiceWidget_GetSelectedIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.InputAction.KeyHold
// (Final, Native, Private)

void UInputAction::KeyHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputAction", "KeyHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.ClientNotifyInteractionEnd
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::ClientNotifyInteractionEnd(class UInteractionItemComponent* InteractingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "ClientNotifyInteractionEnd");

	Params::InteractionActorComponent_ClientNotifyInteractionEnd Parms{};

	Parms.InteractingItem = InteractingItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.ClientNotifyInteractionStart
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::ClientNotifyInteractionStart(class UInteractionItemComponent* InteractingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "ClientNotifyInteractionStart");

	Params::InteractionActorComponent_ClientNotifyInteractionStart Parms{};

	Parms.InteractingItem = InteractingItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.ClientNotifyPreInteractionEnd
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreInteracitonCanceled                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::ClientNotifyPreInteractionEnd(class UInteractionItemComponent* InteractingItem, bool bPreInteracitonCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "ClientNotifyPreInteractionEnd");

	Params::InteractionActorComponent_ClientNotifyPreInteractionEnd Parms{};

	Parms.InteractingItem = InteractingItem;
	Parms.bPreInteracitonCanceled = bPreInteracitonCanceled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.ClientNotifyPreInteractionStart
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreInteractionPhaseLen                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::ClientNotifyPreInteractionStart(class UInteractionItemComponent* InteractingItem, float PreInteractionPhaseLen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "ClientNotifyPreInteractionStart");

	Params::InteractionActorComponent_ClientNotifyPreInteractionStart Parms{};

	Parms.InteractingItem = InteractingItem;
	Parms.PreInteractionPhaseLen = PreInteractionPhaseLen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.MulticastNotifyInteractionEnd
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::MulticastNotifyInteractionEnd(class UInteractionItemComponent* InteractingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "MulticastNotifyInteractionEnd");

	Params::InteractionActorComponent_MulticastNotifyInteractionEnd Parms{};

	Parms.InteractingItem = InteractingItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.MulticastNotifyInteractionStart
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::MulticastNotifyInteractionStart(class UInteractionItemComponent* InteractingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "MulticastNotifyInteractionStart");

	Params::InteractionActorComponent_MulticastNotifyInteractionStart Parms{};

	Parms.InteractingItem = InteractingItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.MulticastNotifyPreInteractionEnd
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreInteracitonCanceled                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::MulticastNotifyPreInteractionEnd(class UInteractionItemComponent* InteractingItem, bool bPreInteracitonCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "MulticastNotifyPreInteractionEnd");

	Params::InteractionActorComponent_MulticastNotifyPreInteractionEnd Parms{};

	Parms.InteractingItem = InteractingItem;
	Parms.bPreInteracitonCanceled = bPreInteracitonCanceled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.MulticastNotifyPreInteractionStart
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionItemComponent*        InteractingItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreInteractionPhaseLen                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::MulticastNotifyPreInteractionStart(class UInteractionItemComponent* InteractingItem, float PreInteractionPhaseLen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "MulticastNotifyPreInteractionStart");

	Params::InteractionActorComponent_MulticastNotifyPreInteractionStart Parms{};

	Parms.InteractingItem = InteractingItem;
	Parms.PreInteractionPhaseLen = PreInteractionPhaseLen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.OnHideMarker
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionActorComponent*       Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::OnHideMarker(class UInteractionActorComponent* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "OnHideMarker");

	Params::InteractionActorComponent_OnHideMarker Parms{};

	Parms.Sender = Sender;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionActorComponent.OnShowMarker
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UInteractionActorComponent*       Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionItemComponent*        InteractionItem                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MarkerPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InteractionAllowed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::OnShowMarker(class UInteractionActorComponent* Sender, class UInteractionItemComponent* InteractionItem, const struct FVector& MarkerPosition, bool InteractionAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "OnShowMarker");

	Params::InteractionActorComponent_OnShowMarker Parms{};

	Parms.Sender = Sender;
	Parms.InteractionItem = InteractionItem;
	Parms.MarkerPosition = std::move(MarkerPosition);
	Parms.InteractionAllowed = InteractionAllowed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionActorComponent.OnUpdateMarker
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UInteractionActorComponent*       Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MarkerPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::OnUpdateMarker(class UInteractionActorComponent* Sender, const struct FVector& MarkerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "OnUpdateMarker");

	Params::InteractionActorComponent_OnUpdateMarker Parms{};

	Parms.Sender = Sender;
	Parms.MarkerPosition = std::move(MarkerPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.InteractionActorComponent.ResetComponent
// (Final, Native, Public, BlueprintCallable)

void UInteractionActorComponent::ResetComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "ResetComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "SetEnabled");

	Params::InteractionActorComponent_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.SetMarkersVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::SetMarkersVisibility(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "SetMarkersVisibility");

	Params::InteractionActorComponent_SetMarkersVisibility Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.SetMarkersVisibilityByOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionActorComponent::SetMarkersVisibilityByOptions(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "SetMarkersVisibilityByOptions");

	Params::InteractionActorComponent_SetMarkersVisibilityByOptions Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InteractionActorComponent.GetInteractingItemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionItemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionItemComponent* UInteractionActorComponent::GetInteractingItemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetInteractingItemComponent");

	Params::InteractionActorComponent_GetInteractingItemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.GetLastInteractingItemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionItemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionItemComponent* UInteractionActorComponent::GetLastInteractingItemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetLastInteractingItemComponent");

	Params::InteractionActorComponent_GetLastInteractingItemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.GetMarkersRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionActorComponent::GetMarkersRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetMarkersRadius");

	Params::InteractionActorComponent_GetMarkersRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.GetMarkersVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionActorComponent::GetMarkersVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetMarkersVisibility");

	Params::InteractionActorComponent_GetMarkersVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.GetMarkersVisibilityByOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionActorComponent::GetMarkersVisibilityByOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetMarkersVisibilityByOptions");

	Params::InteractionActorComponent_GetMarkersVisibilityByOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.GetPreInteractiveTimerProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionActorComponent::GetPreInteractiveTimerProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "GetPreInteractiveTimerProgress");

	Params::InteractionActorComponent_GetPreInteractiveTimerProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionActorComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "IsEnabled");

	Params::InteractionActorComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.IsPlayerInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionActorComponent::IsPlayerInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "IsPlayerInteracting");

	Params::InteractionActorComponent_IsPlayerInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InteractionActorComponent.IsPreInteractiveTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionActorComponent::IsPreInteractiveTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorComponent", "IsPreInteractiveTimerActive");

	Params::InteractionActorComponent_IsPreInteractiveTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Tool.EquipToolInternal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ATool::EquipToolInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "EquipToolInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.HandleInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::HandleInput(const struct FKey& Key, EInputEvent Event, float Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "HandleInput");

	Params::Tool_HandleInput Parms{};

	Parms.Key = std::move(Key);
	Parms.Event = Event;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.HandleInputInternal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::HandleInputInternal(const struct FKey& Key, EInputEvent Event, float Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "HandleInputInternal");

	Params::Tool_HandleInputInternal Parms{};

	Parms.Key = std::move(Key);
	Parms.Event = Event;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.RemoveFromHands
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENetRole                                NetRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::RemoveFromHands(ENetRole NetRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "RemoveFromHands");

	Params::Tool_RemoveFromHands Parms{};

	Parms.NetRole = NetRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.RemoveFromHandsInternal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   NetRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::RemoveFromHandsInternal(uint8 NetRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "RemoveFromHandsInternal");

	Params::Tool_RemoveFromHandsInternal Parms{};

	Parms.NetRole = NetRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.SetHumanOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  NewOwner                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::SetHumanOwner(const class AHumanCharacter* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "SetHumanOwner");

	Params::Tool_SetHumanOwner Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.TakeIntoHands
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENetRole                                NetRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::TakeIntoHands(ENetRole NetRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "TakeIntoHands");

	Params::Tool_TakeIntoHands Parms{};

	Parms.NetRole = NetRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.TakeIntoHandsInternal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   NetRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATool::TakeIntoHandsInternal(uint8 NetRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "TakeIntoHandsInternal");

	Params::Tool_TakeIntoHandsInternal Parms{};

	Parms.NetRole = NetRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Tool.UnequipToolInternal
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ATool::UnequipToolInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tool", "UnequipToolInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.ClientSetCurrentWeaponDirectly
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class AItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::ClientSetCurrentWeaponDirectly(class AItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "ClientSetCurrentWeaponDirectly");

	Params::InventoryComponent_ClientSetCurrentWeaponDirectly Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeCurrentWeapon
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeCurrentWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeItem
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeItemServer
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeItemServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeItemServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeLastOperationId
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeLastOperationId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeLastOperationId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeLastValidItem
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeLastValidItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeLastValidItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangeLastWeapon
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangeLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangeLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.OnRep_PostChangePersistents
// (Final, Native, Protected)

void UInventoryComponent::OnRep_PostChangePersistents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_PostChangePersistents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.ServerUseItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AItem*                            OneConsumable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::ServerUseItem(class AItem* OneConsumable, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "ServerUseItem");

	Params::InventoryComponent_ServerUseItem Parms{};

	Parms.OneConsumable = OneConsumable;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.SetFirstValidWeaponOrHolster
// (Final, Native, Protected, BlueprintCallable)

void UInventoryComponent::SetFirstValidWeaponOrHolster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SetFirstValidWeaponOrHolster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.SetLastKnownItemPtr
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class AItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::SetLastKnownItemPtr(class AItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SetLastKnownItemPtr");

	Params::InventoryComponent_SetLastKnownItemPtr Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.SetWeightModifier
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   NewWeightModifier                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::SetWeightModifier(const float NewWeightModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SetWeightModifier");

	Params::InventoryComponent_SetWeightModifier Parms{};

	Parms.NewWeightModifier = NewWeightModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryComponent.SpawnAndAttachPersistent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APersistentItem>      PersistentClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APersistentItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APersistentItem* UInventoryComponent::SpawnAndAttachPersistent(TSubclassOf<class APersistentItem> PersistentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SpawnAndAttachPersistent");

	Params::InventoryComponent_SpawnAndAttachPersistent Parms{};

	Parms.PersistentClass = PersistentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.DoesSomethingModifyDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResultSimplified             HitOptimised                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        ItemsWhichAffectedDamage                               (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::DoesSomethingModifyDamage(const struct FHitResultSimplified& HitOptimised, EDamageType DamageType, TArray<TSubclassOf<class AItem>>* ItemsWhichAffectedDamage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "DoesSomethingModifyDamage");

	Params::InventoryComponent_DoesSomethingModifyDamage Parms{};

	Parms.HitOptimised = std::move(HitOptimised);
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemsWhichAffectedDamage != nullptr)
		*ItemsWhichAffectedDamage = std::move(Parms.ItemsWhichAffectedDamage);

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.DoesSomethingModifyDamageBone
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Bone                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItem>>        ItemsWhichAffectedDamage                               (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::DoesSomethingModifyDamageBone(class FName Bone, EDamageType DamageType, TArray<TSubclassOf<class AItem>>* ItemsWhichAffectedDamage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "DoesSomethingModifyDamageBone");

	Params::InventoryComponent_DoesSomethingModifyDamageBone Parms{};

	Parms.Bone = Bone;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemsWhichAffectedDamage != nullptr)
		*ItemsWhichAffectedDamage = std::move(Parms.ItemsWhichAffectedDamage);

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.FindFirstPersistentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APersistentItem>      PersistentClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APersistentItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APersistentItem* UInventoryComponent::FindFirstPersistentByClass(TSubclassOf<class APersistentItem> PersistentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "FindFirstPersistentByClass");

	Params::InventoryComponent_FindFirstPersistentByClass Parms{};

	Parms.PersistentClass = PersistentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetAmmoCountForWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetAmmoCountForWeapon(const class AWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetAmmoCountForWeapon");

	Params::InventoryComponent_GetAmmoCountForWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetBackpack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItemsGrid*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemsGrid* UInventoryComponent::GetBackpack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetBackpack");

	Params::InventoryComponent_GetBackpack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetBackpackColsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetBackpackColsCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetBackpackColsCount");

	Params::InventoryComponent_GetBackpackColsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetBackpackDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FResourceGrid                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FResourceGrid UInventoryComponent::GetBackpackDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetBackpackDescriptor");

	Params::InventoryComponent_GetBackpackDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetBackpackRowsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetBackpackRowsCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetBackpackRowsCount");

	Params::InventoryComponent_GetBackpackRowsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetCurrentItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem* UInventoryComponent::GetCurrentItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetCurrentItem");

	Params::InventoryComponent_GetCurrentItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetInventoryWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventoryComponent::GetInventoryWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetInventoryWeight");

	Params::InventoryComponent_GetInventoryWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetLastKnownItemFromServer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem* UInventoryComponent::GetLastKnownItemFromServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetLastKnownItemFromServer");

	Params::InventoryComponent_GetLastKnownItemFromServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.GetWeapons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULinkedWeapons*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULinkedWeapons* UInventoryComponent::GetWeapons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetWeapons");

	Params::InventoryComponent_GetWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryComponent.IsPersistentPresent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APersistentItem>      PersistentClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::IsPersistentPresent(TSubclassOf<class APersistentItem> PersistentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "IsPersistentPresent");

	Params::InventoryComponent_IsPersistentPresent Parms{};

	Parms.PersistentClass = PersistentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootableCorpse.GetDeadPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALootableCorpse::GetDeadPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootableCorpse", "GetDeadPlayerName");

	Params::LootableCorpse_GetDeadPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootableCorpse.GetDeadPlayerPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFlamePlatform                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFlamePlatform ALootableCorpse::GetDeadPlayerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootableCorpse", "GetDeadPlayerPlatform");

	Params::LootableCorpse_GetDeadPlayerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootableCorpse.GetDeadPlayerUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl ALootableCorpse::GetDeadPlayerUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootableCorpse", "GetDeadPlayerUniqueId");

	Params::LootableCorpse_GetDeadPlayerUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.AddItemsFromInventoryToUI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInventoryComponent*              Inventory                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDynamicContainerWidget*          UIContainer                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryFunctions::AddItemsFromInventoryToUI(const class UInventoryComponent* Inventory, class UDynamicContainerWidget* UIContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "AddItemsFromInventoryToUI");

	Params::InventoryFunctions_AddItemsFromInventoryToUI Parms{};

	Parms.Inventory = Inventory;
	Parms.UIContainer = UIContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryFunctions.CanStoreToInventory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInventoryComponent*              Inventory                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCanStoreResult                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCanStoreResult UInventoryFunctions::CanStoreToInventory(const class UInventoryComponent* Inventory, TSubclassOf<class AItemForBackpack> Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CanStoreToInventory");

	Params::InventoryFunctions_CanStoreToInventory Parms{};

	Parms.Inventory = Inventory;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.ClearGrid
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemsList*                       TargetGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryFunctions::ClearGrid(class UItemsList* TargetGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "ClearGrid");

	Params::InventoryFunctions_ClearGrid Parms{};

	Parms.TargetGrid = TargetGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryFunctions.ConsumeResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemsList*                       TargetGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::ConsumeResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "ConsumeResource");

	Params::InventoryFunctions_ConsumeResource Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.CountOfCurrency
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStashComponent*                  TargetStash                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACurrency>            CurrencyClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::CountOfCurrency(const class UStashComponent* TargetStash, TSubclassOf<class ACurrency> CurrencyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CountOfCurrency");

	Params::InventoryFunctions_CountOfCurrency Parms{};

	Parms.TargetStash = TargetStash;
	Parms.CurrencyClass = CurrencyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.CountOfResource
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::CountOfResource(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CountOfResource");

	Params::InventoryFunctions_CountOfResource Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.CountOfWeapons
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeaponsStorage*                  WeaponsList                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::CountOfWeapons(const class UWeaponsStorage* WeaponsList, TSubclassOf<class AWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CountOfWeapons");

	Params::InventoryFunctions_CountOfWeapons Parms{};

	Parms.WeaponsList = WeaponsList;
	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.CountToFullStack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::CountToFullStack(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CountToFullStack");

	Params::InventoryFunctions_CountToFullStack Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.CreateOperationsForItemDistributionFromToBag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInventoryComponent*              TargetInventory                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEquipItemsInfo>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FEquipItemsInfo> UInventoryFunctions::CreateOperationsForItemDistributionFromToBag(const class UInventoryComponent* TargetInventory, TSubclassOf<class AItemForBackpack> Resource, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "CreateOperationsForItemDistributionFromToBag");

	Params::InventoryFunctions_CreateOperationsForItemDistributionFromToBag Parms{};

	Parms.TargetInventory = TargetInventory;
	Parms.Resource = Resource;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.FindFirstEmptySlotIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::FindFirstEmptySlotIndex(const class UItemsList* TargetGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "FindFirstEmptySlotIndex");

	Params::InventoryFunctions_FindFirstEmptySlotIndex Parms{};

	Parms.TargetGrid = TargetGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.GetAllConsumablesClasses
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AConsumableItem>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AConsumableItem>> UInventoryFunctions::GetAllConsumablesClasses(const class UItemsList* TargetGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "GetAllConsumablesClasses");

	Params::InventoryFunctions_GetAllConsumablesClasses Parms{};

	Parms.TargetGrid = TargetGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.GetAllConsumablesSlots
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBackpackItemSlot>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBackpackItemSlot> UInventoryFunctions::GetAllConsumablesSlots(const class UItemsList* TargetGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "GetAllConsumablesSlots");

	Params::InventoryFunctions_GetAllConsumablesSlots Parms{};

	Parms.TargetGrid = TargetGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.GetBackpackDescriptor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInventoryComponent*              SourceInventory                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FResourceGrid                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FResourceGrid UInventoryFunctions::GetBackpackDescriptor(const class UInventoryComponent* SourceInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "GetBackpackDescriptor");

	Params::InventoryFunctions_GetBackpackDescriptor Parms{};

	Parms.SourceInventory = SourceInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.GetInventoryWeapons
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AWeapon*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AWeapon*> UInventoryFunctions::GetInventoryWeapons(const class APawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "GetInventoryWeapons");

	Params::InventoryFunctions_GetInventoryWeapons Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.GetItemCategoryName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EItemCategory                           Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInventoryFunctions::GetItemCategoryName(EItemCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "GetItemCategoryName");

	Params::InventoryFunctions_GetItemCategoryName Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.HowManyCanBeStored
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::HowManyCanBeStored(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "HowManyCanBeStored");

	Params::InventoryFunctions_HowManyCanBeStored Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.HowManyCanBeStoredInOneSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInventoryComponent*              Inventory                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::HowManyCanBeStoredInOneSlot(const class UInventoryComponent* Inventory, TSubclassOf<class AItemForBackpack> Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "HowManyCanBeStoredInOneSlot");

	Params::InventoryFunctions_HowManyCanBeStoredInOneSlot Parms{};

	Parms.Inventory = Inventory;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.HowManyCanBeTakenFromSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemForBackpack*                 Resource                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::HowManyCanBeTakenFromSlot(const class UItemsList* TargetGrid, const class AItemForBackpack* Resource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "HowManyCanBeTakenFromSlot");

	Params::InventoryFunctions_HowManyCanBeTakenFromSlot Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.InitBackpackFromDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInventoryComponent*              TargetInventory                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FResourceGrid                    SourceGrid                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryFunctions::InitBackpackFromDescriptor(class UInventoryComponent* TargetInventory, const struct FResourceGrid& SourceGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "InitBackpackFromDescriptor");

	Params::InventoryFunctions_InitBackpackFromDescriptor Parms{};

	Parms.TargetInventory = TargetInventory;
	Parms.SourceGrid = std::move(SourceGrid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryFunctions.IsAmmoCompatibleWithLoadout
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryFunctions::IsAmmoCompatibleWithLoadout(const class APawn* PlayerPawn, TSubclassOf<class AAmmoItem> AmmoClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "IsAmmoCompatibleWithLoadout");

	Params::InventoryFunctions_IsAmmoCompatibleWithLoadout Parms{};

	Parms.PlayerPawn = PlayerPawn;
	Parms.AmmoClass = AmmoClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.IsGridEmpty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryFunctions::IsGridEmpty(const class UItemsList* TargetGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "IsGridEmpty");

	Params::InventoryFunctions_IsGridEmpty Parms{};

	Parms.TargetGrid = TargetGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.MergeGrids
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemsGrid*                       TargetGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemsGrid*                       SourceGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryFunctions::MergeGrids(class UItemsGrid* TargetGrid, class UItemsGrid* SourceGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "MergeGrids");

	Params::InventoryFunctions_MergeGrids Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.SourceGrid = SourceGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.InventoryFunctions.StoreResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemsList*                       TargetGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryFunctions::StoreResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "StoreResource");

	Params::InventoryFunctions_StoreResource Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.InventoryFunctions.UpdateResource
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemsList*                       TargetGrid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemForBackpack>     Resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryFunctions::UpdateResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryFunctions", "UpdateResource");

	Params::InventoryFunctions_UpdateResource Parms{};

	Parms.TargetGrid = TargetGrid;
	Parms.Resource = Resource;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemClassHelpers.GetItemRowFromDataTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemClassTableRow               RowData                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemClassHelpers::GetItemRowFromDataTable(class UDataTable* DataTable, class FName RowName, bool* Success, struct FItemClassTableRow* RowData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemClassHelpers", "GetItemRowFromDataTable");

	Params::ItemClassHelpers_GetItemRowFromDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (RowData != nullptr)
		*RowData = std::move(Parms.RowData);
}


// Function Flame.ItemClassHelpers.GetTableRowFromItemClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle              TableHandle                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemClassHelpers::GetTableRowFromItemClass(TSubclassOf<class AItem> ItemClass, bool* Success, struct FDataTableRowHandle* TableHandle, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemClassHelpers", "GetTableRowFromItemClass");

	Params::ItemClassHelpers_GetTableRowFromItemClass Parms{};

	Parms.ItemClass = ItemClass;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (TableHandle != nullptr)
		*TableHandle = std::move(Parms.TableHandle);
}


// Function Flame.ItemClassHelpers.GetTableRowFromItemName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle              TableHandle                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemClassHelpers::GetTableRowFromItemName(const class FString& ItemName, bool* Success, struct FDataTableRowHandle* TableHandle, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemClassHelpers", "GetTableRowFromItemName");

	Params::ItemClassHelpers_GetTableRowFromItemName Parms{};

	Parms.ItemName = std::move(ItemName);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (TableHandle != nullptr)
		*TableHandle = std::move(Parms.TableHandle);
}


// Function Flame.OnlineStatusComponent.GetOverview
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineStatusComponent::GetOverview(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStatusComponent", "GetOverview");

	Params::OnlineStatusComponent_GetOverview Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineStatusComponent.GetOverviewDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudOverviewResponse           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineStatusComponent::GetOverviewDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudOverviewResponse& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStatusComponent", "GetOverviewDelegate__DelegateSignature");

	Params::OnlineStatusComponent_GetOverviewDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineStatusComponent.GetStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineStatusComponent::GetStatus(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStatusComponent", "GetStatus");

	Params::OnlineStatusComponent_GetStatus Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineStatusComponent.GetStatusDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudStatusResponse             Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineStatusComponent::GetStatusDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudStatusResponse& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStatusComponent", "GetStatusDelegate__DelegateSignature");

	Params::OnlineStatusComponent_GetStatusDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlatformStoreOffersManager.FindPlatformOfferByGameStoreId
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameStoreProductId              GameStoreProductId                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UPlatformStoreOfferInfo*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformStoreOfferInfo* UPlatformStoreOffersManager::FindPlatformOfferByGameStoreId(const struct FGameStoreProductId& GameStoreProductId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "FindPlatformOfferByGameStoreId");

	Params::PlatformStoreOffersManager_FindPlatformOfferByGameStoreId Parms{};

	Parms.GameStoreProductId = std::move(GameStoreProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOffersManager.FindPlatformOfferByPlatfromId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlatformId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformStoreOfferInfo*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformStoreOfferInfo* UPlatformStoreOffersManager::FindPlatformOfferByPlatfromId(const class FString& PlatformId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "FindPlatformOfferByPlatfromId");

	Params::PlatformStoreOffersManager_FindPlatformOfferByPlatfromId Parms{};

	Parms.PlatformId = std::move(PlatformId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.PlatformStoreOffersManager.PlatformStoreOffersStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPlatformStoreOffersState               OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformStoreOffersState               NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformStoreOffersManager::PlatformStoreOffersStateChanged__DelegateSignature(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "PlatformStoreOffersStateChanged__DelegateSignature");

	Params::PlatformStoreOffersManager_PlatformStoreOffersStateChanged__DelegateSignature Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlatformStoreOffersManager.RefreshPlatformStoreOffers
// (Native, Public, BlueprintCallable)
// Parameters:
// EPlatformStoreOffersRefreshMode         RefreshMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreOffersManager::RefreshPlatformStoreOffers(EPlatformStoreOffersRefreshMode RefreshMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "RefreshPlatformStoreOffers");

	Params::PlatformStoreOffersManager_RefreshPlatformStoreOffers Parms{};

	Parms.RefreshMode = RefreshMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOffersManager.GetOffersManagerState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlatformStoreOffersState               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformStoreOffersState UPlatformStoreOffersManager::GetOffersManagerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "GetOffersManagerState");

	Params::PlatformStoreOffersManager_GetOffersManagerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreOffersManager.GetPlatformOffers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UPlatformStoreOfferInfo*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UPlatformStoreOfferInfo*> UPlatformStoreOffersManager::GetPlatformOffers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreOffersManager", "GetPlatformOffers");

	Params::PlatformStoreOffersManager_GetPlatformOffers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NetworkStatsWidget.UpdateTexts
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             LagText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             BandwidthInText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             BandwidthOutText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LossInText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LossOutText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNetworkStatsWidget::UpdateTexts(const class FText& LagText, const class FText& BandwidthInText, const class FText& BandwidthOutText, const class FText& LossInText, const class FText& LossOutText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkStatsWidget", "UpdateTexts");

	Params::NetworkStatsWidget_UpdateTexts Parms{};

	Parms.LagText = std::move(LagText);
	Parms.BandwidthInText = std::move(BandwidthInText);
	Parms.BandwidthOutText = std::move(BandwidthOutText);
	Parms.LossInText = std::move(LossInText);
	Parms.LossOutText = std::move(LossOutText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.NetworkStatsWidget.UpdateVisibilityFromGameSettings
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameSaveSettings                GameSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNetworkStatsWidget::UpdateVisibilityFromGameSettings(const struct FGameSaveSettings& GameSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkStatsWidget", "UpdateVisibilityFromGameSettings");

	Params::NetworkStatsWidget_UpdateVisibilityFromGameSettings Parms{};

	Parms.GameSettings = std::move(GameSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NetworkStatsWidget.IsActivatedOnOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkStatsWidget::IsActivatedOnOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkStatsWidget", "IsActivatedOnOptions");

	Params::NetworkStatsWidget_IsActivatedOnOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.ComposeQuaternions
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UQuaternionsBPFunctions::ComposeQuaternions(const struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "ComposeQuaternions");

	Params::QuaternionsBPFunctions_ComposeQuaternions Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.InverseTransformRotationQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UQuaternionsBPFunctions::InverseTransformRotationQuat(const struct FTransform& T, const struct FQuat& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "InverseTransformRotationQuat");

	Params::QuaternionsBPFunctions_InverseTransformRotationQuat Parms{};

	Parms.T = std::move(T);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.NormalizeQuaternion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Quaternion                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UQuaternionsBPFunctions::NormalizeQuaternion(const struct FQuat& Quaternion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "NormalizeQuaternion");

	Params::QuaternionsBPFunctions_NormalizeQuaternion Parms{};

	Parms.Quaternion = std::move(Quaternion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.QuaternionToRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Quaternion                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UQuaternionsBPFunctions::QuaternionToRotator(const struct FQuat& Quaternion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "QuaternionToRotator");

	Params::QuaternionsBPFunctions_QuaternionToRotator Parms{};

	Parms.Quaternion = std::move(Quaternion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.RotateTransformQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UQuaternionsBPFunctions::RotateTransformQuat(const struct FTransform& T, const struct FQuat& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "RotateTransformQuat");

	Params::QuaternionsBPFunctions_RotateTransformQuat Parms{};

	Parms.T = std::move(T);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.RotatorToQuaternion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UQuaternionsBPFunctions::RotatorToQuaternion(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "RotatorToQuaternion");

	Params::QuaternionsBPFunctions_RotatorToQuaternion Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.QuaternionsBPFunctions.SetRelativeRotationQuat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            NewRotation                                            (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UQuaternionsBPFunctions::SetRelativeRotationQuat(class USceneComponent* SceneComponent, const struct FQuat& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuaternionsBPFunctions", "SetRelativeRotationQuat");

	Params::QuaternionsBPFunctions_SetRelativeRotationQuat Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.OnlineBoostersComponent.ActivateBoosterTickets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BoosterTicketSku                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineBoostersComponent::ActivateBoosterTickets(class AHumanPlayerController* Player, const class FString& BoosterTicketSku, const int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineBoostersComponent", "ActivateBoosterTickets");

	Params::OnlineBoostersComponent_ActivateBoosterTickets Parms{};

	Parms.Player = Player;
	Parms.BoosterTicketSku = std::move(BoosterTicketSku);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineBoostersComponent.ActivateBoosterTicketsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBoosterDetails                  Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineBoostersComponent::ActivateBoosterTicketsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FBoosterDetails& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineBoostersComponent", "ActivateBoosterTicketsDelegate__DelegateSignature");

	Params::OnlineBoostersComponent_ActivateBoosterTicketsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.RiverCollision.GenerateCollisionMesh
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FVector>                  Vertices                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Indices                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ARiverCollision::GenerateCollisionMesh(const TArray<struct FVector>& Vertices, const TArray<int32>& Indices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverCollision", "GenerateCollisionMesh");

	Params::RiverCollision_GenerateCollisionMesh Parms{};

	Parms.Vertices = std::move(Vertices);
	Parms.Indices = std::move(Indices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverCollision.SetCollisionPointHeight
// (Final, Native, Public, HasOutParams)
// Parameters:
// float                                   NewHeight                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARiverCollision::SetCollisionPointHeight(const float& NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverCollision", "SetCollisionPointHeight");

	Params::RiverCollision_SetCollisionPointHeight Parms{};

	Parms.NewHeight = NewHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverCollision.SetRiverOwner
// (Final, Native, Public)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARiverCollision::SetRiverOwner(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverCollision", "SetRiverOwner");

	Params::RiverCollision_SetRiverOwner Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverCollision.GetCollisionPointHeight
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARiverCollision::GetCollisionPointHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverCollision", "GetCollisionPointHeight");

	Params::RiverCollision_GetCollisionPointHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.RiverCollision.GetRiverOwner
// (Final, Native, Public, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ARiverCollision::GetRiverOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverCollision", "GetRiverOwner");

	Params::RiverCollision_GetRiverOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ObstacleComponent.AddEdge
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FObstacleEdge                    Edge                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UObstacleComponent::AddEdge(const struct FObstacleEdge& Edge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "AddEdge");

	Params::ObstacleComponent_AddEdge Parms{};

	Parms.Edge = std::move(Edge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ObstacleComponent.AddSplineTransformedEdges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObstacleAsset*                   Obstacle                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineMeshComponent*             SplineMeshComponent                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObstacleComponent::AddSplineTransformedEdges(const class UObstacleAsset* Obstacle, const class USplineMeshComponent* SplineMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "AddSplineTransformedEdges");

	Params::ObstacleComponent_AddSplineTransformedEdges Parms{};

	Parms.Obstacle = Obstacle;
	Parms.SplineMeshComponent = SplineMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ObstacleComponent.AddTransformedEdges
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObstacleAsset*                   Obstacle                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UObstacleComponent::AddTransformedEdges(const class UObstacleAsset* Obstacle, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "AddTransformedEdges");

	Params::ObstacleComponent_AddTransformedEdges Parms{};

	Parms.Obstacle = Obstacle;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ObstacleComponent.SetObstacleAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObstacleAsset*                   Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObstacleComponent::SetObstacleAsset(class UObstacleAsset* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "SetObstacleAsset");

	Params::ObstacleComponent_SetObstacleAsset Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ObstacleComponent.SetObstacleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObstacleComponent::SetObstacleEnabled(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "SetObstacleEnabled");

	Params::ObstacleComponent_SetObstacleEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ObstacleComponent.GetTransformedEdges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USplineMeshComponent*             SplineMesh                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FObstacleEdge>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FObstacleEdge> UObstacleComponent::GetTransformedEdges(const class USplineMeshComponent* SplineMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "GetTransformedEdges");

	Params::ObstacleComponent_GetTransformedEdges Parms{};

	Parms.SplineMesh = SplineMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ObstacleComponent.HasEdges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObstacleComponent::HasEdges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "HasEdges");

	Params::ObstacleComponent_HasEdges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ObstacleComponent.IsObstacleEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObstacleComponent::IsObstacleEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObstacleComponent", "IsObstacleEnabled");

	Params::ObstacleComponent_IsObstacleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OnlineCharityBoxComponent.AddToCharityBox
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudCharityBoxAddInfo          Info                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineCharityBoxComponent::AddToCharityBox(class AHumanPlayerController* Player, const struct FCloudCharityBoxAddInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "AddToCharityBox");

	Params::OnlineCharityBoxComponent_AddToCharityBox Parms{};

	Parms.Player = Player;
	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineCharityBoxComponent.AddToCharityBoxDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudCharityBoxState            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineCharityBoxComponent::AddToCharityBoxDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxState& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "AddToCharityBoxDelegate__DelegateSignature");

	Params::OnlineCharityBoxComponent_AddToCharityBoxDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineCharityBoxComponent.ClaimCharityBoxRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SeasonName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineCharityBoxComponent::ClaimCharityBoxRewards(class AHumanPlayerController* Player, const class FString& SeasonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "ClaimCharityBoxRewards");

	Params::OnlineCharityBoxComponent_ClaimCharityBoxRewards Parms{};

	Parms.Player = Player;
	Parms.SeasonName = std::move(SeasonName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineCharityBoxComponent.ClaimCharityBoxRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudCharityBoxClaimInfo        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineCharityBoxComponent::ClaimCharityBoxRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxClaimInfo& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "ClaimCharityBoxRewardsDelegate__DelegateSignature");

	Params::OnlineCharityBoxComponent_ClaimCharityBoxRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineCharityBoxComponent.GetCharityBoxSeasonsInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineCharityBoxComponent::GetCharityBoxSeasonsInfo(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "GetCharityBoxSeasonsInfo");

	Params::OnlineCharityBoxComponent_GetCharityBoxSeasonsInfo Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineCharityBoxComponent.GetCharityBoxSeasonsInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudCharityBoxSeasonsInfo      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineCharityBoxComponent::GetCharityBoxSeasonsInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxSeasonsInfo& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "GetCharityBoxSeasonsInfoDelegate__DelegateSignature");

	Params::OnlineCharityBoxComponent_GetCharityBoxSeasonsInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineCharityBoxComponent.GetCharityBoxState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineCharityBoxComponent::GetCharityBoxState(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "GetCharityBoxState");

	Params::OnlineCharityBoxComponent_GetCharityBoxState Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineCharityBoxComponent.GetCharityBoxStateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudCharityBoxState            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineCharityBoxComponent::GetCharityBoxStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxState& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCharityBoxComponent", "GetCharityBoxStateDelegate__DelegateSignature");

	Params::OnlineCharityBoxComponent_GetCharityBoxStateDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ItemInfoWidget.OnItemChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UItemInfoWidget::OnItemChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInfoWidget", "OnItemChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ItemInfoWidget.SetItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AItem*                            InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemInfoWidget::SetItem(class AItem* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInfoWidget", "SetItem");

	Params::ItemInfoWidget_SetItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LeaderboardSystem.InvalidLeaderboardRequest
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULeaderboardSystem::InvalidLeaderboardRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LeaderboardSystem", "InvalidLeaderboardRequest");

	Params::LeaderboardSystem_InvalidLeaderboardRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.ClearAllCachedLeaderboardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULeaderboardSystem::ClearAllCachedLeaderboardData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "ClearAllCachedLeaderboardData");

	Params::LeaderboardSystem_ClearAllCachedLeaderboardData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.ClearCachedLeaderboardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StatName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULeaderboardSystem::ClearCachedLeaderboardData(class FName StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "ClearCachedLeaderboardData");

	Params::LeaderboardSystem_ClearCachedLeaderboardData Parms{};

	Parms.StatName = StatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.ClearCachedLeaderboardRequest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLeaderboardReadContext          BoardContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULeaderboardSystem::ClearCachedLeaderboardRequest(const struct FLeaderboardReadContext& BoardContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "ClearCachedLeaderboardRequest");

	Params::LeaderboardSystem_ClearCachedLeaderboardRequest Parms{};

	Parms.BoardContext = std::move(BoardContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.DeInitLeaderboardSystem
// (Event, Public, BlueprintEvent)

void ULeaderboardSystem::DeInitLeaderboardSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "DeInitLeaderboardSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.LeaderboardSystem.GetLeaderboardSystemMonitor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULeaderboardSystemMonitor*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULeaderboardSystemMonitor* ULeaderboardSystem::GetLeaderboardSystemMonitor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "GetLeaderboardSystemMonitor");

	Params::LeaderboardSystem_GetLeaderboardSystemMonitor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.InitLeaderboardSystem
// (Event, Public, BlueprintEvent)

void ULeaderboardSystem::InitLeaderboardSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "InitLeaderboardSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Flame.LeaderboardSystem.OnLeaderboardReadBoardFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// bool                                    Succeeded                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequestId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLeaderboardReadContext          BoardContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLeaderboardData                 LeaderboardData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardSystem::OnLeaderboardReadBoardFinished__DelegateSignature(bool Succeeded, int32 RequestId, const struct FLeaderboardReadContext& BoardContext, const struct FLeaderboardData& LeaderboardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "OnLeaderboardReadBoardFinished__DelegateSignature");

	Params::LeaderboardSystem_OnLeaderboardReadBoardFinished__DelegateSignature Parms{};

	Parms.Succeeded = Succeeded;
	Parms.RequestId = RequestId;
	Parms.BoardContext = std::move(BoardContext);
	Parms.LeaderboardData = std::move(LeaderboardData);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.LeaderboardSystem.OnLeaderboardWriteBoardDataFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Succeeded                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequestId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSystem::OnLeaderboardWriteBoardDataFinished__DelegateSignature(bool Succeeded, int32 RequestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "OnLeaderboardWriteBoardDataFinished__DelegateSignature");

	Params::LeaderboardSystem_OnLeaderboardWriteBoardDataFinished__DelegateSignature Parms{};

	Parms.Succeeded = Succeeded;
	Parms.RequestId = RequestId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LeaderboardSystem.OnTick
// (Event, Public, BlueprintEvent)

void ULeaderboardSystem::OnTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "OnTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.LeaderboardSystem.ReadLeaderboardData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLeaderboardReadContext          BoardContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    CheckCachedData                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        UseCacheIfNotOlderThan                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULeaderboardSystem::ReadLeaderboardData(const class AHumanPlayerController* Controller, const struct FLeaderboardReadContext& BoardContext, bool CheckCachedData, const struct FTimespan& UseCacheIfNotOlderThan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "ReadLeaderboardData");

	Params::LeaderboardSystem_ReadLeaderboardData Parms{};

	Parms.Controller = Controller;
	Parms.BoardContext = std::move(BoardContext);
	Parms.CheckCachedData = CheckCachedData;
	Parms.UseCacheIfNotOlderThan = std::move(UseCacheIfNotOlderThan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.SetupLocalLeaderboardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CsvFileName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULeaderboardSystem::SetupLocalLeaderboardData(const class FString& CsvFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "SetupLocalLeaderboardData");

	Params::LeaderboardSystem_SetupLocalLeaderboardData Parms{};

	Parms.CsvFileName = std::move(CsvFileName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.WriteLeaderboardData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoardName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULeaderboardSystem::WriteLeaderboardData(const class AHumanPlayerController* Controller, class FName BoardName, int32 PlayerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "WriteLeaderboardData");

	Params::LeaderboardSystem_WriteLeaderboardData Parms{};

	Parms.Controller = Controller;
	Parms.BoardName = BoardName;
	Parms.PlayerValue = PlayerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LeaderboardSystem.IsLocalLeaderboardEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULeaderboardSystem::IsLocalLeaderboardEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystem", "IsLocalLeaderboardEnabled");

	Params::LeaderboardSystem_IsLocalLeaderboardEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ConsumablePlan.GetConsumableClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AConsumableItem>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AConsumableItem> AConsumablePlan::GetConsumableClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumablePlan", "GetConsumableClass");

	Params::ConsumablePlan_GetConsumableClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OnlineUserStatsComponent.GetUserStatistics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineUserStatsComponent::GetUserStatistics(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserStatsComponent", "GetUserStatistics");

	Params::OnlineUserStatsComponent_GetUserStatistics Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineUserStatsComponent.GetUserStatisticsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudUserProfileStatistics      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineUserStatsComponent::GetUserStatisticsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserProfileStatistics& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserStatsComponent", "GetUserStatisticsDelegate__DelegateSignature");

	Params::OnlineUserStatsComponent_GetUserStatisticsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.WeaponPlan.GetWeaponClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AWeapon>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeapon> AWeaponPlan::GetWeaponClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPlan", "GetWeaponClass");

	Params::WeaponPlan_GetWeaponClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemRarities.GetItemRarities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FItemRarity>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FItemRarity> UItemRarities::GetItemRarities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRarities", "GetItemRarities");

	Params::ItemRarities_GetItemRarities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PerformanceTests.dealayedCommand1
// (Final, Native, Private)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandType                            CommandType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APerformanceTests::DealayedCommand1(const class FString& Command, ECommandType CommandType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "dealayedCommand1");

	Params::PerformanceTests_DealayedCommand1 Parms{};

	Parms.Command = std::move(Command);
	Parms.CommandType = CommandType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.dealayedCommand2
// (Final, Native, Private)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommandType                            CommandType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APerformanceTests::DealayedCommand2(const class FString& Command, ECommandType CommandType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "dealayedCommand2");

	Params::PerformanceTests_DealayedCommand2 Parms{};

	Parms.Command = std::move(Command);
	Parms.CommandType = CommandType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.DelayedWrite
// (Final, Native, Private)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APerformanceTests::DelayedWrite(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "DelayedWrite");

	Params::PerformanceTests_DelayedWrite Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.performanceTestsTriggered
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APerformanceTests::PerformanceTestsTriggered(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "performanceTestsTriggered");

	Params::PerformanceTests_PerformanceTestsTriggered Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.performanceTestsTriggeredTicks
// (Final, Exec, Native, Public)

void APerformanceTests::PerformanceTestsTriggeredTicks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "performanceTestsTriggeredTicks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.performanceTestsTriggeredTicksManual
// (Final, Exec, Native, Public)

void APerformanceTests::PerformanceTestsTriggeredTicksManual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "performanceTestsTriggeredTicksManual");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.performanceTestsTriggeredTicksManualDisable
// (Final, Exec, Native, Public)

void APerformanceTests::PerformanceTestsTriggeredTicksManualDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "performanceTestsTriggeredTicksManualDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PerformanceTests.performanceTestsTriggeredTicksManualEnable
// (Final, Exec, Native, Public)

void APerformanceTests::PerformanceTestsTriggeredTicksManualEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceTests", "performanceTestsTriggeredTicksManualEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationListBase.AddNotification
// (Native, Public)
// Parameters:
// class UNotificationBase*                InNotification                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationListBase::AddNotification(class UNotificationBase* InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "AddNotification");

	Params::NotificationListBase_AddNotification Parms{};

	Parms.InNotification = InNotification;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationListBase.OnAddNotification
// (Event, Public, BlueprintEvent)
// Parameters:
// class UNotificationBase*                InNotification                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationListBase::OnAddNotification(class UNotificationBase* InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "OnAddNotification");

	Params::NotificationListBase_OnAddNotification Parms{};

	Parms.InNotification = InNotification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.NotificationListBase.OnMenuClosed
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuWidget*                      MenuWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationListBase::OnMenuClosed(class UMenuWidget* MenuWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "OnMenuClosed");

	Params::NotificationListBase_OnMenuClosed Parms{};

	Parms.MenuWidget = MenuWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.NotificationListBase.OnMenuOpened
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMenuWidget*                      MenuWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNotificationListBase::OnMenuOpened(class UMenuWidget* MenuWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "OnMenuOpened");

	Params::NotificationListBase_OnMenuOpened Parms{};

	Parms.MenuWidget = MenuWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.NotificationListBase.RefreshRowIndices
// (Final, Native, Protected, BlueprintCallable)

void UNotificationListBase::RefreshRowIndices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "RefreshRowIndices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationListBase.FindNotificationToRemove
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNotificationBase*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNotificationBase* UNotificationListBase::FindNotificationToRemove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "FindNotificationToRemove");

	Params::NotificationListBase_FindNotificationToRemove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NotificationListBase.GetChannels
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNotificationListBase::GetChannels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "GetChannels");

	Params::NotificationListBase_GetChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NotificationListBase.GetMinPriority
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNotificationListBase::GetMinPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationListBase", "GetMinPriority");

	Params::NotificationListBase_GetMinPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemTransferWidget.OnSwapWeaponsClosed
// (Final, Native, Protected)
// Parameters:
// class UFlameWidget*                     FlameWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnSwapWeaponsClosed(class UFlameWidget* FlameWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnSwapWeaponsClosed");

	Params::ItemTransferWidget_OnSwapWeaponsClosed Parms{};

	Parms.FlameWidget = FlameWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ItemTransferWidget.TakeAll
// (Final, Native, Public, BlueprintCallable)

void UItemTransferWidget::TakeAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "TakeAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ItemTransferWidget.TakeFlameSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFlameSlot*                       InFlameSlot                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputIcon                              InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemTransferWidget::TakeFlameSlot(class UFlameSlot* InFlameSlot, EInputIcon InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "TakeFlameSlot");

	Params::ItemTransferWidget_TakeFlameSlot Parms{};

	Parms.InFlameSlot = InFlameSlot;
	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ItemTransferWidget.IsDestroyAllowed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemTransferWidget::IsDestroyAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "IsDestroyAllowed");

	Params::ItemTransferWidget_IsDestroyAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.ConstructJsonObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::ConstructJsonObject(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonObject", "ConstructJsonObject");

	Params::JsonObject_ConstructJsonObject Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.ExportToString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    Pretty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJsonObject::ExportToString(bool Pretty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "ExportToString");

	Params::JsonObject_ExportToString Parms{};

	Parms.Pretty = Pretty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetFieldNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UJsonObject::GetFieldNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetFieldNames");

	Params::JsonObject_GetFieldNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.MergeJsonObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJsonObject*                      InJsonObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Overwrite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::MergeJsonObject(class UJsonObject* InJsonObject, bool Overwrite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "MergeJsonObject");

	Params::JsonObject_MergeJsonObject Parms{};

	Parms.InJsonObject = InJsonObject;
	Parms.Overwrite = Overwrite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.RemoveField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJsonObject::RemoveField(const class FString& FieldName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "RemoveField");

	Params::JsonObject_RemoveField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.JsonObject.Reset
// (Final, Native, Public, BlueprintCallable)

void UJsonObject::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.JsonObject.SetArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UJsonValue*>               InArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetArrayField(const class FString& FieldName, const TArray<class UJsonValue*>& InArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetArrayField");

	Params::JsonObject_SetArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.InArray = std::move(InArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetBoolArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>                            BoolArray                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetBoolArrayField(const class FString& FieldName, const TArray<bool>& BoolArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetBoolArrayField");

	Params::JsonObject_SetBoolArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.BoolArray = std::move(BoolArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetBoolField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetBoolField(const class FString& FieldName, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetBoolField");

	Params::JsonObject_SetBoolField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       JsonValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetField(const class FString& FieldName, class UJsonValue* JsonValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetField");

	Params::JsonObject_SetField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.JsonValue = JsonValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetIntegerArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           NumberArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetIntegerArrayField(const class FString& FieldName, const TArray<int32>& NumberArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetIntegerArrayField");

	Params::JsonObject_SetIntegerArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.NumberArray = std::move(NumberArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetIntegerField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetIntegerField(const class FString& FieldName, int32 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetIntegerField");

	Params::JsonObject_SetIntegerField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetNumberArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           NumberArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetNumberArrayField(const class FString& FieldName, const TArray<float>& NumberArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetNumberArrayField");

	Params::JsonObject_SetNumberArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.NumberArray = std::move(NumberArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetNumberField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetNumberField(const class FString& FieldName, float Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetNumberField");

	Params::JsonObject_SetNumberField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetObjectArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UJsonObject*>              ObjectArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetObjectArrayField(const class FString& FieldName, const TArray<class UJsonObject*>& ObjectArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetObjectArrayField");

	Params::JsonObject_SetObjectArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.ObjectArray = std::move(ObjectArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetObjectField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      JsonObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetObjectField(const class FString& FieldName, class UJsonObject* JsonObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetObjectField");

	Params::JsonObject_SetObjectField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.JsonObject = JsonObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetStringArrayField
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   StringArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetStringArrayField(const class FString& FieldName, const TArray<class FString>& StringArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetStringArrayField");

	Params::JsonObject_SetStringArrayField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.StringArray = std::move(StringArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.SetStringField
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StringValue                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::SetStringField(const class FString& FieldName, const class FString& StringValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "SetStringField");

	Params::JsonObject_SetStringField Parms{};

	Parms.FieldName = std::move(FieldName);
	Parms.StringValue = std::move(StringValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UJsonValue*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UJsonValue*> UJsonObject::GetArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetArrayField");

	Params::JsonObject_GetArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetBoolArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<bool> UJsonObject::GetBoolArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetBoolArrayField");

	Params::JsonObject_GetBoolArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetBoolField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJsonObject::GetBoolField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetBoolField");

	Params::JsonObject_GetBoolField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonObject::GetField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetField");

	Params::JsonObject_GetField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetIntegerArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UJsonObject::GetIntegerArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetIntegerArrayField");

	Params::JsonObject_GetIntegerArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetIntegerField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJsonObject::GetIntegerField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetIntegerField");

	Params::JsonObject_GetIntegerField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetNumberArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UJsonObject::GetNumberArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetNumberArrayField");

	Params::JsonObject_GetNumberArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetNumberField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJsonObject::GetNumberField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetNumberField");

	Params::JsonObject_GetNumberField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetObjectArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UJsonObject*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UJsonObject*> UJsonObject::GetObjectArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetObjectArrayField");

	Params::JsonObject_GetObjectArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetObjectField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonObject::GetObjectField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetObjectField");

	Params::JsonObject_GetObjectField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetStringArrayField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UJsonObject::GetStringArrayField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetStringArrayField");

	Params::JsonObject_GetStringArrayField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.GetStringField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJsonObject::GetStringField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "GetStringField");

	Params::JsonObject_GetStringField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonObject.HasField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJsonObject::HasField(const class FString& FieldName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonObject", "HasField");

	Params::JsonObject_HasField Parms{};

	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.ConstructJsonValueArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UJsonValue*>               InArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonValue::ConstructJsonValueArray(class UObject* WorldContextObject, const TArray<class UJsonValue*>& InArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonValue", "ConstructJsonValueArray");

	Params::JsonValue_ConstructJsonValueArray Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InArray = std::move(InArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.ConstructJsonValueBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonValue::ConstructJsonValueBool(class UObject* WorldContextObject, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonValue", "ConstructJsonValueBool");

	Params::JsonValue_ConstructJsonValueBool Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.ConstructJsonValueNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonValue::ConstructJsonValueNumber(class UObject* WorldContextObject, float Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonValue", "ConstructJsonValueNumber");

	Params::JsonValue_ConstructJsonValueNumber Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.ConstructJsonValueObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonObject*                      JsonObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonValue::ConstructJsonValueObject(class UObject* WorldContextObject, class UJsonObject* JsonObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonValue", "ConstructJsonValueObject");

	Params::JsonValue_ConstructJsonValueObject Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.JsonObject = JsonObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.ConstructJsonValueString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StringValue                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonValue* UJsonValue::ConstructJsonValueString(class UObject* WorldContextObject, const class FString& StringValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JsonValue", "ConstructJsonValueString");

	Params::JsonValue_ConstructJsonValueString Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StringValue = std::move(StringValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.AsObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJsonObject*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJsonObject* UJsonValue::AsObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "AsObject");

	Params::JsonValue_AsObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.AsArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UJsonValue*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UJsonValue*> UJsonValue::AsArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "AsArray");

	Params::JsonValue_AsArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.AsBool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJsonValue::AsBool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "AsBool");

	Params::JsonValue_AsBool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.AsNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJsonValue::AsNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "AsNumber");

	Params::JsonValue_AsNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.AsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJsonValue::AsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "AsString");

	Params::JsonValue_AsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.GetType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EJsonType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EJsonType UJsonValue::GetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "GetType");

	Params::JsonValue_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.GetTypeString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJsonValue::GetTypeString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "GetTypeString");

	Params::JsonValue_GetTypeString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.JsonValue.IsNull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJsonValue::IsNull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JsonValue", "IsNull");

	Params::JsonValue_IsNull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LayeredSoundAudioComponent.SetLayerEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LayerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableLayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULayeredSoundAudioComponent::SetLayerEnabled(class FName LayerName, bool bEnableLayer, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LayeredSoundAudioComponent", "SetLayerEnabled");

	Params::LayeredSoundAudioComponent_SetLayerEnabled Parms{};

	Parms.LayerName = LayerName;
	Parms.bEnableLayer = bEnableLayer;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LayeredSoundAudioComponent.SetLayerValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LayerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULayeredSoundAudioComponent::SetLayerValue(class FName LayerName, float Value, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LayeredSoundAudioComponent", "SetLayerValue");

	Params::LayeredSoundAudioComponent_SetLayerValue Parms{};

	Parms.LayerName = LayerName;
	Parms.Value = Value;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LeaderboardSystemMonitor.Init
// (Native, Event, Public, BlueprintEvent)

void ULeaderboardSystemMonitor::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystemMonitor", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LeaderboardSystemMonitor.OnLeaderboardReadCall
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLeaderboardReadContext          BoardContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULeaderboardSystemMonitor::OnLeaderboardReadCall(const struct FLeaderboardReadContext& BoardContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystemMonitor", "OnLeaderboardReadCall");

	Params::LeaderboardSystemMonitor_OnLeaderboardReadCall Parms{};

	Parms.BoardContext = std::move(BoardContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LeaderboardSystemMonitor.OnLeaderboardWriteCall
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             BoardName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSystemMonitor::OnLeaderboardWriteCall(class FName BoardName, int32 PlayerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystemMonitor", "OnLeaderboardWriteCall");

	Params::LeaderboardSystemMonitor_OnLeaderboardWriteCall Parms{};

	Parms.BoardName = BoardName;
	Parms.PlayerValue = PlayerValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LeaderboardSystemMonitor.OnTick
// (Native, Event, Public, BlueprintEvent)

void ULeaderboardSystemMonitor::OnTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSystemMonitor", "OnTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LoadoutWidget.OnDestroyHold
// (Final, Native, Private)

void ULoadoutWidget::OnDestroyHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutWidget", "OnDestroyHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.LoadoutWidget.GetFocusedItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItem* ULoadoutWidget::GetFocusedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutWidget", "GetFocusedItem");

	Params::LoadoutWidget_GetFocusedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LoadoutWidget.GetFocusedSlot
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlameSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameSlot* ULoadoutWidget::GetFocusedSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutWidget", "GetFocusedSlot");

	Params::LoadoutWidget_GetFocusedSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LoadoutWidget.IsDestroyAllowed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoadoutWidget::IsDestroyAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutWidget", "IsDestroyAllowed");

	Params::LoadoutWidget_IsDestroyAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootableWeapon.LootWeapon
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALootableWeapon::LootWeapon(class AHumanCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootableWeapon", "LootWeapon");

	Params::LootableWeapon_LootWeapon Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.LootBoxComponent.AllLootBoxesInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLootBoxesInfoCloud              LootBoxesInfo                                          (Parm, NativeAccessSpecifierPublic)

void ULootBoxComponent::AllLootBoxesInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxesInfoCloud& LootBoxesInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "AllLootBoxesInfoDelegate__DelegateSignature");

	Params::LootBoxComponent_AllLootBoxesInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.LootBoxesInfo = std::move(LootBoxesInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LootBoxComponent.GetAllLootBoxesInfoItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULootBoxComponent::GetAllLootBoxesInfoItem(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "GetAllLootBoxesInfoItem");

	Params::LootBoxComponent_GetAllLootBoxesInfoItem Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootBoxComponent.GetLootBoxInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LootBoxName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULootBoxComponent::GetLootBoxInfo(class AHumanPlayerController* Player, const class FString& LootBoxName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "GetLootBoxInfo");

	Params::LootBoxComponent_GetLootBoxInfo Parms{};

	Parms.Player = Player;
	Parms.LootBoxName = std::move(LootBoxName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.LootBoxComponent.GetLootBoxInfoItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                LootBox                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULootBoxComponent::GetLootBoxInfoItem(class AHumanPlayerController* Player, const TSubclassOf<class AItem>& LootBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "GetLootBoxInfoItem");

	Params::LootBoxComponent_GetLootBoxInfoItem Parms{};

	Parms.Player = Player;
	Parms.LootBox = LootBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.LootBoxComponent.LootBoxInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLootBoxInfoCloud                LootBoxInfo                                            (Parm, NativeAccessSpecifierPublic)

void ULootBoxComponent::LootBoxInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxInfoCloud& LootBoxInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "LootBoxInfoDelegate__DelegateSignature");

	Params::LootBoxComponent_LootBoxInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.LootBoxInfo = std::move(LootBoxInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LootBoxComponent.OpenLootBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LootBoxName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULootBoxComponent::OpenLootBox(class AHumanPlayerController* Player, const class FString& LootBoxName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "OpenLootBox");

	Params::LootBoxComponent_OpenLootBox Parms{};

	Parms.Player = Player;
	Parms.LootBoxName = std::move(LootBoxName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.LootBoxComponent.OpenLootBoxDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLootBoxOpenedCloudResult        LootBoxItems                                           (Parm, NativeAccessSpecifierPublic)

void ULootBoxComponent::OpenLootBoxDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxOpenedCloudResult& LootBoxItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "OpenLootBoxDelegate__DelegateSignature");

	Params::LootBoxComponent_OpenLootBoxDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.LootBoxItems = std::move(LootBoxItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.LootBoxComponent.OpenLootBoxItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                LootBox                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULootBoxComponent::OpenLootBoxItem(class AHumanPlayerController* Player, const TSubclassOf<class AItem>& LootBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootBoxComponent", "OpenLootBoxItem");

	Params::LootBoxComponent_OpenLootBoxItem Parms{};

	Parms.Player = Player;
	Parms.LootBox = LootBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MapsManager.BlueprintDeInit
// (Event, Public, BlueprintEvent)

void UMapsManager::BlueprintDeInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "BlueprintDeInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MapsManager.BlueprintInit
// (Event, Public, BlueprintEvent)

void UMapsManager::BlueprintInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "BlueprintInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.MapsManager.GetGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFlameGameInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameGameInstance* UMapsManager::GetGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "GetGameInstance");

	Params::MapsManager_GetGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MapsManager.GetMapsRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapsManager::GetMapsRotation(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "GetMapsRotation");

	Params::MapsManager_GetMapsRotation Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MapsManager.GetMapsRotationDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudMapRotationsResponse       Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMapsManager::GetMapsRotationDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudMapRotationsResponse& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "GetMapsRotationDelegate__DelegateSignature");

	Params::MapsManager_GetMapsRotationDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Userid = std::move(Userid);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MapsManager.Tick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapsManager::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "Tick");

	Params::MapsManager_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MapsManager.GetDefaultMapRotationSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCloudMapRotationSlot            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudMapRotationSlot UMapsManager::GetDefaultMapRotationSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapsManager", "GetDefaultMapRotationSlot");

	Params::MapsManager_GetDefaultMapRotationSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MatchInfoComponent.CommitMatchSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCloudUserLobbyInfo>      UserInfos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::CommitMatchSettings(const TArray<struct FCloudUserLobbyInfo>& UserInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "CommitMatchSettings");

	Params::MatchInfoComponent_CommitMatchSettings Parms{};

	Parms.UserInfos = std::move(UserInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.CommitMatchSettingsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudMatchCommitInfo            CloudSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::CommitMatchSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchCommitInfo& CloudSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "CommitMatchSettingsDelegate__DelegateSignature");

	Params::MatchInfoComponent_CommitMatchSettingsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.CloudSettings = std::move(CloudSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.GetLootSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::GetLootSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetLootSettings");

	Params::MatchInfoComponent_GetLootSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.GetLootSettingsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudLootSettings               LootSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::GetLootSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudLootSettings& LootSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetLootSettingsDelegate__DelegateSignature");

	Params::MatchInfoComponent_GetLootSettingsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.LootSettings = std::move(LootSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.GetMatchLoadouts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudGetMatchLoadoutsRequest    RequestSettings                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::GetMatchLoadouts(const struct FCloudGetMatchLoadoutsRequest& RequestSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetMatchLoadouts");

	Params::MatchInfoComponent_GetMatchLoadouts Parms{};

	Parms.RequestSettings = std::move(RequestSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.GetMatchLoadoutsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudMatchLoadouts              Loadouts                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::GetMatchLoadoutsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchLoadouts& Loadouts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetMatchLoadoutsDelegate__DelegateSignature");

	Params::MatchInfoComponent_GetMatchLoadoutsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Loadouts = std::move(Loadouts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.GetMatchSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::GetMatchSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetMatchSettings");

	Params::MatchInfoComponent_GetMatchSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.GetMatchSettingsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudMatchSettingsInfo          CommitSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::GetMatchSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchSettingsInfo& CommitSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetMatchSettingsDelegate__DelegateSignature");

	Params::MatchInfoComponent_GetMatchSettingsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.CommitSettings = std::move(CommitSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.GetUserMatchesStatistic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudUserMatchStatisticsPeriod         TimePeriod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::GetUserMatchesStatistic(class AHumanPlayerController* Player, ECloudUserMatchStatisticsPeriod TimePeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetUserMatchesStatistic");

	Params::MatchInfoComponent_GetUserMatchesStatistic Parms{};

	Parms.Player = Player;
	Parms.TimePeriod = TimePeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.GetUserMatchesStatisticDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ECloudUserMatchStatisticsPeriod         TimePeriod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserMatchesStatistic       Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMatchInfoComponent::GetUserMatchesStatisticDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, ECloudUserMatchStatisticsPeriod TimePeriod, const struct FCloudUserMatchesStatistic& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetUserMatchesStatisticDelegate__DelegateSignature");

	Params::MatchInfoComponent_GetUserMatchesStatisticDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.TimePeriod = TimePeriod;
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.MatchInfoComponent.MatchStartedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchInfoComponent::MatchStartedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "MatchStartedDelegate__DelegateSignature");

	Params::MatchInfoComponent_MatchStartedDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.MatchID = std::move(MatchID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.RegisterMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GameMode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::RegisterMatch(const class FString& GameMode, const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "RegisterMatch");

	Params::MatchInfoComponent_RegisterMatch Parms{};

	Parms.GameMode = std::move(GameMode);
	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MatchInfoComponent.RegisterUserToMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::RegisterUserToMatch(class AHumanPlayerController* Player, const class FString& GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "RegisterUserToMatch");

	Params::MatchInfoComponent_RegisterUserToMatch Parms{};

	Parms.Player = Player;
	Parms.GroupName = std::move(GroupName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MatchInfoComponent.SetMatchResultForPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUserMatchInfo                   MatchInfo                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::SetMatchResultForPlayer(class AHumanPlayerController* Player, const struct FUserMatchInfo& MatchInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "SetMatchResultForPlayer");

	Params::MatchInfoComponent_SetMatchResultForPlayer Parms{};

	Parms.Player = Player;
	Parms.MatchInfo = std::move(MatchInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.SetPlayerMatchDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUserMatchReward                 Reward                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::SetPlayerMatchDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, const struct FUserMatchReward& Reward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "SetPlayerMatchDelegate__DelegateSignature");

	Params::MatchInfoComponent_SetPlayerMatchDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.Reward = std::move(Reward);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.SetTutorialCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TutorialCompleted                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::SetTutorialCompleted(class AController* Player, bool TutorialCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "SetTutorialCompleted");

	Params::MatchInfoComponent_SetTutorialCompleted Parms{};

	Parms.Player = Player;
	Parms.TutorialCompleted = TutorialCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.SetTutorialCompletedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::SetTutorialCompletedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "SetTutorialCompletedDelegate__DelegateSignature");

	Params::MatchInfoComponent_SetTutorialCompletedDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.UnregisterMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::UnregisterMatch(const class FString& MatchCloudId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "UnregisterMatch");

	Params::MatchInfoComponent_UnregisterMatch Parms{};

	Parms.MatchCloudId = std::move(MatchCloudId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.UnregisterMatchDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchInfoComponent::UnregisterMatchDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "UnregisterMatchDelegate__DelegateSignature");

	Params::MatchInfoComponent_UnregisterMatchDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.UnregisterUserFromMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchInfoComponent::UnregisterUserFromMatch(const class FString& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "UnregisterUserFromMatch");

	Params::MatchInfoComponent_UnregisterUserFromMatch Parms{};

	Parms.Userid = std::move(Userid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.MatchInfoComponent.UserRegisteredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchInfoComponent::UserRegisteredDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "UserRegisteredDelegate__DelegateSignature");

	Params::MatchInfoComponent_UserRegisteredDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.MatchInfoComponent.UserUnregisteredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchInfoComponent::UserUnregisteredDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "UserUnregisteredDelegate__DelegateSignature");

	Params::MatchInfoComponent_UserUnregisteredDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Userid = std::move(Userid);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.MatchInfoComponent.GetMatchId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchInfoComponent::GetMatchId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchInfoComponent", "GetMatchId");

	Params::MatchInfoComponent_GetMatchId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.MessageBoxWidget.OnActionCancelPressed
// (Final, Native, Protected)

void UMessageBoxWidget::OnActionCancelPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "OnActionCancelPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.OnActionConfirmPressed
// (Final, Native, Protected)

void UMessageBoxWidget::OnActionConfirmPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "OnActionConfirmPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.OnActionGotItPressed
// (Final, Native, Protected)

void UMessageBoxWidget::OnActionGotItPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "OnActionGotItPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.OnActionNoPressed
// (Final, Native, Protected)

void UMessageBoxWidget::OnActionNoPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "OnActionNoPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.OnActionYesPressed
// (Final, Native, Protected)

void UMessageBoxWidget::OnActionYesPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "OnActionYesPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.SetMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMessageBoxWidget::SetMessage(const class FText& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "SetMessage");

	Params::MessageBoxWidget_SetMessage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.SetTitle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMessageBoxWidget::SetTitle(const class FText& InTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "SetTitle");

	Params::MessageBoxWidget_SetTitle Parms{};

	Parms.InTitle = std::move(InTitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MessageBoxWidget.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMessageBoxType                         InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageBoxWidget::SetType(EMessageBoxType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageBoxWidget", "SetType");

	Params::MessageBoxWidget_SetType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.MotionAimComponent.SetMotionAimEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlsoSixAxisSensors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlsoAimAssist                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionAimComponent::SetMotionAimEnabled(bool bEnabled, bool bAlsoSixAxisSensors, bool bAlsoAimAssist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionAimComponent", "SetMotionAimEnabled");

	Params::MotionAimComponent_SetMotionAimEnabled Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bAlsoSixAxisSensors = bAlsoSixAxisSensors;
	Parms.bAlsoAimAssist = bAlsoAimAssist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NavLinkClimb.JumpAfterTime
// (Final, Native, Private)
// Parameters:
// class AHumanCharacter*                  HumanCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkClimb::JumpAfterTime(class AHumanCharacter* HumanCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkClimb", "JumpAfterTime");

	Params::NavLinkClimb_JumpAfterTime Parms{};

	Parms.HumanCharacter = HumanCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NavLinkClimb.OnActorBeginOverlapDelegate
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANavLinkClimb::OnActorBeginOverlapDelegate(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkClimb", "OnActorBeginOverlapDelegate");

	Params::NavLinkClimb_OnActorBeginOverlapDelegate Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NavLinkClimb.OnActorEndOverlapDelegate
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkClimb::OnActorEndOverlapDelegate(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkClimb", "OnActorEndOverlapDelegate");

	Params::NavLinkClimb_OnActorEndOverlapDelegate Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NavLinkClimb.OnNavLinkReached
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UNavLinkCustomComponent*          NavLinkComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkClimb::OnNavLinkReached(class UNavLinkCustomComponent* NavLinkComponent, class UObject* Actor, const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkClimb", "OnNavLinkReached");

	Params::NavLinkClimb_OnNavLinkReached Parms{};

	Parms.NavLinkComponent = NavLinkComponent;
	Parms.Actor = Actor;
	Parms.Destination = std::move(Destination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NavLinkClimb.SetDefaultTrigger
// (Final, Native, Public)

void ANavLinkClimb::SetDefaultTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkClimb", "SetDefaultTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationBase.Deactivate
// (Native, Public, BlueprintCallable)

void UNotificationBase::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationBase", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationBase.OnHide
// (Event, Public, BlueprintEvent)

void UNotificationBase::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationBase", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.NotificationBase.OnShow
// (Event, Public, BlueprintEvent)

void UNotificationBase::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationBase", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.NotificationBase.ToString
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNotificationBase::ToString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationBase", "ToString");

	Params::NotificationBase_ToString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NotificationSubscriber.AddNotification
// (Native, Public)
// Parameters:
// class UNotificationBase*                InNotification                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INotificationSubscriber::AddNotification(class UNotificationBase* InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationSubscriber", "AddNotification");

	Params::NotificationSubscriber_AddNotification Parms{};

	Parms.InNotification = InNotification;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.NotificationSubscriber.GetChannels
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 INotificationSubscriber::GetChannels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationSubscriber", "GetChannels");

	Params::NotificationSubscriber_GetChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.NotificationSubscriber.GetMinPriority
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 INotificationSubscriber::GetMinPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NotificationSubscriber", "GetMinPriority");

	Params::NotificationSubscriber_GetMinPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OnlineChallengesComponent.ClaimUserChallenge
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotCategory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChallengeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::ClaimUserChallenge(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ClaimUserChallenge");

	Params::OnlineChallengesComponent_ClaimUserChallenge Parms{};

	Parms.Player = Player;
	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotId = SlotId;
	Parms.ChallengeName = ChallengeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.ClaimUserChallengeDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudChallengeClaimResult       ClaimResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::ClaimUserChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeClaimResult& ClaimResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ClaimUserChallengeDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_ClaimUserChallengeDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.ClaimResult = std::move(ClaimResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.ClaimUserSeasonChallenge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::ClaimUserSeasonChallenge(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ClaimUserSeasonChallenge");

	Params::OnlineChallengesComponent_ClaimUserSeasonChallenge Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.ClaimUserSeasonChallengeDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudSeasonChallengeClaimResult ClaimResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::ClaimUserSeasonChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeClaimResult& ClaimResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ClaimUserSeasonChallengeDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_ClaimUserSeasonChallengeDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.ClaimResult = std::move(ClaimResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.GetUserChallengeSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::GetUserChallengeSlots(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserChallengeSlots");

	Params::OnlineChallengesComponent_GetUserChallengeSlots Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.GetUserChallengeSlotsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudGetChallengeResponse       Response                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::GetUserChallengeSlotsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetChallengeResponse& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserChallengeSlotsDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_GetUserChallengeSlotsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Response = std::move(Response);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.GetUserSeasonChallengeProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::GetUserSeasonChallengeProgress(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserSeasonChallengeProgress");

	Params::OnlineChallengesComponent_GetUserSeasonChallengeProgress Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.GetUserSeasonChallengeProgressDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudSeasonChallengeProgressResultResponse                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::GetUserSeasonChallengeProgressDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeProgressResult& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserSeasonChallengeProgressDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_GetUserSeasonChallengeProgressDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Response = std::move(Response);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.GetUserSeasonChallengeRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::GetUserSeasonChallengeRewards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserSeasonChallengeRewards");

	Params::OnlineChallengesComponent_GetUserSeasonChallengeRewards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.GetUserSeasonChallengeRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudSeasonChallengeRewardsResultResponse                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::GetUserSeasonChallengeRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeRewardsResult& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "GetUserSeasonChallengeRewardsDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_GetUserSeasonChallengeRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Response = std::move(Response);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.ReRollUserChallenge
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotCategory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChallengeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::ReRollUserChallenge(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ReRollUserChallenge");

	Params::OnlineChallengesComponent_ReRollUserChallenge Parms{};

	Parms.Player = Player;
	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotId = SlotId;
	Parms.ChallengeName = ChallengeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.ReRollUserChallengeDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudChallengeClaimResult       Response                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::ReRollUserChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeClaimResult& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "ReRollUserChallengeDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_ReRollUserChallengeDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Response = std::move(Response);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineChallengesComponent.SetUserChallengeProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotCategory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChallengeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineChallengesComponent::SetUserChallengeProgress(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName, int32 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "SetUserChallengeProgress");

	Params::OnlineChallengesComponent_SetUserChallengeProgress Parms{};

	Parms.Player = Player;
	Parms.SlotCategory = std::move(SlotCategory);
	Parms.SlotId = SlotId;
	Parms.ChallengeName = ChallengeName;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineChallengesComponent.SetUserChallengeProgressDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudChallengeSlotInfo          ProgressResult                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineChallengesComponent::SetUserChallengeProgressDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeSlotInfo& ProgressResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineChallengesComponent", "SetUserChallengeProgressDelegate__DelegateSignature");

	Params::OnlineChallengesComponent_SetUserChallengeProgressDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.ProgressResult = std::move(ProgressResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineMapRewardsComponent.GetMapRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineMapRewardsComponent::GetMapRewards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineMapRewardsComponent", "GetMapRewards");

	Params::OnlineMapRewardsComponent_GetMapRewards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineMapRewardsComponent.GetMapRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudMapRewardsResult           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineMapRewardsComponent::GetMapRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMapRewardsResult& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineMapRewardsComponent", "GetMapRewardsDelegate__DelegateSignature");

	Params::OnlineMapRewardsComponent_GetMapRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineUserLeaderBoardsComponent.GetUserLeaderBoardDetail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserLeaderBoardDetailRequestReq                                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineUserLeaderBoardsComponent::GetUserLeaderBoardDetail(class AHumanPlayerController* Player, const struct FCloudUserLeaderBoardDetailRequest& Req)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserLeaderBoardsComponent", "GetUserLeaderBoardDetail");

	Params::OnlineUserLeaderBoardsComponent_GetUserLeaderBoardDetail Parms{};

	Parms.Player = Player;
	Parms.Req = std::move(Req);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineUserLeaderBoardsComponent.GetUserLeaderBoardDetailDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudUserLeaderBoardDetailDto   Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineUserLeaderBoardsComponent::GetUserLeaderBoardDetailDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserLeaderBoardDetailDto& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserLeaderBoardsComponent", "GetUserLeaderBoardDetailDelegate__DelegateSignature");

	Params::OnlineUserLeaderBoardsComponent_GetUserLeaderBoardDetailDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineUserLeaderBoardsComponent.GetUserLeaderBoards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineUserLeaderBoardsComponent::GetUserLeaderBoards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserLeaderBoardsComponent", "GetUserLeaderBoards");

	Params::OnlineUserLeaderBoardsComponent_GetUserLeaderBoards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineUserLeaderBoardsComponent.GetUserLeaderBoardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudUserLeaderBoards           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineUserLeaderBoardsComponent::GetUserLeaderBoardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserLeaderBoards& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserLeaderBoardsComponent", "GetUserLeaderBoardsDelegate__DelegateSignature");

	Params::OnlineUserLeaderBoardsComponent_GetUserLeaderBoardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineWipeRewardsComponent.GetUserWipeRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineWipeRewardsComponent::GetUserWipeRewards(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineWipeRewardsComponent", "GetUserWipeRewards");

	Params::OnlineWipeRewardsComponent_GetUserWipeRewards Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineWipeRewardsComponent.GetUserWipeRewardsDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudUserWipeRewards            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineWipeRewardsComponent::GetUserWipeRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserWipeRewards& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineWipeRewardsComponent", "GetUserWipeRewardsDelegate__DelegateSignature");

	Params::OnlineWipeRewardsComponent_GetUserWipeRewardsDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PhysicsFunctions.GetHitOptimisedSurfaceType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResultSimplified             HitOptimised                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UPhysicsFunctions::GetHitOptimisedSurfaceType(const struct FHitResultSimplified& HitOptimised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysicsFunctions", "GetHitOptimisedSurfaceType");

	Params::PhysicsFunctions_GetHitOptimisedSurfaceType Parms{};

	Parms.HitOptimised = std::move(HitOptimised);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PhysicsFunctions.GetHitSurfaceType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UPhysicsFunctions::GetHitSurfaceType(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysicsFunctions", "GetHitSurfaceType");

	Params::PhysicsFunctions_GetHitSurfaceType Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PhysicsFunctions.IsPointInBuilding
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointToTest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysicsFunctions::IsPointInBuilding(class UObject* WorldContextObject, const struct FVector& PointToTest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysicsFunctions", "IsPointInBuilding");

	Params::PhysicsFunctions_IsPointInBuilding Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PointToTest = std::move(PointToTest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PhysicsFunctions.IsPointInWater
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Depth                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WaterSurfaceLocation                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PointToTest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DetectionLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysicsFunctions::IsPointInWater(float* Depth, struct FVector* WaterSurfaceLocation, class UObject* WorldContextObject, const struct FVector& PointToTest, float DetectionLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysicsFunctions", "IsPointInWater");

	Params::PhysicsFunctions_IsPointInWater Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PointToTest = std::move(PointToTest);
	Parms.DetectionLength = DetectionLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Depth != nullptr)
		*Depth = Parms.Depth;

	if (WaterSurfaceLocation != nullptr)
		*WaterSurfaceLocation = std::move(Parms.WaterSurfaceLocation);

	return Parms.ReturnValue;
}


// Function Flame.PlatformStore.OnStoreEmpty
// (Final, Native, Public, BlueprintCallable)

void UPlatformStore::OnStoreEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStore", "OnStoreEmpty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlatformStoreSystem.GetPlatformStoreOffersManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlatformStoreOffersManager*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformStoreOffersManager* UPlatformStoreSystem::GetPlatformStoreOffersManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlatformStoreSystem", "GetPlatformStoreOffersManager");

	Params::PlatformStoreSystem_GetPlatformStoreOffersManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreSystem.CheckoutInSystemShop
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::CheckoutInSystemShop(const struct FUniqueNetIdRepl& InUserId, const class FString& ProductId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "CheckoutInSystemShop");

	Params::PlatformStoreSystem_CheckoutInSystemShop Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.ProductId = std::move(ProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreSystem.GetCurrentPurchaseRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPlatformStorePurchaseHandlerBase*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformStorePurchaseHandlerBase* UPlatformStoreSystem::GetCurrentPurchaseRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "GetCurrentPurchaseRequest");

	Params::PlatformStoreSystem_GetCurrentPurchaseRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreSystem.OnPurchaseFinished
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudRequestResult              CloudRequestResult                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameStorePurchaseResult         GameStorePurchaseResult                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlatformStoreSystem::OnPurchaseFinished(const struct FCloudRequestResult& CloudRequestResult, const struct FGameStorePurchaseResult& GameStorePurchaseResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "OnPurchaseFinished");

	Params::PlatformStoreSystem_OnPurchaseFinished Parms{};

	Parms.CloudRequestResult = std::move(CloudRequestResult);
	Parms.GameStorePurchaseResult = std::move(GameStorePurchaseResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlatformStoreSystem.OnStoreOverlayActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformStoreSystem::OnStoreOverlayActivated(bool bIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "OnStoreOverlayActivated");

	Params::PlatformStoreSystem_OnStoreOverlayActivated Parms{};

	Parms.bIsActive = bIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlatformStoreSystem.OpenSystemShop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::OpenSystemShop(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "OpenSystemShop");

	Params::PlatformStoreSystem_OpenSystemShop Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreSystem.OpenSystemShopItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlatformProductId                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::OpenSystemShopItem(int32 ControllerId, const class FString& PlatformProductId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "OpenSystemShopItem");

	Params::PlatformStoreSystem_OpenSystemShopItem Parms{};

	Parms.ControllerId = ControllerId;
	Parms.PlatformProductId = std::move(PlatformProductId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.PlatformStoreSystem.RefreshPlatformPurchasesFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequestResult              Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlatformStoreSystem::RefreshPlatformPurchasesFinished__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const struct FCloudRequestResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "RefreshPlatformPurchasesFinished__DelegateSignature");

	Params::PlatformStoreSystem_RefreshPlatformPurchasesFinished__DelegateSignature Parms{};

	Parms.Userid = std::move(Userid);
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlatformStoreSystem.RefreshPlatformPurchasesOnCloud
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 ControllerUserId                                       (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::RefreshPlatformPurchasesOnCloud(const class APlayerController* Controller, struct FUniqueNetIdRepl* ControllerUserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "RefreshPlatformPurchasesOnCloud");

	Params::PlatformStoreSystem_RefreshPlatformPurchasesOnCloud Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ControllerUserId != nullptr)
		*ControllerUserId = std::move(Parms.ControllerUserId);

	return Parms.ReturnValue;
}


// Function Flame.PlatformStoreSystem.SetPurchaseFinishedDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FCloudRequestResult& CloudRequestResult, struct FGameStorePurchaseResult& GameStorePurchaseResult)>Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UPlatformStoreSystem::SetPurchaseFinishedDelegate(TDelegate<void(struct FCloudRequestResult& CloudRequestResult, struct FGameStorePurchaseResult& GameStorePurchaseResult)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "SetPurchaseFinishedDelegate");

	Params::PlatformStoreSystem_SetPurchaseFinishedDelegate Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlatformStoreSystem.ShowLastPlatfromRefreshErrorMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::ShowLastPlatfromRefreshErrorMessage(const struct FUniqueNetIdRepl& InUserId, bool ClearError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "ShowLastPlatfromRefreshErrorMessage");

	Params::PlatformStoreSystem_ShowLastPlatfromRefreshErrorMessage Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.ClearError = ClearError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.PlatformStoreSystem.SystemShopClosed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Purchased                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformStoreSystem::SystemShopClosed__DelegateSignature(bool Purchased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "SystemShopClosed__DelegateSignature");

	Params::PlatformStoreSystem_SystemShopClosed__DelegateSignature Parms{};

	Parms.Purchased = Purchased;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlatformStoreSystem.IsAllowedToMakePurchases
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 Userid                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformStoreSystem::IsAllowedToMakePurchases(const struct FUniqueNetIdRepl& Userid) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformStoreSystem", "IsAllowedToMakePurchases");

	Params::PlatformStoreSystem_IsAllowedToMakePurchases Parms{};

	Parms.Userid = std::move(Userid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformToolsSteam.IsMicrotransactionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformToolsSteam::IsMicrotransactionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformToolsSteam", "IsMicrotransactionEnabled");

	Params::PlatformToolsSteam_IsMicrotransactionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlatformToolsSteam.IsOverlayEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformToolsSteam::IsOverlayEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformToolsSteam", "IsOverlayEnabled");

	Params::PlatformToolsSteam_IsOverlayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerGroupInfo.CheckNewPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerGroupInfo::CheckNewPlayer(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGroupInfo", "CheckNewPlayer");

	Params::PlayerGroupInfo_CheckNewPlayer Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerGroupInfo.FindPlayerStartForController
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStartFlame*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStartFlame* UPlayerGroupInfo::FindPlayerStartForController(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGroupInfo", "FindPlayerStartForController");

	Params::PlayerGroupInfo_FindPlayerStartForController Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerGroupInfo.GetControllers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AHumanPlayerController*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AHumanPlayerController*> UPlayerGroupInfo::GetControllers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGroupInfo", "GetControllers");

	Params::PlayerGroupInfo_GetControllers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerGroupInfo.GetPrimaryGroupStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerStartPrimary*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStartPrimary* UPlayerGroupInfo::GetPrimaryGroupStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGroupInfo", "GetPrimaryGroupStart");

	Params::PlayerGroupInfo_GetPrimaryGroupStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerGroupInfo.GetPlayerCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    OnlyActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerGroupInfo::GetPlayerCount(bool OnlyActive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerGroupInfo", "GetPlayerCount");

	Params::PlayerGroupInfo_GetPlayerCount Parms{};

	Parms.OnlyActive = OnlyActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerInfoWidget.OnPlayerChanged
// (Event, Protected, BlueprintEvent)

void UPlayerInfoWidget::OnPlayerChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "OnPlayerChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.PlayerInfoWidget.SetPlayerNetId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoWidget::SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "SetPlayerNetId");

	Params::PlayerInfoWidget_SetPlayerNetId Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerInfoWidget.IsValidPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoWidget::IsValidPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "IsValidPlayer");

	Params::PlayerInfoWidget_IsValidPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerLobby.PreparePlayerStarts
// (Native, Event, Public, BlueprintEvent)

void APlayerLobby::PreparePlayerStarts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLobby", "PreparePlayerStarts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerLobby.SelectNextLobbyStartForPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStartFlame*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStartFlame* APlayerLobby::SelectNextLobbyStartForPlayer(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLobby", "SelectNextLobbyStartForPlayer");

	Params::PlayerLobby_SelectNextLobbyStartForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerLobby.SetReady
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMarketplaceComponent*            TheInstigator                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerLobby::SetReady(class UMarketplaceComponent* TheInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLobby", "SetReady");

	Params::PlayerLobby_SetReady Parms{};

	Parms.TheInstigator = TheInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlayerNicknameWidget.AdjustIconSizeToFontSize
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FontSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                           Icon                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNicknameWidget::AdjustIconSizeToFontSize(int32 FontSize, class UImage* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNicknameWidget", "AdjustIconSizeToFontSize");

	Params::PlayerNicknameWidget_AdjustIconSizeToFontSize Parms{};

	Parms.FontSize = FontSize;
	Parms.Icon = Icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.PlayerNicknameWidget.SetDefaultNameAndPlatform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlamePlatform                          Platform                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNicknameWidget::SetDefaultNameAndPlatform(const class FString& Name_0, EFlamePlatform Platform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNicknameWidget", "SetDefaultNameAndPlatform");

	Params::PlayerNicknameWidget_SetDefaultNameAndPlatform Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Platform = Platform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerNicknameWidget.SetMaximumCharacters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNicknameWidget::SetMaximumCharacters(int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNicknameWidget", "SetMaximumCharacters");

	Params::PlayerNicknameWidget_SetMaximumCharacters Parms{};

	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerNicknameWidget.SetPlayerNetId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNicknameWidget::SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNicknameWidget", "SetPlayerNetId");

	Params::PlayerNicknameWidget_SetPlayerNetId Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerNicknameWidget.SetPlayerOfflineInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlamePlatform                          Platform                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNicknameWidget::SetPlayerOfflineInfo(const struct FUniqueNetIdRepl& InPlayerNetId, const class FString& Name_0, EFlamePlatform Platform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNicknameWidget", "SetPlayerOfflineInfo");

	Params::PlayerNicknameWidget_SetPlayerOfflineInfo Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);
	Parms.Name_0 = std::move(Name_0);
	Parms.Platform = Platform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerNotification.OnPlayerChanged
// (Native, Event, Protected, BlueprintEvent)

void UPlayerNotification::OnPlayerChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNotification", "OnPlayerChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerNotification.SetPlayerNetId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerNotification::SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerNotification", "SetPlayerNetId");

	Params::PlayerNotification_SetPlayerNetId Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerPresenceWidget.OnPresenceUpdated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// EPlayerPresence                         InPresence                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerPresenceWidget::OnPresenceUpdated(EPlayerPresence InPresence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPresenceWidget", "OnPresenceUpdated");

	Params::PlayerPresenceWidget_OnPresenceUpdated Parms{};

	Parms.InPresence = InPresence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayerPresenceWidget.SetPlayerNetId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerPresenceWidget::SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPresenceWidget", "SetPlayerNetId");

	Params::PlayerPresenceWidget_SetPlayerNetId Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.PlayersFunctions.GetAvailableAmmo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AAmmoItem>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AAmmoItem>> UPlayersFunctions::GetAvailableAmmo(const class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetAvailableAmmo");

	Params::PlayersFunctions_GetAvailableAmmo Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetAvailableConsumables
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AConsumableItem>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AConsumableItem>> UPlayersFunctions::GetAvailableConsumables(const class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetAvailableConsumables");

	Params::PlayersFunctions_GetAvailableConsumables Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetAvailableWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AWeapon>>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AWeapon>> UPlayersFunctions::GetAvailableWeapons(const class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetAvailableWeapons");

	Params::PlayersFunctions_GetAvailableWeapons Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetAverageDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetAverageDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetAverageDistToPlayers");

	Params::PlayersFunctions_GetAverageDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetAverageSquaredDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetAverageSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetAverageSquaredDistToPlayers");

	Params::PlayersFunctions_GetAverageSquaredDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetMaxDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetMaxDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetMaxDistToPlayers");

	Params::PlayersFunctions_GetMaxDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetMaxSquaredDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetMaxSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetMaxSquaredDistToPlayers");

	Params::PlayersFunctions_GetMaxSquaredDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetMinDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetMinDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetMinDistToPlayers");

	Params::PlayersFunctions_GetMinDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetMinSquaredDistToPlayers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayersFunctions::GetMinSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetMinSquaredDistToPlayers");

	Params::PlayersFunctions_GetMinSquaredDistToPlayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldPos = std::move(WorldPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetPlayerControllers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreWithoutPawn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerController*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerController*> UPlayersFunctions::GetPlayerControllers(class UObject* WorldContextObject, bool IgnoreWithoutPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetPlayerControllers");

	Params::PlayersFunctions_GetPlayerControllers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IgnoreWithoutPawn = IgnoreWithoutPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayersFunctions.GetPlayersCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreWithoutPawn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayersFunctions::GetPlayersCount(class UObject* WorldContextObject, bool IgnoreWithoutPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayersFunctions", "GetPlayersCount");

	Params::PlayersFunctions_GetPlayersCount Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IgnoreWithoutPawn = IgnoreWithoutPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PlayerStartPrimary.FindStartForPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHumanPlayerController*           Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStartFlame*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStartFlame* APlayerStartPrimary::FindStartForPlayer(class AHumanPlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStartPrimary", "FindStartForPlayer");

	Params::PlayerStartPrimary_FindStartForPlayer Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PoiseComponent.Inflict
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageType                             DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPoiseInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPoiseInfo UPoiseComponent::Inflict(float Damage, const class AWeapon* Weapon, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoiseComponent", "Inflict");

	Params::PoiseComponent_Inflict Parms{};

	Parms.Damage = Damage;
	Parms.Weapon = Weapon;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileWeapon.ClientNotifySpreadAboutFire
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void AProjectileWeapon::ClientNotifySpreadAboutFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ClientNotifySpreadAboutFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProjectileWeapon.MulticastFireBullet
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// struct FVector_NetQuantize              Location                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector_NetQuantizeNormal>Directions                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldSpawnTracer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::MulticastFireBullet(const struct FVector_NetQuantize& Location, const TArray<struct FVector_NetQuantizeNormal>& Directions, bool bShouldSpawnTracer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "MulticastFireBullet");

	Params::ProjectileWeapon_MulticastFireBullet Parms{};

	Parms.Location = std::move(Location);
	Parms.Directions = std::move(Directions);
	Parms.bShouldSpawnTracer = bShouldSpawnTracer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProjectileWeapon.OnRep_AmmoCount
// (Final, Native, Private)
// Parameters:
// int32                                   PreviousCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnRep_AmmoCount(int32 PreviousCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnRep_AmmoCount");

	Params::ProjectileWeapon_OnRep_AmmoCount Parms{};

	Parms.PreviousCount = PreviousCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProjectileWeapon.OnRep_ChamberLoadedAmmoCount
// (Final, Native, Private)
// Parameters:
// int32                                   PreviousCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnRep_ChamberLoadedAmmoCount(int32 PreviousCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnRep_ChamberLoadedAmmoCount");

	Params::ProjectileWeapon_OnRep_ChamberLoadedAmmoCount Parms{};

	Parms.PreviousCount = PreviousCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProjectileWeapon.ServerSendShot_Anticheat
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void AProjectileWeapon::ServerSendShot_Anticheat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ServerSendShot_Anticheat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProjectileWeapon.GetChamberLoadedAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetChamberLoadedAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetChamberLoadedAmmo");

	Params::ProjectileWeapon_GetChamberLoadedAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileWeapon.GetCurrentAmmoCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetCurrentAmmoCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetCurrentAmmoCount");

	Params::ProjectileWeapon_GetCurrentAmmoCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileWeapon.GetCurrentAmmoRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectileWeapon::GetCurrentAmmoRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetCurrentAmmoRatio");

	Params::ProjectileWeapon_GetCurrentAmmoRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileWeapon.GetCurrentChamberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetCurrentChamberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetCurrentChamberCount");

	Params::ProjectileWeapon_GetCurrentChamberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileWeapon.GetCurrentModifiedDispersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectileWeapon::GetCurrentModifiedDispersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetCurrentModifiedDispersion");

	Params::ProjectileWeapon_GetCurrentModifiedDispersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.PrimaryWeapon.OnEnter1PV
// (Event, Public, BlueprintEvent)

void APrimaryWeapon::OnEnter1PV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimaryWeapon", "OnEnter1PV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.PrimaryWeapon.OnExit1PV
// (Event, Public, BlueprintEvent)

void APrimaryWeapon::OnExit1PV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimaryWeapon", "OnExit1PV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ProfilePictureQuery.OnDownloadImageFailed
// (Final, Native, Protected)
// Parameters:
// class UTexture2DDynamic*                Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureQuery::OnDownloadImageFailed(class UTexture2DDynamic* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureQuery", "OnDownloadImageFailed");

	Params::ProfilePictureQuery_OnDownloadImageFailed Parms{};

	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProfilePictureQuery.OnDownloadImageSucceeded
// (Final, Native, Protected)
// Parameters:
// class UTexture2DDynamic*                Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureQuery::OnDownloadImageSucceeded(class UTexture2DDynamic* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureQuery", "OnDownloadImageSucceeded");

	Params::ProfilePictureQuery_OnDownloadImageSucceeded Parms{};

	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProfilePictureWidget.OnDownloadCompleted
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2DDynamic*                InTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureWidget::OnDownloadCompleted(const struct FUniqueNetIdRepl& InPlayerNetId, class UTexture2DDynamic* InTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureWidget", "OnDownloadCompleted");

	Params::ProfilePictureWidget_OnDownloadCompleted Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);
	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProfilePictureWidget.OnDownloadStarted
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureWidget::OnDownloadStarted(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureWidget", "OnDownloadStarted");

	Params::ProfilePictureWidget_OnDownloadStarted Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ProfilePictureWidget.SetPlayerNetId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUniqueNetIdRepl                 InPlayerNetId                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProfilePictureWidget::SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProfilePictureWidget", "SetPlayerNetId");

	Params::ProfilePictureWidget_SetPlayerNetId Parms{};

	Parms.InPlayerNetId = std::move(InPlayerNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.AddBulletImpactEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  OwnerHuman                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ParticleSystem                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::AddBulletImpactEmitter(class AHumanCharacter* OwnerHuman, EPhysicalSurface Surface, class UParticleSystemComponent* ParticleSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "AddBulletImpactEmitter");

	Params::BulletManager_AddBulletImpactEmitter Parms{};

	Parms.OwnerHuman = OwnerHuman;
	Parms.Surface = Surface;
	Parms.ParticleSystem = ParticleSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.AddTracerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TracerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::AddTracerActor(class AActor* TracerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "AddTracerActor");

	Params::BulletManager_AddTracerActor Parms{};

	Parms.TracerActor = TracerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.CreateTrace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItem>                ProjectileClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileTracer*                Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  ProjectileOwner                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          OwningWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FirePositionRaw                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FireDirectionRaw                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::CreateTrace(const TSubclassOf<class AItem>& ProjectileClass, const struct FVector& Location, const struct FVector& Direction, class AProjectileTracer* Projectile, class AHumanCharacter* ProjectileOwner, class AWeapon* OwningWeapon, const struct FVector& FirePositionRaw, const struct FVector& FireDirectionRaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "CreateTrace");

	Params::BulletManager_CreateTrace Parms{};

	Parms.ProjectileClass = ProjectileClass;
	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);
	Parms.Projectile = Projectile;
	Parms.ProjectileOwner = ProjectileOwner;
	Parms.OwningWeapon = OwningWeapon;
	Parms.FirePositionRaw = std::move(FirePositionRaw);
	Parms.FireDirectionRaw = std::move(FireDirectionRaw);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.OnHit
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TSubclassOf<class AItem>                BulletType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitResultOptimised                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  OwnerCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPenetrating                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDeformed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::OnHit(TSubclassOf<class AItem> BulletType, const struct FHitResultSimplified& HitResultOptimised, const class AHumanCharacter* OwnerCharacter, bool bIsPenetrating, bool bIsDeformed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "OnHit");

	Params::BulletManager_OnHit Parms{};

	Parms.BulletType = BulletType;
	Parms.HitResultOptimised = std::move(HitResultOptimised);
	Parms.OwnerCharacter = OwnerCharacter;
	Parms.bIsPenetrating = bIsPenetrating;
	Parms.bIsDeformed = bIsDeformed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.OnHitRelativePosition
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// TSubclassOf<class AItem>                BulletType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitResultOptimised                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  OwnerCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPenetrating                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDeformed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativeHitPosition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::OnHitRelativePosition(TSubclassOf<class AItem> BulletType, const struct FHitResultSimplified& HitResultOptimised, const class AHumanCharacter* OwnerCharacter, bool bIsPenetrating, bool bIsDeformed, const struct FVector& RelativeHitPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "OnHitRelativePosition");

	Params::BulletManager_OnHitRelativePosition Parms{};

	Parms.BulletType = BulletType;
	Parms.HitResultOptimised = std::move(HitResultOptimised);
	Parms.OwnerCharacter = OwnerCharacter;
	Parms.bIsPenetrating = bIsPenetrating;
	Parms.bIsDeformed = bIsDeformed;
	Parms.RelativeHitPosition = std::move(RelativeHitPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.OnProjectileFlyby
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EProjectileType                         ProjectileType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileOriginLocation                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileRectangularLocation                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerVictim                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerIsBeingHit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::OnProjectileFlyby(EProjectileType ProjectileType, const struct FVector& ProjectileOriginLocation, const struct FVector& ProjectileRectangularLocation, const class AHumanCharacter* PlayerVictim, const class AHumanCharacter* PlayerInstigator, bool bPlayerIsBeingHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "OnProjectileFlyby");

	Params::BulletManager_OnProjectileFlyby Parms{};

	Parms.ProjectileType = ProjectileType;
	Parms.ProjectileOriginLocation = std::move(ProjectileOriginLocation);
	Parms.ProjectileRectangularLocation = std::move(ProjectileRectangularLocation);
	Parms.PlayerVictim = PlayerVictim;
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.bPlayerIsBeingHit = bPlayerIsBeingHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BulletManager.OnProjectileFlybyGeneric
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EProjectileType                         ProjectileType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileOriginLocation                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerVictim                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerIsBeingHit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResultSimplified             HitOptimised                                           (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABulletManager::OnProjectileFlybyGeneric(EProjectileType ProjectileType, const struct FVector& ProjectileOriginLocation, const class AHumanCharacter* PlayerVictim, const class AHumanCharacter* PlayerInstigator, bool bPlayerIsBeingHit, const struct FHitResultSimplified& HitOptimised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "OnProjectileFlybyGeneric");

	Params::BulletManager_OnProjectileFlybyGeneric Parms{};

	Parms.ProjectileType = ProjectileType;
	Parms.ProjectileOriginLocation = std::move(ProjectileOriginLocation);
	Parms.PlayerVictim = PlayerVictim;
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.bPlayerIsBeingHit = bPlayerIsBeingHit;
	Parms.HitOptimised = std::move(HitOptimised);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.BulletManager.PlayArrowWhizz
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WhizzLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ABulletManager::PlayArrowWhizz(const struct FVector& WhizzLocation, float ArrowSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "PlayArrowWhizz");

	Params::BulletManager_PlayArrowWhizz Parms{};

	Parms.WhizzLocation = std::move(WhizzLocation);
	Parms.ArrowSpeed = ArrowSpeed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.BulletManager.PlayBulletSonicCrack
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          SonicCrackLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BulletOrigin                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BulletSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerVictim                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerIsBeingHit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsProjectileDeformed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ABulletManager::PlayBulletSonicCrack(const struct FVector& SonicCrackLocation, const struct FVector& BulletOrigin, float BulletSpeed, const class AHumanCharacter* PlayerVictim, bool bPlayerIsBeingHit, bool bIsProjectileDeformed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "PlayBulletSonicCrack");

	Params::BulletManager_PlayBulletSonicCrack Parms{};

	Parms.SonicCrackLocation = std::move(SonicCrackLocation);
	Parms.BulletOrigin = std::move(BulletOrigin);
	Parms.BulletSpeed = BulletSpeed;
	Parms.PlayerVictim = PlayerVictim;
	Parms.bPlayerIsBeingHit = bPlayerIsBeingHit;
	Parms.bIsProjectileDeformed = bIsProjectileDeformed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.BulletManager.PlayBulletWhizz
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WhizzLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BulletOrigin                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BulletSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  PlayerVictim                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerIsBeingHit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsProjectileDeformed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ABulletManager::PlayBulletWhizz(const struct FVector& WhizzLocation, const struct FVector& BulletOrigin, float BulletSpeed, const class AHumanCharacter* PlayerVictim, bool bPlayerIsBeingHit, bool bIsProjectileDeformed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "PlayBulletWhizz");

	Params::BulletManager_PlayBulletWhizz Parms{};

	Parms.WhizzLocation = std::move(WhizzLocation);
	Parms.BulletOrigin = std::move(BulletOrigin);
	Parms.BulletSpeed = BulletSpeed;
	Parms.PlayerVictim = PlayerVictim;
	Parms.bPlayerIsBeingHit = bPlayerIsBeingHit;
	Parms.bIsProjectileDeformed = bIsProjectileDeformed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.BulletManager.RemoveTracerActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           TracerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::RemoveTracerActor(class AActor* TracerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "RemoveTracerActor");

	Params::BulletManager_RemoveTracerActor Parms{};

	Parms.TracerActor = TracerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.StopArrowWhizz
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAudioComponent*                  WhizzSound                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletManager::StopArrowWhizz(class UAudioComponent* WhizzSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "StopArrowWhizz");

	Params::BulletManager_StopArrowWhizz Parms{};

	Parms.WhizzSound = WhizzSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.BulletManager.TryMovingBulletImpactEmitter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AHumanCharacter*                  OwnerHuman                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABulletManager::TryMovingBulletImpactEmitter(class AHumanCharacter* OwnerHuman, EPhysicalSurface Surface, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletManager", "TryMovingBulletImpactEmitter");

	Params::BulletManager_TryMovingBulletImpactEmitter Parms{};

	Parms.OwnerHuman = OwnerHuman;
	Parms.Surface = Surface;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ProjectileBlueprintLibrary.GetBulletTraceChannel
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UProjectileBlueprintLibrary::GetBulletTraceChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileBlueprintLibrary", "GetBulletTraceChannel");

	Params::ProjectileBlueprintLibrary_GetBulletTraceChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.RadiationShieldingComponent.AddShielding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERadiationShieldingLevel                Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadiationShieldingComponent::AddShielding(ERadiationShieldingLevel Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "AddShielding");

	Params::RadiationShieldingComponent_AddShielding Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RadiationShieldingComponent.OnBuildingEnter
// (Final, Native, Private)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadiationShieldingComponent::OnBuildingEnter(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "OnBuildingEnter");

	Params::RadiationShieldingComponent_OnBuildingEnter Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RadiationShieldingComponent.OnBuildingLeave
// (Final, Native, Private)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadiationShieldingComponent::OnBuildingLeave(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "OnBuildingLeave");

	Params::RadiationShieldingComponent_OnBuildingLeave Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RadiationShieldingComponent.RemoveShielding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERadiationShieldingLevel                Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadiationShieldingComponent::RemoveShielding(ERadiationShieldingLevel Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "RemoveShielding");

	Params::RadiationShieldingComponent_RemoveShielding Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RadiationShieldingComponent.RequestAcquireController
// (Final, Native, Private)

void URadiationShieldingComponent::RequestAcquireController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "RequestAcquireController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RadiationShieldingComponent.GetCurrentRadiationShieldingLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERadiationShieldingLevel                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERadiationShieldingLevel URadiationShieldingComponent::GetCurrentRadiationShieldingLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiationShieldingComponent", "GetCurrentRadiationShieldingLevel");

	Params::RadiationShieldingComponent_GetCurrentRadiationShieldingLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.RichPresence.SetRichPresence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichPresence::SetRichPresence(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RichPresence", "SetRichPresence");

	Params::RichPresence_SetRichPresence Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverSplineComponent.DeleteColliders
// (Final, Native, Public, BlueprintCallable)

void URiverSplineComponent::DeleteColliders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverSplineComponent", "DeleteColliders");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverSplineComponent.GenerateColliders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HeightAddition                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceStep                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WidthStep                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRiverSplinePointDimensions>PointDimensions                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void URiverSplineComponent::GenerateColliders(const float HeightAddition, const float DistanceStep, const float WidthStep, const TArray<struct FRiverSplinePointDimensions>& PointDimensions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverSplineComponent", "GenerateColliders");

	Params::RiverSplineComponent_GenerateColliders Parms{};

	Parms.HeightAddition = HeightAddition;
	Parms.DistanceStep = DistanceStep;
	Parms.WidthStep = WidthStep;
	Parms.PointDimensions = std::move(PointDimensions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverSplineComponent.SetScaleAtRiverSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIdx                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiverSplineComponent::SetScaleAtRiverSplinePoint(const int32 PointIdx, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverSplineComponent", "SetScaleAtRiverSplinePoint");

	Params::RiverSplineComponent_SetScaleAtRiverSplinePoint Parms{};

	Parms.PointIdx = PointIdx;
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverSplineComponent.UpdateMaxFordingDepth
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   NewMaxFordingDepth                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiverSplineComponent::UpdateMaxFordingDepth(const float& NewMaxFordingDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverSplineComponent", "UpdateMaxFordingDepth");

	Params::RiverSplineComponent_UpdateMaxFordingDepth Parms{};

	Parms.NewMaxFordingDepth = NewMaxFordingDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.RiverSplineComponent.GetSplinePointAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URiverSplineComponent::GetSplinePointAtDistanceAlongSpline(const float Distance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverSplineComponent", "GetSplinePointAtDistanceAlongSpline");

	Params::RiverSplineComponent_GetSplinePointAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ScarecrowActor.MulticastOnPlayerDied
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScarecrowActor::MulticastOnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, class AHumanCharacter* InstigatingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScarecrowActor", "MulticastOnPlayerDied");

	Params::ScarecrowActor_MulticastOnPlayerDied Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitResult = std::move(HitResult);
	Parms.InstigatingCharacter = InstigatingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ScarecrowActor.OnPlayerDied
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScarecrowActor::OnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, class AHumanCharacter* InstigatingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScarecrowActor", "OnPlayerDied");

	Params::ScarecrowActor_OnPlayerDied Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitResult = std::move(HitResult);
	Parms.InstigatingCharacter = InstigatingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ScarecrowActor.TakeDamageBlueprint
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  InstigatingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScarecrowActor::TakeDamageBlueprint(float DamageAmount, class AHumanCharacter* InstigatingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScarecrowActor", "TakeDamageBlueprint");

	Params::ScarecrowActor_TakeDamageBlueprint Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.InstigatingCharacter = InstigatingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.SceneComponentSmoothing.SetSourceComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponentSmoothing::SetSourceComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneComponentSmoothing", "SetSourceComponent");

	Params::SceneComponentSmoothing_SetSourceComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SectionHeaderWidget.SetSectionNameAndType
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EStashSection                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USectionHeaderWidget::SetSectionNameAndType(const class FText& InText, EStashSection Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SectionHeaderWidget", "SetSectionNameAndType");

	Params::SectionHeaderWidget_SetSectionNameAndType Parms{};

	Parms.InText = std::move(InText);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelComponent.CloseWheel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void USelectionWheelComponent::CloseWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "CloseWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelComponent.OpenWheel
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESelectionWheelType                     WheelType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheelComponent::OpenWheel(const ESelectionWheelType& WheelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "OpenWheel");

	Params::SelectionWheelComponent_OpenWheel Parms{};

	Parms.WheelType = WheelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelComponent.SelectLastItem
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESelectionWheelType                     WheelType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheelComponent::SelectLastItem(const ESelectionWheelType& WheelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "SelectLastItem");

	Params::SelectionWheelComponent_SelectLastItem Parms{};

	Parms.WheelType = WheelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelComponent.SetWeaponWheelIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheelComponent::SetWeaponWheelIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "SetWeaponWheelIndex");

	Params::SelectionWheelComponent_SetWeaponWheelIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelComponent.CanWheelOpen
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ESelectionWheelType                     WheelType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USelectionWheelComponent::CanWheelOpen(const ESelectionWheelType& WheelType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "CanWheelOpen");

	Params::SelectionWheelComponent_CanWheelOpen Parms{};

	Parms.WheelType = WheelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheelComponent.GetWeaponIndices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<int32> USelectionWheelComponent::GetWeaponIndices() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "GetWeaponIndices");

	Params::SelectionWheelComponent_GetWeaponIndices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheelComponent.IsWheelOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USelectionWheelComponent::IsWheelOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelComponent", "IsWheelOpen");

	Params::SelectionWheelComponent_IsWheelOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SelectionWheelWeaponSlot.SetAmmoAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectionWheelWeaponSlot::SetAmmoAngle(float InAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelWeaponSlot", "SetAmmoAngle");

	Params::SelectionWheelWeaponSlot_SetAmmoAngle Parms{};

	Parms.InAngle = InAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelWeaponSlot.UpdateAmmoCountPosition
// (Final, Native, Public, BlueprintCallable)

void USelectionWheelWeaponSlot::UpdateAmmoCountPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelWeaponSlot", "UpdateAmmoCountPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SelectionWheelWeaponSlot.UpdateAmmoVisualPosition
// (Final, Native, Public, BlueprintCallable)

void USelectionWheelWeaponSlot::UpdateAmmoVisualPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectionWheelWeaponSlot", "UpdateAmmoVisualPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCraftingList.DEBUG_SetInstantCollecting
// (Final, Native, Public, BlueprintCallable)

void UShelterCraftingList::DEBUG_SetInstantCollecting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCraftingList", "DEBUG_SetInstantCollecting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCustomizationComponent.OnRepAssignedSkins
// (Final, Native, Private)

void UShelterCustomizationComponent::OnRepAssignedSkins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCustomizationComponent", "OnRepAssignedSkins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCustomizationComponent.OnRepHighlightedVariants
// (Final, Native, Private)

void UShelterCustomizationComponent::OnRepHighlightedVariants()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCustomizationComponent", "OnRepHighlightedVariants");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCustomizationComponent.OnRepOwnedBundles
// (Final, Native, Private)

void UShelterCustomizationComponent::OnRepOwnedBundles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCustomizationComponent", "OnRepOwnedBundles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCustomizationComponent.OnRepOwnedSkins
// (Final, Native, Private)

void UShelterCustomizationComponent::OnRepOwnedSkins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCustomizationComponent", "OnRepOwnedSkins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterCustomizationComponent.OnRepOwnedVariants
// (Final, Native, Private)

void UShelterCustomizationComponent::OnRepOwnedVariants()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterCustomizationComponent", "OnRepOwnedVariants");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterFunctions.BoostImprovementUpgrade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UShelterFunctions::BoostImprovementUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "BoostImprovementUpgrade");

	Params::ShelterFunctions_BoostImprovementUpgrade Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.CanBoostImprovementUpgrade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::CanBoostImprovementUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "CanBoostImprovementUpgrade");

	Params::ShelterFunctions_CanBoostImprovementUpgrade Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.CanBuildSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::CanBuildSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "CanBuildSlot");

	Params::ShelterFunctions_CanBuildSlot Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.CanCollectFromImprovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::CanCollectFromImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "CanCollectFromImprovement");

	Params::ShelterFunctions_CanCollectFromImprovement Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.CanUpgradeLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::CanUpgradeLevel(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "CanUpgradeLevel");

	Params::ShelterFunctions_CanUpgradeLevel Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.CollectFromShelterImprovementSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UShelterFunctions::CollectFromShelterImprovementSlot(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "CollectFromShelterImprovementSlot");

	Params::ShelterFunctions_CollectFromShelterImprovementSlot Parms{};

	Parms.SlotClass = SlotClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.DeconstructSpecialResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterResourceItem> ShelterResourceClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       UICallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UShelterFunctions::DeconstructSpecialResource(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, int32 Count, const class AStash* OneStash, TDelegate<void()> UICallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "DeconstructSpecialResource");

	Params::ShelterFunctions_DeconstructSpecialResource Parms{};

	Parms.ShelterResourceClass = ShelterResourceClass;
	Parms.Count = Count;
	Parms.OneStash = OneStash;
	Parms.UICallback = UICallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetAllImprovements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCloudImprovementInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCloudImprovementInfo> UShelterFunctions::GetAllImprovements(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetAllImprovements");

	Params::ShelterFunctions_GetAllImprovements Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetAllRepairs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AShelterRepair>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AShelterRepair>> UShelterFunctions::GetAllRepairs(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetAllRepairs");

	Params::ShelterFunctions_GetAllRepairs Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetBoosterTicket
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TypeKey                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetBoosterTicket(const class AStash* OneStash, const class FString& TypeKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetBoosterTicket");

	Params::ShelterFunctions_GetBoosterTicket Parms{};

	Parms.OneStash = OneStash;
	Parms.TypeKey = std::move(TypeKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetBoosterTicketDetails
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Type                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBoosterDetails                  BoosterDetails                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::GetBoosterTicketDetails(const class AStash* OneStash, const class FString& Type, int32* Index_0, struct FBoosterDetails* BoosterDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetBoosterTicketDetails");

	Params::ShelterFunctions_GetBoosterTicketDetails Parms{};

	Parms.OneStash = OneStash;
	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (BoosterDetails != nullptr)
		*BoosterDetails = std::move(Parms.BoosterDetails);

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetBoostImprovementUpgradePrice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetBoostImprovementUpgradePrice(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetBoostImprovementUpgradePrice");

	Params::ShelterFunctions_GetBoostImprovementUpgradePrice Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfChemicals
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfChemicals(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfChemicals");

	Params::ShelterFunctions_GetCountOfChemicals Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfElectronics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfElectronics(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfElectronics");

	Params::ShelterFunctions_GetCountOfElectronics Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfFertilizer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfFertilizer(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfFertilizer");

	Params::ShelterFunctions_GetCountOfFertilizer Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfFuel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfFuel(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfFuel");

	Params::ShelterFunctions_GetCountOfFuel Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfGlass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfGlass(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfGlass");

	Params::ShelterFunctions_GetCountOfGlass Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfImprovementsInProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfImprovementsInProgress(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfImprovementsInProgress");

	Params::ShelterFunctions_GetCountOfImprovementsInProgress Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfLootForCollectFromImprovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfLootForCollectFromImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfLootForCollectFromImprovement");

	Params::ShelterFunctions_GetCountOfLootForCollectFromImprovement Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfLootForCollectFromImprovementWithPrecision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShelterFunctions::GetCountOfLootForCollectFromImprovementWithPrecision(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfLootForCollectFromImprovementWithPrecision");

	Params::ShelterFunctions_GetCountOfLootForCollectFromImprovementWithPrecision Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfMetalParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfMetalParts(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfMetalParts");

	Params::ShelterFunctions_GetCountOfMetalParts Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfNails
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfNails(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfNails");

	Params::ShelterFunctions_GetCountOfNails Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfShelterResource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterResourceItem> ShelterResourceClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfShelterResource(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfShelterResource");

	Params::ShelterFunctions_GetCountOfShelterResource Parms{};

	Parms.ShelterResourceClass = ShelterResourceClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCountOfWire
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCountOfWire(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCountOfWire");

	Params::ShelterFunctions_GetCountOfWire Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCraftingTableLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCraftingTableLevel(const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCraftingTableLevel");

	Params::ShelterFunctions_GetCraftingTableLevel Parms{};

	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCurrentGeneratorRateMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShelterFunctions::GetCurrentGeneratorRateMultiplier(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCurrentGeneratorRateMultiplier");

	Params::ShelterFunctions_GetCurrentGeneratorRateMultiplier Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetCurrentImprovementLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetCurrentImprovementLevel(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetCurrentImprovementLevel");

	Params::ShelterFunctions_GetCurrentImprovementLevel Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetFoodCurrency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetFoodCurrency(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetFoodCurrency");

	Params::ShelterFunctions_GetFoodCurrency Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetFoodCurrencyCap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetFoodCurrencyCap(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetFoodCurrencyCap");

	Params::ShelterFunctions_GetFoodCurrencyCap Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetGeneratorRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBonusMode                              Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShelterFunctions::GetGeneratorRate(TSubclassOf<class AShelterSlot> Slot, int32 Level, const class AStash* OneStash, EBonusMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetGeneratorRate");

	Params::ShelterFunctions_GetGeneratorRate Parms{};

	Parms.Slot = Slot;
	Parms.Level = Level;
	Parms.OneStash = OneStash;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetHardCurrency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetHardCurrency(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetHardCurrency");

	Params::ShelterFunctions_GetHardCurrency Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetHardCurrencyCap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetHardCurrencyCap(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetHardCurrencyCap");

	Params::ShelterFunctions_GetHardCurrencyCap Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetImprovementsCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetImprovementsCount(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetImprovementsCount");

	Params::ShelterFunctions_GetImprovementsCount Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetImprovementSlotState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShelterSlotInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FShelterSlotInfo UShelterFunctions::GetImprovementSlotState(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetImprovementSlotState");

	Params::ShelterFunctions_GetImprovementSlotState Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetImprovementStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudImprovementInfo            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCloudImprovementInfo UShelterFunctions::GetImprovementStatus(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetImprovementStatus");

	Params::ShelterFunctions_GetImprovementStatus Parms{};

	Parms.SlotClass = SlotClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetImprovementTextDescriptionForLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterImprovement>  Improvement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EShelterImprovementDescription          Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImprovementTextDescription      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FImprovementTextDescription UShelterFunctions::GetImprovementTextDescriptionForLevel(TSubclassOf<class AShelterImprovement> Improvement, TSubclassOf<class AShelterSlot> Slot, int32 Level, EShelterImprovementDescription Mode, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetImprovementTextDescriptionForLevel");

	Params::ShelterFunctions_GetImprovementTextDescriptionForLevel Parms{};

	Parms.Improvement = Improvement;
	Parms.Slot = Slot;
	Parms.Level = Level;
	Parms.Mode = Mode;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetInfoAboutImprovementInSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShelterImprovementInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FShelterImprovementInfo UShelterFunctions::GetInfoAboutImprovementInSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetInfoAboutImprovementInSlot");

	Params::ShelterFunctions_GetInfoAboutImprovementInSlot Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetInstantPriceToUpgradeImprovementForCertainLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetInstantPriceToUpgradeImprovementForCertainLevel(TSubclassOf<class AShelterSlot> SlotClass, int32 Level, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetInstantPriceToUpgradeImprovementForCertainLevel");

	Params::ShelterFunctions_GetInstantPriceToUpgradeImprovementForCertainLevel Parms{};

	Parms.SlotClass = SlotClass;
	Parms.Level = Level;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetLevelDescriptor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   NeededLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudDataShelterLevel           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudDataShelterLevel UShelterFunctions::GetLevelDescriptor(int32 NeededLevel, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetLevelDescriptor");

	Params::ShelterFunctions_GetLevelDescriptor Parms{};

	Parms.NeededLevel = NeededLevel;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetMaterialCostForNextLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetMaterialCostForNextLevel(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetMaterialCostForNextLevel");

	Params::ShelterFunctions_GetMaterialCostForNextLevel Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetMaterialCurrency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetMaterialCurrency(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetMaterialCurrency");

	Params::ShelterFunctions_GetMaterialCurrency Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetMaterialCurrencyCap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetMaterialCurrencyCap(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetMaterialCurrencyCap");

	Params::ShelterFunctions_GetMaterialCurrencyCap Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetMaxImprovementLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetMaxImprovementLevel(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetMaxImprovementLevel");

	Params::ShelterFunctions_GetMaxImprovementLevel Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetMaxImprovementsInProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetMaxImprovementsInProgress(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetMaxImprovementsInProgress");

	Params::ShelterFunctions_GetMaxImprovementsInProgress Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetNeededImprovementsCountForNextLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetNeededImprovementsCountForNextLevel(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetNeededImprovementsCountForNextLevel");

	Params::ShelterFunctions_GetNeededImprovementsCountForNextLevel Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetNeededLevelForImprovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterImprovement>  ImprovementClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetNeededLevelForImprovement(TSubclassOf<class AShelterImprovement> ImprovementClass, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetNeededLevelForImprovement");

	Params::ShelterFunctions_GetNeededLevelForImprovement Parms{};

	Parms.ImprovementClass = ImprovementClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetNeededLevelForSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetNeededLevelForSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetNeededLevelForSlot");

	Params::ShelterFunctions_GetNeededLevelForSlot Parms{};

	Parms.Slot = Slot;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetRemainingImprovementBuildingTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UShelterFunctions::GetRemainingImprovementBuildingTime(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetRemainingImprovementBuildingTime");

	Params::ShelterFunctions_GetRemainingImprovementBuildingTime Parms{};

	Parms.SlotClass = SlotClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetRepairLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetRepairLevel(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetRepairLevel");

	Params::ShelterFunctions_GetRepairLevel Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetRepairLevelCap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetRepairLevelCap(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetRepairLevelCap");

	Params::ShelterFunctions_GetRepairLevelCap Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetRequirementsForUpgrade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FShelterResourceInfo>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FShelterResourceInfo> UShelterFunctions::GetRequirementsForUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetRequirementsForUpgrade");

	Params::ShelterFunctions_GetRequirementsForUpgrade Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetShelterResourceMaterialCost
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterResourceItem> ShelterResourceClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetShelterResourceMaterialCost(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetShelterResourceMaterialCost");

	Params::ShelterFunctions_GetShelterResourceMaterialCost Parms{};

	Parms.ShelterResourceClass = ShelterResourceClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetSlotLootCapacity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetSlotLootCapacity(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetSlotLootCapacity");

	Params::ShelterFunctions_GetSlotLootCapacity Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetTimeToUpgradeImprovementForCertainLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBonusMode                              Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetTimeToUpgradeImprovementForCertainLevel(TSubclassOf<class AShelterSlot> SlotClass, int32 Level, const class AStash* Stash, EBonusMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetTimeToUpgradeImprovementForCertainLevel");

	Params::ShelterFunctions_GetTimeToUpgradeImprovementForCertainLevel Parms{};

	Parms.SlotClass = SlotClass;
	Parms.Level = Level;
	Parms.Stash = Stash;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.GetTimeToUpgradeImprovementForNextLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBonusMode                              Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterFunctions::GetTimeToUpgradeImprovementForNextLevel(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* Stash, EBonusMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "GetTimeToUpgradeImprovementForNextLevel");

	Params::ShelterFunctions_GetTimeToUpgradeImprovementForNextLevel Parms{};

	Parms.SlotClass = SlotClass;
	Parms.Stash = Stash;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.HasLevelForBuildImprovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterImprovement>  ImprovementClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::HasLevelForBuildImprovement(TSubclassOf<class AShelterImprovement> ImprovementClass, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "HasLevelForBuildImprovement");

	Params::ShelterFunctions_HasLevelForBuildImprovement Parms{};

	Parms.ImprovementClass = ImprovementClass;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.HasLevelForBuildSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           Stash                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::HasLevelForBuildSlot(TSubclassOf<class AShelterSlot> Slot, class AStash* Stash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "HasLevelForBuildSlot");

	Params::ShelterFunctions_HasLevelForBuildSlot Parms{};

	Parms.Slot = Slot;
	Parms.Stash = Stash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.HasToken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AToken>               TokenClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::HasToken(TSubclassOf<class AToken> TokenClass, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "HasToken");

	Params::ShelterFunctions_HasToken Parms{};

	Parms.TokenClass = TokenClass;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.IsMatchmakingAllowed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::IsMatchmakingAllowed(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "IsMatchmakingAllowed");

	Params::ShelterFunctions_IsMatchmakingAllowed Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.IsSlotFullOfLoot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::IsSlotFullOfLoot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "IsSlotFullOfLoot");

	Params::ShelterFunctions_IsSlotFullOfLoot Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.RepairLevelUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UShelterFunctions::RepairLevelUp(const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "RepairLevelUp");

	Params::ShelterFunctions_RepairLevelUp Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.UpgradeImprovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudRequest                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudRequest UShelterFunctions::UpgradeImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShelterFunctions", "UpgradeImprovement");

	Params::ShelterFunctions_UpgradeImprovement Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.IsShelterLevelLowerThanCap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::IsShelterLevelLowerThanCap(const class AStash* OneStash) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterFunctions", "IsShelterLevelLowerThanCap");

	Params::ShelterFunctions_IsShelterLevelLowerThanCap Parms{};

	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterFunctions.IsSlotLevelLowerThanCap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AShelterSlot>         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStash*                           OneStash                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterFunctions::IsSlotLevelLowerThanCap(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterFunctions", "IsSlotLevelLowerThanCap");

	Params::ShelterFunctions_IsSlotLevelLowerThanCap Parms{};

	Parms.Slot = Slot;
	Parms.OneStash = OneStash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterImprovement.SetParentShelterSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AShelterSlot>         OwnerSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShelterImprovement::SetParentShelterSlot(TSubclassOf<class AShelterSlot> OwnerSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterImprovement", "SetParentShelterSlot");

	Params::ShelterImprovement_SetParentShelterSlot Parms{};

	Parms.OwnerSlot = OwnerSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterImprovement.GetParentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AShelterSlot>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AShelterSlot> AShelterImprovement::GetParentSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterImprovement", "GetParentSlot");

	Params::ShelterImprovement_GetParentSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TabControlWidget.Lock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bApplyToParents                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::Lock(bool bApplyToParents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "Lock");

	Params::TabControlWidget_Lock Parms{};

	Parms.bApplyToParents = bApplyToParents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.OnLock
// (Event, Public, BlueprintEvent)

void UTabControlWidget::OnLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "OnLock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.TabControlWidget.OnSelectionChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::OnSelectionChanged(int32 NewIndex, int32 OldIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "OnSelectionChanged");

	Params::TabControlWidget_OnSelectionChanged Parms{};

	Parms.NewIndex = NewIndex;
	Parms.OldIndex = OldIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.TabControlWidget.OnUnlock
// (Event, Public, BlueprintEvent)

void UTabControlWidget::OnUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "OnUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.TabControlWidget.ReselectTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::ReselectTab(int32 TabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "ReselectTab");

	Params::TabControlWidget_ReselectTab Parms{};

	Parms.TabIndex = TabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.SelectNextTab
// (Final, Native, Public, BlueprintCallable)

void UTabControlWidget::SelectNextTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "SelectNextTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.SelectPreviousTab
// (Final, Native, Public, BlueprintCallable)

void UTabControlWidget::SelectPreviousTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "SelectPreviousTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.SelectTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::SelectTab(int32 TabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "SelectTab");

	Params::TabControlWidget_SelectTab Parms{};

	Parms.TabIndex = TabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.SetInitialTabIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::SetInitialTabIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "SetInitialTabIndex");

	Params::TabControlWidget_SetInitialTabIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.Unlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bApplyToParents                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabControlWidget::Unlock(bool bApplyToParents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "Unlock");

	Params::TabControlWidget_Unlock Parms{};

	Parms.bApplyToParents = bApplyToParents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabControlWidget.CreateTabs
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UTabWidget*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UTabWidget*> UTabControlWidget::CreateTabs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "CreateTabs");

	Params::TabControlWidget_CreateTabs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.TabControlWidget.GetSelectedTab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTabWidget*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTabWidget* UTabControlWidget::GetSelectedTab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "GetSelectedTab");

	Params::TabControlWidget_GetSelectedTab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TabControlWidget.GetTabCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTabControlWidget::GetTabCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "GetTabCount");

	Params::TabControlWidget_GetTabCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TabControlWidget.IsLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTabControlWidget::IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabControlWidget", "IsLocked");

	Params::TabControlWidget_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterMainTabControl.SelectMainTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShelterMainTab                         Tab                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMainTabControl::SelectMainTab(EShelterMainTab Tab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMainTabControl", "SelectMainTab");

	Params::ShelterMainTabControl_SelectMainTab Parms{};

	Parms.Tab = Tab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMainTabControl.SetInitialMainTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShelterMainTab                         Tab                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMainTabControl::SetInitialMainTab(EShelterMainTab Tab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMainTabControl", "SetInitialMainTab");

	Params::ShelterMainTabControl_SetInitialMainTab Parms{};

	Parms.Tab = Tab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMainTabControl.GetTabIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EShelterMainTab                         InTab                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShelterMainTabControl::GetTabIndex(EShelterMainTab InTab) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMainTabControl", "GetTabIndex");

	Params::ShelterMainTabControl_GetTabIndex Parms{};

	Parms.InTab = InTab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterMapTile.NativeOnCrossPlayCheckFinished
// (Native, Protected)
// Parameters:
// bool                                    bCanUserCrossPlay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMapTile::NativeOnCrossPlayCheckFinished(bool bCanUserCrossPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "NativeOnCrossPlayCheckFinished");

	Params::ShelterMapTile_NativeOnCrossPlayCheckFinished Parms{};

	Parms.bCanUserCrossPlay = bCanUserCrossPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMapTile.NativeOnPlayerJoinedGroup
// (Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InGroupId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMapTile::NativeOnPlayerJoinedGroup(const struct FUniqueNetIdRepl& InUserId, const class FString& InGroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "NativeOnPlayerJoinedGroup");

	Params::ShelterMapTile_NativeOnPlayerJoinedGroup Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.InGroupId = std::move(InGroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMapTile.NativeOnPlayerLeftGroup
// (Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 InUserId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InGroupId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMapTile::NativeOnPlayerLeftGroup(const struct FUniqueNetIdRepl& InUserId, const class FString& InGroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "NativeOnPlayerLeftGroup");

	Params::ShelterMapTile_NativeOnPlayerLeftGroup Parms{};

	Parms.InUserId = std::move(InUserId);
	Parms.InGroupId = std::move(InGroupId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.ShelterMapTile.OnMapTileFocused__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UShelterMapTile*                  InMapTile                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterMapTile::OnMapTileFocused__DelegateSignature(const class UShelterMapTile* InMapTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "OnMapTileFocused__DelegateSignature");

	Params::ShelterMapTile_OnMapTileFocused__DelegateSignature Parms{};

	Parms.InMapTile = InMapTile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.ShelterMapTile.OnTileInitialized
// (Event, Protected, BlueprintEvent)

void UShelterMapTile::OnTileInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "OnTileInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ShelterMapTile.SetCloudMapRotationSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudMapRotationSlot            InCloudMapRotationSlot                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UShelterMapTile::SetCloudMapRotationSlot(const struct FCloudMapRotationSlot& InCloudMapRotationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "SetCloudMapRotationSlot");

	Params::ShelterMapTile_SetCloudMapRotationSlot Parms{};

	Parms.InCloudMapRotationSlot = std::move(InCloudMapRotationSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMapTile.UpdateMapRotationSlot
// (Final, Native, Public)

void UShelterMapTile::UpdateMapRotationSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "UpdateMapRotationSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMapTile.UpdateRemainingTime
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UShelterMapTile::UpdateRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "UpdateRemainingTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.ShelterMapTile.UpdateVisualState
// (Final, Native, Public, BlueprintCallable)

void UShelterMapTile::UpdateVisualState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "UpdateVisualState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterMapTile.GetGameModeAlias
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UShelterMapTile::GetGameModeAlias() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "GetGameModeAlias");

	Params::ShelterMapTile_GetGameModeAlias Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterMapTile.IsAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterMapTile::IsAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "IsAllowed");

	Params::ShelterMapTile_IsAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterMapTile.IsMapRotationSlotCurrentlyValid
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMapRotationSlotEntry            InMapRotationSlot                                      (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShelterMapTile::IsMapRotationSlotCurrentlyValid(const struct FMapRotationSlotEntry& InMapRotationSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "IsMapRotationSlotCurrentlyValid");

	Params::ShelterMapTile_IsMapRotationSlotCurrentlyValid Parms{};

	Parms.InMapRotationSlot = std::move(InMapRotationSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterMapTile.ToClientDateTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        InCloudTime                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UShelterMapTile::ToClientDateTime(const struct FDateTime& InCloudTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterMapTile", "ToClientDateTime");

	Params::ShelterMapTile_ToClientDateTime Parms{};

	Parms.InCloudTime = std::move(InCloudTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterStashItemProvider.SetCurrentPlayerPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStashItemProvider::SetCurrentPlayerPawn(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStashItemProvider", "SetCurrentPlayerPawn");

	Params::ShelterStashItemProvider_SetCurrentPlayerPawn Parms{};

	Parms.InPawn = InPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStashItemProvider.SetCurrentSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStashSection                           InSection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStashItemProvider::SetCurrentSection(EStashSection InSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStashItemProvider", "SetCurrentSection");

	Params::ShelterStashItemProvider_SetCurrentSection Parms{};

	Parms.InSection = InSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStashItemProvider.SetCurrentView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventoryView                          InCurrentTab                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShelterStashItemProvider::SetCurrentView(EInventoryView InCurrentTab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStashItemProvider", "SetCurrentView");

	Params::ShelterStashItemProvider_SetCurrentView Parms{};

	Parms.InCurrentTab = InCurrentTab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStashItemProvider.UpdateUnlockedAmmoTypes
// (Final, Native, Public, BlueprintCallable)

void UShelterStashItemProvider::UpdateUnlockedAmmoTypes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStashItemProvider", "UpdateUnlockedAmmoTypes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterStashItemProvider.GetUnlockedAmmoTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<TSubclassOf<class AAmmoItem>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSubclassOf<class AAmmoItem>> UShelterStashItemProvider::GetUnlockedAmmoTypes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterStashItemProvider", "GetUnlockedAmmoTypes");

	Params::ShelterStashItemProvider_GetUnlockedAmmoTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterTimerManager.CheckCraftingState
// (Final, Native, Public, BlueprintCallable)

void AShelterTimerManager::CheckCraftingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterTimerManager", "CheckCraftingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.ShelterTimerManager.GetLastUpdateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime AShelterTimerManager::GetLastUpdateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterTimerManager", "GetLastUpdateTime");

	Params::ShelterTimerManager_GetLastUpdateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ShelterUIBase.GetItemPreviews
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AMannequin*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMannequin* AShelterUIBase::GetItemPreviews()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShelterUIBase", "GetItemPreviews");

	Params::ShelterUIBase_GetItemPreviews Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.OnlineSimpleRequestComponent.SendSimpleNoAuthGetRequestJson
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           APIName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineSimpleRequestComponent::SendSimpleNoAuthGetRequestJson(const class FString& APIName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSimpleRequestComponent", "SendSimpleNoAuthGetRequestJson");

	Params::OnlineSimpleRequestComponent_SendSimpleNoAuthGetRequestJson Parms{};

	Parms.APIName = std::move(APIName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineSimpleRequestComponent.SendSimpleNoAuthGetRequestJsonDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           APIName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJsonValue*                       Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSimpleRequestComponent::SendSimpleNoAuthGetRequestJsonDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& APIName, const class UJsonValue* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSimpleRequestComponent", "SendSimpleNoAuthGetRequestJsonDelegate__DelegateSignature");

	Params::OnlineSimpleRequestComponent_SendSimpleNoAuthGetRequestJsonDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.APIName = std::move(APIName);
	Parms.Data = Data;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.SkinFunctions.ApplySkinExtraGeometry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AItemSkin*                        Skin                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ExtraGeometryMesh                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinFunctions::ApplySkinExtraGeometry(const class AItemSkin* Skin, class USkeletalMeshComponent* ExtraGeometryMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "ApplySkinExtraGeometry");

	Params::SkinFunctions_ApplySkinExtraGeometry Parms{};

	Parms.Skin = Skin;
	Parms.ExtraGeometryMesh = ExtraGeometryMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.ApplyWeaponSkinVisual
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AItemSkin>            SkinClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinFunctions::ApplyWeaponSkinVisual(TSubclassOf<class AItemSkin> SkinClass, class AWeapon* Weapon, class UMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "ApplyWeaponSkinVisual");

	Params::SkinFunctions_ApplyWeaponSkinVisual Parms{};

	Parms.SkinClass = SkinClass;
	Parms.Weapon = Weapon;
	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.ClearExtraSkinGeometryVisuals
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MainWeaponMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinFunctions::ClearExtraSkinGeometryVisuals(class UMeshComponent* MainWeaponMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "ClearExtraSkinGeometryVisuals");

	Params::SkinFunctions_ClearExtraSkinGeometryVisuals Parms{};

	Parms.MainWeaponMesh = MainWeaponMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SkinFunctions.ClearSkinFromWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinFunctions::ClearSkinFromWeapon(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "ClearSkinFromWeapon");

	Params::SkinFunctions_ClearSkinFromWeapon Parms{};

	Parms.Player = Player;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SkinFunctions.ClearWeaponSkinVisual
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   PrimaryMesh                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinFunctions::ClearWeaponSkinVisual(class UMeshComponent* PrimaryMesh, class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "ClearWeaponSkinVisual");

	Params::SkinFunctions_ClearWeaponSkinVisual Parms{};

	Parms.PrimaryMesh = PrimaryMesh;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetAllAvailableItemSkins
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AItem>                Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItemSkin>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AItemSkin>> USkinFunctions::GetAllAvailableItemSkins(class AHumanPlayerController* Player, TSubclassOf<class AItem> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetAllAvailableItemSkins");

	Params::SkinFunctions_GetAllAvailableItemSkins Parms{};

	Parms.Player = Player;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetAllAvailableWeaponSkins
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AWeaponSkin>>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AWeaponSkin>> USkinFunctions::GetAllAvailableWeaponSkins(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetAllAvailableWeaponSkins");

	Params::SkinFunctions_GetAllAvailableWeaponSkins Parms{};

	Parms.Player = Player;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetAllOwnedSkins
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AItemSkin>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AItemSkin>> USkinFunctions::GetAllOwnedSkins(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetAllOwnedSkins");

	Params::SkinFunctions_GetAllOwnedSkins Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetAllOwnedWeaponSkins
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AWeaponSkin>>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AWeaponSkin>> USkinFunctions::GetAllOwnedWeaponSkins(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetAllOwnedWeaponSkins");

	Params::SkinFunctions_GetAllOwnedWeaponSkins Parms{};

	Parms.Player = Player;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetBasicSkinSlotNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> USkinFunctions::GetBasicSkinSlotNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetBasicSkinSlotNames");

	Params::SkinFunctions_GetBasicSkinSlotNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetExtraSkinSlotNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> USkinFunctions::GetExtraSkinSlotNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetExtraSkinSlotNames");

	Params::SkinFunctions_GetExtraSkinSlotNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetWeaponFromSkin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponSkin>          Skin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeapon> USkinFunctions::GetWeaponFromSkin(class AHumanPlayerController* Player, TSubclassOf<class AWeaponSkin> Skin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetWeaponFromSkin");

	Params::SkinFunctions_GetWeaponFromSkin Parms{};

	Parms.Player = Player;
	Parms.Skin = Skin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.GetWeaponSkin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponSkin>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AWeaponSkin> USkinFunctions::GetWeaponSkin(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "GetWeaponSkin");

	Params::SkinFunctions_GetWeaponSkin Parms{};

	Parms.Player = Player;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.LoadSkinMaterialSynchronous
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UMaterialInstance> MaterialLink                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USkinFunctions::LoadSkinMaterialSynchronous(TSoftObjectPtr<class UMaterialInstance> MaterialLink)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "LoadSkinMaterialSynchronous");

	Params::SkinFunctions_LoadSkinMaterialSynchronous Parms{};

	Parms.MaterialLink = MaterialLink;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.SetDefaultWeaponSkinVisual
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   PrimaryMesh                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinFunctions::SetDefaultWeaponSkinVisual(class UMeshComponent* PrimaryMesh, class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "SetDefaultWeaponSkinVisual");

	Params::SkinFunctions_SetDefaultWeaponSkinVisual Parms{};

	Parms.PrimaryMesh = PrimaryMesh;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SkinFunctions.SetSkinToWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponSkin>          Skin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinFunctions::SetSkinToWeapon(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon, TSubclassOf<class AWeaponSkin> Skin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkinFunctions", "SetSkinToWeapon");

	Params::SkinFunctions_SetSkinToWeapon Parms{};

	Parms.Player = Player;
	Parms.Weapon = Weapon;
	Parms.Skin = Skin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.SetBackground
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlotVisualBackground                   InBackground                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::SetBackground(ESlotVisualBackground InBackground)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "SetBackground");

	Params::SlotVisual_SetBackground Parms{};

	Parms.InBackground = InBackground;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.SetCount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::SetCount(int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "SetCount");

	Params::SlotVisual_SetCount Parms{};

	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.SetNoItemIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       InIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::SetNoItemIcon(class UTexture2D* InIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "SetNoItemIcon");

	Params::SlotVisual_SetNoItemIcon Parms{};

	Parms.InIcon = InIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.SetSlotColor
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLinearColor                     InColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::SetSlotColor(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "SetSlotColor");

	Params::SlotVisual_SetSlotColor Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.SetSlotOpacity
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::SetSlotOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "SetSlotOpacity");

	Params::SlotVisual_SetSlotOpacity Parms{};

	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.ShowEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::ShowEffect(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "ShowEffect");

	Params::SlotVisual_ShowEffect Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.ShowFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::ShowFocus(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "ShowFocus");

	Params::SlotVisual_ShowFocus Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SlotVisual.ShowInsuranceIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlotVisual::ShowInsuranceIcon(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotVisual", "ShowInsuranceIcon");

	Params::SlotVisual_ShowInsuranceIcon Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorSpringArmComponent.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpectatorSpringArmComponent::AddIgnoredActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorSpringArmComponent", "AddIgnoredActor");

	Params::SpectatorSpringArmComponent_AddIgnoredActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorSpringArmComponent.ClearIgnoredActors
// (Final, Native, Public, BlueprintCallable)

void USpectatorSpringArmComponent::ClearIgnoredActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorSpringArmComponent", "ClearIgnoredActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpectatorSpringArmComponent.RemoveIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpectatorSpringArmComponent::RemoveIgnoredActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpectatorSpringArmComponent", "RemoveIgnoredActor");

	Params::SpectatorSpringArmComponent_RemoveIgnoredActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SpeedModifierComponent.GetSpeedModifierData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FContextSpeedModifier>    OutContext                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FActiveEventSpeedModifierCurve>OutCurve                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FActiveEventSpeedModifierConstant>OutConstant                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USpeedModifierComponent::GetSpeedModifierData(TArray<struct FContextSpeedModifier>* OutContext, TArray<struct FActiveEventSpeedModifierCurve>* OutCurve, TArray<struct FActiveEventSpeedModifierConstant>* OutConstant) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeedModifierComponent", "GetSpeedModifierData");

	Params::SpeedModifierComponent_GetSpeedModifierData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutContext != nullptr)
		*OutContext = std::move(Parms.OutContext);

	if (OutCurve != nullptr)
		*OutCurve = std::move(Parms.OutCurve);

	if (OutConstant != nullptr)
		*OutConstant = std::move(Parms.OutConstant);
}


// Function Flame.CurveStamina.GetValues
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveStamina::GetValues(float InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveStamina", "GetValues");

	Params::CurveStamina_GetValues Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.CurveStaminaMultiplier.GetValues
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveStaminaMultiplier::GetValues(float InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveStaminaMultiplier", "GetValues");

	Params::CurveStaminaMultiplier_GetValues Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StartScreen.NativeOnUserLoginChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bLogin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStartScreen::NativeOnUserLoginChanged(bool bLogin, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "NativeOnUserLoginChanged");

	Params::StartScreen_NativeOnUserLoginChanged Parms{};

	Parms.bLogin = bLogin;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StartScreen.OnFirstTimeOptionsClosed
// (Final, Native, Protected)
// Parameters:
// class UFlameWidget*                     InOptionsWidget                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStartScreen::OnFirstTimeOptionsClosed(class UFlameWidget* InOptionsWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "OnFirstTimeOptionsClosed");

	Params::StartScreen_OnFirstTimeOptionsClosed Parms{};

	Parms.InOptionsWidget = InOptionsWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StartScreen.OnRefreshUI
// (Event, Protected, BlueprintEvent)

void UStartScreen::OnRefreshUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "OnRefreshUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.StartScreen.OnStartGameRequested
// (Final, Native, Protected)

void UStartScreen::OnStartGameRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "OnStartGameRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StartScreen.OnSwitchProfileRequested
// (Final, Native, Protected)

void UStartScreen::OnSwitchProfileRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "OnSwitchProfileRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StartScreen.StartGame
// (Event, Protected, BlueprintEvent)

void UStartScreen::StartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "StartGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.StartScreen.StartGameClicked
// (Final, Native, Private, BlueprintCallable)

void UStartScreen::StartGameClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "StartGameClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StartScreen.WindowsInputTypeChanged
// (Final, Native, Private, BlueprintCallable)

void UStartScreen::WindowsInputTypeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreen", "WindowsInputTypeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.OnRep_PostChangeCraftingAmmo
// (Final, Native, Protected)
// Parameters:
// class UAmmoCraftingList*                OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStashComponent::OnRep_PostChangeCraftingAmmo(class UAmmoCraftingList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "OnRep_PostChangeCraftingAmmo");

	Params::StashComponent_OnRep_PostChangeCraftingAmmo Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.OnRep_PostChangeCraftingConsumables
// (Final, Native, Protected)
// Parameters:
// class UConsumablesCraftingList*         OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStashComponent::OnRep_PostChangeCraftingConsumables(class UConsumablesCraftingList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "OnRep_PostChangeCraftingConsumables");

	Params::StashComponent_OnRep_PostChangeCraftingConsumables Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.OnRep_PostChangeCraftingShelter
// (Final, Native, Protected)
// Parameters:
// class UShelterCraftingList*             OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStashComponent::OnRep_PostChangeCraftingShelter(class UShelterCraftingList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "OnRep_PostChangeCraftingShelter");

	Params::StashComponent_OnRep_PostChangeCraftingShelter Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.OnRep_PostChangeCraftingWeapons
// (Final, Native, Protected)
// Parameters:
// class UWeaponsCraftingList*             OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStashComponent::OnRep_PostChangeCraftingWeapons(class UWeaponsCraftingList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "OnRep_PostChangeCraftingWeapons");

	Params::StashComponent_OnRep_PostChangeCraftingWeapons Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.OnRep_PostChangeTokens
// (Final, Native, Protected)
// Parameters:
// class UTokensList*                      OldContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStashComponent::OnRep_PostChangeTokens(class UTokensList* OldContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "OnRep_PostChangeTokens");

	Params::StashComponent_OnRep_PostChangeTokens Parms{};

	Parms.OldContainer = OldContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StashComponent.GetBoosterTicketCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           TypeKey                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetBoosterTicketCount(const class FString& TypeKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetBoosterTicketCount");

	Params::StashComponent_GetBoosterTicketCount Parms{};

	Parms.TypeKey = std::move(TypeKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetBoosterTicketDetails
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Type                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBoosterDetails                  BoosterDetails                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStashComponent::GetBoosterTicketDetails(const class FString& Type, int32* Index_0, struct FBoosterDetails* BoosterDetails) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetBoosterTicketDetails");

	Params::StashComponent_GetBoosterTicketDetails Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (BoosterDetails != nullptr)
		*BoosterDetails = std::move(Parms.BoosterDetails);

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetCraftingAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAmmoCraftingList*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAmmoCraftingList* UStashComponent::GetCraftingAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetCraftingAmmo");

	Params::StashComponent_GetCraftingAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetCraftingConsumables
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UConsumablesCraftingList*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConsumablesCraftingList* UStashComponent::GetCraftingConsumables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetCraftingConsumables");

	Params::StashComponent_GetCraftingConsumables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetCraftingShelter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UShelterCraftingList*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShelterCraftingList* UStashComponent::GetCraftingShelter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetCraftingShelter");

	Params::StashComponent_GetCraftingShelter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetCraftingWeapons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponsCraftingList*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponsCraftingList* UStashComponent::GetCraftingWeapons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetCraftingWeapons");

	Params::StashComponent_GetCraftingWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetCurrencyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetCurrencyCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetCurrencyCount");

	Params::StashComponent_GetCurrencyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetFoodCapacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetFoodCapacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetFoodCapacity");

	Params::StashComponent_GetFoodCapacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetFoodCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetFoodCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetFoodCount");

	Params::StashComponent_GetFoodCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetMaterialCapacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetMaterialCapacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetMaterialCapacity");

	Params::StashComponent_GetMaterialCapacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetMaterialCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetMaterialCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetMaterialCount");

	Params::StashComponent_GetMaterialCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.GetShelterLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStashComponent::GetShelterLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "GetShelterLevel");

	Params::StashComponent_GetShelterLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StashComponent.IsInitiliazed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStashComponent::IsInitiliazed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StashComponent", "IsInitiliazed");

	Params::StashComponent_IsInitiliazed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineComponent.MulticastReceivedStateEndFromServer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// struct FServerStateInfo                 Info                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStateMachineComponent::MulticastReceivedStateEndFromServer(const struct FServerStateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "MulticastReceivedStateEndFromServer");

	Params::StateMachineComponent_MulticastReceivedStateEndFromServer Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StateMachineComponent.MulticastReceivedStateStartFromServer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// struct FServerStateInfo                 Info                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStateMachineComponent::MulticastReceivedStateStartFromServer(const struct FServerStateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "MulticastReceivedStateStartFromServer");

	Params::StateMachineComponent_MulticastReceivedStateStartFromServer Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StateMachineComponent.OnRepHistory
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FItemStateHistoryInfo>    OldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachineComponent::OnRepHistory(const TArray<struct FItemStateHistoryInfo>& OldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "OnRepHistory");

	Params::StateMachineComponent_OnRepHistory Parms{};

	Parms.OldArray = std::move(OldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StateMachineComponent.OnRepStates
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FItemStatePair>           OldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachineComponent::OnRepStates(const TArray<struct FItemStatePair>& OldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "OnRepStates");

	Params::StateMachineComponent_OnRepStates Parms{};

	Parms.OldArray = std::move(OldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.StateMachineComponent.GetCurrentStateInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineComponent::GetCurrentStateInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "GetCurrentStateInfo");

	Params::StateMachineComponent_GetCurrentStateInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineComponent.GetCurrentStateInfoServer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UStateMachineComponent::GetCurrentStateInfoServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "GetCurrentStateInfoServer");

	Params::StateMachineComponent_GetCurrentStateInfoServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineComponent.GetCurrentStateInMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItemState*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemState* UStateMachineComponent::GetCurrentStateInMachine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "GetCurrentStateInMachine");

	Params::StateMachineComponent_GetCurrentStateInMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.StateMachineComponent.IsMachineEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateMachineComponent::IsMachineEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachineComponent", "IsMachineEmpty");

	Params::StateMachineComponent_IsMachineEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.SteamGameStorePurchaseHandler.SetSimulateOverlaySteam
// (Final, Exec, Native, Static, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamGameStorePurchaseHandler::SetSimulateOverlaySteam(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamGameStorePurchaseHandler", "SetSimulateOverlaySteam");

	Params::SteamGameStorePurchaseHandler_SetSimulateOverlaySteam Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SteamGameStorePurchaseHandler.CheckStorePurchaseCompleted
// (Final, Native, Protected)

void USteamGameStorePurchaseHandler::CheckStorePurchaseCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamGameStorePurchaseHandler", "CheckStorePurchaseCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SteamGameStorePurchaseHandler.StartPollingStore
// (Final, Native, Protected)

void USteamGameStorePurchaseHandler::StartPollingStore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamGameStorePurchaseHandler", "StartPollingStore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SteamGameStorePurchaseHandler.StopPollingStore
// (Final, Native, Protected)

void USteamGameStorePurchaseHandler::StopPollingStore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamGameStorePurchaseHandler", "StopPollingStore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SteamMicrotransactionGameStorePurchaseHandler.SetSimulateOverlaySteam
// (Final, Exec, Native, Static, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamMicrotransactionGameStorePurchaseHandler::SetSimulateOverlaySteam(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamMicrotransactionGameStorePurchaseHandler", "SetSimulateOverlaySteam");

	Params::SteamMicrotransactionGameStorePurchaseHandler_SetSimulateOverlaySteam Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SubtitleWidget.OnSetSubtitleText
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InSubtitleText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USubtitleWidget::OnSetSubtitleText(const class FText& InSubtitleText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleWidget", "OnSetSubtitleText");

	Params::SubtitleWidget_OnSetSubtitleText Parms{};

	Parms.InSubtitleText = std::move(InSubtitleText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SwapWeaponsWidget.OnClosed
// (Final, Native, Protected)

void USwapWeaponsWidget::OnClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwapWeaponsWidget", "OnClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SwapWeaponsWidget.OnSelectedWeaponA
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwapWeaponsWidget::OnSelectedWeaponA(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwapWeaponsWidget", "OnSelectedWeaponA");

	Params::SwapWeaponsWidget_OnSelectedWeaponA Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SwapWeaponsWidget.OnSelectedWeaponB
// (Final, Native, Protected)
// Parameters:
// class UButton*                          Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwapWeaponsWidget::OnSelectedWeaponB(class UButton* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwapWeaponsWidget", "OnSelectedWeaponB");

	Params::SwapWeaponsWidget_OnSelectedWeaponB Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.SwapWeaponsWidget.SelectWeaponOnMouseClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFlameSlot*                       WeaponSlot                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwapWeaponsWidget::SelectWeaponOnMouseClick(class UFlameSlot* WeaponSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwapWeaponsWidget", "SelectWeaponOnMouseClick");

	Params::SwapWeaponsWidget_SelectWeaponOnMouseClick Parms{};

	Parms.WeaponSlot = WeaponSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabWidget.OnDeselect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTabWidget::OnDeselect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabWidget", "OnDeselect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabWidget.OnSelect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTabWidget::OnSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabWidget", "OnSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabWidget.OnTabHovered
// (Final, Native, Protected)

void UTabWidget::OnTabHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabWidget", "OnTabHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabWidget.OnTabUnhovered
// (Final, Native, Protected)

void UTabWidget::OnTabUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabWidget", "OnTabUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TabWidget.GetTabContent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UTabWidget::GetTabContent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabWidget", "GetTabContent");

	Params::TabWidget_GetTabContent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flame.Task.AdvanceTaskCompletion
// (Final, Native, Public, BlueprintCallable)

void UTask::AdvanceTaskCompletion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "AdvanceTaskCompletion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Task.BindTaskDelegates
// (Event, Public, BlueprintEvent)

void UTask::BindTaskDelegates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "BindTaskDelegates");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Task.ChangeTaskState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETaskState                              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTask::ChangeTaskState(ETaskState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "ChangeTaskState");

	Params::Task_ChangeTaskState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Task.CompleteTask
// (Final, Native, Public, BlueprintCallable)

void UTask::CompleteTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "CompleteTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Task.GetFormattedTaskText
// (Event, Public, BlueprintEvent)

void UTask::GetFormattedTaskText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "GetFormattedTaskText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Task.StartTask
// (Final, Native, Public, BlueprintCallable)

void UTask::StartTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "StartTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Task.UnBindTaskDelegates
// (Event, Public, BlueprintEvent)

void UTask::UnBindTaskDelegates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "UnBindTaskDelegates");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.Task.UpdateTask
// (Event, Public, BlueprintEvent)

void UTask::UpdateTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task", "UpdateTask");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.TaskSystemComponent.AddTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTask>                TaskToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTaskSystemComponent::AddTask(TSubclassOf<class UTask> TaskToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "AddTask");

	Params::TaskSystemComponent_AddTask Parms{};

	Parms.TaskToAdd = TaskToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TaskSystemComponent.CompleteTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TaskID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTaskSystemComponent::CompleteTask(int32 TaskID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "CompleteTask");

	Params::TaskSystemComponent_CompleteTask Parms{};

	Parms.TaskID = TaskID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TaskSystemComponent.GetReadyTasks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class UTask>>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UTask>> UTaskSystemComponent::GetReadyTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "GetReadyTasks");

	Params::TaskSystemComponent_GetReadyTasks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TaskSystemComponent.GetTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TaskID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTask*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTask* UTaskSystemComponent::GetTask(int32 TaskID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "GetTask");

	Params::TaskSystemComponent_GetTask Parms{};

	Parms.TaskID = TaskID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TaskSystemComponent.GetTaskState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TaskID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETaskState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETaskState UTaskSystemComponent::GetTaskState(int32 TaskID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "GetTaskState");

	Params::TaskSystemComponent_GetTaskState Parms{};

	Parms.TaskID = TaskID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TaskSystemComponent.HasTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TaskID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTaskSystemComponent::HasTask(int32 TaskID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSystemComponent", "HasTask");

	Params::TaskSystemComponent_HasTask Parms{};

	Parms.TaskID = TaskID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.TextNotification.OnContentChanged
// (Native, Event, Protected, BlueprintEvent)

void UTextNotification::OnContentChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextNotification", "OnContentChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TextNotification.SetMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UTextNotification::SetMessage(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextNotification", "SetMessage");

	Params::TextNotification_SetMessage Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.TextNotification.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextNotificationType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextNotification::SetType(ETextNotificationType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextNotification", "SetType");

	Params::TextNotification_SetType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Throwable.ReceiveOnThrow
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AThrowableConsumable*             ProjectileFired                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowable::ReceiveOnThrow(class AThrowableConsumable* ProjectileFired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Throwable", "ReceiveOnThrow");

	Params::Throwable_ReceiveOnThrow Parms{};

	Parms.ProjectileFired = ProjectileFired;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UICoreObject.GetItemRarity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemRarity                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemRarity UUICoreObject::GetItemRarity(int32 InIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoreObject", "GetItemRarity");

	Params::UICoreObject_GetItemRarity Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UICoreObject.GetLevelDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InLevelName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLevelDescriptionTableRow        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelDescriptionTableRow UUICoreObject::GetLevelDescription(class FName InLevelName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoreObject", "GetLevelDescription");

	Params::UICoreObject_GetLevelDescription Parms{};

	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UICoreObject.GetModalWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UModalWidget*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UModalWidget* UUICoreObject::GetModalWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoreObject", "GetModalWidget");

	Params::UICoreObject_GetModalWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UICoreObject.GetZOrder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUILayer                                InLayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUICoreObject::GetZOrder(EUILayer InLayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoreObject", "GetZOrder");

	Params::UICoreObject_GetZOrder Parms{};

	Parms.InLayer = InLayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.CloseGameMenu
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::CloseGameMenu(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "CloseGameMenu");

	Params::UserInterfaceFunctionLibrary_CloseGameMenu Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.CloseModalWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InOwningPlayer                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::CloseModalWidget(const class APlayerController* InOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "CloseModalWidget");

	Params::UserInterfaceFunctionLibrary_CloseModalWidget Parms{};

	Parms.InOwningPlayer = InOwningPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.CloseShelterUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::CloseShelterUI(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "CloseShelterUI");

	Params::UserInterfaceFunctionLibrary_CloseShelterUI Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.Conv_NetIdToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 InNetId                                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUserInterfaceFunctionLibrary::Conv_NetIdToString(const struct FUniqueNetIdRepl& InNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "Conv_NetIdToString");

	Params::UserInterfaceFunctionLibrary_Conv_NetIdToString Parms{};

	Parms.InNetId = std::move(InNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.EqualEqual_NetIdNetId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 A                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 B                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::EqualEqual_NetIdNetId(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "EqualEqual_NetIdNetId");

	Params::UserInterfaceFunctionLibrary_EqualEqual_NetIdNetId Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.ExistsModalWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InOwningPlayer                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::ExistsModalWidget(const class APlayerController* InOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ExistsModalWidget");

	Params::UserInterfaceFunctionLibrary_ExistsModalWidget Parms{};

	Parms.InOwningPlayer = InOwningPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.FindFocusedWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AHumanPlayerController*           HumanController                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUserInterfaceFunctionLibrary::FindFocusedWidget(const class AHumanPlayerController* HumanController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "FindFocusedWidget");

	Params::UserInterfaceFunctionLibrary_FindFocusedWidget Parms{};

	Parms.HumanController = HumanController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetActiveMenuWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AHumanPlayerController*           HumanController                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuWidget* UUserInterfaceFunctionLibrary::GetActiveMenuWidget(const class AHumanPlayerController* HumanController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetActiveMenuWidget");

	Params::UserInterfaceFunctionLibrary_GetActiveMenuWidget Parms{};

	Parms.HumanController = HumanController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetAllNestedUserWidgets
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      InUserWidget                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UUserWidget*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UUserWidget*> UUserInterfaceFunctionLibrary::GetAllNestedUserWidgets(const class UUserWidget* InUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetAllNestedUserWidgets");

	Params::UserInterfaceFunctionLibrary_GetAllNestedUserWidgets Parms{};

	Parms.InUserWidget = InUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetAllOpenedWidgets
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UFlameWidget*>             OutWidgets                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UFlameWidget>         InWidgetClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::GetAllOpenedWidgets(const class APlayerController* InPlayerController, TArray<class UFlameWidget*>* OutWidgets, TSubclassOf<class UFlameWidget> InWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetAllOpenedWidgets");

	Params::UserInterfaceFunctionLibrary_GetAllOpenedWidgets Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.InWidgetClass = InWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidgets != nullptr)
		*OutWidgets = std::move(Parms.OutWidgets);
}


// Function Flame.UserInterfaceFunctionLibrary.GetGameMenu
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuWidget* UUserInterfaceFunctionLibrary::GetGameMenu(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetGameMenu");

	Params::UserInterfaceFunctionLibrary_GetGameMenu Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetGrandParentUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          InWidget                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNumOfGenerations                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UUserInterfaceFunctionLibrary::GetGrandParentUserWidget(const class UWidget* InWidget, int32 InNumOfGenerations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetGrandParentUserWidget");

	Params::UserInterfaceFunctionLibrary_GetGrandParentUserWidget Parms{};

	Parms.InWidget = InWidget;
	Parms.InNumOfGenerations = InNumOfGenerations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetHighestInputPriority
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UUserWidget*>              InUserWidgets                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInterfaceFunctionLibrary::GetHighestInputPriority(TArray<class UUserWidget*>* InUserWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetHighestInputPriority");

	Params::UserInterfaceFunctionLibrary_GetHighestInputPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InUserWidgets != nullptr)
		*InUserWidgets = std::move(Parms.InUserWidgets);

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetInputsFromText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UUserInterfaceFunctionLibrary::GetInputsFromText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetInputsFromText");

	Params::UserInterfaceFunctionLibrary_GetInputsFromText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetItemRarity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItem*                            InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemRarity                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemRarity UUserInterfaceFunctionLibrary::GetItemRarity(class UObject* WorldContextObject, class AItem* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetItemRarity");

	Params::UserInterfaceFunctionLibrary_GetItemRarity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetLevelDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InLevelName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLevelDescriptionTableRow        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLevelDescriptionTableRow UUserInterfaceFunctionLibrary::GetLevelDescription(class UObject* WorldContextObject, class FName InLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetLevelDescription");

	Params::UserInterfaceFunctionLibrary_GetLevelDescription Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLevelName = InLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetMapMarkerColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapMarkerType                          InMarkerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UUserInterfaceFunctionLibrary::GetMapMarkerColor(class UObject* WorldContextObject, EMapMarkerType InMarkerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetMapMarkerColor");

	Params::UserInterfaceFunctionLibrary_GetMapMarkerColor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMarkerType = InMarkerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetNotificationSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNotificationSystem*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNotificationSystem* UUserInterfaceFunctionLibrary::GetNotificationSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetNotificationSystem");

	Params::UserInterfaceFunctionLibrary_GetNotificationSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetParentUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          InWidget                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UUserInterfaceFunctionLibrary::GetParentUserWidget(const class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetParentUserWidget");

	Params::UserInterfaceFunctionLibrary_GetParentUserWidget Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetPlatformGroup
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUserInterfaceFunctionLibrary::GetPlatformGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetPlatformGroup");

	Params::UserInterfaceFunctionLibrary_GetPlatformGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetProfilePictureCache
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProfilePictureCache*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProfilePictureCache* UUserInterfaceFunctionLibrary::GetProfilePictureCache(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetProfilePictureCache");

	Params::UserInterfaceFunctionLibrary_GetProfilePictureCache Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetRichPlayerNickname
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InPlayerNickname                                       (Parm, NativeAccessSpecifierPublic)
// EFlamePlatform                          InPlayerPlatform                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUserInterfaceFunctionLibrary::GetRichPlayerNickname(const class FText& InPlayerNickname, EFlamePlatform InPlayerPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetRichPlayerNickname");

	Params::UserInterfaceFunctionLibrary_GetRichPlayerNickname Parms{};

	Parms.InPlayerNickname = std::move(InPlayerNickname);
	Parms.InPlayerPlatform = InPlayerPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetRichPlayerNicknameWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUserInterfaceFunctionLibrary::GetRichPlayerNicknameWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetRichPlayerNicknameWidget");

	Params::UserInterfaceFunctionLibrary_GetRichPlayerNicknameWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetShelterUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UShelterMainTabControl*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShelterMainTabControl* UUserInterfaceFunctionLibrary::GetShelterUI(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetShelterUI");

	Params::UserInterfaceFunctionLibrary_GetShelterUI Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetUICoreObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUICoreObject*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUICoreObject* UUserInterfaceFunctionLibrary::GetUICoreObject(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetUICoreObject");

	Params::UserInterfaceFunctionLibrary_GetUICoreObject Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.GetZOrder
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUILayer                                Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInterfaceFunctionLibrary::GetZOrder(const class UObject* WorldContextObject, EUILayer Layer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "GetZOrder");

	Params::UserInterfaceFunctionLibrary_GetZOrder Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Layer = Layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.HasFocus
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          InWidget                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::HasFocus(const class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "HasFocus");

	Params::UserInterfaceFunctionLibrary_HasFocus Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsAnyMenuOpen
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsAnyMenuOpen(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsAnyMenuOpen");

	Params::UserInterfaceFunctionLibrary_IsAnyMenuOpen Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsExhibitionPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 UniqueNetId                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsExhibitionPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsExhibitionPlayer");

	Params::UserInterfaceFunctionLibrary_IsExhibitionPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UniqueNetId = std::move(UniqueNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsLocalPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 UniqueNetId                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsLocalPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsLocalPlayer");

	Params::UserInterfaceFunctionLibrary_IsLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UniqueNetId = std::move(UniqueNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsPlatformGroupConsole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsPlatformGroupConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsPlatformGroupConsole");

	Params::UserInterfaceFunctionLibrary_IsPlatformGroupConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsPlatformGroupDesktop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsPlatformGroupDesktop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsPlatformGroupDesktop");

	Params::UserInterfaceFunctionLibrary_IsPlatformGroupDesktop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsPlatformGroupMobile
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsPlatformGroupMobile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsPlatformGroupMobile");

	Params::UserInterfaceFunctionLibrary_IsPlatformGroupMobile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsReallyVisible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          InWidget                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsReallyVisible(const class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsReallyVisible");

	Params::UserInterfaceFunctionLibrary_IsReallyVisible Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.IsValidPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 UniqueNetId                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::IsValidPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "IsValidPlayer");

	Params::UserInterfaceFunctionLibrary_IsValidPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UniqueNetId = std::move(UniqueNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.KeepCurrentFocus
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::KeepCurrentFocus(class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "KeepCurrentFocus");

	Params::UserInterfaceFunctionLibrary_KeepCurrentFocus Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.LinearColorFromHexString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InHexString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UUserInterfaceFunctionLibrary::LinearColorFromHexString(const class FString& InHexString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "LinearColorFromHexString");

	Params::UserInterfaceFunctionLibrary_LinearColorFromHexString Parms{};

	Parms.InHexString = std::move(InHexString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.NotEqual_NetIdNetId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 A                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 B                                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::NotEqual_NetIdNetId(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "NotEqual_NetIdNetId");

	Params::UserInterfaceFunctionLibrary_NotEqual_NetIdNetId Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.OpenGameMenu
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::OpenGameMenu(const class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "OpenGameMenu");

	Params::UserInterfaceFunctionLibrary_OpenGameMenu Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.OpenIdleWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InOwningPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UModalWidget*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UModalWidget* UUserInterfaceFunctionLibrary::OpenIdleWidget(class APlayerController* InOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "OpenIdleWidget");

	Params::UserInterfaceFunctionLibrary_OpenIdleWidget Parms{};

	Parms.InOwningPlayer = InOwningPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.OpenModalWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InOwningPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UModalWidget>         InWidgetClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UModalWidget*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UModalWidget* UUserInterfaceFunctionLibrary::OpenModalWidget(class APlayerController* InOwningPlayer, TSubclassOf<class UModalWidget> InWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "OpenModalWidget");

	Params::UserInterfaceFunctionLibrary_OpenModalWidget Parms{};

	Parms.InOwningPlayer = InOwningPlayer;
	Parms.InWidgetClass = InWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.OpenShelterUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EShelterMainTab                         InTab                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::OpenShelterUI(const class APlayerController* InPlayerController, EShelterMainTab InTab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "OpenShelterUI");

	Params::UserInterfaceFunctionLibrary_OpenShelterUI Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.InTab = InTab;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.ReplaceTextWithControls
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// TArray<class FText>                     Inputs                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUserInterfaceFunctionLibrary::ReplaceTextWithControls(const class FText& Text, const TArray<class FText>& Inputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ReplaceTextWithControls");

	Params::UserInterfaceFunctionLibrary_ReplaceTextWithControls Parms{};

	Parms.Text = std::move(Text);
	Parms.Inputs = std::move(Inputs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.ReportEnterInGameStoreUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void UUserInterfaceFunctionLibrary::ReportEnterInGameStoreUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ReportEnterInGameStoreUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.ReportExitInGameStoreUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void UUserInterfaceFunctionLibrary::ReportExitInGameStoreUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ReportExitInGameStoreUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.SetDefaultLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUserInterfaceFunctionLibrary::SetDefaultLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "SetDefaultLanguage");

	Params::UserInterfaceFunctionLibrary_SetDefaultLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.SetLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InCultureName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::SetLanguage(const class FString& InCultureName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "SetLanguage");

	Params::UserInterfaceFunctionLibrary_SetLanguage Parms{};

	Parms.InCultureName = std::move(InCultureName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.ShowMessageBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InTitle                                                (Parm, NativeAccessSpecifierPublic)
// class FText                             InMessage                                              (Parm, NativeAccessSpecifierPublic)
// EMessageBoxType                         InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EMessageBoxAction Result)>OnMessageBoxClosed                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UMessageBoxWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMessageBoxWidget* UUserInterfaceFunctionLibrary::ShowMessageBox(class UObject* WorldContextObject, const class FText& InTitle, const class FText& InMessage, EMessageBoxType InType, const TDelegate<void(EMessageBoxAction Result)>& OnMessageBoxClosed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ShowMessageBox");

	Params::UserInterfaceFunctionLibrary_ShowMessageBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTitle = std::move(InTitle);
	Parms.InMessage = std::move(InMessage);
	Parms.InType = InType;
	Parms.OnMessageBoxClosed = OnMessageBoxClosed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.ShowTextNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextNotificationType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InMessage                                              (Parm, NativeAccessSpecifierPublic)
// struct FNotificationParams              InParameters                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::ShowTextNotification(class UObject* WorldContextObject, ETextNotificationType InType, float InDuration, const class FText& InMessage, const struct FNotificationParams& InParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "ShowTextNotification");

	Params::UserInterfaceFunctionLibrary_ShowTextNotification Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InType = InType;
	Parms.InDuration = InDuration;
	Parms.InMessage = std::move(InMessage);
	Parms.InParameters = std::move(InParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInterfaceFunctionLibrary.StringIsEmpty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::StringIsEmpty(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "StringIsEmpty");

	Params::UserInterfaceFunctionLibrary_StringIsEmpty Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.StringNotEmpty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInterfaceFunctionLibrary::StringNotEmpty(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "StringNotEmpty");

	Params::UserInterfaceFunctionLibrary_StringNotEmpty Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInterfaceFunctionLibrary.TimerWithString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& Value)>Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::TimerWithString(const TDelegate<void(const class FString& Value)>& Event, float Time, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserInterfaceFunctionLibrary", "TimerWithString");

	Params::UserInterfaceFunctionLibrary_TimerWithString Parms{};

	Parms.Event = Event;
	Parms.Time = Time;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Flame.UserInterfaceFunctionLibrary.TimerDynamicDelegateS__DelegateSignature
// (Public, Delegate)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInterfaceFunctionLibrary::TimerDynamicDelegateS__DelegateSignature(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInterfaceFunctionLibrary", "TimerDynamicDelegateS__DelegateSignature");

	Params::UserInterfaceFunctionLibrary_TimerDynamicDelegateS__DelegateSignature Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UsableComponent.CanBeUsed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUsableComponent::CanBeUsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UsableComponent", "CanBeUsed");

	Params::UsableComponent_CanBeUsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.OnlineUserCountersComponent.GetUserCounter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CounterName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineUserCountersComponent::GetUserCounter(class AHumanPlayerController* Player, class FName CounterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserCountersComponent", "GetUserCounter");

	Params::OnlineUserCountersComponent_GetUserCounter Parms{};

	Parms.Player = Player;
	Parms.CounterName = CounterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineUserCountersComponent.GetUserCounterDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserCounterValue           CounterValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnlineUserCountersComponent::GetUserCounterDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, const struct FCloudUserCounterValue& CounterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserCountersComponent", "GetUserCounterDelegate__DelegateSignature");

	Params::OnlineUserCountersComponent_GetUserCounterDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.CounterValue = std::move(CounterValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.OnlineUserCountersComponent.UpdateUserCounter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CounterName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserCounterUpdate          UpdateData                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineUserCountersComponent::UpdateUserCounter(class AHumanPlayerController* Player, class FName CounterName, const struct FCloudUserCounterUpdate& UpdateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserCountersComponent", "UpdateUserCounter");

	Params::OnlineUserCountersComponent_UpdateUserCounter Parms{};

	Parms.Player = Player;
	Parms.CounterName = CounterName;
	Parms.UpdateData = std::move(UpdateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.OnlineUserCountersComponent.UpdateUserCounterDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudUserCounterOperation              Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserCounterValue           CounterValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnlineUserCountersComponent::UpdateUserCounterDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, ECloudUserCounterOperation Operation, const struct FCloudUserCounterValue& CounterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineUserCountersComponent", "UpdateUserCounterDelegate__DelegateSignature");

	Params::OnlineUserCountersComponent_UpdateUserCounterDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Player = Player;
	Parms.Operation = Operation;
	Parms.CounterValue = std::move(CounterValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UserInfoComponent.BanPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerCloudId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::BanPlayer(class AHumanPlayerController* Player, const class FString& PlayerCloudId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "BanPlayer");

	Params::UserInfoComponent_BanPlayer Parms{};

	Parms.Player = Player;
	Parms.PlayerCloudId = std::move(PlayerCloudId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.UserInfoComponent.BanPlayerDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudBannedPlayersResult        Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserInfoComponent::BanPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudBannedPlayersResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "BanPlayerDelegate__DelegateSignature");

	Params::UserInfoComponent_BanPlayerDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Userid = std::move(Userid);
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UserInfoComponent.GetMatchInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::GetMatchInfo(const class FString& MatchCloudId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetMatchInfo");

	Params::UserInfoComponent_GetMatchInfo Parms{};

	Parms.MatchCloudId = std::move(MatchCloudId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInfoComponent.GetPlayerBans
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::GetPlayerBans(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetPlayerBans");

	Params::UserInfoComponent_GetPlayerBans Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.UserInfoComponent.GetPlayerBansDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCloudBannedPlayersResult        Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserInfoComponent::GetPlayerBansDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBannedPlayersResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetPlayerBansDelegate__DelegateSignature");

	Params::UserInfoComponent_GetPlayerBansDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UserInfoComponent.GetUserCloudInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceUpdate                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::GetUserCloudInfo(const bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetUserCloudInfo");

	Params::UserInfoComponent_GetUserCloudInfo Parms{};

	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInfoComponent.GetUserCloudInfoForController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::GetUserCloudInfoForController(class AHumanPlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetUserCloudInfoForController");

	Params::UserInfoComponent_GetUserCloudInfoForController Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.UserInfoComponent.GetUserMatchesStatistic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloudUserMatchStatisticsPeriod         TimePeriod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::GetUserMatchesStatistic(class AHumanPlayerController* Player, ECloudUserMatchStatisticsPeriod TimePeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetUserMatchesStatistic");

	Params::UserInfoComponent_GetUserMatchesStatistic Parms{};

	Parms.Player = Player;
	Parms.TimePeriod = TimePeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.UserInfoComponent.GetUserMatchesStatisticDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ECloudUserMatchStatisticsPeriod         TimePeriod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudUserMatchesStatistic       Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserInfoComponent::GetUserMatchesStatisticDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, ECloudUserMatchStatisticsPeriod TimePeriod, const struct FCloudUserMatchesStatistic& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "GetUserMatchesStatisticDelegate__DelegateSignature");

	Params::UserInfoComponent_GetUserMatchesStatisticDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.TimePeriod = TimePeriod;
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.UserInfoComponent.MatchInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           MatchCloudId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUserMatchResult                 MatchResult                                            (Parm, NativeAccessSpecifierPublic)

void UUserInfoComponent::MatchInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& MatchCloudId, const struct FUserMatchResult& MatchResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "MatchInfoDelegate__DelegateSignature");

	Params::UserInfoComponent_MatchInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.MatchCloudId = std::move(MatchCloudId);
	Parms.MatchResult = std::move(MatchResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.UserInfoComponent.RequestUserCloudInfo
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// bool                                    bForceUpdate                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInfoComponent::RequestUserCloudInfo(const bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "RequestUserCloudInfo");

	Params::UserInfoComponent_RequestUserCloudInfo Parms{};

	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.UserInfoComponent.UnbanPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHumanPlayerController*           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerCloudId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUserInfoComponent::UnbanPlayer(class AHumanPlayerController* Player, const class FString& PlayerCloudId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "UnbanPlayer");

	Params::UserInfoComponent_UnbanPlayer Parms{};

	Parms.Player = Player;
	Parms.PlayerCloudId = std::move(PlayerCloudId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction Flame.UserInfoComponent.UnbanPlayerDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Userid                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudBannedPlayersResult        Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserInfoComponent::UnbanPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudBannedPlayersResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "UnbanPlayerDelegate__DelegateSignature");

	Params::UserInfoComponent_UnbanPlayerDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.Userid = std::move(Userid);
	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction Flame.UserInfoComponent.UserCloudInfoDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FCloudRequestResult              RequestResult                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FUserCloudInfo                   UserInfo                                               (Parm, NativeAccessSpecifierPublic)

void UUserInfoComponent::UserCloudInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FUserCloudInfo& UserInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInfoComponent", "UserCloudInfoDelegate__DelegateSignature");

	Params::UserInfoComponent_UserCloudInfoDelegate__DelegateSignature Parms{};

	Parms.RequestResult = std::move(RequestResult);
	Parms.UserInfo = std::move(UserInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.WaterVolume.SetupWaterBrushCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWaterVolume::SetupWaterBrushCollision(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WaterVolume", "SetupWaterBrushCollision");

	Params::WaterVolume_SetupWaterBrushCollision Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.AimPointComponent.AdjustAimpointToSocket
// (Final, Native, Public, BlueprintCallable)

void UAimPointComponent::AdjustAimpointToSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointComponent", "AdjustAimpointToSocket");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponContainerWidget.FillSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULinkedWeapons*                   WeaponsComponent                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponContainerWidget::FillSlots(const class ULinkedWeapons* WeaponsComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponContainerWidget", "FillSlots");

	Params::WeaponContainerWidget_FillSlots Parms{};

	Parms.WeaponsComponent = WeaponsComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponContainerWidget.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponSlotType                         SlotType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UWeaponContainerWidget::GetWeapon(const EWeaponSlotType SlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponContainerWidget", "GetWeapon");

	Params::WeaponContainerWidget_GetWeapon Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponContainerWidget.GetWeaponSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponSlotType                         SlotType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlameSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlameSlot* UWeaponContainerWidget::GetWeaponSlot(const EWeaponSlotType SlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponContainerWidget", "GetWeaponSlot");

	Params::WeaponContainerWidget_GetWeaponSlot Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Muzzle.GetOuterAWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UMuzzle::GetOuterAWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Muzzle", "GetOuterAWeapon");

	Params::Muzzle_GetOuterAWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Muzzle.GetMuzzleType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMuzzleType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMuzzleType UMuzzle::GetMuzzleType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Muzzle", "GetMuzzleType");

	Params::Muzzle_GetMuzzleType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Muzzle.GetWeaponData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFirearmWeaponConfigurationReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FFirearmWeaponConfiguration UMuzzle::GetWeaponData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Muzzle", "GetWeaponData");

	Params::Muzzle_GetWeaponData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponMuzzle.OnRep_AmmoCount
// (Final, Native, Private)
// Parameters:
// int32                                   PreviousCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponMuzzle::OnRep_AmmoCount(int32 PreviousCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "OnRep_AmmoCount");

	Params::WeaponMuzzle_OnRep_AmmoCount Parms{};

	Parms.PreviousCount = PreviousCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponMuzzle.OnRep_ChamberLoadedAmmoCount
// (Final, Native, Private)
// Parameters:
// int32                                   PreviousCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponMuzzle::OnRep_ChamberLoadedAmmoCount(int32 PreviousCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "OnRep_ChamberLoadedAmmoCount");

	Params::WeaponMuzzle_OnRep_ChamberLoadedAmmoCount Parms{};

	Parms.PreviousCount = PreviousCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponMuzzle.GetChamberLoadedAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponMuzzle::GetChamberLoadedAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "GetChamberLoadedAmmo");

	Params::WeaponMuzzle_GetChamberLoadedAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponMuzzle.GetCurrentAmmoCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponMuzzle::GetCurrentAmmoCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "GetCurrentAmmoCount");

	Params::WeaponMuzzle_GetCurrentAmmoCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponMuzzle.GetCurrentAmmoRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponMuzzle::GetCurrentAmmoRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "GetCurrentAmmoRatio");

	Params::WeaponMuzzle_GetCurrentAmmoRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponMuzzle.GetCurrentChamberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponMuzzle::GetCurrentChamberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMuzzle", "GetCurrentChamberCount");

	Params::WeaponMuzzle_GetCurrentChamberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponSegment.SetWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          InWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponSegment::SetWeapon(class AWeapon* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSegment", "SetWeapon");

	Params::WeaponSegment_SetWeapon Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponSegment.SetWeaponIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InWeaponIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponSegment::SetWeaponIndex(int32 InWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSegment", "SetWeaponIndex");

	Params::WeaponSegment_SetWeaponIndex Parms{};

	Parms.InWeaponIndex = InWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WeaponSegment.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UWeaponSegment::GetWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSegment", "GetWeapon");

	Params::WeaponSegment_GetWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.AreWeaponAndAmmoCompatible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAmmoItem>            AmmoClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::AreWeaponAndAmmoCompatible(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass, TSubclassOf<class AAmmoItem> AmmoClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "AreWeaponAndAmmoCompatible");

	Params::WeaponsFunctions_AreWeaponAndAmmoCompatible Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WeaponClass = WeaponClass;
	Parms.AmmoClass = AmmoClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.ConvertIndexToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponSlotType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponSlotType UWeaponsFunctions::ConvertIndexToSlot(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "ConvertIndexToSlot");

	Params::WeaponsFunctions_ConvertIndexToSlot Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.ConvertSlotToIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWeaponSlotType                         Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponsFunctions::ConvertSlotToIndex(EWeaponSlotType Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "ConvertSlotToIndex");

	Params::WeaponsFunctions_ConvertSlotToIndex Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.CreateWeaponDescriptor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponDescriptor                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeaponDescriptor UWeaponsFunctions::CreateWeaponDescriptor(const class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "CreateWeaponDescriptor");

	Params::WeaponsFunctions_CreateWeaponDescriptor Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.CreateWeaponFromDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponDescriptor                Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UWeaponsFunctions::CreateWeaponFromDescriptor(const class UObject* WorldContextObject, const struct FWeaponDescriptor& Info, class AHumanCharacter* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "CreateWeaponFromDescriptor");

	Params::WeaponsFunctions_CreateWeaponFromDescriptor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Info = std::move(Info);
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.GetCompatibleAmmoTypes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AAmmoItem>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class AAmmoItem>> UWeaponsFunctions::GetCompatibleAmmoTypes(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "GetCompatibleAmmoTypes");

	Params::WeaponsFunctions_GetCompatibleAmmoTypes Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.GetCountOfAvailableAmmoInBagForWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Owner                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponsFunctions::GetCountOfAvailableAmmoInBagForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AHumanCharacter* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "GetCountOfAvailableAmmoInBagForWeapon");

	Params::WeaponsFunctions_GetCountOfAvailableAmmoInBagForWeapon Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.GetCurrentAmmoCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponsFunctions::GetCurrentAmmoCount(const class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "GetCurrentAmmoCount");

	Params::WeaponsFunctions_GetCurrentAmmoCount Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.GetWeaponCapacity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponsFunctions::GetWeaponCapacity(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "GetWeaponCapacity");

	Params::WeaponsFunctions_GetWeaponCapacity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.GetWeaponMagazineAndChamberCapacities
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MagazineCount                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChamberCount                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::GetWeaponMagazineAndChamberCapacities(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass, int32* MagazineCount, int32* ChamberCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "GetWeaponMagazineAndChamberCapacities");

	Params::WeaponsFunctions_GetWeaponMagazineAndChamberCapacities Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MagazineCount != nullptr)
		*MagazineCount = Parms.MagazineCount;

	if (ChamberCount != nullptr)
		*ChamberCount = Parms.ChamberCount;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.IsSecondaryWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::IsSecondaryWeapon(const class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "IsSecondaryWeapon");

	Params::WeaponsFunctions_IsSecondaryWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.IsShotgun
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::IsShotgun(const class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "IsShotgun");

	Params::WeaponsFunctions_IsShotgun Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.IsValidWeaponDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWeaponDescriptor                Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::IsValidWeaponDescriptor(const struct FWeaponDescriptor& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "IsValidWeaponDescriptor");

	Params::WeaponsFunctions_IsValidWeaponDescriptor Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponsFunctions.UnloadWeaponToInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHumanCharacter*                  Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponsFunctions::UnloadWeaponToInventory(class AWeapon* Weapon, class AHumanCharacter* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponsFunctions", "UnloadWeaponToInventory");

	Params::WeaponsFunctions_UnloadWeaponToInventory Parms{};

	Parms.Weapon = Weapon;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetCanRenderExtraGeometryStatic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemSkin::GetCanRenderExtraGeometryStatic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetCanRenderExtraGeometryStatic");

	Params::ItemSkin_GetCanRenderExtraGeometryStatic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetExtraGeometryMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> AItemSkin::GetExtraGeometryMaterials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetExtraGeometryMaterials");

	Params::ItemSkin_GetExtraGeometryMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetItemClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItem>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItem> AItemSkin::GetItemClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetItemClass");

	Params::ItemSkin_GetItemClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> AItemSkin::GetMaterials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetMaterials");

	Params::ItemSkin_GetMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetSkinParticleConfigHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDataTableRowHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDataTableRowHandle AItemSkin::GetSkinParticleConfigHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetSkinParticleConfigHandle");

	Params::ItemSkin_GetSkinParticleConfigHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.ItemSkin.GetTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* AItemSkin::GetTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSkin", "GetTexture");

	Params::ItemSkin_GetTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WeaponStateReload.RoundLoaded
// (Final, Native, Public)
// Parameters:
// class USkeletalMeshComponent*           Skeleton                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAuthority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStateReload::RoundLoaded(class USkeletalMeshComponent* Skeleton, class UAnimSequenceBase* Animation, bool bAuthority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponStateReload", "RoundLoaded");

	Params::WeaponStateReload_RoundLoaded Parms{};

	Parms.Skeleton = Skeleton;
	Parms.Animation = Animation;
	Parms.bAuthority = bAuthority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WidgetDecorator.GetUserWidgetByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UWidgetDecorator::GetUserWidgetByName(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetDecorator", "GetUserWidgetByName");

	Params::WidgetDecorator_GetUserWidgetByName Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Window.BlockWindow
// (Final, Native, Public, BlueprintCallable)

void AWindow::BlockWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "BlockWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Window.LockWindow
// (Final, Native, Public, BlueprintCallable)

void AWindow::LockWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "LockWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Window.TriggerOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::TriggerOpen(bool bOpen, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "TriggerOpen");

	Params::Window_TriggerOpen Parms{};

	Parms.bOpen = bOpen;
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.Window.GetSashSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWindowSashSet*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWindowSashSet* AWindow::GetSashSet(const int32 Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetSashSet");

	Params::Window_GetSashSet Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.Window.GetSashSetIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWindowSashSet*                   SashSet                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindow::GetSashSetIndex(class AWindowSashSet* SashSet, int32* ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetSashSetIndex");

	Params::Window_GetSashSetIndex Parms{};

	Parms.SashSet = SashSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ID != nullptr)
		*ID = Parms.ID;

	return Parms.ReturnValue;
}


// Function Flame.WindowSashSet.ShouldSpawnBoarded
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// EWindowBoardBehavior                    BoardBehavior                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool AWindowSashSet::ShouldSpawnBoarded(const EWindowBoardBehavior BoardBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WindowSashSet", "ShouldSpawnBoarded");

	Params::WindowSashSet_ShouldSpawnBoarded Parms{};

	Parms.BoardBehavior = BoardBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WindowSashSet.EndAnimationUpdate
// (Native, Event, Protected, BlueprintEvent)

void AWindowSashSet::EndAnimationUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "EndAnimationUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.LockWindow
// (Final, Native, Public, BlueprintCallable)

void AWindowSashSet::LockWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "LockWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.MulticastOnPaneShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::MulticastOnPaneShot(const int32 Idx, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "MulticastOnPaneShot");

	Params::WindowSashSet_MulticastOnPaneShot Parms{};

	Parms.Idx = Idx;
	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.MulticastPlayOpenAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::MulticastPlayOpenAnimation(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "MulticastPlayOpenAnimation");

	Params::WindowSashSet_MulticastPlayOpenAnimation Parms{};

	Parms.bOpen = bOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.OnDamage
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AActor*                           SomeActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCounter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::OnDamage(class AActor* SomeActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnDamage");

	Params::WindowSashSet_OnDamage Parms{};

	Parms.SomeActor = SomeActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCounter = DamageCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.OnInteract
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionItemComponent*        Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::OnInteract(class UInteractionItemComponent* Sender, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnInteract");

	Params::WindowSashSet_OnInteract Parms{};

	Parms.Sender = Sender;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.OnPaneShot
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       PaneTransform                                          (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UStaticMesh*                      PaneMesh                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::OnPaneShot(const struct FVector& HitLocation, const struct FTransform& PaneTransform, class UStaticMesh* PaneMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnPaneShot");

	Params::WindowSashSet_OnPaneShot Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.PaneTransform = std::move(PaneTransform);
	Parms.PaneMesh = PaneMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flame.WindowSashSet.OnPlayOpenAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::OnPlayOpenAnimation(bool bOpen, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnPlayOpenAnimation");

	Params::WindowSashSet_OnPlayOpenAnimation Parms{};

	Parms.bOpen = bOpen;
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.OnWindowClose
// (Event, Protected, BlueprintEvent)

void AWindowSashSet::OnWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnWindowClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.WindowSashSet.OnWindowOpen
// (Event, Protected, BlueprintEvent)

void AWindowSashSet::OnWindowOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OnWindowOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flame.WindowSashSet.OpenAnimationUpdate
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   T                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::OpenAnimationUpdate(float T)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "OpenAnimationUpdate");

	Params::WindowSashSet_OpenAnimationUpdate Parms{};

	Parms.T = T;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.RegisterPane
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             PaneComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindowSashSet::RegisterPane(class UStaticMeshComponent* PaneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "RegisterPane");

	Params::WindowSashSet_RegisterPane Parms{};

	Parms.PaneComponent = PaneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WindowSashSet.UnlockWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindowSashSet::UnlockWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "UnlockWindow");

	Params::WindowSashSet_UnlockWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WindowSashSet.GetPaneByIdx
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AWindowSashSet::GetPaneByIdx(const int32 Idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "GetPaneByIdx");

	Params::WindowSashSet_GetPaneByIdx Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WindowSashSet.IsWindowOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindowSashSet::IsWindowOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowSashSet", "IsWindowOpen");

	Params::WindowSashSet_IsWindowOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flame.WoundsManagerComponent.AddMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWoundsManagerComponent::AddMesh(class UMeshComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WoundsManagerComponent", "AddMesh");

	Params::WoundsManagerComponent_AddMesh Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WoundsManagerComponent.AddWound
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitWorldPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWoundsManagerComponent::AddWound(const struct FVector& HitWorldPosition, class UPrimitiveComponent* HitComponent, class FName HitBoneName, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WoundsManagerComponent", "AddWound");

	Params::WoundsManagerComponent_AddWound Parms{};

	Parms.HitWorldPosition = std::move(HitWorldPosition);
	Parms.HitComponent = HitComponent;
	Parms.HitBoneName = HitBoneName;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WoundsManagerComponent.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWoundsManagerComponent::Init(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WoundsManagerComponent", "Init");

	Params::WoundsManagerComponent_Init Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WoundsManagerComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UWoundsManagerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WoundsManagerComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flame.WoundsManagerComponent.SetMaterialParameterNames
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Names                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWoundsManagerComponent::SetMaterialParameterNames(const TArray<class FName>& Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WoundsManagerComponent", "SetMaterialParameterNames");

	Params::WoundsManagerComponent_SetMaterialParameterNames Parms{};

	Parms.Names = std::move(Names);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}


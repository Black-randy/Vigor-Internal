#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Flame

#include "Basic.hpp"

#include "Flame_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "FlameUI_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "CloudManager_structs.hpp"
#include "Foliage_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "LoadingScreen_structs.hpp"


namespace SDK
{

// Class Flame.DropPlaneMovementComponent
// 0x0040 (0x0130 - 0x00F0)
class UDropPlaneMovementComponent final : public UMovementComponent
{
public:
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerStartTime;                                   // 0x00F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DropDuration;                                      // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndDuration;                                       // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                StartPosition;                                     // 0x0100(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DropPosition;                                      // 0x010C(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EndPosition;                                       // 0x0118(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               Rotation;                                          // 0x0124(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_ServerStartTime();
	void StartFlight(const struct FVector& DirXY, const struct FVector& DropLocation, float FlightRadius, float FlightSpeed, float StartHeightOffset, float DropHeightOffset);

	bool IsCloseToDropLocation() const;
	bool IsCloseToEndPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropPlaneMovementComponent">();
	}
	static class UDropPlaneMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropPlaneMovementComponent>();
	}
};
static_assert(alignof(UDropPlaneMovementComponent) == 0x000008, "Wrong alignment on UDropPlaneMovementComponent");
static_assert(sizeof(UDropPlaneMovementComponent) == 0x000130, "Wrong size on UDropPlaneMovementComponent");
static_assert(offsetof(UDropPlaneMovementComponent, ServerStartTime) == 0x0000F4, "Member 'UDropPlaneMovementComponent::ServerStartTime' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, DropDuration) == 0x0000F8, "Member 'UDropPlaneMovementComponent::DropDuration' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, EndDuration) == 0x0000FC, "Member 'UDropPlaneMovementComponent::EndDuration' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, StartPosition) == 0x000100, "Member 'UDropPlaneMovementComponent::StartPosition' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, DropPosition) == 0x00010C, "Member 'UDropPlaneMovementComponent::DropPosition' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, EndPosition) == 0x000118, "Member 'UDropPlaneMovementComponent::EndPosition' has a wrong offset!");
static_assert(offsetof(UDropPlaneMovementComponent, Rotation) == 0x000124, "Member 'UDropPlaneMovementComponent::Rotation' has a wrong offset!");

// Class Flame.WeaponCollisionBuilder
// 0x0010 (0x0230 - 0x0220)
class AWeaponCollisionBuilder final : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddReport(const struct FWeaponCollisionEntry& Entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponCollisionBuilder">();
	}
	static class AWeaponCollisionBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponCollisionBuilder>();
	}
};
static_assert(alignof(AWeaponCollisionBuilder) == 0x000008, "Wrong alignment on AWeaponCollisionBuilder");
static_assert(sizeof(AWeaponCollisionBuilder) == 0x000230, "Wrong size on AWeaponCollisionBuilder");

// Class Flame.AccessorComponent
// 0x0008 (0x00B8 - 0x00B0)
class UAccessorComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class AActor>                  AccessedActor;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientNotifyAboutAccess(class AActor* ActorForAccess);
	void ClientReactionOnInteract(class AActor* InteractedActor);
	void ServerAskForDetach();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccessorComponent">();
	}
	static class UAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccessorComponent>();
	}
};
static_assert(alignof(UAccessorComponent) == 0x000008, "Wrong alignment on UAccessorComponent");
static_assert(sizeof(UAccessorComponent) == 0x0000B8, "Wrong size on UAccessorComponent");
static_assert(offsetof(UAccessorComponent, AccessedActor) == 0x0000B0, "Member 'UAccessorComponent::AccessedActor' has a wrong offset!");

// Class Flame.CanAimComponent
// 0x00D0 (0x0180 - 0x00B0)
class UCanAimComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x11];                                      // 0x00B0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             CollisionTestChannel;                              // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VisualWeaponDistortion;                            // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMinPitchScan;                                  // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMinPitchOnlyInProne;                           // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPitchScanDistSq;                                // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECanAimState                                  CanAimState;                                       // 0x00D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StanceStandOffset;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StanceCrouchOffset;                                // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StanceProneOffset;                                 // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StanceProneOffsetForward;                          // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RadiusFactorOnHit;                                 // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x68];                                      // 0x00F0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraManagerComponent*                CameraManagerComponent;                            // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpAdjustmentSphereRadiusMultiplier;                // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpAdjustmentMaxDistance;                           // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UpAdjustmentIterations;                            // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpHeightAdjustmentTarget;                          // 0x016C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x4];                                      // 0x0170(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpHeightAdjustmentSpeedUp;                         // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpHeightAdjustmentSpeedDown;                       // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ECanAimState CanAim() const;
	float GetUpHeightAdjustment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanAimComponent">();
	}
	static class UCanAimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanAimComponent>();
	}
};
static_assert(alignof(UCanAimComponent) == 0x000008, "Wrong alignment on UCanAimComponent");
static_assert(sizeof(UCanAimComponent) == 0x000180, "Wrong size on UCanAimComponent");
static_assert(offsetof(UCanAimComponent, CollisionTestChannel) == 0x0000C1, "Member 'UCanAimComponent::CollisionTestChannel' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, VisualWeaponDistortion) == 0x0000C4, "Member 'UCanAimComponent::VisualWeaponDistortion' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, bUseMinPitchScan) == 0x0000D0, "Member 'UCanAimComponent::bUseMinPitchScan' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, bUseMinPitchOnlyInProne) == 0x0000D1, "Member 'UCanAimComponent::bUseMinPitchOnlyInProne' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, MinPitchScanDistSq) == 0x0000D4, "Member 'UCanAimComponent::MinPitchScanDistSq' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, CanAimState) == 0x0000D8, "Member 'UCanAimComponent::CanAimState' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, StanceStandOffset) == 0x0000DC, "Member 'UCanAimComponent::StanceStandOffset' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, StanceCrouchOffset) == 0x0000E0, "Member 'UCanAimComponent::StanceCrouchOffset' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, StanceProneOffset) == 0x0000E4, "Member 'UCanAimComponent::StanceProneOffset' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, StanceProneOffsetForward) == 0x0000E8, "Member 'UCanAimComponent::StanceProneOffsetForward' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, RadiusFactorOnHit) == 0x0000EC, "Member 'UCanAimComponent::RadiusFactorOnHit' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, CameraManagerComponent) == 0x000158, "Member 'UCanAimComponent::CameraManagerComponent' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpAdjustmentSphereRadiusMultiplier) == 0x000160, "Member 'UCanAimComponent::UpAdjustmentSphereRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpAdjustmentMaxDistance) == 0x000164, "Member 'UCanAimComponent::UpAdjustmentMaxDistance' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpAdjustmentIterations) == 0x000168, "Member 'UCanAimComponent::UpAdjustmentIterations' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpHeightAdjustmentTarget) == 0x00016C, "Member 'UCanAimComponent::UpHeightAdjustmentTarget' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpHeightAdjustmentSpeedUp) == 0x000174, "Member 'UCanAimComponent::UpHeightAdjustmentSpeedUp' has a wrong offset!");
static_assert(offsetof(UCanAimComponent, UpHeightAdjustmentSpeedDown) == 0x000178, "Member 'UCanAimComponent::UpHeightAdjustmentSpeedDown' has a wrong offset!");

// Class Flame.Item
// 0x0178 (0x0398 - 0x0220)
class AItem : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemOrigin                                   Origin;                                            // 0x0228(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x1F];                                     // 0x0229(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHumanCharacter*                        Character;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CharacterAnimMesh;                                 // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x80];                                     // 0x0260(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemStateBringDown*                    BringDownStateServer;                              // 0x02E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStateBringUp*                      BringUpStateServer;                                // 0x02E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStateBringDown*                    BringDownStateLocal;                               // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemStateBringUp*                      BringUpStateLocal;                                 // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachSocketName;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x90];                                     // 0x0308(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Character();
	void OnRep_ItemStateBringDown(class UItemStateBringDown* OldState);
	void OnRep_ItemStateBringUp(class UItemStateBringUp* OldState);

	bool CanBeDestroyed() const;
	bool CanBeUsedImpl() const;
	class UTexture2D* GetCardImage() const;
	const TSoftObjectPtr<class UTexture2D> GetCardSoftImage() const;
	EItemCategory GetCategory() const;
	class FText GetCategoryName() const;
	class AHumanCharacter* GetCharacter() const;
	class FString GetDebugInfo() const;
	class FText GetDescription() const;
	class UTexture2D* GetIcon(EIconSize IconSize) const;
	TSoftObjectPtr<class UTexture2D> GetIconSoft(EIconSize IconSize) const;
	class FText GetItemName() const;
	int32 GetRarity() const;
	class USkeletalMesh* GetShelterPreviewSkeletalMesh() const;
	class UStaticMesh* GetShelterPreviewStaticMesh() const;
	float GetUnitWeight() const;
	float GetWeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item">();
	}
	static class AItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItem>();
	}
};
static_assert(alignof(AItem) == 0x000008, "Wrong alignment on AItem");
static_assert(sizeof(AItem) == 0x000398, "Wrong size on AItem");
static_assert(offsetof(AItem, Origin) == 0x000228, "Member 'AItem::Origin' has a wrong offset!");
static_assert(offsetof(AItem, Count) == 0x000248, "Member 'AItem::Count' has a wrong offset!");
static_assert(offsetof(AItem, Character) == 0x000250, "Member 'AItem::Character' has a wrong offset!");
static_assert(offsetof(AItem, CharacterAnimMesh) == 0x000258, "Member 'AItem::CharacterAnimMesh' has a wrong offset!");
static_assert(offsetof(AItem, BringDownStateServer) == 0x0002E0, "Member 'AItem::BringDownStateServer' has a wrong offset!");
static_assert(offsetof(AItem, BringUpStateServer) == 0x0002E8, "Member 'AItem::BringUpStateServer' has a wrong offset!");
static_assert(offsetof(AItem, BringDownStateLocal) == 0x0002F0, "Member 'AItem::BringDownStateLocal' has a wrong offset!");
static_assert(offsetof(AItem, BringUpStateLocal) == 0x0002F8, "Member 'AItem::BringUpStateLocal' has a wrong offset!");
static_assert(offsetof(AItem, AttachSocketName) == 0x000300, "Member 'AItem::AttachSocketName' has a wrong offset!");

// Class Flame.ItemForBackpack
// 0x0018 (0x03B0 - 0x0398)
class AItemForBackpack : public AItem
{
public:
	int32                                         AmountPerSlotLimitation;                           // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x14];                                     // 0x039C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCost() const;
	int32 GetStackSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemForBackpack">();
	}
	static class AItemForBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemForBackpack>();
	}
};
static_assert(alignof(AItemForBackpack) == 0x000008, "Wrong alignment on AItemForBackpack");
static_assert(sizeof(AItemForBackpack) == 0x0003B0, "Wrong size on AItemForBackpack");
static_assert(offsetof(AItemForBackpack, AmountPerSlotLimitation) == 0x000398, "Member 'AItemForBackpack::AmountPerSlotLimitation' has a wrong offset!");

// Class Flame.AmmoItem
// 0x0000 (0x03B0 - 0x03B0)
class AAmmoItem : public AItemForBackpack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoItem">();
	}
	static class AAmmoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmoItem>();
	}
};
static_assert(alignof(AAmmoItem) == 0x000008, "Wrong alignment on AAmmoItem");
static_assert(sizeof(AAmmoItem) == 0x0003B0, "Wrong size on AAmmoItem");

// Class Flame.FlameWidget
// 0x0058 (0x02B8 - 0x0260)
class UFlameWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClosedDelegate;                                  // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChildFocusReceivedDelegate;                      // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChildFocusLostDelegate;                          // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCursor*                          CursorWidget;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ListenForInputAxis(class FName AxisName, bool bConsume, TDelegate<void(float AxisValue)> Callback);
	void OnChildFocusChange(class UWidget* Widget);
	void OnChildFocusLost(class UWidget* InWidget);
	void OnChildFocusReceived(class UWidget* InWidget);
	void StopListeningForInputAxis(class FName AxisName);

	class UWidget* GetFocusedWidget() const;
	const TArray<class FName> GetInputAxesToConsume() const;
	bool IsListeningForInputAxis(class FName AxisName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameWidget">();
	}
	static class UFlameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameWidget>();
	}
};
static_assert(alignof(UFlameWidget) == 0x000008, "Wrong alignment on UFlameWidget");
static_assert(sizeof(UFlameWidget) == 0x0002B8, "Wrong size on UFlameWidget");
static_assert(offsetof(UFlameWidget, OnClosedDelegate) == 0x000260, "Member 'UFlameWidget::OnClosedDelegate' has a wrong offset!");
static_assert(offsetof(UFlameWidget, OnChildFocusReceivedDelegate) == 0x000270, "Member 'UFlameWidget::OnChildFocusReceivedDelegate' has a wrong offset!");
static_assert(offsetof(UFlameWidget, OnChildFocusLostDelegate) == 0x000280, "Member 'UFlameWidget::OnChildFocusLostDelegate' has a wrong offset!");
static_assert(offsetof(UFlameWidget, CursorWidget) == 0x0002B0, "Member 'UFlameWidget::CursorWidget' has a wrong offset!");

// Class Flame.DefaultItemsComponent
// 0x0000 (0x00B0 - 0x00B0)
class UDefaultItemsComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultItemsComponent">();
	}
	static class UDefaultItemsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultItemsComponent>();
	}
};
static_assert(alignof(UDefaultItemsComponent) == 0x000008, "Wrong alignment on UDefaultItemsComponent");
static_assert(sizeof(UDefaultItemsComponent) == 0x0000B0, "Wrong size on UDefaultItemsComponent");

// Class Flame.StoredItemsComponent
// 0x0050 (0x0100 - 0x00B0)
class UStoredItemsComponent : public UDefaultItemsComponent
{
public:
	TMap<TSubclassOf<class AItemForBackpack>, int32> Items;                                             // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void SotoreItems(class UEquipmentStorageComponent* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoredItemsComponent">();
	}
	static class UStoredItemsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoredItemsComponent>();
	}
};
static_assert(alignof(UStoredItemsComponent) == 0x000008, "Wrong alignment on UStoredItemsComponent");
static_assert(sizeof(UStoredItemsComponent) == 0x000100, "Wrong size on UStoredItemsComponent");
static_assert(offsetof(UStoredItemsComponent, Items) == 0x0000B0, "Member 'UStoredItemsComponent::Items' has a wrong offset!");

// Class Flame.DefaultLootComponent
// 0x0060 (0x0160 - 0x0100)
class UDefaultLootComponent : public UStoredItemsComponent
{
public:
	TArray<TSubclassOf<class ATool>>              Tools;                                             // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AWeapon>, int32>       Weapons;                                           // 0x0110(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultLootComponent">();
	}
	static class UDefaultLootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultLootComponent>();
	}
};
static_assert(alignof(UDefaultLootComponent) == 0x000008, "Wrong alignment on UDefaultLootComponent");
static_assert(sizeof(UDefaultLootComponent) == 0x000160, "Wrong size on UDefaultLootComponent");
static_assert(offsetof(UDefaultLootComponent, Tools) == 0x000100, "Member 'UDefaultLootComponent::Tools' has a wrong offset!");
static_assert(offsetof(UDefaultLootComponent, Weapons) == 0x000110, "Member 'UDefaultLootComponent::Weapons' has a wrong offset!");

// Class Flame.CanBeSelectedInterface
// 0x0000 (0x0028 - 0x0028)
class ICanBeSelectedInterface final : public IInterface
{
public:
	void DoSelect(EInputIcon InputAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanBeSelectedInterface">();
	}
	static class ICanBeSelectedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanBeSelectedInterface>();
	}
};
static_assert(alignof(ICanBeSelectedInterface) == 0x000008, "Wrong alignment on ICanBeSelectedInterface");
static_assert(sizeof(ICanBeSelectedInterface) == 0x000028, "Wrong size on ICanBeSelectedInterface");

// Class Flame.ActionMachineDebugWidget
// 0x0000 (0x02B8 - 0x02B8)
class UActionMachineDebugWidget : public UFlameWidget
{
public:
	class FString GetItemStatesHistory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionMachineDebugWidget">();
	}
	static class UActionMachineDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionMachineDebugWidget>();
	}
};
static_assert(alignof(UActionMachineDebugWidget) == 0x000008, "Wrong alignment on UActionMachineDebugWidget");
static_assert(sizeof(UActionMachineDebugWidget) == 0x0002B8, "Wrong size on UActionMachineDebugWidget");

// Class Flame.CanvasFunctions
// 0x0000 (0x0028 - 0x0028)
class UCanvasFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void DrawMaterialQuads(class UCanvas* Canvas, class UMaterialInterface* RenderMaterial, const TArray<struct FCanvasUVQuad>& Quads);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanvasFunctions">();
	}
	static class UCanvasFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanvasFunctions>();
	}
};
static_assert(alignof(UCanvasFunctions) == 0x000008, "Wrong alignment on UCanvasFunctions");
static_assert(sizeof(UCanvasFunctions) == 0x000028, "Wrong size on UCanvasFunctions");

// Class Flame.ResourceItem
// 0x0000 (0x03B0 - 0x03B0)
class AResourceItem : public AItemForBackpack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceItem">();
	}
	static class AResourceItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResourceItem>();
	}
};
static_assert(alignof(AResourceItem) == 0x000008, "Wrong alignment on AResourceItem");
static_assert(sizeof(AResourceItem) == 0x0003B0, "Wrong size on AResourceItem");

// Class Flame.ShelterResourceItem
// 0x0000 (0x03B0 - 0x03B0)
class AShelterResourceItem : public AResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterResourceItem">();
	}
	static class AShelterResourceItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterResourceItem>();
	}
};
static_assert(alignof(AShelterResourceItem) == 0x000008, "Wrong alignment on AShelterResourceItem");
static_assert(sizeof(AShelterResourceItem) == 0x0003B0, "Wrong size on AShelterResourceItem");

// Class Flame.Fuel
// 0x0000 (0x03B0 - 0x03B0)
class AFuel : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fuel">();
	}
	static class AFuel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFuel>();
	}
};
static_assert(alignof(AFuel) == 0x000008, "Wrong alignment on AFuel");
static_assert(sizeof(AFuel) == 0x0003B0, "Wrong size on AFuel");

// Class Flame.ActionMachineSettings
// 0x0080 (0x00B8 - 0x0038)
class UActionMachineSettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        TableWithInputRules;                               // 0x0038(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TableWithNetworkInputRules;                        // 0x0050(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TableWithCustomInputRules;                         // 0x0068(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TableWithCustomInputFilters;                       // 0x0080(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithInputRulesLink;                           // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithNetworkInputRulesLink;                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithCustomInputRulesLink;                     // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithCustomInputFiltersLink;                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionMachineSettings">();
	}
	static class UActionMachineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionMachineSettings>();
	}
};
static_assert(alignof(UActionMachineSettings) == 0x000008, "Wrong alignment on UActionMachineSettings");
static_assert(sizeof(UActionMachineSettings) == 0x0000B8, "Wrong size on UActionMachineSettings");
static_assert(offsetof(UActionMachineSettings, TableWithInputRules) == 0x000038, "Member 'UActionMachineSettings::TableWithInputRules' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithNetworkInputRules) == 0x000050, "Member 'UActionMachineSettings::TableWithNetworkInputRules' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithCustomInputRules) == 0x000068, "Member 'UActionMachineSettings::TableWithCustomInputRules' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithCustomInputFilters) == 0x000080, "Member 'UActionMachineSettings::TableWithCustomInputFilters' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithInputRulesLink) == 0x000098, "Member 'UActionMachineSettings::TableWithInputRulesLink' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithNetworkInputRulesLink) == 0x0000A0, "Member 'UActionMachineSettings::TableWithNetworkInputRulesLink' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithCustomInputRulesLink) == 0x0000A8, "Member 'UActionMachineSettings::TableWithCustomInputRulesLink' has a wrong offset!");
static_assert(offsetof(UActionMachineSettings, TableWithCustomInputFiltersLink) == 0x0000B0, "Member 'UActionMachineSettings::TableWithCustomInputFiltersLink' has a wrong offset!");

// Class Flame.EditorTools
// 0x0000 (0x0028 - 0x0028)
class UEditorTools final : public UObject
{
public:
	static const float GetRealTimeForUserInterface();
	static void GetSelectedActors(TArray<class AActor*>* ActorList);
	static bool IsPreviewActor(const class AActor* Actor);
	static void SelectActor(class AActor* Actor, bool AddToSelection);
	static void SelectNoActors();
	static void UnSelectActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorTools">();
	}
	static class UEditorTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorTools>();
	}
};
static_assert(alignof(UEditorTools) == 0x000008, "Wrong alignment on UEditorTools");
static_assert(sizeof(UEditorTools) == 0x000028, "Wrong size on UEditorTools");

// Class Flame.Customization
// 0x0068 (0x0400 - 0x0398)
class ACustomization : public AItem
{
public:
	TSubclassOf<class ACustomizationSlot>         CustomMajorSlot;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ACustomizationSlot>> ForceHiddenSlots;                                  // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x50];                                     // 0x03B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMesh* GetMeshForGender(TSubclassOf<class AGender> Gender) const;
	bool IsCompatibleWithSlot(TSubclassOf<class ACustomizationSlot> Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Customization">();
	}
	static class ACustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomization>();
	}
};
static_assert(alignof(ACustomization) == 0x000008, "Wrong alignment on ACustomization");
static_assert(sizeof(ACustomization) == 0x000400, "Wrong size on ACustomization");
static_assert(offsetof(ACustomization, CustomMajorSlot) == 0x000398, "Member 'ACustomization::CustomMajorSlot' has a wrong offset!");
static_assert(offsetof(ACustomization, ForceHiddenSlots) == 0x0003A0, "Member 'ACustomization::ForceHiddenSlots' has a wrong offset!");

// Class Flame.CustomizationClothes
// 0x0000 (0x0400 - 0x0400)
class ACustomizationClothes : public ACustomization
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationClothes">();
	}
	static class ACustomizationClothes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationClothes>();
	}
};
static_assert(alignof(ACustomizationClothes) == 0x000008, "Wrong alignment on ACustomizationClothes");
static_assert(sizeof(ACustomizationClothes) == 0x000400, "Wrong size on ACustomizationClothes");

// Class Flame.AffectAmmoInterface
// 0x0000 (0x0028 - 0x0028)
class IAffectAmmoInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AffectAmmoInterface">();
	}
	static class IAffectAmmoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAffectAmmoInterface>();
	}
};
static_assert(alignof(IAffectAmmoInterface) == 0x000008, "Wrong alignment on IAffectAmmoInterface");
static_assert(sizeof(IAffectAmmoInterface) == 0x000028, "Wrong size on IAffectAmmoInterface");

// Class Flame.ClothesHeadgear
// 0x0010 (0x0410 - 0x0400)
class AClothesHeadgear : public ACustomizationClothes
{
public:
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesHeadgear">();
	}
	static class AClothesHeadgear* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesHeadgear>();
	}
};
static_assert(alignof(AClothesHeadgear) == 0x000008, "Wrong alignment on AClothesHeadgear");
static_assert(sizeof(AClothesHeadgear) == 0x000410, "Wrong size on AClothesHeadgear");

// Class Flame.CurrencyItem
// 0x0000 (0x03B0 - 0x03B0)
class ACurrencyItem : public AResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyItem">();
	}
	static class ACurrencyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyItem>();
	}
};
static_assert(alignof(ACurrencyItem) == 0x000008, "Wrong alignment on ACurrencyItem");
static_assert(sizeof(ACurrencyItem) == 0x0003B0, "Wrong size on ACurrencyItem");

// Class Flame.FoodItem
// 0x0000 (0x03B0 - 0x03B0)
class AFoodItem : public ACurrencyItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodItem">();
	}
	static class AFoodItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoodItem>();
	}
};
static_assert(alignof(AFoodItem) == 0x000008, "Wrong alignment on AFoodItem");
static_assert(sizeof(AFoodItem) == 0x0003B0, "Wrong size on AFoodItem");

// Class Flame.AimAssistComponent
// 0x0070 (0x0120 - 0x00B0)
class UAimAssistComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputDetectorModeChanged(int32 PlayerIndex, EInputMode NewMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistComponent">();
	}
	static class UAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistComponent>();
	}
};
static_assert(alignof(UAimAssistComponent) == 0x000008, "Wrong alignment on UAimAssistComponent");
static_assert(sizeof(UAimAssistComponent) == 0x000120, "Wrong size on UAimAssistComponent");

// Class Flame.EventAnimNotify
// 0x0020 (0x0058 - 0x0038)
class UEventAnimNotify final : public UAnimNotify
{
public:
	class FName                                   EventName;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAnimNotify">();
	}
	static class UEventAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAnimNotify>();
	}
};
static_assert(alignof(UEventAnimNotify) == 0x000008, "Wrong alignment on UEventAnimNotify");
static_assert(sizeof(UEventAnimNotify) == 0x000058, "Wrong size on UEventAnimNotify");
static_assert(offsetof(UEventAnimNotify, EventName) == 0x000038, "Member 'UEventAnimNotify::EventName' has a wrong offset!");

// Class Flame.ClothesHeadgearSet
// 0x0000 (0x0410 - 0x0410)
class AClothesHeadgearSet : public AClothesHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesHeadgearSet">();
	}
	static class AClothesHeadgearSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesHeadgearSet>();
	}
};
static_assert(alignof(AClothesHeadgearSet) == 0x000008, "Wrong alignment on AClothesHeadgearSet");
static_assert(sizeof(AClothesHeadgearSet) == 0x000410, "Wrong size on AClothesHeadgearSet");

// Class Flame.AIPatrolPathPoint
// 0x0010 (0x0230 - 0x0220)
class AAIPatrolPathPoint final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPatrolPathPoint">();
	}
	static class AAIPatrolPathPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIPatrolPathPoint>();
	}
};
static_assert(alignof(AAIPatrolPathPoint) == 0x000008, "Wrong alignment on AAIPatrolPathPoint");
static_assert(sizeof(AAIPatrolPathPoint) == 0x000230, "Wrong size on AAIPatrolPathPoint");
static_assert(offsetof(AAIPatrolPathPoint, Root) == 0x000220, "Member 'AAIPatrolPathPoint::Root' has a wrong offset!");
static_assert(offsetof(AAIPatrolPathPoint, SpriteComponent) == 0x000228, "Member 'AAIPatrolPathPoint::SpriteComponent' has a wrong offset!");

// Class Flame.ClothesHeadgearTop
// 0x0000 (0x0410 - 0x0410)
class AClothesHeadgearTop : public AClothesHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesHeadgearTop">();
	}
	static class AClothesHeadgearTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesHeadgearTop>();
	}
};
static_assert(alignof(AClothesHeadgearTop) == 0x000008, "Wrong alignment on AClothesHeadgearTop");
static_assert(sizeof(AClothesHeadgearTop) == 0x000410, "Wrong size on AClothesHeadgearTop");

// Class Flame.Currency
// 0x0000 (0x0398 - 0x0398)
class ACurrency : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Currency">();
	}
	static class ACurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrency>();
	}
};
static_assert(alignof(ACurrency) == 0x000008, "Wrong alignment on ACurrency");
static_assert(sizeof(ACurrency) == 0x000398, "Wrong size on ACurrency");

// Class Flame.CurrencyBoosterTicket
// 0x0010 (0x03A8 - 0x0398)
class ACurrencyBoosterTicket : public ACurrency
{
public:
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicket">();
	}
	static class ACurrencyBoosterTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicket>();
	}
};
static_assert(alignof(ACurrencyBoosterTicket) == 0x000008, "Wrong alignment on ACurrencyBoosterTicket");
static_assert(sizeof(ACurrencyBoosterTicket) == 0x0003A8, "Wrong size on ACurrencyBoosterTicket");

// Class Flame.CurrencyBoosterTicketEliminationScoreBooster
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketEliminationScoreBooster : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketEliminationScoreBooster">();
	}
	static class ACurrencyBoosterTicketEliminationScoreBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketEliminationScoreBooster>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketEliminationScoreBooster) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketEliminationScoreBooster");
static_assert(sizeof(ACurrencyBoosterTicketEliminationScoreBooster) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketEliminationScoreBooster");

// Class Flame.AIPatrolPath
// 0x0018 (0x0238 - 0x0220)
class AAIPatrolPath final : public AActor
{
public:
	EAAIPatrolPathType                            PatrolType;                                        // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAIPatrolPathPoint*>             PatrolPoints;                                      // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPatrolPath">();
	}
	static class AAIPatrolPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIPatrolPath>();
	}
};
static_assert(alignof(AAIPatrolPath) == 0x000008, "Wrong alignment on AAIPatrolPath");
static_assert(sizeof(AAIPatrolPath) == 0x000238, "Wrong size on AAIPatrolPath");
static_assert(offsetof(AAIPatrolPath, PatrolType) == 0x000220, "Member 'AAIPatrolPath::PatrolType' has a wrong offset!");
static_assert(offsetof(AAIPatrolPath, PatrolPoints) == 0x000228, "Member 'AAIPatrolPath::PatrolPoints' has a wrong offset!");

// Class Flame.SelectableWidget
// 0x0018 (0x02D0 - 0x02B8)
class USelectableWidget : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectableWidget">();
	}
	static class USelectableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectableWidget>();
	}
};
static_assert(alignof(USelectableWidget) == 0x000008, "Wrong alignment on USelectableWidget");
static_assert(sizeof(USelectableWidget) == 0x0002D0, "Wrong size on USelectableWidget");

// Class Flame.ClothesHeadgearMiddle
// 0x0000 (0x0410 - 0x0410)
class AClothesHeadgearMiddle : public AClothesHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesHeadgearMiddle">();
	}
	static class AClothesHeadgearMiddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesHeadgearMiddle>();
	}
};
static_assert(alignof(AClothesHeadgearMiddle) == 0x000008, "Wrong alignment on AClothesHeadgearMiddle");
static_assert(sizeof(AClothesHeadgearMiddle) == 0x000410, "Wrong size on AClothesHeadgearMiddle");

// Class Flame.AmbientSoundExtended
// 0x0008 (0x0228 - 0x0220)
class AAmbientSoundExtended : public AActor
{
public:
	class UAudioComponentExtended*                AudioComponent;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientSoundExtended">();
	}
	static class AAmbientSoundExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbientSoundExtended>();
	}
};
static_assert(alignof(AAmbientSoundExtended) == 0x000008, "Wrong alignment on AAmbientSoundExtended");
static_assert(sizeof(AAmbientSoundExtended) == 0x000228, "Wrong size on AAmbientSoundExtended");
static_assert(offsetof(AAmbientSoundExtended, AudioComponent) == 0x000220, "Member 'AAmbientSoundExtended::AudioComponent' has a wrong offset!");

// Class Flame.Electronics
// 0x0000 (0x03B0 - 0x03B0)
class AElectronics : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Electronics">();
	}
	static class AElectronics* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElectronics>();
	}
};
static_assert(alignof(AElectronics) == 0x000008, "Wrong alignment on AElectronics");
static_assert(sizeof(AElectronics) == 0x0003B0, "Wrong size on AElectronics");

// Class Flame.AmbienceAreaBase
// 0x0070 (0x0298 - 0x0228)
class AAmbienceAreaBase : public AAmbientSoundExtended
{
public:
	TArray<struct FAmbienceAreaProceduralSound>   ProceduralSounds;                                  // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAmbienceAreaLoopingSound>      LoopingSounds;                                     // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForestModifier;                                    // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ForestModifierCurve;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingsAreaModifier;                             // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BuildingsAreaModifierCurve;                        // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlendGlobalAmbience;                              // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmbienceWeight;                                    // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            GlobalAmbienceVolumeCurve;                         // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddProceduralSound(class USoundBase* Sound, float MinDelay, float MaxDelay);
	void OnPlayProceduralSound(class USoundBase* Sound, bool PlaceOnGround);
	void StartGlobalAmbienceBlend();
	void StartProceduralSounds();
	void StopGlobalAmbienceBlend();
	void StopProceduralSounds();

	float GetRelativeDistanceFromCenter(const struct FVector& Location, bool bInnerOnly, bool bClamped) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbienceAreaBase">();
	}
	static class AAmbienceAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbienceAreaBase>();
	}
};
static_assert(alignof(AAmbienceAreaBase) == 0x000008, "Wrong alignment on AAmbienceAreaBase");
static_assert(sizeof(AAmbienceAreaBase) == 0x000298, "Wrong size on AAmbienceAreaBase");
static_assert(offsetof(AAmbienceAreaBase, ProceduralSounds) == 0x000228, "Member 'AAmbienceAreaBase::ProceduralSounds' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, LoopingSounds) == 0x000238, "Member 'AAmbienceAreaBase::LoopingSounds' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, ForestModifier) == 0x000258, "Member 'AAmbienceAreaBase::ForestModifier' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, ForestModifierCurve) == 0x000260, "Member 'AAmbienceAreaBase::ForestModifierCurve' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, BuildingsAreaModifier) == 0x000268, "Member 'AAmbienceAreaBase::BuildingsAreaModifier' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, BuildingsAreaModifierCurve) == 0x000270, "Member 'AAmbienceAreaBase::BuildingsAreaModifierCurve' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, bBlendGlobalAmbience) == 0x000278, "Member 'AAmbienceAreaBase::bBlendGlobalAmbience' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, AmbienceWeight) == 0x00027C, "Member 'AAmbienceAreaBase::AmbienceWeight' has a wrong offset!");
static_assert(offsetof(AAmbienceAreaBase, GlobalAmbienceVolumeCurve) == 0x000280, "Member 'AAmbienceAreaBase::GlobalAmbienceVolumeCurve' has a wrong offset!");

// Class Flame.ItemsList
// 0x0090 (0x00B8 - 0x0028)
class UItemsList : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBackpackItemSlot>              SlotsClasses;                                      // 0x0078(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x30];                                      // 0x0088(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PostChange();
	void OnRep_PostChangeClasses();

	const TArray<struct FBackpackItemSlot> GetSlotsClassesConst() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsList">();
	}
	static class UItemsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsList>();
	}
};
static_assert(alignof(UItemsList) == 0x000008, "Wrong alignment on UItemsList");
static_assert(sizeof(UItemsList) == 0x0000B8, "Wrong size on UItemsList");
static_assert(offsetof(UItemsList, SlotsClasses) == 0x000078, "Member 'UItemsList::SlotsClasses' has a wrong offset!");

// Class Flame.CraftingList
// 0x0018 (0x00D0 - 0x00B8)
class UCraftingList : public UItemsList
{
public:
	TWeakObjectPtr<class UStashComponent>         ParentStash;                                       // 0x00B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class APlan>>              AvailablePlans;                                    // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	TArray<TSubclassOf<class APartItem>> GetMissingPartsFor(TSubclassOf<class APlan> OnePlanClass) const;
	class UStashComponent* GetStashComponent() const;
	bool HasAllPartsFor(TSubclassOf<class APlan> OnePlanClass) const;
	bool IsPlanUnlocked(TSubclassOf<class APlan> OnePlanClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingList">();
	}
	static class UCraftingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingList>();
	}
};
static_assert(alignof(UCraftingList) == 0x000008, "Wrong alignment on UCraftingList");
static_assert(sizeof(UCraftingList) == 0x0000D0, "Wrong size on UCraftingList");
static_assert(offsetof(UCraftingList, ParentStash) == 0x0000B8, "Member 'UCraftingList::ParentStash' has a wrong offset!");
static_assert(offsetof(UCraftingList, AvailablePlans) == 0x0000C0, "Member 'UCraftingList::AvailablePlans' has a wrong offset!");

// Class Flame.AmmoCraftingList
// 0x0000 (0x00D0 - 0x00D0)
class UAmmoCraftingList final : public UCraftingList
{
public:
	class AAmmoItem* AssemblyAmmo(const class AAmmoPlan* OnePlan);

	bool HasMaterialFor(const class AAmmoPlan* OnePlan) const;
	int32 HowManyMaterialIsMissingFor(const class AAmmoPlan* OnePlan) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoCraftingList">();
	}
	static class UAmmoCraftingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoCraftingList>();
	}
};
static_assert(alignof(UAmmoCraftingList) == 0x000008, "Wrong alignment on UAmmoCraftingList");
static_assert(sizeof(UAmmoCraftingList) == 0x0000D0, "Wrong size on UAmmoCraftingList");

// Class Flame.AnalyticsManager
// 0x0038 (0x0060 - 0x0028)
class UAnalyticsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool SendEvent(class UObject* WorldContextObject, const class FString& EventName, class UJsonObject* EventData);

	void OnCloudStateChange(ECloudManagerState OldState, ECloudManagerState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalyticsManager">();
	}
	static class UAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalyticsManager>();
	}
};
static_assert(alignof(UAnalyticsManager) == 0x000008, "Wrong alignment on UAnalyticsManager");
static_assert(sizeof(UAnalyticsManager) == 0x000060, "Wrong size on UAnalyticsManager");

// Class Flame.Wire
// 0x0000 (0x03B0 - 0x03B0)
class AWire : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wire">();
	}
	static class AWire* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWire>();
	}
};
static_assert(alignof(AWire) == 0x000008, "Wrong alignment on AWire");
static_assert(sizeof(AWire) == 0x0003B0, "Wrong size on AWire");

// Class Flame.CustomizationArchetype
// 0x0088 (0x0488 - 0x0400)
class ACustomizationArchetype : public ACustomization
{
public:
	TSubclassOf<class ACustomizationSlotArchetype> Slot;                                              // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x80];                                     // 0x0408(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationArchetype">();
	}
	static class ACustomizationArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationArchetype>();
	}
};
static_assert(alignof(ACustomizationArchetype) == 0x000008, "Wrong alignment on ACustomizationArchetype");
static_assert(sizeof(ACustomizationArchetype) == 0x000488, "Wrong size on ACustomizationArchetype");
static_assert(offsetof(ACustomizationArchetype, Slot) == 0x000400, "Member 'ACustomizationArchetype::Slot' has a wrong offset!");

// Class Flame.AudioComponentExtended
// 0x0040 (0x08A0 - 0x0860)
class UAudioComponentExtended : public UAudioComponent
{
public:
	bool                                          bUseSpeedOfSound;                                  // 0x0860(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_861[0x33];                                     // 0x0861(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyWeatherParameters;                           // 0x0894(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyEnvironmentParameters;                       // 0x0895(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_896[0xA];                                      // 0x0896(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustAttenuationExtended(const struct FSoundAttenuationSettings& InAttenuationSettings);
	void FadeInDelayed(float Delay, float FadeInDuration, float FadeVolumeLevel, float StartTime);
	void FadeOutDelayed(float Delay, float FadeOutDuration, float FadeVolumeLevel);
	void PlayDelayed(float Delay, float StartTime);
	void SetApplyEnvironmentParameters(bool bApply);
	void SetApplyWeatherParameters(bool bEnable);

	float GetSoundTravelTimeForListener() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioComponentExtended">();
	}
	static class UAudioComponentExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioComponentExtended>();
	}
};
static_assert(alignof(UAudioComponentExtended) == 0x000010, "Wrong alignment on UAudioComponentExtended");
static_assert(sizeof(UAudioComponentExtended) == 0x0008A0, "Wrong size on UAudioComponentExtended");
static_assert(offsetof(UAudioComponentExtended, bUseSpeedOfSound) == 0x000860, "Member 'UAudioComponentExtended::bUseSpeedOfSound' has a wrong offset!");
static_assert(offsetof(UAudioComponentExtended, bApplyWeatherParameters) == 0x000894, "Member 'UAudioComponentExtended::bApplyWeatherParameters' has a wrong offset!");
static_assert(offsetof(UAudioComponentExtended, bApplyEnvironmentParameters) == 0x000895, "Member 'UAudioComponentExtended::bApplyEnvironmentParameters' has a wrong offset!");

// Class Flame.ItemState
// 0x0050 (0x0078 - 0x0028)
class UItemState : public UObject
{
public:
	float                                         NeededTime;                                        // 0x0028(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTimeInSeconds;                                // 0x0030(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EStatePhase                                   Phase;                                             // 0x0038(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3F];                                      // 0x0039(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetDebugString() const;
	EStatePhase GetPhase() const;
	float GetRunningTimeInSec() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemState">();
	}
	static class UItemState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemState>();
	}
};
static_assert(alignof(UItemState) == 0x000008, "Wrong alignment on UItemState");
static_assert(sizeof(UItemState) == 0x000078, "Wrong size on UItemState");
static_assert(offsetof(UItemState, NeededTime) == 0x000028, "Member 'UItemState::NeededTime' has a wrong offset!");
static_assert(offsetof(UItemState, StartTimeInSeconds) == 0x000030, "Member 'UItemState::StartTimeInSeconds' has a wrong offset!");
static_assert(offsetof(UItemState, Phase) == 0x000038, "Member 'UItemState::Phase' has a wrong offset!");

// Class Flame.ItemStateBringUp
// 0x0008 (0x0080 - 0x0078)
class UItemStateBringUp final : public UItemState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStateBringUp">();
	}
	static class UItemStateBringUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStateBringUp>();
	}
};
static_assert(alignof(UItemStateBringUp) == 0x000008, "Wrong alignment on UItemStateBringUp");
static_assert(sizeof(UItemStateBringUp) == 0x000080, "Wrong size on UItemStateBringUp");

// Class Flame.AudioFunctions
// 0x0000 (0x0028 - 0x0028)
class UAudioFunctions final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateBoxAttenuationValue(const class UObject* WorldContextObject, const struct FVector& SourceLocation, const struct FRotator& SourceRotation, const struct FVector& BoxExtent, const struct FVector& BoxOffset, float InnerRadiusRatio, class UCurveFloat* AttenuationCurveX, class UCurveFloat* AttenuationCurveY, class UCurveFloat* AttenuationCurveZ, bool bDebug);
	static struct FVector GetAudioListenerLocation(const class UObject* WorldContextObject, int32 ListenerIndex);
	static float GetAudioRelativeZLevel(const class UObject* WorldContextObject, const struct FVector& Location);
	static struct FAudioWeatherInfo GetAudioWeatherInfo(const class UObject* WorldContextObject);
	static bool GetBoolParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName);
	static float GetFloatParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName);
	static int32 GetIntParameter(class UAudioComponent* AudioComponent, const class FName& ParameterName);
	static class USoundBase* GetSoundByGender(class USoundBase* MaleSound, class USoundBase* FemaleSound, const class AActor* ActorWithCustomizationComponent);
	static class USoundClass* GetSoundClass(class USoundBase* Sound);
	static void HandleVehicleRainSound(float RainAmount, class UCurveFloat* RainAmountCurve, class UAudioComponent* AudioComponent, float FadeInTime, float FadeOutTime);
	static void SetAudioListener(class USceneComponent* ListenerComponent, const struct FVector& Location, const struct FRotator& Rotation);
	static void SetAudioListenerToCamera(const class UObject* WorldContextObject);
	static void SetBoolParameterSafe(class UAudioComponent* AudioComponent, class FName InName, bool InBool);
	static void SetDefaultAudioListener(const class UObject* WorldContextObject);
	static void SetFloatParameterSafe(class UAudioComponent* AudioComponent, class FName InName, float InFloat);
	static void SetIntParameterSafe(class UAudioComponent* AudioComponent, class FName InName, int32 InInt);
	static void SetPitchMultiplierSafe(class UAudioComponent* AudioComponent, float NewPitchMultiplier);
	static void SetVolumeMultiplierSafe(class UAudioComponent* AudioComponent, float NewVolumeMultiplier);
	static void SetWaveParameterSafe(class UAudioComponent* AudioComponent, class FName InName, class USoundWave* InWave);
	static class UAudioComponentExtended* SpawnSoundAtLocationExtended(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, float Delay, bool bUseSpeedOfSound, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static class UAudioComponentExtended* SpawnSoundAttachedExtended(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, float Delay, bool bUseSpeedOfSound, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static class UAudioComponentExtended* SpawnVoiceSound(class USoundBase* MaleSound, class USoundBase* FemaleSound, class AHumanCharacter* OwnerCharacter, class FName VoiceSoundType, float RepeatTimeSeconds, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFunctions">();
	}
	static class UAudioFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFunctions>();
	}
};
static_assert(alignof(UAudioFunctions) == 0x000008, "Wrong alignment on UAudioFunctions");
static_assert(sizeof(UAudioFunctions) == 0x000028, "Wrong size on UAudioFunctions");

// Class Flame.AudioOcclusionComponentBase
// 0x0018 (0x00C8 - 0x00B0)
class UAudioOcclusionComponentBase final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xC];                                       // 0x00B0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSideTraceRings;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CountIndexesFromTraceResults(const struct FAudioOcclusionMainTraceResult& MainTrace, const TArray<struct FAudioOcclusionSideTraceResult>& SideTraces, float* OcclusionIndex, float* LowPassIndex);
	void EaseIndexes(float DeltaTime, float CurrentOcclusionIndex, float CurrentLowPassIndex, float PreviousOcclusionIndex, float PreviousLowPassIndex, float* EasedOcclusionIndex, float* EasedLowPassIndex);
	float LowPassIndexToLowPassFrequency(float LowPassIndex);
	float OcclusionIndexToVolumeMultiplier(float OcclusionIndex);
	void PerformMainTrace(const class UAudioComponent* AudioSource, struct FAudioOcclusionMainTraceResult* Result);
	void PerformSideTrace(const class UAudioComponent* AudioSource, int32 RingIndex, int32 TraceInRingIndex, float MainOcclusionIndex, float MainLowPassIndex, struct FAudioOcclusionSideTraceResult* Result);
	void PlayDebugSound(class USoundBase* SoundToPlay, const struct FVector& Location);
	void PrintDebugDepthTraceHitInfo(EPhysicalSurface SurfaceType, float Depth, float DepthIndex, float Distance, float DistanceIndex, float OcclusionIndex);
	void PrintDebugFloat(const class FString& Name_0, float Value);
	void PrintDebugString(const class FString& Text);
	void StopDebugSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioOcclusionComponentBase">();
	}
	static class UAudioOcclusionComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioOcclusionComponentBase>();
	}
};
static_assert(alignof(UAudioOcclusionComponentBase) == 0x000008, "Wrong alignment on UAudioOcclusionComponentBase");
static_assert(sizeof(UAudioOcclusionComponentBase) == 0x0000C8, "Wrong size on UAudioOcclusionComponentBase");
static_assert(offsetof(UAudioOcclusionComponentBase, NumSideTraceRings) == 0x0000BC, "Member 'UAudioOcclusionComponentBase::NumSideTraceRings' has a wrong offset!");

// Class Flame.Plan
// 0x0040 (0x03D8 - 0x0398)
class APlan : public AItem
{
public:
	uint8                                         Pad_398[0x40];                                     // 0x0398(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Plan">();
	}
	static class APlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlan>();
	}
};
static_assert(alignof(APlan) == 0x000008, "Wrong alignment on APlan");
static_assert(sizeof(APlan) == 0x0003D8, "Wrong size on APlan");

// Class Flame.AmmoPlan
// 0x0008 (0x03E0 - 0x03D8)
class AAmmoPlan final : public APlan
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class AAmmoItem> GetAmmoClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoPlan">();
	}
	static class AAmmoPlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmoPlan>();
	}
};
static_assert(alignof(AAmmoPlan) == 0x000008, "Wrong alignment on AAmmoPlan");
static_assert(sizeof(AAmmoPlan) == 0x0003E0, "Wrong size on AAmmoPlan");

// Class Flame.AvailableWeaponsForLoadout
// 0x0040 (0x0068 - 0x0028)
class UAvailableWeaponsForLoadout final : public UObject
{
public:
	TArray<TSubclassOf<class APrimaryWeapon>>     PrimaryWeapons;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ASideArmWeapon>>     SecondaryWeapons;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AMeleeWeapon>>       MeleeWeapons;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AThrowable>>         GrenadeWeapons;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvailableWeaponsForLoadout">();
	}
	static class UAvailableWeaponsForLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvailableWeaponsForLoadout>();
	}
};
static_assert(alignof(UAvailableWeaponsForLoadout) == 0x000008, "Wrong alignment on UAvailableWeaponsForLoadout");
static_assert(sizeof(UAvailableWeaponsForLoadout) == 0x000068, "Wrong size on UAvailableWeaponsForLoadout");
static_assert(offsetof(UAvailableWeaponsForLoadout, PrimaryWeapons) == 0x000028, "Member 'UAvailableWeaponsForLoadout::PrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UAvailableWeaponsForLoadout, SecondaryWeapons) == 0x000038, "Member 'UAvailableWeaponsForLoadout::SecondaryWeapons' has a wrong offset!");
static_assert(offsetof(UAvailableWeaponsForLoadout, MeleeWeapons) == 0x000048, "Member 'UAvailableWeaponsForLoadout::MeleeWeapons' has a wrong offset!");
static_assert(offsetof(UAvailableWeaponsForLoadout, GrenadeWeapons) == 0x000058, "Member 'UAvailableWeaponsForLoadout::GrenadeWeapons' has a wrong offset!");

// Class Flame.CustomisationMeshComponent
// 0x0010 (0x0EF0 - 0x0EE0)
class UCustomisationMeshComponent : public USkeletalMeshComponent
{
public:
	TSubclassOf<class ACustomizationSlot>         Slot;                                              // 0x0ED8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EE0[0x10];                                     // 0x0EE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class ACustomizationSlot> GetSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomisationMeshComponent">();
	}
	static class UCustomisationMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomisationMeshComponent>();
	}
};
static_assert(alignof(UCustomisationMeshComponent) == 0x000010, "Wrong alignment on UCustomisationMeshComponent");
static_assert(sizeof(UCustomisationMeshComponent) == 0x000EF0, "Wrong size on UCustomisationMeshComponent");
static_assert(offsetof(UCustomisationMeshComponent, Slot) == 0x000ED8, "Member 'UCustomisationMeshComponent::Slot' has a wrong offset!");

// Class Flame.ObjectiveItem
// 0x0010 (0x03C0 - 0x03B0)
class AObjectiveItem : public AItemForBackpack
{
public:
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveItem">();
	}
	static class AObjectiveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectiveItem>();
	}
};
static_assert(alignof(AObjectiveItem) == 0x000008, "Wrong alignment on AObjectiveItem");
static_assert(sizeof(AObjectiveItem) == 0x0003C0, "Wrong size on AObjectiveItem");

// Class Flame.BackpackComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UBackpackComponent : public UCustomisationMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackpackComponent">();
	}
	static class UBackpackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackpackComponent>();
	}
};
static_assert(alignof(UBackpackComponent) == 0x000010, "Wrong alignment on UBackpackComponent");
static_assert(sizeof(UBackpackComponent) == 0x000EF0, "Wrong size on UBackpackComponent");

// Class Flame.BattlePassSystem
// 0x0070 (0x0098 - 0x0028)
class UBattlePassSystem : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             GetCurrentBattlePassSeasonStateFinished;           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetAllBattlePassSeasonsStateFinished;              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClaimBattlePassRewardsFinished;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PurchaseBattlePassLevelFinished;                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SelectLegacySeasonFinished;                        // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewExperienceEvent;                              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BlueprintDeInit();
	void BlueprintInit();
	int32 ClaimBattlePassRewards(class AHumanPlayerController* Player, const TArray<struct FCloudBattlePassSeasonClaim>& ClaimInfo);
	void ClaimBattlePassRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassRewardsClaim& Data);
	int32 GetAllBattlePassSeasonsState(class AHumanPlayerController* Player);
	void GetAllBattlePassSeasonsStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassSeasonsState& Data);
	int32 GetCurrentBattlePassSeasonState(class AHumanPlayerController* Player);
	void GetCurrentBattlePassSeasonStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassSeasonState& Data);
	class UFlameGameInstance* GetGameInstance();
	int32 GetLevelInSeason(class FName SeasonName);
	bool GetPremiumStatus(class FName SeasonName);
	class FName GetSeasonName(EBattlePassSeasonType SeasonType);
	int32 GetTotalXP(class FName SeasonName);
	TArray<class FName> GetUnclaimedRewardsCode(bool IsLegacy, TArray<struct FBattlePassLevelRewardFull>* FreeRewards, TArray<struct FBattlePassLevelRewardFull>* PremiumRewards);
	int32 GetXPBooster();
	int32 GetXPWithinLevel(class FName SeasonName);
	void OnNewExperienceEvent__DelegateSignature(class AHumanPlayerController* Player, const struct FCloudBattlePassExperienceEvent& Event);
	int32 PurchaseBattlePassLevel(class AHumanPlayerController* Player, const class FName& SeasonName, int32 CurrentLevel, int32 TargetLevel, int32 Price);
	void PurchaseBattlePassLevelDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBattlePassLevelPurchase& Data);
	int32 SelectLegacySeason(class AHumanPlayerController* Player, const class FName& SeasonName);
	void SelectLegacySeasonDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassSystem">();
	}
	static class UBattlePassSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassSystem>();
	}
};
static_assert(alignof(UBattlePassSystem) == 0x000008, "Wrong alignment on UBattlePassSystem");
static_assert(sizeof(UBattlePassSystem) == 0x000098, "Wrong size on UBattlePassSystem");
static_assert(offsetof(UBattlePassSystem, GetCurrentBattlePassSeasonStateFinished) == 0x000038, "Member 'UBattlePassSystem::GetCurrentBattlePassSeasonStateFinished' has a wrong offset!");
static_assert(offsetof(UBattlePassSystem, GetAllBattlePassSeasonsStateFinished) == 0x000048, "Member 'UBattlePassSystem::GetAllBattlePassSeasonsStateFinished' has a wrong offset!");
static_assert(offsetof(UBattlePassSystem, ClaimBattlePassRewardsFinished) == 0x000058, "Member 'UBattlePassSystem::ClaimBattlePassRewardsFinished' has a wrong offset!");
static_assert(offsetof(UBattlePassSystem, PurchaseBattlePassLevelFinished) == 0x000068, "Member 'UBattlePassSystem::PurchaseBattlePassLevelFinished' has a wrong offset!");
static_assert(offsetof(UBattlePassSystem, SelectLegacySeasonFinished) == 0x000078, "Member 'UBattlePassSystem::SelectLegacySeasonFinished' has a wrong offset!");
static_assert(offsetof(UBattlePassSystem, OnNewExperienceEvent) == 0x000088, "Member 'UBattlePassSystem::OnNewExperienceEvent' has a wrong offset!");

// Class Flame.BiSignificanceManagerImpl
// 0x0048 (0x0268 - 0x0220)
class ABiSignificanceManagerImpl final : public AActor
{
public:
	int32                                         BaseDist;                                          // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket0Multip;                                     // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket1Multip;                                     // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket2Multip;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket3Multip;                                     // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket0UpdateRate;                                 // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket1UpdateRate;                                 // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket2UpdateRate;                                 // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket3UpdateRate;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket4UpdateRate;                                 // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bucket5UpdateRate;                                 // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USignificanceManager*                   SignificanceManager;                               // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ManagedActors;                                     // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void MyPostSignificanceFunctionBody(class AActor* Actor, int32 Bucket);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BiSignificanceManagerImpl">();
	}
	static class ABiSignificanceManagerImpl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABiSignificanceManagerImpl>();
	}
};
static_assert(alignof(ABiSignificanceManagerImpl) == 0x000008, "Wrong alignment on ABiSignificanceManagerImpl");
static_assert(sizeof(ABiSignificanceManagerImpl) == 0x000268, "Wrong size on ABiSignificanceManagerImpl");
static_assert(offsetof(ABiSignificanceManagerImpl, BaseDist) == 0x000220, "Member 'ABiSignificanceManagerImpl::BaseDist' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket0Multip) == 0x000224, "Member 'ABiSignificanceManagerImpl::Bucket0Multip' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket1Multip) == 0x000228, "Member 'ABiSignificanceManagerImpl::Bucket1Multip' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket2Multip) == 0x00022C, "Member 'ABiSignificanceManagerImpl::Bucket2Multip' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket3Multip) == 0x000230, "Member 'ABiSignificanceManagerImpl::Bucket3Multip' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket0UpdateRate) == 0x000234, "Member 'ABiSignificanceManagerImpl::Bucket0UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket1UpdateRate) == 0x000238, "Member 'ABiSignificanceManagerImpl::Bucket1UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket2UpdateRate) == 0x00023C, "Member 'ABiSignificanceManagerImpl::Bucket2UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket3UpdateRate) == 0x000240, "Member 'ABiSignificanceManagerImpl::Bucket3UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket4UpdateRate) == 0x000244, "Member 'ABiSignificanceManagerImpl::Bucket4UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, Bucket5UpdateRate) == 0x000248, "Member 'ABiSignificanceManagerImpl::Bucket5UpdateRate' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, SignificanceManager) == 0x000250, "Member 'ABiSignificanceManagerImpl::SignificanceManager' has a wrong offset!");
static_assert(offsetof(ABiSignificanceManagerImpl, ManagedActors) == 0x000258, "Member 'ABiSignificanceManagerImpl::ManagedActors' has a wrong offset!");

// Class Flame.BitwiseBPFunctions
// 0x0000 (0x0028 - 0x0028)
class UBitwiseBPFunctions final : public UBlueprintFunctionLibrary
{
public:
	static int32 BitwiseShiftLeft(const int32 A, const int32 Bits);
	static int32 BitwiseShiftRight(const int32 A, const int32 Bits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BitwiseBPFunctions">();
	}
	static class UBitwiseBPFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBitwiseBPFunctions>();
	}
};
static_assert(alignof(UBitwiseBPFunctions) == 0x000008, "Wrong alignment on UBitwiseBPFunctions");
static_assert(sizeof(UBitwiseBPFunctions) == 0x000028, "Wrong size on UBitwiseBPFunctions");

// Class Flame.BTTask_AIBase
// 0x0000 (0x0070 - 0x0070)
class UBTTask_AIBase : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIBase">();
	}
	static class UBTTask_AIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIBase>();
	}
};
static_assert(alignof(UBTTask_AIBase) == 0x000008, "Wrong alignment on UBTTask_AIBase");
static_assert(sizeof(UBTTask_AIBase) == 0x000070, "Wrong size on UBTTask_AIBase");

// Class Flame.BTTask_AimAndShootCharacter
// 0x0020 (0x00B8 - 0x0098)
class UBTTask_AimAndShootCharacter final : public UBTTask_BlackboardBase
{
public:
	float                                         TimeBetweeenShotsMin;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeBetweeenShotsMax;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInfiniteShots;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfShots;                                     // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreIfInSight;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseSuccessRateFromBlackboard;                     // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShortestDistanceToEnemy;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FarthestDistanceToEnemy;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SuccessRateNear;                                   // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SuccessRateFar;                                    // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AimAndShootCharacter">();
	}
	static class UBTTask_AimAndShootCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AimAndShootCharacter>();
	}
};
static_assert(alignof(UBTTask_AimAndShootCharacter) == 0x000008, "Wrong alignment on UBTTask_AimAndShootCharacter");
static_assert(sizeof(UBTTask_AimAndShootCharacter) == 0x0000B8, "Wrong size on UBTTask_AimAndShootCharacter");
static_assert(offsetof(UBTTask_AimAndShootCharacter, TimeBetweeenShotsMin) == 0x000098, "Member 'UBTTask_AimAndShootCharacter::TimeBetweeenShotsMin' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, TimeBetweeenShotsMax) == 0x00009C, "Member 'UBTTask_AimAndShootCharacter::TimeBetweeenShotsMax' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, bInfiniteShots) == 0x0000A0, "Member 'UBTTask_AimAndShootCharacter::bInfiniteShots' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, NumberOfShots) == 0x0000A4, "Member 'UBTTask_AimAndShootCharacter::NumberOfShots' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, bIgnoreIfInSight) == 0x0000A8, "Member 'UBTTask_AimAndShootCharacter::bIgnoreIfInSight' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, bUseSuccessRateFromBlackboard) == 0x0000A9, "Member 'UBTTask_AimAndShootCharacter::bUseSuccessRateFromBlackboard' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, ShortestDistanceToEnemy) == 0x0000AC, "Member 'UBTTask_AimAndShootCharacter::ShortestDistanceToEnemy' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, FarthestDistanceToEnemy) == 0x0000B0, "Member 'UBTTask_AimAndShootCharacter::FarthestDistanceToEnemy' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, SuccessRateNear) == 0x0000B4, "Member 'UBTTask_AimAndShootCharacter::SuccessRateNear' has a wrong offset!");
static_assert(offsetof(UBTTask_AimAndShootCharacter, SuccessRateFar) == 0x0000B5, "Member 'UBTTask_AimAndShootCharacter::SuccessRateFar' has a wrong offset!");

// Class Flame.ItemUseState
// 0x0010 (0x0088 - 0x0078)
class UItemUseState : public UItemState
{
public:
	EItemUseMode                                  Mode;                                              // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EItemUseMode GetMode() const;
	float GetProgress() const;
	class AActor* GetTargetUnderCursor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUseState">();
	}
	static class UItemUseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUseState>();
	}
};
static_assert(alignof(UItemUseState) == 0x000008, "Wrong alignment on UItemUseState");
static_assert(sizeof(UItemUseState) == 0x000088, "Wrong size on UItemUseState");
static_assert(offsetof(UItemUseState, Mode) == 0x000078, "Member 'UItemUseState::Mode' has a wrong offset!");
static_assert(offsetof(UItemUseState, Target) == 0x00007C, "Member 'UItemUseState::Target' has a wrong offset!");

// Class Flame.ItemUseStateThrowable
// 0x0008 (0x0090 - 0x0088)
class UItemUseStateThrowable final : public UItemUseState
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUseStateThrowable">();
	}
	static class UItemUseStateThrowable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUseStateThrowable>();
	}
};
static_assert(alignof(UItemUseStateThrowable) == 0x000008, "Wrong alignment on UItemUseStateThrowable");
static_assert(sizeof(UItemUseStateThrowable) == 0x000090, "Wrong size on UItemUseStateThrowable");

// Class Flame.BTTask_CleanBlackboardValue
// 0x0000 (0x0098 - 0x0098)
class UBTTask_CleanBlackboardValue final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CleanBlackboardValue">();
	}
	static class UBTTask_CleanBlackboardValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CleanBlackboardValue>();
	}
};
static_assert(alignof(UBTTask_CleanBlackboardValue) == 0x000008, "Wrong alignment on UBTTask_CleanBlackboardValue");
static_assert(sizeof(UBTTask_CleanBlackboardValue) == 0x000098, "Wrong size on UBTTask_CleanBlackboardValue");

// Class Flame.BTTask_StopAiming
// 0x0000 (0x0070 - 0x0070)
class UBTTask_StopAiming final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_StopAiming">();
	}
	static class UBTTask_StopAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_StopAiming>();
	}
};
static_assert(alignof(UBTTask_StopAiming) == 0x000008, "Wrong alignment on UBTTask_StopAiming");
static_assert(sizeof(UBTTask_StopAiming) == 0x000070, "Wrong size on UBTTask_StopAiming");

// Class Flame.LeaderboardDataCache
// 0x0050 (0x0078 - 0x0028)
class ULeaderboardDataCache final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardDataCache">();
	}
	static class ULeaderboardDataCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardDataCache>();
	}
};
static_assert(alignof(ULeaderboardDataCache) == 0x000008, "Wrong alignment on ULeaderboardDataCache");
static_assert(sizeof(ULeaderboardDataCache) == 0x000078, "Wrong size on ULeaderboardDataCache");

// Class Flame.BTTask_ShootAtPlayer
// 0x0000 (0x0070 - 0x0070)
class UBTTask_ShootAtPlayer final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ShootAtPlayer">();
	}
	static class UBTTask_ShootAtPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ShootAtPlayer>();
	}
};
static_assert(alignof(UBTTask_ShootAtPlayer) == 0x000008, "Wrong alignment on UBTTask_ShootAtPlayer");
static_assert(sizeof(UBTTask_ShootAtPlayer) == 0x000070, "Wrong size on UBTTask_ShootAtPlayer");

// Class Flame.BTTask_CheckAmmoAndReload
// 0x0000 (0x0070 - 0x0070)
class UBTTask_CheckAmmoAndReload final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CheckAmmoAndReload">();
	}
	static class UBTTask_CheckAmmoAndReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CheckAmmoAndReload>();
	}
};
static_assert(alignof(UBTTask_CheckAmmoAndReload) == 0x000008, "Wrong alignment on UBTTask_CheckAmmoAndReload");
static_assert(sizeof(UBTTask_CheckAmmoAndReload) == 0x000070, "Wrong size on UBTTask_CheckAmmoAndReload");

// Class Flame.WorldLadder
// 0x00A0 (0x02C0 - 0x0220)
class AWorldLadder final : public AActor
{
public:
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSlideDown;                                     // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LadderTarget;                                      // 0x022C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   LadderMeshComp;                                    // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInstancedStaticMeshComponent*>  RungMeshComponents;                                // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          ConnectionMeshComp;                                // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RailMeshComp;                                      // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RailStartMeshComp;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RailEndMeshComp;                                   // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxEffectiveRungs;                                 // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        InteractTopComp;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionItemComponent*              InteractionComponent;                              // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          InteractionBlockComponent;                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TopRungLocation;                                   // 0x0298(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RungDeltaLocation;                                 // 0x02A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHumanMovementComponent*>        AttachedCharacters;                                // 0x02B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void Interact(class UInteractionItemComponent* Sender, class AActor* InteractingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldLadder">();
	}
	static class AWorldLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldLadder>();
	}
};
static_assert(alignof(AWorldLadder) == 0x000008, "Wrong alignment on AWorldLadder");
static_assert(sizeof(AWorldLadder) == 0x0002C0, "Wrong size on AWorldLadder");
static_assert(offsetof(AWorldLadder, PhysicalMaterial) == 0x000220, "Member 'AWorldLadder::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(AWorldLadder, bCanSlideDown) == 0x000228, "Member 'AWorldLadder::bCanSlideDown' has a wrong offset!");
static_assert(offsetof(AWorldLadder, LadderTarget) == 0x00022C, "Member 'AWorldLadder::LadderTarget' has a wrong offset!");
static_assert(offsetof(AWorldLadder, LadderMeshComp) == 0x000238, "Member 'AWorldLadder::LadderMeshComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, RungMeshComponents) == 0x000240, "Member 'AWorldLadder::RungMeshComponents' has a wrong offset!");
static_assert(offsetof(AWorldLadder, ConnectionMeshComp) == 0x000250, "Member 'AWorldLadder::ConnectionMeshComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, RailMeshComp) == 0x000258, "Member 'AWorldLadder::RailMeshComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, RailStartMeshComp) == 0x000260, "Member 'AWorldLadder::RailStartMeshComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, RailEndMeshComp) == 0x000268, "Member 'AWorldLadder::RailEndMeshComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, MaxEffectiveRungs) == 0x000270, "Member 'AWorldLadder::MaxEffectiveRungs' has a wrong offset!");
static_assert(offsetof(AWorldLadder, InteractTopComp) == 0x000278, "Member 'AWorldLadder::InteractTopComp' has a wrong offset!");
static_assert(offsetof(AWorldLadder, InteractionComponent) == 0x000288, "Member 'AWorldLadder::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AWorldLadder, InteractionBlockComponent) == 0x000290, "Member 'AWorldLadder::InteractionBlockComponent' has a wrong offset!");
static_assert(offsetof(AWorldLadder, TopRungLocation) == 0x000298, "Member 'AWorldLadder::TopRungLocation' has a wrong offset!");
static_assert(offsetof(AWorldLadder, RungDeltaLocation) == 0x0002A4, "Member 'AWorldLadder::RungDeltaLocation' has a wrong offset!");
static_assert(offsetof(AWorldLadder, AttachedCharacters) == 0x0002B0, "Member 'AWorldLadder::AttachedCharacters' has a wrong offset!");

// Class Flame.BTTask_RotateToSuspiciousSpot
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_RotateToSuspiciousSpot final : public UBTTask_BlackboardBase
{
public:
	float                                         RotationThreshold;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RotateToSuspiciousSpot">();
	}
	static class UBTTask_RotateToSuspiciousSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RotateToSuspiciousSpot>();
	}
};
static_assert(alignof(UBTTask_RotateToSuspiciousSpot) == 0x000008, "Wrong alignment on UBTTask_RotateToSuspiciousSpot");
static_assert(sizeof(UBTTask_RotateToSuspiciousSpot) == 0x0000A0, "Wrong size on UBTTask_RotateToSuspiciousSpot");
static_assert(offsetof(UBTTask_RotateToSuspiciousSpot, RotationThreshold) == 0x000098, "Member 'UBTTask_RotateToSuspiciousSpot::RotationThreshold' has a wrong offset!");

// Class Flame.BTTask_StanceChange
// 0x0008 (0x0078 - 0x0070)
class UBTTask_StanceChange final : public UBTTask_AIBase
{
public:
	EStance                                       NewStance;                                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_StanceChange">();
	}
	static class UBTTask_StanceChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_StanceChange>();
	}
};
static_assert(alignof(UBTTask_StanceChange) == 0x000008, "Wrong alignment on UBTTask_StanceChange");
static_assert(sizeof(UBTTask_StanceChange) == 0x000078, "Wrong size on UBTTask_StanceChange");
static_assert(offsetof(UBTTask_StanceChange, NewStance) == 0x000070, "Member 'UBTTask_StanceChange::NewStance' has a wrong offset!");

// Class Flame.Token
// 0x0000 (0x0398 - 0x0398)
class AToken : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Token">();
	}
	static class AToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<AToken>();
	}
};
static_assert(alignof(AToken) == 0x000008, "Wrong alignment on AToken");
static_assert(sizeof(AToken) == 0x000398, "Wrong size on AToken");

// Class Flame.BattlePassLevelToken
// 0x0000 (0x0398 - 0x0398)
class ABattlePassLevelToken : public AToken
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassLevelToken">();
	}
	static class ABattlePassLevelToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlePassLevelToken>();
	}
};
static_assert(alignof(ABattlePassLevelToken) == 0x000008, "Wrong alignment on ABattlePassLevelToken");
static_assert(sizeof(ABattlePassLevelToken) == 0x000398, "Wrong size on ABattlePassLevelToken");

// Class Flame.BTTask_SetBlackboardBoolean
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_SetBlackboardBoolean final : public UBTTask_BlackboardBase
{
public:
	bool                                          NewBoolean;                                        // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetBlackboardBoolean">();
	}
	static class UBTTask_SetBlackboardBoolean* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetBlackboardBoolean>();
	}
};
static_assert(alignof(UBTTask_SetBlackboardBoolean) == 0x000008, "Wrong alignment on UBTTask_SetBlackboardBoolean");
static_assert(sizeof(UBTTask_SetBlackboardBoolean) == 0x0000A0, "Wrong size on UBTTask_SetBlackboardBoolean");
static_assert(offsetof(UBTTask_SetBlackboardBoolean, NewBoolean) == 0x000098, "Member 'UBTTask_SetBlackboardBoolean::NewBoolean' has a wrong offset!");

// Class Flame.BTTask_DrawBlackboardLocation
// 0x0010 (0x00A8 - 0x0098)
class UBTTask_DrawBlackboardLocation final : public UBTTask_BlackboardBase
{
public:
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 Color;                                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_DrawBlackboardLocation">();
	}
	static class UBTTask_DrawBlackboardLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_DrawBlackboardLocation>();
	}
};
static_assert(alignof(UBTTask_DrawBlackboardLocation) == 0x000008, "Wrong alignment on UBTTask_DrawBlackboardLocation");
static_assert(sizeof(UBTTask_DrawBlackboardLocation) == 0x0000A8, "Wrong size on UBTTask_DrawBlackboardLocation");
static_assert(offsetof(UBTTask_DrawBlackboardLocation, Duration) == 0x000098, "Member 'UBTTask_DrawBlackboardLocation::Duration' has a wrong offset!");
static_assert(offsetof(UBTTask_DrawBlackboardLocation, Radius) == 0x00009C, "Member 'UBTTask_DrawBlackboardLocation::Radius' has a wrong offset!");
static_assert(offsetof(UBTTask_DrawBlackboardLocation, Color) == 0x0000A0, "Member 'UBTTask_DrawBlackboardLocation::Color' has a wrong offset!");

// Class Flame.OptionsElementWidget
// 0x00F0 (0x03A8 - 0x02B8)
class UOptionsElementWidget : public UFlameWidget
{
public:
	float                                         OpacityDisabled;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityNormal;                                     // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityFocused;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameTextBlock*                        OptionLabel;                                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHidden;                                         // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Label;                                             // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EFlamePlatform, class FText>             Tooltips;                                          // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Tooltip;                                           // 0x0340(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateInstantly;                                  // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPartOfPage;                                       // 0x0361(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDefaultValue;                                  // 0x0362(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBlueprintManaged;                                // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptionsMenuWidget*                     ParentOptionsMenuWidget;                           // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x30];                                     // 0x0378(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateWidget();
	void ResetElementToDefault();
	void SetValue(const struct FOptionsElementValue& InValues);

	bool CanModifyElement() const;
	bool CanResetElementToDefault() const;
	bool IsElementVisible() const;
	struct FOptionsElementValue PopulateValues() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsElementWidget">();
	}
	static class UOptionsElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsElementWidget>();
	}
};
static_assert(alignof(UOptionsElementWidget) == 0x000008, "Wrong alignment on UOptionsElementWidget");
static_assert(sizeof(UOptionsElementWidget) == 0x0003A8, "Wrong size on UOptionsElementWidget");
static_assert(offsetof(UOptionsElementWidget, OpacityDisabled) == 0x0002B8, "Member 'UOptionsElementWidget::OpacityDisabled' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, OpacityNormal) == 0x0002BC, "Member 'UOptionsElementWidget::OpacityNormal' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, OpacityFocused) == 0x0002C0, "Member 'UOptionsElementWidget::OpacityFocused' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, OptionLabel) == 0x0002C8, "Member 'UOptionsElementWidget::OptionLabel' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, bIsHidden) == 0x0002D0, "Member 'UOptionsElementWidget::bIsHidden' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, Label) == 0x0002D8, "Member 'UOptionsElementWidget::Label' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, Tooltips) == 0x0002F0, "Member 'UOptionsElementWidget::Tooltips' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, Tooltip) == 0x000340, "Member 'UOptionsElementWidget::Tooltip' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, Identifier) == 0x000358, "Member 'UOptionsElementWidget::Identifier' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, bUpdateInstantly) == 0x000360, "Member 'UOptionsElementWidget::bUpdateInstantly' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, bPartOfPage) == 0x000361, "Member 'UOptionsElementWidget::bPartOfPage' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, bHasDefaultValue) == 0x000362, "Member 'UOptionsElementWidget::bHasDefaultValue' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, IsBlueprintManaged) == 0x000363, "Member 'UOptionsElementWidget::IsBlueprintManaged' has a wrong offset!");
static_assert(offsetof(UOptionsElementWidget, ParentOptionsMenuWidget) == 0x000370, "Member 'UOptionsElementWidget::ParentOptionsMenuWidget' has a wrong offset!");

// Class Flame.OptionsElementPicker
// 0x0048 (0x03F0 - 0x03A8)
class UOptionsElementPicker : public UOptionsElementWidget
{
public:
	EPickerDirection                              Direction;                                         // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedOptionIndex;                               // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanNavigate;                                      // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanNavigatePrevious;                               // 0x03B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanNavigateNext;                                   // 0x03B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B3[0x1];                                      // 0x03B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingIndex;                                     // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        SelectedOptionText;                                // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PreviousOptionIcon;                                // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NextOptionIcon;                                    // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnValueChangedDelegate;                            // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FOptionsPickerValue>            Options;                                           // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void OnNavigateIndex(int32 Index_0, bool BypassConditions, bool BroadcastValueChange);
	void OnNavigateNext();
	void OnNavigatePrevious();
	void OnNavigateVisualIndex(int32 Index_0);
	void OnVisualUpdated();
	void UpdateOptions(const TArray<struct FOptionsPickerValue>& InOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsElementPicker">();
	}
	static class UOptionsElementPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsElementPicker>();
	}
};
static_assert(alignof(UOptionsElementPicker) == 0x000008, "Wrong alignment on UOptionsElementPicker");
static_assert(sizeof(UOptionsElementPicker) == 0x0003F0, "Wrong size on UOptionsElementPicker");
static_assert(offsetof(UOptionsElementPicker, Direction) == 0x0003A8, "Member 'UOptionsElementPicker::Direction' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, SelectedOptionIndex) == 0x0003AC, "Member 'UOptionsElementPicker::SelectedOptionIndex' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, bCanNavigate) == 0x0003B0, "Member 'UOptionsElementPicker::bCanNavigate' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, CanNavigatePrevious) == 0x0003B1, "Member 'UOptionsElementPicker::CanNavigatePrevious' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, CanNavigateNext) == 0x0003B2, "Member 'UOptionsElementPicker::CanNavigateNext' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, StartingIndex) == 0x0003B4, "Member 'UOptionsElementPicker::StartingIndex' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, SelectedOptionText) == 0x0003B8, "Member 'UOptionsElementPicker::SelectedOptionText' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, PreviousOptionIcon) == 0x0003C0, "Member 'UOptionsElementPicker::PreviousOptionIcon' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, NextOptionIcon) == 0x0003C8, "Member 'UOptionsElementPicker::NextOptionIcon' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, OnValueChangedDelegate) == 0x0003D0, "Member 'UOptionsElementPicker::OnValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UOptionsElementPicker, Options) == 0x0003E0, "Member 'UOptionsElementPicker::Options' has a wrong offset!");

// Class Flame.LanguagePicker
// 0x0000 (0x03F0 - 0x03F0)
class ULanguagePicker : public UOptionsElementPicker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanguagePicker">();
	}
	static class ULanguagePicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULanguagePicker>();
	}
};
static_assert(alignof(ULanguagePicker) == 0x000008, "Wrong alignment on ULanguagePicker");
static_assert(sizeof(ULanguagePicker) == 0x0003F0, "Wrong size on ULanguagePicker");

// Class Flame.BTTask_ChooseNextPatrolPositon
// 0x0000 (0x0098 - 0x0098)
class UBTTask_ChooseNextPatrolPositon final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ChooseNextPatrolPositon">();
	}
	static class UBTTask_ChooseNextPatrolPositon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ChooseNextPatrolPositon>();
	}
};
static_assert(alignof(UBTTask_ChooseNextPatrolPositon) == 0x000008, "Wrong alignment on UBTTask_ChooseNextPatrolPositon");
static_assert(sizeof(UBTTask_ChooseNextPatrolPositon) == 0x000098, "Wrong size on UBTTask_ChooseNextPatrolPositon");

// Class Flame.BTTask_StopRunningBehaviourTree
// 0x0000 (0x0070 - 0x0070)
class UBTTask_StopRunningBehaviourTree final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_StopRunningBehaviourTree">();
	}
	static class UBTTask_StopRunningBehaviourTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_StopRunningBehaviourTree>();
	}
};
static_assert(alignof(UBTTask_StopRunningBehaviourTree) == 0x000008, "Wrong alignment on UBTTask_StopRunningBehaviourTree");
static_assert(sizeof(UBTTask_StopRunningBehaviourTree) == 0x000070, "Wrong size on UBTTask_StopRunningBehaviourTree");

// Class Flame.CurrencyCraftingBooster
// 0x0000 (0x0398 - 0x0398)
class ACurrencyCraftingBooster : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyCraftingBooster">();
	}
	static class ACurrencyCraftingBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyCraftingBooster>();
	}
};
static_assert(alignof(ACurrencyCraftingBooster) == 0x000008, "Wrong alignment on ACurrencyCraftingBooster");
static_assert(sizeof(ACurrencyCraftingBooster) == 0x000398, "Wrong size on ACurrencyCraftingBooster");

// Class Flame.BTTask_MultiBehavioralAimAndShoot
// 0x0010 (0x00A8 - 0x0098)
class UBTTask_MultiBehavioralAimAndShoot final : public UBTTask_BlackboardBase
{
public:
	TArray<struct FAimAndShootBehaviorData>       Behaviors;                                         // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MultiBehavioralAimAndShoot">();
	}
	static class UBTTask_MultiBehavioralAimAndShoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MultiBehavioralAimAndShoot>();
	}
};
static_assert(alignof(UBTTask_MultiBehavioralAimAndShoot) == 0x000008, "Wrong alignment on UBTTask_MultiBehavioralAimAndShoot");
static_assert(sizeof(UBTTask_MultiBehavioralAimAndShoot) == 0x0000A8, "Wrong size on UBTTask_MultiBehavioralAimAndShoot");
static_assert(offsetof(UBTTask_MultiBehavioralAimAndShoot, Behaviors) == 0x000098, "Member 'UBTTask_MultiBehavioralAimAndShoot::Behaviors' has a wrong offset!");

// Class Flame.BTTask_TriggerSprint
// 0x0008 (0x0078 - 0x0070)
class UBTTask_TriggerSprint final : public UBTTask_AIBase
{
public:
	bool                                          bStartSprint;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TriggerSprint">();
	}
	static class UBTTask_TriggerSprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TriggerSprint>();
	}
};
static_assert(alignof(UBTTask_TriggerSprint) == 0x000008, "Wrong alignment on UBTTask_TriggerSprint");
static_assert(sizeof(UBTTask_TriggerSprint) == 0x000078, "Wrong size on UBTTask_TriggerSprint");
static_assert(offsetof(UBTTask_TriggerSprint, bStartSprint) == 0x000070, "Member 'UBTTask_TriggerSprint::bStartSprint' has a wrong offset!");

// Class Flame.InventoryOperationsComponent
// 0x00D8 (0x0188 - 0x00B0)
class UInventoryOperationsComponent : public UActorComponent
{
public:
	TMap<EInventoryView, TSubclassOf<class UInventoryActionMapping>> InventoryMapping;                                  // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnExchange;                                        // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnOperation;                                       // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FEquipWeaponWithAmmoOperationContext   EquipWeaponContext;                                // 0x0120(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FInventoryOperationInfoClient>  OperationsInProcessClient;                         // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FInventoryOperationInfoServer>  OperationsInProcessServer;                         // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AHumanCharacter>         AccessingHuman;                                    // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  LootActor;                                         // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UInventoryComponent>     HumanInventory;                                    // 0x0168(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UEquipmentStorageComponent> LootEquipment;                                     // 0x0170(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UEquipmentStorageComponent> SourceEquipment;                                   // 0x0178(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UEquipmentStorageComponent> TargetEquipment;                                   // 0x0180(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BinaryOperation(const struct FInvetoryItemDescriptor& LootItemDsc, const struct FInvetoryItemDescriptor& HumanItemDsc, const struct FInventoryOperationContext& Context);
	EOperationResult BinaryOperationSwitch(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context);
	void ClientConfirmOperation(const struct FInventoryOperationInfoServer& ResultFromServer);
	void ClientResetOperations();
	void ServerAskForBinaryOperation(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context, int32 ID);
	void ServerAskForUnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context, int32 ID);
	void UnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context);
	EOperationResult UnaryOperationSwitch(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context);

	bool CanProcessBinaryOperation(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context) const;
	bool CanProcessBinaryOperationSwitch(const struct FInvetoryItemDescriptor& FirstDsc, const struct FInvetoryItemDescriptor& SecondDsc, const struct FInventoryOperationContext& Context) const;
	bool CanProcessUnaryOperation(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context) const;
	bool CanProcessUnaryOperationSwitch(const struct FInvetoryItemDescriptor& Descriptor, const struct FInventoryOperationContext& Context) const;
	class UEquipmentStorageComponent* FindOpositeEquipment(const class UEquipmentStorageComponent* Storage) const;
	class UEquipmentStorageComponent* FindParentEquipment(const struct FInvetoryItemDescriptor& Descriptor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryOperationsComponent">();
	}
	static class UInventoryOperationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryOperationsComponent>();
	}
};
static_assert(alignof(UInventoryOperationsComponent) == 0x000008, "Wrong alignment on UInventoryOperationsComponent");
static_assert(sizeof(UInventoryOperationsComponent) == 0x000188, "Wrong size on UInventoryOperationsComponent");
static_assert(offsetof(UInventoryOperationsComponent, InventoryMapping) == 0x0000B0, "Member 'UInventoryOperationsComponent::InventoryMapping' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, OnExchange) == 0x000100, "Member 'UInventoryOperationsComponent::OnExchange' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, OnOperation) == 0x000110, "Member 'UInventoryOperationsComponent::OnOperation' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, EquipWeaponContext) == 0x000120, "Member 'UInventoryOperationsComponent::EquipWeaponContext' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, OperationsInProcessClient) == 0x000138, "Member 'UInventoryOperationsComponent::OperationsInProcessClient' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, OperationsInProcessServer) == 0x000148, "Member 'UInventoryOperationsComponent::OperationsInProcessServer' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, AccessingHuman) == 0x000158, "Member 'UInventoryOperationsComponent::AccessingHuman' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, LootActor) == 0x000160, "Member 'UInventoryOperationsComponent::LootActor' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, HumanInventory) == 0x000168, "Member 'UInventoryOperationsComponent::HumanInventory' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, LootEquipment) == 0x000170, "Member 'UInventoryOperationsComponent::LootEquipment' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, SourceEquipment) == 0x000178, "Member 'UInventoryOperationsComponent::SourceEquipment' has a wrong offset!");
static_assert(offsetof(UInventoryOperationsComponent, TargetEquipment) == 0x000180, "Member 'UInventoryOperationsComponent::TargetEquipment' has a wrong offset!");

// Class Flame.BTTask_CleanPathPositionOnAI
// 0x0000 (0x0070 - 0x0070)
class UBTTask_CleanPathPositionOnAI final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CleanPathPositionOnAI">();
	}
	static class UBTTask_CleanPathPositionOnAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CleanPathPositionOnAI>();
	}
};
static_assert(alignof(UBTTask_CleanPathPositionOnAI) == 0x000008, "Wrong alignment on UBTTask_CleanPathPositionOnAI");
static_assert(sizeof(UBTTask_CleanPathPositionOnAI) == 0x000070, "Wrong size on UBTTask_CleanPathPositionOnAI");

// Class Flame.BTTask_CleanPerception
// 0x0000 (0x0070 - 0x0070)
class UBTTask_CleanPerception final : public UBTTask_AIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CleanPerception">();
	}
	static class UBTTask_CleanPerception* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CleanPerception>();
	}
};
static_assert(alignof(UBTTask_CleanPerception) == 0x000008, "Wrong alignment on UBTTask_CleanPerception");
static_assert(sizeof(UBTTask_CleanPerception) == 0x000070, "Wrong size on UBTTask_CleanPerception");

// Class Flame.BuildingReferenceHelper
// 0x0000 (0x0028 - 0x0028)
class UBuildingReferenceHelper final : public UBlueprintFunctionLibrary
{
public:
	static class ABuilding* GetBuildingAtPoint(class UObject* WorldContext, const struct FVector& Point);
	static class ADoor* ResolveDoorReference(const struct FDoorReference& Reference);
	static class AWindow* ResolveWindowReference(const struct FWindowReference& Reference);
	static class AWindowSashSet* ResolveWindowSashSetReference(const struct FWindowSashSetReference& Reference);
	static bool UpdateDoorReference(struct FDoorReference& RefToUpdate);
	static bool UpdateWindowReference(struct FWindowReference& RefToUpdate);
	static bool UpdateWindowSashSetReference(struct FWindowSashSetReference& RefToUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingReferenceHelper">();
	}
	static class UBuildingReferenceHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingReferenceHelper>();
	}
};
static_assert(alignof(UBuildingReferenceHelper) == 0x000008, "Wrong alignment on UBuildingReferenceHelper");
static_assert(sizeof(UBuildingReferenceHelper) == 0x000028, "Wrong size on UBuildingReferenceHelper");

// Class Flame.CurrencyFood
// 0x0000 (0x0398 - 0x0398)
class ACurrencyFood : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyFood">();
	}
	static class ACurrencyFood* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyFood>();
	}
};
static_assert(alignof(ACurrencyFood) == 0x000008, "Wrong alignment on ACurrencyFood");
static_assert(sizeof(ACurrencyFood) == 0x000398, "Wrong size on ACurrencyFood");

// Class Flame.AudioVolumeOverwrite
// 0x0048 (0x0078 - 0x0030)
class UAudioVolumeOverwrite final : public UDataAsset
{
public:
	float                                         Priority;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReverbSettings                        ReverbSettings;                                    // 0x0038(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExteriorVolume;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorTime;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPF;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPFTime;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorVolume;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorTime;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPF;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPFTime;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioVolumeOverwrite">();
	}
	static class UAudioVolumeOverwrite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioVolumeOverwrite>();
	}
};
static_assert(alignof(UAudioVolumeOverwrite) == 0x000008, "Wrong alignment on UAudioVolumeOverwrite");
static_assert(sizeof(UAudioVolumeOverwrite) == 0x000078, "Wrong size on UAudioVolumeOverwrite");
static_assert(offsetof(UAudioVolumeOverwrite, Priority) == 0x000030, "Member 'UAudioVolumeOverwrite::Priority' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, bEnabled) == 0x000034, "Member 'UAudioVolumeOverwrite::bEnabled' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, ReverbSettings) == 0x000038, "Member 'UAudioVolumeOverwrite::ReverbSettings' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, ExteriorVolume) == 0x000058, "Member 'UAudioVolumeOverwrite::ExteriorVolume' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, ExteriorTime) == 0x00005C, "Member 'UAudioVolumeOverwrite::ExteriorTime' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, ExteriorLPF) == 0x000060, "Member 'UAudioVolumeOverwrite::ExteriorLPF' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, ExteriorLPFTime) == 0x000064, "Member 'UAudioVolumeOverwrite::ExteriorLPFTime' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, InteriorVolume) == 0x000068, "Member 'UAudioVolumeOverwrite::InteriorVolume' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, InteriorTime) == 0x00006C, "Member 'UAudioVolumeOverwrite::InteriorTime' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, InteriorLPF) == 0x000070, "Member 'UAudioVolumeOverwrite::InteriorLPF' has a wrong offset!");
static_assert(offsetof(UAudioVolumeOverwrite, InteriorLPFTime) == 0x000074, "Member 'UAudioVolumeOverwrite::InteriorLPFTime' has a wrong offset!");

// Class Flame.Building
// 0x0110 (0x0330 - 0x0220)
class ABuilding final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowExterior;                                      // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterior;                                         // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFoundation;                                       // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B[0x1];                                      // 0x022B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDrawDistanceOnChildMeshes;                      // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredCullScreenSpaceSizeOnChildMeshes;           // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingOverrideBehavior                     DefaultDoorExteriorBehavior;                       // 0x0234(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingOverrideBehavior                     DefaultDoorInteriorBehavior;                       // 0x0235(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingOverrideBehavior                     DefaultWindowBehavior;                             // 0x0236(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_237[0x1];                                      // 0x0237(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuildingMaterialsMasterSlider;                     // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildingMaterialsInteriorMasterSlider;             // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildingMaterialsFoundationMasterSlider;           // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBuildingMaterial>              BuildingMaterials;                                 // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInterior*>                      AvailableInteriors;                                // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UInterior>>       AvailableSoftInteriors;                            // 0x0268(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UInterior*                              BaseInterior;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnBaseInterior;                                // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightmapGenerationOverride                   LightmapGenerationOverride;                        // 0x0281(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0x6];                                      // 0x0282(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommoditySpawnNode*                    CommodityComponent;                                // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BuildingMeshComponent;                             // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FoundationComponent;                               // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   InteriorMeshComponent;                             // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            BuildingMobility;                                  // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            FoundationMobility;                                // 0x02A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            InteriorMobility;                                  // 0x02AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x5];                                      // 0x02AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BuildingMesh;                                      // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            InterierMesh;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FoundationMesh;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        SocketAttachedClasses;                             // 0x02C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDynamicInterior;                                  // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrayHelper>                   SocketAttachedInstances;                           // 0x02E0(0x0010)(ZeroConstructor, DuplicateTransient, NativeAccessSpecifierPrivate)
	class UInterior*                              InteriorObject;                                    // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        InteriorRoot;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AWindow*>                        Windows;                                           // 0x0300(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ADoor*>                          Doors;                                             // 0x0310(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                AdditionalComponents;                              // 0x0320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void HideInterior(bool bNewHidden);

	class ADoor* GetDoor(const int32 Idx) const;
	bool GetDoorIdx(class ADoor* Door, int32* Idx) const;
	class AWindow* GetWindow(const int32 Idx) const;
	bool GetWindowIndex(class AWindow* Window, int32* Idx) const;
	void MulticastLockDoorsAndWindows(const EBuildingOverrideBehavior DoorBehaviorExterior, const EBuildingOverrideBehavior DoorBehaviorInterior, const EBuildingOverrideBehavior WindowBehavior, bool bTakeDefaultFromObjectsIfNoChange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Building">();
	}
	static class ABuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuilding>();
	}
};
static_assert(alignof(ABuilding) == 0x000008, "Wrong alignment on ABuilding");
static_assert(sizeof(ABuilding) == 0x000330, "Wrong size on ABuilding");
static_assert(offsetof(ABuilding, ShowExterior) == 0x000228, "Member 'ABuilding::ShowExterior' has a wrong offset!");
static_assert(offsetof(ABuilding, bInterior) == 0x000229, "Member 'ABuilding::bInterior' has a wrong offset!");
static_assert(offsetof(ABuilding, bFoundation) == 0x00022A, "Member 'ABuilding::bFoundation' has a wrong offset!");
static_assert(offsetof(ABuilding, MinDrawDistanceOnChildMeshes) == 0x00022C, "Member 'ABuilding::MinDrawDistanceOnChildMeshes' has a wrong offset!");
static_assert(offsetof(ABuilding, DesiredCullScreenSpaceSizeOnChildMeshes) == 0x000230, "Member 'ABuilding::DesiredCullScreenSpaceSizeOnChildMeshes' has a wrong offset!");
static_assert(offsetof(ABuilding, DefaultDoorExteriorBehavior) == 0x000234, "Member 'ABuilding::DefaultDoorExteriorBehavior' has a wrong offset!");
static_assert(offsetof(ABuilding, DefaultDoorInteriorBehavior) == 0x000235, "Member 'ABuilding::DefaultDoorInteriorBehavior' has a wrong offset!");
static_assert(offsetof(ABuilding, DefaultWindowBehavior) == 0x000236, "Member 'ABuilding::DefaultWindowBehavior' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMaterialsMasterSlider) == 0x000238, "Member 'ABuilding::BuildingMaterialsMasterSlider' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMaterialsInteriorMasterSlider) == 0x00023C, "Member 'ABuilding::BuildingMaterialsInteriorMasterSlider' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMaterialsFoundationMasterSlider) == 0x000240, "Member 'ABuilding::BuildingMaterialsFoundationMasterSlider' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMaterials) == 0x000248, "Member 'ABuilding::BuildingMaterials' has a wrong offset!");
static_assert(offsetof(ABuilding, AvailableInteriors) == 0x000258, "Member 'ABuilding::AvailableInteriors' has a wrong offset!");
static_assert(offsetof(ABuilding, AvailableSoftInteriors) == 0x000268, "Member 'ABuilding::AvailableSoftInteriors' has a wrong offset!");
static_assert(offsetof(ABuilding, BaseInterior) == 0x000278, "Member 'ABuilding::BaseInterior' has a wrong offset!");
static_assert(offsetof(ABuilding, bSpawnBaseInterior) == 0x000280, "Member 'ABuilding::bSpawnBaseInterior' has a wrong offset!");
static_assert(offsetof(ABuilding, LightmapGenerationOverride) == 0x000281, "Member 'ABuilding::LightmapGenerationOverride' has a wrong offset!");
static_assert(offsetof(ABuilding, CommodityComponent) == 0x000288, "Member 'ABuilding::CommodityComponent' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMeshComponent) == 0x000290, "Member 'ABuilding::BuildingMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuilding, FoundationComponent) == 0x000298, "Member 'ABuilding::FoundationComponent' has a wrong offset!");
static_assert(offsetof(ABuilding, InteriorMeshComponent) == 0x0002A0, "Member 'ABuilding::InteriorMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMobility) == 0x0002A8, "Member 'ABuilding::BuildingMobility' has a wrong offset!");
static_assert(offsetof(ABuilding, FoundationMobility) == 0x0002A9, "Member 'ABuilding::FoundationMobility' has a wrong offset!");
static_assert(offsetof(ABuilding, InteriorMobility) == 0x0002AA, "Member 'ABuilding::InteriorMobility' has a wrong offset!");
static_assert(offsetof(ABuilding, BuildingMesh) == 0x0002B0, "Member 'ABuilding::BuildingMesh' has a wrong offset!");
static_assert(offsetof(ABuilding, InterierMesh) == 0x0002B8, "Member 'ABuilding::InterierMesh' has a wrong offset!");
static_assert(offsetof(ABuilding, FoundationMesh) == 0x0002C0, "Member 'ABuilding::FoundationMesh' has a wrong offset!");
static_assert(offsetof(ABuilding, SocketAttachedClasses) == 0x0002C8, "Member 'ABuilding::SocketAttachedClasses' has a wrong offset!");
static_assert(offsetof(ABuilding, bDynamicInterior) == 0x0002D8, "Member 'ABuilding::bDynamicInterior' has a wrong offset!");
static_assert(offsetof(ABuilding, SocketAttachedInstances) == 0x0002E0, "Member 'ABuilding::SocketAttachedInstances' has a wrong offset!");
static_assert(offsetof(ABuilding, InteriorObject) == 0x0002F0, "Member 'ABuilding::InteriorObject' has a wrong offset!");
static_assert(offsetof(ABuilding, InteriorRoot) == 0x0002F8, "Member 'ABuilding::InteriorRoot' has a wrong offset!");
static_assert(offsetof(ABuilding, Windows) == 0x000300, "Member 'ABuilding::Windows' has a wrong offset!");
static_assert(offsetof(ABuilding, Doors) == 0x000310, "Member 'ABuilding::Doors' has a wrong offset!");
static_assert(offsetof(ABuilding, AdditionalComponents) == 0x000320, "Member 'ABuilding::AdditionalComponents' has a wrong offset!");

// Class Flame.BuildingComponent
// 0x0008 (0x00B8 - 0x00B0)
class UBuildingComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class AActor>                  OwningParentActor;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingComponent">();
	}
	static class UBuildingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingComponent>();
	}
};
static_assert(alignof(UBuildingComponent) == 0x000008, "Wrong alignment on UBuildingComponent");
static_assert(sizeof(UBuildingComponent) == 0x0000B8, "Wrong size on UBuildingComponent");
static_assert(offsetof(UBuildingComponent, OwningParentActor) == 0x0000B0, "Member 'UBuildingComponent::OwningParentActor' has a wrong offset!");

// Class Flame.Door
// 0x0150 (0x0370 - 0x0220)
class ADoor : public AActor
{
public:
	class UInteractionItemComponent*              InteractionItemComponent;                          // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        Pivot;                                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          FrontBox;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BackBox;                                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0xC0];                                     // 0x0248(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageOnRam;                                       // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOnPush;                                      // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveFloat;                                        // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionPlayRate;                                // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionPlayRateOnRam;                           // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxApertureAngle;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorSpeedRequiredForBreaking;                     // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorState                                    DoorState;                                         // 0x0328(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorExterior;                                     // 0x0329(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorLocked;                                       // 0x032A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorBlocked;                                      // 0x032B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BlockedMesh;                                       // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BlockedMeshComponent;                              // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0348(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlot;                                      // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingOverrideBehavior                     OverrideBehavior;                                  // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuilding*                              ParentBuilding;                                    // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetOtherActorDirection(class AActor* OtherActor);
	EDoorState GetState();
	void HandleProgress(float Value);
	void Interact(class UInteractionItemComponent* Sender, class AActor* InteractingActor);
	void OnDoorClose();
	void OnDoorOpen();
	void OnRep_ChangeDoorState();
	void ServerChangeStateTo(EDoorState NewState);
	void SetCanOpenBackward(bool bAble);
	void SetCanOpenForward(bool bAble);
	void SetDoorBlocked(bool bBlocked);
	void SetDoorLocked(bool bLocked);
	void SetDoorOpen(bool bOpen);
	void TimelineFinished();

	bool IsPointInFront(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Door">();
	}
	static class ADoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoor>();
	}
};
static_assert(alignof(ADoor) == 0x000008, "Wrong alignment on ADoor");
static_assert(sizeof(ADoor) == 0x000370, "Wrong size on ADoor");
static_assert(offsetof(ADoor, InteractionItemComponent) == 0x000220, "Member 'ADoor::InteractionItemComponent' has a wrong offset!");
static_assert(offsetof(ADoor, StaticMesh) == 0x000228, "Member 'ADoor::StaticMesh' has a wrong offset!");
static_assert(offsetof(ADoor, Pivot) == 0x000230, "Member 'ADoor::Pivot' has a wrong offset!");
static_assert(offsetof(ADoor, FrontBox) == 0x000238, "Member 'ADoor::FrontBox' has a wrong offset!");
static_assert(offsetof(ADoor, BackBox) == 0x000240, "Member 'ADoor::BackBox' has a wrong offset!");
static_assert(offsetof(ADoor, DamageOnRam) == 0x000308, "Member 'ADoor::DamageOnRam' has a wrong offset!");
static_assert(offsetof(ADoor, DamageOnPush) == 0x00030C, "Member 'ADoor::DamageOnPush' has a wrong offset!");
static_assert(offsetof(ADoor, CurveFloat) == 0x000310, "Member 'ADoor::CurveFloat' has a wrong offset!");
static_assert(offsetof(ADoor, TransitionPlayRate) == 0x000318, "Member 'ADoor::TransitionPlayRate' has a wrong offset!");
static_assert(offsetof(ADoor, TransitionPlayRateOnRam) == 0x00031C, "Member 'ADoor::TransitionPlayRateOnRam' has a wrong offset!");
static_assert(offsetof(ADoor, MaxApertureAngle) == 0x000320, "Member 'ADoor::MaxApertureAngle' has a wrong offset!");
static_assert(offsetof(ADoor, ActorSpeedRequiredForBreaking) == 0x000324, "Member 'ADoor::ActorSpeedRequiredForBreaking' has a wrong offset!");
static_assert(offsetof(ADoor, DoorState) == 0x000328, "Member 'ADoor::DoorState' has a wrong offset!");
static_assert(offsetof(ADoor, bDoorExterior) == 0x000329, "Member 'ADoor::bDoorExterior' has a wrong offset!");
static_assert(offsetof(ADoor, bDoorLocked) == 0x00032A, "Member 'ADoor::bDoorLocked' has a wrong offset!");
static_assert(offsetof(ADoor, bDoorBlocked) == 0x00032B, "Member 'ADoor::bDoorBlocked' has a wrong offset!");
static_assert(offsetof(ADoor, BlockedMesh) == 0x000330, "Member 'ADoor::BlockedMesh' has a wrong offset!");
static_assert(offsetof(ADoor, BlockedMeshComponent) == 0x000338, "Member 'ADoor::BlockedMeshComponent' has a wrong offset!");
static_assert(offsetof(ADoor, MaterialIndex) == 0x000340, "Member 'ADoor::MaterialIndex' has a wrong offset!");
static_assert(offsetof(ADoor, Materials) == 0x000348, "Member 'ADoor::Materials' has a wrong offset!");
static_assert(offsetof(ADoor, MaterialSlot) == 0x000358, "Member 'ADoor::MaterialSlot' has a wrong offset!");
static_assert(offsetof(ADoor, OverrideBehavior) == 0x000360, "Member 'ADoor::OverrideBehavior' has a wrong offset!");
static_assert(offsetof(ADoor, ParentBuilding) == 0x000368, "Member 'ADoor::ParentBuilding' has a wrong offset!");

// Class Flame.BuildingBoxComponent
// 0x0000 (0x0480 - 0x0480)
class UBuildingBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingBoxComponent">();
	}
	static class UBuildingBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingBoxComponent>();
	}
};
static_assert(alignof(UBuildingBoxComponent) == 0x000010, "Wrong alignment on UBuildingBoxComponent");
static_assert(sizeof(UBuildingBoxComponent) == 0x000480, "Wrong size on UBuildingBoxComponent");

// Class Flame.BuildingOptimizer
// 0x0038 (0x0258 - 0x0220)
class ABuildingOptimizer final : public AActor
{
public:
	uint8                                         Pad_220[0x38];                                     // 0x0220(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOptimizer">();
	}
	static class ABuildingOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOptimizer>();
	}
};
static_assert(alignof(ABuildingOptimizer) == 0x000008, "Wrong alignment on ABuildingOptimizer");
static_assert(sizeof(ABuildingOptimizer) == 0x000258, "Wrong size on ABuildingOptimizer");

// Class Flame.FlameSaveSystem
// 0x0000 (0x0028 - 0x0028)
class UFlameSaveSystem : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameSaveSystem">();
	}
	static class UFlameSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameSaveSystem>();
	}
};
static_assert(alignof(UFlameSaveSystem) == 0x000008, "Wrong alignment on UFlameSaveSystem");
static_assert(sizeof(UFlameSaveSystem) == 0x000028, "Wrong size on UFlameSaveSystem");

// Class Flame.BuildingOptionalMesh
// 0x0018 (0x0238 - 0x0220)
class ABuildingOptionalMesh final : public AActor
{
public:
	bool                                          bShowMesh;                                         // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOptionalMesh">();
	}
	static class ABuildingOptionalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOptionalMesh>();
	}
};
static_assert(alignof(ABuildingOptionalMesh) == 0x000008, "Wrong alignment on ABuildingOptionalMesh");
static_assert(sizeof(ABuildingOptionalMesh) == 0x000238, "Wrong size on ABuildingOptionalMesh");
static_assert(offsetof(ABuildingOptionalMesh, bShowMesh) == 0x000220, "Member 'ABuildingOptionalMesh::bShowMesh' has a wrong offset!");
static_assert(offsetof(ABuildingOptionalMesh, Mesh) == 0x000228, "Member 'ABuildingOptionalMesh::Mesh' has a wrong offset!");
static_assert(offsetof(ABuildingOptionalMesh, StaticMeshComponent) == 0x000230, "Member 'ABuildingOptionalMesh::StaticMeshComponent' has a wrong offset!");

// Class Flame.BulletDecalManager
// 0x0040 (0x0260 - 0x0220)
class alignas(0x10) ABulletDecalManager : public AInfo
{
public:
	int32                                         MaxVisibleDecals;                                  // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDecalsPerFrame;                                 // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDecalTime;                                      // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DecalActorClass;                                   // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDecalFrames;                                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x14];                                     // 0x023C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveDecal>                   ActiveDecals;                                      // 0x0250(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BeginPlay();
	class UDecalComponent* CreateDecal(const struct FDecalInfo& Info);
	void DestroyDecal(class UDecalComponent* DecalActor, int32 Index_0);
	void RequestDecal(const struct FTransform& Position, class UMaterialInterface* Material, float SizeMultiplier);
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletDecalManager">();
	}
	static class ABulletDecalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletDecalManager>();
	}
};
static_assert(alignof(ABulletDecalManager) == 0x000010, "Wrong alignment on ABulletDecalManager");
static_assert(sizeof(ABulletDecalManager) == 0x000260, "Wrong size on ABulletDecalManager");
static_assert(offsetof(ABulletDecalManager, MaxVisibleDecals) == 0x000220, "Member 'ABulletDecalManager::MaxVisibleDecals' has a wrong offset!");
static_assert(offsetof(ABulletDecalManager, MaxDecalsPerFrame) == 0x000224, "Member 'ABulletDecalManager::MaxDecalsPerFrame' has a wrong offset!");
static_assert(offsetof(ABulletDecalManager, MaxDecalTime) == 0x000228, "Member 'ABulletDecalManager::MaxDecalTime' has a wrong offset!");
static_assert(offsetof(ABulletDecalManager, DecalActorClass) == 0x000230, "Member 'ABulletDecalManager::DecalActorClass' has a wrong offset!");
static_assert(offsetof(ABulletDecalManager, NumDecalFrames) == 0x000238, "Member 'ABulletDecalManager::NumDecalFrames' has a wrong offset!");
static_assert(offsetof(ABulletDecalManager, ActiveDecals) == 0x000250, "Member 'ABulletDecalManager::ActiveDecals' has a wrong offset!");

// Class Flame.HumanCharacter
// 0x0740 (0x0C00 - 0x04C0)
class AHumanCharacter : public ACharacter
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             CloudLoadedAuthority;                              // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedClient;                                 // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             AttachedCharactersChanged;                         // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             PlayGestureDelegate;                               // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         AffiliationID;                                     // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x1];                                      // 0x0509(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutonomous;                                     // 0x050A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAutonomousOrAuthority;                          // 0x050B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x2];                                      // 0x050C(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableSkinDebug;                                  // 0x050E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50F[0x1];                                      // 0x050F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccessorComponent*                     Accessor;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    Inventory;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryCustomizationComponent*       Customization;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDefaultInventoryComponent*             DefaultInventory;                                  // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateMachineComponent*                 StateMachine;                                      // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayActionsComponent*              GameplayActions;                                   // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanAimComponent*                       CanAimComponent;                                   // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterHitZoneComponent*             HitZoneManager;                                    // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWoundsManagerComponent*                WoundsManagerComponent;                            // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BaseMesh;                                          // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformComponent*                      Uniform;                                           // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHairComponent*                         Hair;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadComponent*                         Head;                                              // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGlovesComponent*                       Gloves;                                            // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBackpackComponent*                     Backpack;                                          // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadgearUpperComponent*                HeadgearUpper;                                     // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadgearMiddleComponent*               HeadgearMiddle;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadgearLowerComponent*                HeadgearLower;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFootStepComponent>         FootStepClass;                                     // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVegetationComponent>       VegetationClass;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStaminaComponent>          StaminaClass;                                      // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaminaComponent*                      StaminaComponent;                                  // 0x05D8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPoiseComponent>            PoiseClass;                                        // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPoiseComponent*                        PoiseComponent;                                    // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpeedModifierComponent>    SpeedModifierClass;                                // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpeedModifierComponent*                SpeedModifierComponent;                            // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraManagerComponentBase> CameraManagerClass;                                // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraManagerComponentBase*            CameraManagerComponent;                            // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ArchetypeDataTable;                                // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ArchetypeName;                                     // 0x0618(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLoadoutInfo                           LastKnownLoadoutBeforeDeath;                       // 0x0620(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bFireRequested;                                    // 0x0648(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFire;                                        // 0x0649(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64A[0x2];                                      // 0x064A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ADSTransitionDelay;                                // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsADS;                                            // 0x0658(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_659[0x2];                                      // 0x0659(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsADSThrowable;                                   // 0x065B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUsedThrowable;                                 // 0x065C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65D[0xB];                                      // 0x065D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionADSMinTime;                             // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_66C[0x10];                                     // 0x066C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneTransitionDispersion;                         // 0x067C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneTransitionDispersion1PV;                      // 0x0680(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInfiniteAmmo;                                     // 0x0684(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInfiniteReload;                                   // 0x0685(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowReload;                                      // 0x0686(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugAmmoReplication;                             // 0x0687(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x10];                                     // 0x0688(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHumanAnimInstace*                      HumanAnimInstance;                                 // 0x0698(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x68];                                     // 0x06A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        BreathAudioComponent;                              // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULayeredSoundAudioComponent*            HeartbeatAudioComponent;                           // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        Foley1AudioComponent;                              // 0x0718(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        Foley2AudioComponent;                              // 0x0720(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        WeaponRattleAudioComponent;                        // 0x0728(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LeftFootStepAudioComponent;                        // 0x0730(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        RightFootStepAudioComponent;                       // 0x0738(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LeftArmStepAudioComponent;                         // 0x0740(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        RightArmStepAudioComponent;                        // 0x0748(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FoliageFoleyAudioComponent;                        // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x80];                                     // 0x0758(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTriggerDown;                                      // 0x07D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D9[0x7];                                      // 0x07D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneAngleAdjustmentRate;                          // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneMaxAngleDiffMax;                              // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneMaxAngleDiffMin;                              // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneMaxAngleThresholdMax;                         // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneMaxAngleThresholdMin;                         // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneCrouchDelay;                                  // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F8[0x10];                                     // 0x07F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAimPointDistance;                               // 0x0808(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCharacterAimPointDistance;                      // 0x080C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAimPointDistance;                               // 0x0810(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionDistance;                               // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanToggleCrouch;                                  // 0x0818(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanToggleProne;                                   // 0x0819(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanToggleStand;                                   // 0x081A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDigging;                                        // 0x081B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanJumpHuman;                                     // 0x081C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81D[0x7];                                      // 0x081D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsSprintAllowed;                                   // 0x0824(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_825[0x3];                                      // 0x0825(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintBreachAngle;                                 // 0x0828(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82C[0x4];                                      // 0x082C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleRotationRate;                               // 0x0830(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DisableMovementCount;                              // 0x0834(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_835[0x3];                                      // 0x0835(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterMovementModifier;                             // 0x0838(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDepthThreshold;                            // 0x083C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterTickInterval;                                 // 0x0840(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_844[0xC];                                      // 0x0844(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashTimeout;                                       // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0854(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_855[0x3];                                      // 0x0855(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAimBlockDistance;                               // 0x0858(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletTrajectoryBlocked;                          // 0x085C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85D[0x7];                                      // 0x085D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimBlockedLocation;                                // 0x0864(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_870[0x18];                                     // 0x0870(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        CompressedLookRotation;                            // 0x0888(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShootWhileJumping;                             // 0x088A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88B[0x1];                                      // 0x088B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookRotationInterpSpeed;                           // 0x088C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeaponUp;                                       // 0x0890(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_891[0x7];                                      // 0x0891(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FallDamageCurve;                                   // 0x0898(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FallSlideDamageCurve;                              // 0x08A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FallDamageTimeThresholdCurve;                      // 0x08A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageWaterThreshold;                          // 0x08B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageWaterMultiplier;                         // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbVaultStaminaCostPercentage;                   // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            JumpCooldownCurve;                                 // 0x08C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispersionAfterLandingTime;                        // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CC[0xC];                                      // 0x08CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FallStunnedCurve;                                  // 0x08D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FallSlowDownCurve;                                 // 0x08E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x8];                                      // 0x08E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AttackMultiplierCurve;                             // 0x08F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FallShowDebug;                                     // 0x08F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F9[0x17];                                     // 0x08F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         SimulatedInsufficientDistance;                     // 0x0910(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_911[0x7];                                      // 0x0911(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCameraStateChanged;                              // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStanceChanged;                                   // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x1C];                                     // 0x0938(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             TraceChannel;                                      // 0x0954(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_955[0x3];                                      // 0x0955(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterOutline>          CharOutline;                                       // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHumanAnimConfig>           AnimConfig;                                        // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      OwnerSoundAttenuation;                             // 0x0968(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_970[0x34];                                     // 0x0970(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterPullStrength;                                 // 0x09A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterPushStrength;                                 // 0x09A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9AC[0x2C];                                     // 0x09AC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UWaterComponent*                        WaterOverlapped;                                   // 0x09D8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E0[0x19];                                     // 0x09E0(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLagSwitching;                                     // 0x09F9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9FA[0x6];                                      // 0x09FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterVersionServer;                            // 0x0A00(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A04[0x2];                                      // 0x0A04(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowReloadWhenCannotAim;                         // 0x0A06(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A07[0x1];                                      // 0x0A07(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FiredWeaponCooldownOnFireTime;                     // 0x0A08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireWeaponCooldownQuickMeleeTime;                  // 0x0A0C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireWeaponCooldownIsFiringTime;                    // 0x0A10(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireWeaponCooldownIsFiringTimeMelee;               // 0x0A14(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x18];                                     // 0x0A18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionActorComponent*             InteractionActorComponent;                         // 0x0A30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A38[0x4];                                      // 0x0A38(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneClampAngle;                                   // 0x0A3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowProneRotateWhileUsingWeapon;                 // 0x0A40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A41[0x6F];                                     // 0x0A41(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerCameraStart;                                 // 0x0AB0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerCameraDirection;                             // 0x0ABC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    PlayerCameraStartServer;                           // 0x0AC8(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  PlayerCameraDirectionServer;                       // 0x0AD4(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUseBackpackSocketsForEquipment;              // 0x0AE0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE1[0x3];                                      // 0x0AE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponCameraToSpecialSpeed;                        // 0x0AE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponCameraToRegularSpeed;                        // 0x0AE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AEC[0x3C];                                     // 0x0AEC(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFallHeightForClimb;                             // 0x0B28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2C[0x8];                                      // 0x0B2C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrenadeBlockedThreshold;                           // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastItemDamageCauser;                              // 0x0B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashbangMaxEffect;                                // 0x0B3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcussionMaxEffect;                               // 0x0B40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B44[0x4];                                      // 0x0B44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicalSurface, float>                 DamagePercentageThroughMaterial;                   // 0x0B48(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         StaggerEffectStrength;                             // 0x0B98(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9C[0x4];                                      // 0x0B9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaggerEffectDuration;                             // 0x0BA0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaggerDispersionMax;                              // 0x0BA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdrenalineBoostDuration;                           // 0x0BA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BAC[0x4];                                      // 0x0BAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicsHeadName;                                   // 0x0BB0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMirrorPose;                                       // 0x0BB8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB9[0x7];                                      // 0x0BB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHumanCharacter*>                AttachedCharacters;                                // 0x0BC0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD0[0x30];                                     // 0x0BD0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ADSAction();
	void BeforeDied(float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const struct FHitResult& HitResult);
	void BeginAdrenalineBoostTick();
	void BlockADSInput();
	struct FExplosionEffect CalculateExplosionExposure(class UExplosionComponent* ExplosionComponent);
	void CanAimChanged(class UObject* Sender, bool CanAimComponentState);
	void ChamberAction();
	void ChangeFireModeAction();
	void CheatToggleDebugAmmoReplication();
	void ClientAskForUpdateWeaponAmmo(class AWeapon* Weapon);
	void ClientDeselectCurrentItem();
	void ClientDrawBox(const struct FBoxCollider& Box, const struct FColor& Color);
	void ClientDrawBoxCustom(const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, const float LifeTime, const float Thickness);
	void ClientDrawCapsule(const struct FCapsuleCollider& Capsule, const struct FColor& Color);
	void ClientDrawCapsuleCustom(const struct FVector& Center, const float HalfHeight, const float Radius, const struct FQuat& Rotation, const struct FColor& Color, const float LifeTime, const float Thickness);
	void ClientDrawDebugBox(const struct FVector& Location, const struct FVector& BoxExtent, float Time);
	void ClientDrawDebugLine(const struct FVector& Start, const struct FVector& End, float Time, const struct FColor& Colour);
	void ClientDrawLine(const struct FVector& Start, const struct FVector& End, const struct FColor& Color);
	void ClientDrawLineCustom(const struct FVector& Start, const struct FVector& End, const struct FColor& Color, const float LifeTime);
	void ClientLogLagswitchingStats(const bool bDisconnected, const float TimeToLagswitchProtection, const int32 Strikes);
	void ClientOnOtherPlayerHit(float DamageAmount, EDamageType DamageType, class AHumanCharacter* Victim, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResult& HitResult, const TArray<TSubclassOf<class AItem>>& AffectedItems);
	void ClientOnShowHitMarkerOfColor(float CrosshairScale, const struct FColor& Color);
	void ClientPlayStaggerSound();
	void ClientShowDebugMessage(const float Duration, const class FString& Message, const struct FColor& Color);
	void ClientUpdateWeaponsAmmo(const TArray<struct FAmmoSyncMessage>& Messages);
	void ConfirmLadderAttach(class AWorldLadder* Ladder, const struct FVector& ActorLocation);
	void CrouchAction();
	void CrouchIgnoringMovement();
	void Die(float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const struct FHitResult& HitResult);
	void DisableAimingAffectedByConcussion();
	void DisableControlRotationYaw();
	void DisableJump();
	void DisableMainStances();
	void DisableMovement();
	void DisableMovementForDuration(float Duration);
	void DisableProne();
	void DisableTheUseOfConsumables();
	void DrawDebugHeadLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole);
	void DrawDebugMuzzleLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole);
	void DrawDebugTargetLocation(const struct FVector_NetQuantize& Location, ENetRole CallerRole);
	void DrawMeleeDebug(const struct FVector& Start, const struct FVector& End, const bool bHasHit, const bool bHasAuthority);
	void EnableAimingAffectedByConcussion();
	void EnableControlRotationYaw();
	void EnableJump();
	void EnableMainStances();
	void EnableMovement();
	void EnableProne();
	void EnableTheUseOfConsumables();
	void FireAction();
	class UHumanAnimInstace* GetAnimInstance();
	float GetSpecialDamageAmountForCharacter(const class AHumanCharacter* EnemyTakingDamage, float CurrentDamageAmount);
	const bool HasThrown();
	void HolsterAction();
	void InWaterTick(float DeltaTime);
	void JumpAction();
	void MulticastAddWound(const struct FVector_NetQuantize& HitWorldPosition, class UPrimitiveComponent* HitComponent, class FName HitBoneName);
	void MulticastBeginAdrenalineBoost();
	void MulticastDie(float DamageAmount, const struct FHitResult& HitResult, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const int32 LastItemDamageCauserID);
	void MulticastDisableControlRotationYaw();
	void MulticastEnableControlRotationYaw();
	void MulticastPlayGesture(class UAnimMontage* GestureToPlay);
	void MulticastSetCollision(bool NewCollision);
	void MulticastSetPlayerGroup(const class FString& NewGroup);
	void MulticastStaggerPlayer(float StunDuration, float Damage, const struct FVector& Direction);
	void MulticastStopGesture();
	void MulticastTakeDamage(float DamageAmount, const struct FHitResultSimplified& HitResult, const struct FVector_NetQuantizeNormal& Direction, const class AHumanCharacter* InstigatingActor, const class AActor* DamageCauser, EDamageType DamageType, const TArray<TSubclassOf<class AItem>>& AffectedItems);
	void MulticastUpdateWeaponAmmo(const struct FAmmoSyncMessage& Message);
	void OnAfterRespawn();
	void OnItemChangedStart(class UGameplayActionsComponent* GAC, class AItem* NewItem, class AItem* OldItem);
	void OnMeshChanged(class UPrimitiveComponent* Component);
	void OnOtherPlayerHit(float DamageAmount, EDamageType DamageType, class AHumanCharacter* Victim, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResult& HitResult, const TArray<TSubclassOf<class AItem>>& AffectedItems);
	bool OnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem);
	void OnPlayerEnterWater(const struct FVector& ImpactLocation, float WaterDepthAtImpact, float WaterDepthInFront);
	void OnPlayerExitWater();
	void OnRep_ArchetypeName();
	void OnRep_CompressedLookRotation();
	void OnRep_DisableMovementClount(uint8 OldValue);
	void OnRep_PlayerCameraDirection();
	void OnRep_PlayerCameraStart();
	void OnRep_PostChangeAttachedCharacters(const TArray<class AHumanCharacter*>& OldArray);
	void OnRep_WaterOverlapped(class UWaterComponent* OldValue);
	void OnShowHitMarkerOfColor(float CrosshairScale, const struct FColor& Color);
	void OnStaminaDepleted();
	void OnTakeDamage(float DamageAmount, EDamageType DamageType, const class AHumanCharacter* InstigatingActor, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResultSimplified& HitOptimised, const TArray<TSubclassOf<class AItem>>& AffectedItems);
	void OnTakeMeleeDamageOnClient(const class AHumanCharacter* PlayerInstigator, EItemCategory InstigatingItemCategory, const struct FHitResultSimplified& HitOptimised);
	void PlayGesture(class UAnimMontage* GestureToPlay);
	void PlayStaggerSound(const bool bIsInstigator, const bool bIsVictim);
	void ProcessExplosion(class UExplosionComponent* ExplosionComponent, const struct FExplosionEffect& Explosion, const EDamageType DamageType);
	void ProneAction();
	void QuickMeleeAction();
	void ReceiveOnFire();
	void ReloadAction();
	void ResetAnimInstance();
	void ResetInteract();
	void Respawn(float RemainingLifeTime);
	void SelectWeapon(EWeaponSlotType Slot);
	void SendMovementDebugDataToServer(const float CurrentSpeed);
	void ServerAskForUpdateWeaponsAmmo();
	void ServerDisableControlRotationYaw();
	void ServerDisableMovement();
	void ServerEnableControlRotationYaw();
	void ServerEnableHitRegistrationDebug();
	void ServerEnableMovement();
	void ServerPlayGesture(class UAnimMontage* GestureToPlay);
	void ServerReloadNotify();
	void ServerRequestLadderAttach(class AWorldLadder* Ladder);
	void ServerSetAimingDebug(bool bEnabled);
	void ServerSetAllowReload(bool bValue);
	void ServerSetArchetype(const class FString& InArchetypeName);
	void ServerSetInfiniteAmmo(bool bValue);
	void ServerSetInfiniteReload(bool bValue);
	void ServerStopGesture();
	void ServerToggleInfiniteAmmo();
	void ServerToggleInfiniteReload();
	void ServerUpdateWeaponAmmo(const struct FAmmoSyncMessage& Message);
	void SetADS(bool IsADS);
	void SetADSDesiredHold(bool IsADS);
	void SetADSDesiredTrigger(bool IsADS);
	void SetADSThrowable(bool IsADS);
	void SetAimingDebug(bool bEnabled);
	void SetAllowFire(bool bNewAllowFire);
	void SetCharacterVisible(bool bVisible);
	void SetSprint(bool Sprint);
	void SetWantsToSprint(bool Sprint);
	void SetWantsToSprintHotFix(bool Sprint);
	void SetWeaponRaised(bool IsWeaponRaised);
	void SetWeightModifier(const float NewWeightModifier);
	bool ShouldTakeDamageBP(class AHumanCharacter* InstigatingCharacter, const class AActor* DamageCauser, TSubclassOf<class AItem> ItemClass, EDamageType DamageType);
	void ShowBulletIndicatorNative(bool bIsPlayerHit, EDamageType DamageType, const class AHumanCharacter* PlayerInstigator, const struct FVector& Origin, const struct FHitResultSimplified& HitOptimised);
	void SprintAction();
	void StandAction();
	void StartDiggingInteraction();
	void StopADSAction();
	void StopChamberAction();
	void StopDiggingInteraction();
	void StopFireAction();
	void StopGestureAction();
	void StopJumpAction();
	void StopReloadAction();
	void StopSprintAction();
	void StopThrowableAimingAction();
	void StopUseAction();
	void SwitchAction();
	float TakeDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType);
	void TakeDamageOnClosestBone(float DamageAmount, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType);
	void ThrowableAimingAction();
	void ToggleCrouch();
	void ToggleCrouchAction();
	void ToggleProne();
	void ToggleProneAction();
	void UpdateAdrenalineDeprivationEffect(float Strength, float RemainingTime);
	void UpdateStaggerEffect(float Strength, float RemainingTime);
	void UseAction();
	void VerifyHitOnServer(class AHumanCharacter* Shooter, class AHumanCharacter* Target, const struct FVector& ShootLocation, const struct FVector& ShootDirection, const float BulletTravelTime, const float Timestamp, const struct FHitResult& ClientHitResult, const float ClientDamage);
	void VerifyHitOnServerDebug(class AHumanCharacter* Shooter, class AHumanCharacter* Target, const struct FVector& ShootLocation, const struct FVector& ShootDirection, const float BulletTravelTime, const float Timestamp, const struct FHitResult& ClientHitResult, const float ClientDamage, const TArray<struct FQuat>& ClientHitBodyCollidersRotations, const TArray<struct FCapsuleCollider>& ClientHitBodyCollidersCapsules);

	bool AnimIsRunning() const;
	void ApplyOwnerSoundAttenuation(class UAudioComponent* AudioComponent) const;
	void AreCharactersInSameTeam(class AHumanCharacter* OtherCharacter, bool* AreInSameTeam, bool* AreSameCharacter) const;
	void CalculateBodyExposureToPoint(const struct FVector& Location, float* OutFaceExposure, float* OutBodyExposure, int32 Precision, float MaxThickness, class AActor* IgnoreActor) const;
	bool CanAim() const;
	bool CanClimbLadder() const;
	bool CanProcessCustomizationChangesToCloud() const;
	bool CanShowActionsInHistory() const;
	bool CanShowFiringTraces() const;
	bool CanUseConsumables() const;
	const struct FVector GetAimAtLocation() const;
	const struct FVector GetAimpointWeaponTarget() const;
	bool GetAllowReload() const;
	class UAudioComponent* GetBreathAudioComponent() const;
	void GetCharacterWeightSoundProperties(float* VolumeMultiplier, float* PitchMultiplier) const;
	class UFootStepComponent* GetFootStepComponent() const;
	TSubclassOf<class AGender> GetGenderClass() const;
	bool GetInfiniteAmmo() const;
	bool GetInfiniteReload() const;
	class UInventoryOperationsComponent* GetInventoryOperationsComponent() const;
	const bool GetIsADSThrowable() const;
	void GetMovementSoundProperties(const class USoundBase* Sound, float* VolumeMultiplier, float* PitchMultiplier) const;
	ENetRole GetNetworkRole() const;
	void GetPlayerCameraStartAndDirection(struct FVector* OutCameraStart, struct FVector* OutCameraDirection) const;
	struct FVector GetProneForwardVector() const;
	float GetRemoteViewPitch() const;
	float GetRemoteViewPitchSmooth() const;
	class FString GetRoleText(ENetRole NetRole) const;
	class UStaminaComponent* GetStaminaComponent() const;
	EStance GetStance() const;
	class UVegetationComponent* GetVegetationComponent() const;
	void GetWaterDetails(bool* bIsInWater, float* Depth, struct FVector* Flow, float* MaxDepth) const;
	float GetWeaponCollisionInsufficientDistance() const;
	float GetWeaponCollisionInsufficientHorizontalDistance() const;
	const bool HasUsedThrowable() const;
	bool IsADS() const;
	bool IsAimingAffectedByConcussion() const;
	bool IsAttacking() const;
	bool IsChambering() const;
	bool IsChamberInProgress() const;
	bool IsChangeFireModeInProgress() const;
	bool IsCharacterInWater() const;
	bool IsClimbing() const;
	bool IsClimbingLadder() const;
	bool IsCrouchInProgress() const;
	bool IsCyclingMode() const;
	bool IsDebugAmmoReplicationEnabled() const;
	bool IsFireInProgress() const;
	bool IsFiring() const;
	bool IsFirstPersonADS() const;
	bool IsGestureInProgress() const;
	bool IsHipFiring() const;
	bool IsHolsterInProgress() const;
	bool IsJumpInProgress() const;
	bool IsPoseMirrored() const;
	bool IsProneInProgress() const;
	bool IsProningInMotion() const;
	bool IsQuickMeleeInProgress() const;
	bool IsReloading() const;
	bool IsReloadInProgress() const;
	bool IsSlidingDownLadder() const;
	bool IsSprinting() const;
	bool IsSprintInProgress() const;
	bool IsStandInProgress() const;
	bool IsSwitchInProgress() const;
	bool IsThirdPersonADS() const;
	bool IsTriggerDownAuthority() const;
	bool IsTriggerDownLocal() const;
	bool IsUseInProgress() const;
	bool IsVaulting() const;
	bool ShouldScaleHeadDown() const;
	bool ShouldShowCharacterAiming() const;
	bool WantsToSprint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanCharacter">();
	}
	static class AHumanCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanCharacter>();
	}
};
static_assert(alignof(AHumanCharacter) == 0x000010, "Wrong alignment on AHumanCharacter");
static_assert(sizeof(AHumanCharacter) == 0x000C00, "Wrong size on AHumanCharacter");
static_assert(offsetof(AHumanCharacter, CloudLoadedAuthority) == 0x0004C8, "Member 'AHumanCharacter::CloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CloudLoadedClient) == 0x0004D8, "Member 'AHumanCharacter::CloudLoadedClient' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AttachedCharactersChanged) == 0x0004E8, "Member 'AHumanCharacter::AttachedCharactersChanged' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PlayGestureDelegate) == 0x0004F8, "Member 'AHumanCharacter::PlayGestureDelegate' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AffiliationID) == 0x000508, "Member 'AHumanCharacter::AffiliationID' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsAutonomous) == 0x00050A, "Member 'AHumanCharacter::bIsAutonomous' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsAutonomousOrAuthority) == 0x00050B, "Member 'AHumanCharacter::bIsAutonomousOrAuthority' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bEnableSkinDebug) == 0x00050E, "Member 'AHumanCharacter::bEnableSkinDebug' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Accessor) == 0x000510, "Member 'AHumanCharacter::Accessor' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Inventory) == 0x000518, "Member 'AHumanCharacter::Inventory' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Customization) == 0x000520, "Member 'AHumanCharacter::Customization' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, DefaultInventory) == 0x000528, "Member 'AHumanCharacter::DefaultInventory' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StateMachine) == 0x000530, "Member 'AHumanCharacter::StateMachine' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, GameplayActions) == 0x000538, "Member 'AHumanCharacter::GameplayActions' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CanAimComponent) == 0x000540, "Member 'AHumanCharacter::CanAimComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HitZoneManager) == 0x000548, "Member 'AHumanCharacter::HitZoneManager' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WoundsManagerComponent) == 0x000550, "Member 'AHumanCharacter::WoundsManagerComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HealthComponent) == 0x000558, "Member 'AHumanCharacter::HealthComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, BaseMesh) == 0x000560, "Member 'AHumanCharacter::BaseMesh' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Uniform) == 0x000568, "Member 'AHumanCharacter::Uniform' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Hair) == 0x000570, "Member 'AHumanCharacter::Hair' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Head) == 0x000578, "Member 'AHumanCharacter::Head' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Gloves) == 0x000580, "Member 'AHumanCharacter::Gloves' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Backpack) == 0x000588, "Member 'AHumanCharacter::Backpack' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HeadgearUpper) == 0x000590, "Member 'AHumanCharacter::HeadgearUpper' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HeadgearMiddle) == 0x000598, "Member 'AHumanCharacter::HeadgearMiddle' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HeadgearLower) == 0x0005A0, "Member 'AHumanCharacter::HeadgearLower' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FootStepClass) == 0x0005B0, "Member 'AHumanCharacter::FootStepClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, VegetationClass) == 0x0005C0, "Member 'AHumanCharacter::VegetationClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StaminaClass) == 0x0005D0, "Member 'AHumanCharacter::StaminaClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StaminaComponent) == 0x0005D8, "Member 'AHumanCharacter::StaminaComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PoiseClass) == 0x0005E0, "Member 'AHumanCharacter::PoiseClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PoiseComponent) == 0x0005E8, "Member 'AHumanCharacter::PoiseComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, SpeedModifierClass) == 0x0005F0, "Member 'AHumanCharacter::SpeedModifierClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, SpeedModifierComponent) == 0x0005F8, "Member 'AHumanCharacter::SpeedModifierComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CameraManagerClass) == 0x000600, "Member 'AHumanCharacter::CameraManagerClass' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CameraManagerComponent) == 0x000608, "Member 'AHumanCharacter::CameraManagerComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ArchetypeDataTable) == 0x000610, "Member 'AHumanCharacter::ArchetypeDataTable' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ArchetypeName) == 0x000618, "Member 'AHumanCharacter::ArchetypeName' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, LastKnownLoadoutBeforeDeath) == 0x000620, "Member 'AHumanCharacter::LastKnownLoadoutBeforeDeath' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bFireRequested) == 0x000648, "Member 'AHumanCharacter::bFireRequested' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bAllowFire) == 0x000649, "Member 'AHumanCharacter::bAllowFire' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ADSTransitionDelay) == 0x00064C, "Member 'AHumanCharacter::ADSTransitionDelay' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsADS) == 0x000658, "Member 'AHumanCharacter::bIsADS' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsADSThrowable) == 0x00065B, "Member 'AHumanCharacter::bIsADSThrowable' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bHasUsedThrowable) == 0x00065C, "Member 'AHumanCharacter::bHasUsedThrowable' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, InteractionADSMinTime) == 0x000668, "Member 'AHumanCharacter::InteractionADSMinTime' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneTransitionDispersion) == 0x00067C, "Member 'AHumanCharacter::ProneTransitionDispersion' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneTransitionDispersion1PV) == 0x000680, "Member 'AHumanCharacter::ProneTransitionDispersion1PV' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bInfiniteAmmo) == 0x000684, "Member 'AHumanCharacter::bInfiniteAmmo' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bInfiniteReload) == 0x000685, "Member 'AHumanCharacter::bInfiniteReload' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bAllowReload) == 0x000686, "Member 'AHumanCharacter::bAllowReload' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bDebugAmmoReplication) == 0x000687, "Member 'AHumanCharacter::bDebugAmmoReplication' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HumanAnimInstance) == 0x000698, "Member 'AHumanCharacter::HumanAnimInstance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, BreathAudioComponent) == 0x000708, "Member 'AHumanCharacter::BreathAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, HeartbeatAudioComponent) == 0x000710, "Member 'AHumanCharacter::HeartbeatAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Foley1AudioComponent) == 0x000718, "Member 'AHumanCharacter::Foley1AudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, Foley2AudioComponent) == 0x000720, "Member 'AHumanCharacter::Foley2AudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WeaponRattleAudioComponent) == 0x000728, "Member 'AHumanCharacter::WeaponRattleAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, LeftFootStepAudioComponent) == 0x000730, "Member 'AHumanCharacter::LeftFootStepAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, RightFootStepAudioComponent) == 0x000738, "Member 'AHumanCharacter::RightFootStepAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, LeftArmStepAudioComponent) == 0x000740, "Member 'AHumanCharacter::LeftArmStepAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, RightArmStepAudioComponent) == 0x000748, "Member 'AHumanCharacter::RightArmStepAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FoliageFoleyAudioComponent) == 0x000750, "Member 'AHumanCharacter::FoliageFoleyAudioComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bTriggerDown) == 0x0007D8, "Member 'AHumanCharacter::bTriggerDown' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneAngleAdjustmentRate) == 0x0007E0, "Member 'AHumanCharacter::ProneAngleAdjustmentRate' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneMaxAngleDiffMax) == 0x0007E4, "Member 'AHumanCharacter::ProneMaxAngleDiffMax' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneMaxAngleDiffMin) == 0x0007E8, "Member 'AHumanCharacter::ProneMaxAngleDiffMin' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneMaxAngleThresholdMax) == 0x0007EC, "Member 'AHumanCharacter::ProneMaxAngleThresholdMax' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneMaxAngleThresholdMin) == 0x0007F0, "Member 'AHumanCharacter::ProneMaxAngleThresholdMin' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneCrouchDelay) == 0x0007F4, "Member 'AHumanCharacter::ProneCrouchDelay' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MinAimPointDistance) == 0x000808, "Member 'AHumanCharacter::MinAimPointDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MinCharacterAimPointDistance) == 0x00080C, "Member 'AHumanCharacter::MinCharacterAimPointDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MaxAimPointDistance) == 0x000810, "Member 'AHumanCharacter::MaxAimPointDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, InteractionDistance) == 0x000814, "Member 'AHumanCharacter::InteractionDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bCanToggleCrouch) == 0x000818, "Member 'AHumanCharacter::bCanToggleCrouch' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bCanToggleProne) == 0x000819, "Member 'AHumanCharacter::bCanToggleProne' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bCanToggleStand) == 0x00081A, "Member 'AHumanCharacter::bCanToggleStand' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsDigging) == 0x00081B, "Member 'AHumanCharacter::bIsDigging' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bCanJumpHuman) == 0x00081C, "Member 'AHumanCharacter::bCanJumpHuman' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, IsSprintAllowed) == 0x000824, "Member 'AHumanCharacter::IsSprintAllowed' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, SprintBreachAngle) == 0x000828, "Member 'AHumanCharacter::SprintBreachAngle' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CapsuleRotationRate) == 0x000830, "Member 'AHumanCharacter::CapsuleRotationRate' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, DisableMovementCount) == 0x000834, "Member 'AHumanCharacter::DisableMovementCount' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WaterMovementModifier) == 0x000838, "Member 'AHumanCharacter::WaterMovementModifier' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MovementDepthThreshold) == 0x00083C, "Member 'AHumanCharacter::MovementDepthThreshold' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WaterTickInterval) == 0x000840, "Member 'AHumanCharacter::WaterTickInterval' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, DashTimeout) == 0x000850, "Member 'AHumanCharacter::DashTimeout' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsAiming) == 0x000854, "Member 'AHumanCharacter::bIsAiming' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MaxAimBlockDistance) == 0x000858, "Member 'AHumanCharacter::MaxAimBlockDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bBulletTrajectoryBlocked) == 0x00085C, "Member 'AHumanCharacter::bBulletTrajectoryBlocked' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AimBlockedLocation) == 0x000864, "Member 'AHumanCharacter::AimBlockedLocation' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CompressedLookRotation) == 0x000888, "Member 'AHumanCharacter::CompressedLookRotation' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bCanShootWhileJumping) == 0x00088A, "Member 'AHumanCharacter::bCanShootWhileJumping' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, LookRotationInterpSpeed) == 0x00088C, "Member 'AHumanCharacter::LookRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bIsWeaponUp) == 0x000890, "Member 'AHumanCharacter::bIsWeaponUp' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallDamageCurve) == 0x000898, "Member 'AHumanCharacter::FallDamageCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallSlideDamageCurve) == 0x0008A0, "Member 'AHumanCharacter::FallSlideDamageCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallDamageTimeThresholdCurve) == 0x0008A8, "Member 'AHumanCharacter::FallDamageTimeThresholdCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallDamageWaterThreshold) == 0x0008B0, "Member 'AHumanCharacter::FallDamageWaterThreshold' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallDamageWaterMultiplier) == 0x0008B4, "Member 'AHumanCharacter::FallDamageWaterMultiplier' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ClimbVaultStaminaCostPercentage) == 0x0008B8, "Member 'AHumanCharacter::ClimbVaultStaminaCostPercentage' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, JumpCooldownCurve) == 0x0008C0, "Member 'AHumanCharacter::JumpCooldownCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, DispersionAfterLandingTime) == 0x0008C8, "Member 'AHumanCharacter::DispersionAfterLandingTime' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallStunnedCurve) == 0x0008D8, "Member 'AHumanCharacter::FallStunnedCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallSlowDownCurve) == 0x0008E0, "Member 'AHumanCharacter::FallSlowDownCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AttackMultiplierCurve) == 0x0008F0, "Member 'AHumanCharacter::AttackMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FallShowDebug) == 0x0008F8, "Member 'AHumanCharacter::FallShowDebug' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, SimulatedInsufficientDistance) == 0x000910, "Member 'AHumanCharacter::SimulatedInsufficientDistance' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, OnCameraStateChanged) == 0x000918, "Member 'AHumanCharacter::OnCameraStateChanged' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, OnStanceChanged) == 0x000928, "Member 'AHumanCharacter::OnStanceChanged' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, TraceChannel) == 0x000954, "Member 'AHumanCharacter::TraceChannel' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CharOutline) == 0x000958, "Member 'AHumanCharacter::CharOutline' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AnimConfig) == 0x000960, "Member 'AHumanCharacter::AnimConfig' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, OwnerSoundAttenuation) == 0x000968, "Member 'AHumanCharacter::OwnerSoundAttenuation' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WaterPullStrength) == 0x0009A4, "Member 'AHumanCharacter::WaterPullStrength' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WaterPushStrength) == 0x0009A8, "Member 'AHumanCharacter::WaterPushStrength' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WaterOverlapped) == 0x0009D8, "Member 'AHumanCharacter::WaterOverlapped' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bLagSwitching) == 0x0009F9, "Member 'AHumanCharacter::bLagSwitching' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, CharacterVersionServer) == 0x000A00, "Member 'AHumanCharacter::CharacterVersionServer' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bAllowReloadWhenCannotAim) == 0x000A06, "Member 'AHumanCharacter::bAllowReloadWhenCannotAim' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FiredWeaponCooldownOnFireTime) == 0x000A08, "Member 'AHumanCharacter::FiredWeaponCooldownOnFireTime' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FireWeaponCooldownQuickMeleeTime) == 0x000A0C, "Member 'AHumanCharacter::FireWeaponCooldownQuickMeleeTime' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FireWeaponCooldownIsFiringTime) == 0x000A10, "Member 'AHumanCharacter::FireWeaponCooldownIsFiringTime' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FireWeaponCooldownIsFiringTimeMelee) == 0x000A14, "Member 'AHumanCharacter::FireWeaponCooldownIsFiringTimeMelee' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, InteractionActorComponent) == 0x000A30, "Member 'AHumanCharacter::InteractionActorComponent' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ProneClampAngle) == 0x000A3C, "Member 'AHumanCharacter::ProneClampAngle' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bAllowProneRotateWhileUsingWeapon) == 0x000A40, "Member 'AHumanCharacter::bAllowProneRotateWhileUsingWeapon' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PlayerCameraStart) == 0x000AB0, "Member 'AHumanCharacter::PlayerCameraStart' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PlayerCameraDirection) == 0x000ABC, "Member 'AHumanCharacter::PlayerCameraDirection' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PlayerCameraStartServer) == 0x000AC8, "Member 'AHumanCharacter::PlayerCameraStartServer' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PlayerCameraDirectionServer) == 0x000AD4, "Member 'AHumanCharacter::PlayerCameraDirectionServer' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ShouldUseBackpackSocketsForEquipment) == 0x000AE0, "Member 'AHumanCharacter::ShouldUseBackpackSocketsForEquipment' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WeaponCameraToSpecialSpeed) == 0x000AE4, "Member 'AHumanCharacter::WeaponCameraToSpecialSpeed' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, WeaponCameraToRegularSpeed) == 0x000AE8, "Member 'AHumanCharacter::WeaponCameraToRegularSpeed' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, MaxFallHeightForClimb) == 0x000B28, "Member 'AHumanCharacter::MaxFallHeightForClimb' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, GrenadeBlockedThreshold) == 0x000B34, "Member 'AHumanCharacter::GrenadeBlockedThreshold' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, LastItemDamageCauser) == 0x000B38, "Member 'AHumanCharacter::LastItemDamageCauser' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, FlashbangMaxEffect) == 0x000B3C, "Member 'AHumanCharacter::FlashbangMaxEffect' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, ConcussionMaxEffect) == 0x000B40, "Member 'AHumanCharacter::ConcussionMaxEffect' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, DamagePercentageThroughMaterial) == 0x000B48, "Member 'AHumanCharacter::DamagePercentageThroughMaterial' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StaggerEffectStrength) == 0x000B98, "Member 'AHumanCharacter::StaggerEffectStrength' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StaggerEffectDuration) == 0x000BA0, "Member 'AHumanCharacter::StaggerEffectDuration' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, StaggerDispersionMax) == 0x000BA4, "Member 'AHumanCharacter::StaggerDispersionMax' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AdrenalineBoostDuration) == 0x000BA8, "Member 'AHumanCharacter::AdrenalineBoostDuration' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, PhysicsHeadName) == 0x000BB0, "Member 'AHumanCharacter::PhysicsHeadName' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, bMirrorPose) == 0x000BB8, "Member 'AHumanCharacter::bMirrorPose' has a wrong offset!");
static_assert(offsetof(AHumanCharacter, AttachedCharacters) == 0x000BC0, "Member 'AHumanCharacter::AttachedCharacters' has a wrong offset!");

// Class Flame.InteractionItemComponent
// 0x00C8 (0x0178 - 0x00B0)
class UInteractionItemComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DOnPreInteractionStart;                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DOnPreInteractionEnd;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DOnInteractionStart;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DOnInteractionEnd;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x00F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MarkerSocketNames;                                 // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSocketDescriptor>              MarkerComponents;                                  // 0x0108(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bVisibleMarkers;                                   // 0x0118(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClientNotify;                                     // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExclusiveUse;                                     // 0x011A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExtraCollisionTestFromPlayer;                     // 0x011B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreInteractionTime;                                // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionDistanceLimit;                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAngleLimit                        InteractionLimit;                                  // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionAngleLimit;                             // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayEndInteractionAnimation;                      // 0x012C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimInteractionType                          AnimInteractionType;                               // 0x012D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHumanCharacter>         LockOwner;                                         // 0x0130(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x30];                                     // 0x0138(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFilterBlockedByStanding;                          // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFilterBlockedByCrouching;                         // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFilterBlockedByProne;                             // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFilterNeedsKnife;                                 // 0x016B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKnifeAffectsInteractionTime;                      // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnifeInteractionTimeMultiplier;                    // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHideMarker(class UInteractionItemComponent* Sender);
	void OnInteractionEnd(class UInteractionItemComponent* Sender, class AActor* InteractingActor);
	void OnInteractionStart(class UInteractionItemComponent* Sender, class AActor* InteractingActor);
	void OnPreInteractionEnd(class UInteractionItemComponent* Sender, class AActor* InteractingActor, bool Canceled);
	void OnPreInteractionStart(class UInteractionItemComponent* Sender, class AActor* InteractingActor);
	void OnShowMarker(class UInteractionItemComponent* Sender, const struct FVector& MarkerPosition);
	void OnUpdateMarker(class UInteractionItemComponent* Sender, const struct FVector& MarkerPosition);
	void ReInitializeSockets();
	void SetEnabled(bool Enabled);
	void SetInteractionTime(float NewTime);
	void SetMarkerVisibility(bool Visibility);
	void SetPlayEndInteractionAnimation(bool PlayAnimation);

	bool CanInteract(class AHumanCharacter* Human) const;
	bool CanShowMarker(class AHumanCharacter* Human) const;
	float GetInteractionAngleLimit() const;
	float GetInteractionDistanceLimit() const;
	EInteractionAngleLimit GetInteractionLimit() const;
	float GetInteractionTime() const;
	bool GetMarkerVisibility() const;
	bool GetNearestSocketPos(class AHumanCharacter* Human, const struct FVector& ViewPos, struct FVector* SocketPos) const;
	bool IsCompoundInteraction() const;
	bool IsEnabled() const;
	bool IsExclusivityLocked(class AHumanCharacter* Human) const;
	bool IsExclusivityUsing() const;
	bool PlayEndInteractionAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionItemComponent">();
	}
	static class UInteractionItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionItemComponent>();
	}
};
static_assert(alignof(UInteractionItemComponent) == 0x000008, "Wrong alignment on UInteractionItemComponent");
static_assert(sizeof(UInteractionItemComponent) == 0x000178, "Wrong size on UInteractionItemComponent");
static_assert(offsetof(UInteractionItemComponent, DOnPreInteractionStart) == 0x0000B0, "Member 'UInteractionItemComponent::DOnPreInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, DOnPreInteractionEnd) == 0x0000C0, "Member 'UInteractionItemComponent::DOnPreInteractionEnd' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, DOnInteractionStart) == 0x0000D0, "Member 'UInteractionItemComponent::DOnInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, DOnInteractionEnd) == 0x0000E0, "Member 'UInteractionItemComponent::DOnInteractionEnd' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bIsEnabled) == 0x0000F0, "Member 'UInteractionItemComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, MarkerSocketNames) == 0x0000F8, "Member 'UInteractionItemComponent::MarkerSocketNames' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, MarkerComponents) == 0x000108, "Member 'UInteractionItemComponent::MarkerComponents' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bVisibleMarkers) == 0x000118, "Member 'UInteractionItemComponent::bVisibleMarkers' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bClientNotify) == 0x000119, "Member 'UInteractionItemComponent::bClientNotify' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bExclusiveUse) == 0x00011A, "Member 'UInteractionItemComponent::bExclusiveUse' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bExtraCollisionTestFromPlayer) == 0x00011B, "Member 'UInteractionItemComponent::bExtraCollisionTestFromPlayer' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, PreInteractionTime) == 0x00011C, "Member 'UInteractionItemComponent::PreInteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, InteractionDistanceLimit) == 0x000120, "Member 'UInteractionItemComponent::InteractionDistanceLimit' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, InteractionLimit) == 0x000124, "Member 'UInteractionItemComponent::InteractionLimit' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, InteractionAngleLimit) == 0x000128, "Member 'UInteractionItemComponent::InteractionAngleLimit' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bPlayEndInteractionAnimation) == 0x00012C, "Member 'UInteractionItemComponent::bPlayEndInteractionAnimation' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, AnimInteractionType) == 0x00012D, "Member 'UInteractionItemComponent::AnimInteractionType' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, LockOwner) == 0x000130, "Member 'UInteractionItemComponent::LockOwner' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bFilterBlockedByStanding) == 0x000168, "Member 'UInteractionItemComponent::bFilterBlockedByStanding' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bFilterBlockedByCrouching) == 0x000169, "Member 'UInteractionItemComponent::bFilterBlockedByCrouching' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bFilterBlockedByProne) == 0x00016A, "Member 'UInteractionItemComponent::bFilterBlockedByProne' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bFilterNeedsKnife) == 0x00016B, "Member 'UInteractionItemComponent::bFilterNeedsKnife' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, bKnifeAffectsInteractionTime) == 0x00016C, "Member 'UInteractionItemComponent::bKnifeAffectsInteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionItemComponent, KnifeInteractionTimeMultiplier) == 0x000170, "Member 'UInteractionItemComponent::KnifeInteractionTimeMultiplier' has a wrong offset!");

// Class Flame.CameraManagerComponentBase
// 0x0010 (0x00C0 - 0x00B0)
class UCameraManagerComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraState(const ECameraPositionState& NewState);

	class UCameraComponent* GetActiveCamera() const;
	ECameraPositionState GetCameraState() const;
	float GetShakeModifier() const;
	float GetWaterSurfaceZ() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraManagerComponentBase">();
	}
	static class UCameraManagerComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraManagerComponentBase>();
	}
};
static_assert(alignof(UCameraManagerComponentBase) == 0x000008, "Wrong alignment on UCameraManagerComponentBase");
static_assert(sizeof(UCameraManagerComponentBase) == 0x0000C0, "Wrong size on UCameraManagerComponentBase");

// Class Flame.CameraManagerComponent
// 0x03A8 (0x0468 - 0x00C0)
class UCameraManagerComponent : public UCameraManagerComponentBase
{
public:
	ECameraPositionState                          CameraState;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UsingRightShoulder;                                // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxZAdjustmentSpeed;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraSpeedDependentHeightOffset      SpeedDependentHeight;                              // 0x00C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArmForwardOffset;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZStand;                                         // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZSmoothnessStand;                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraSpeedDependentHeightOffset      SpeedDependentHeightCrouch;                        // 0x00EC(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArmForwardOffsetCrouch;                            // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZCrouch;                                        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZSmoothnessCrouch;                              // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraSpeedDependentHeightOffset      SpeedDependentHeightProne;                         // 0x0110(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArmForwardOffsetProne;                             // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZProne;                                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZSmoothnessProne;                               // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         PitchLimit;                                        // 0x0134(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         PitchLimitCrouch;                                  // 0x013C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         PitchLimitProne;                                   // 0x0144(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmTravelSpeed;                                    // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0xC];                                      // 0x0150(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetOffsetAdjustmentSpeedLaterally;              // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedLaterallyAccelerationRate;    // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedAccelerationRate;             // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedStandToCrouch;                // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedStandToProne;                 // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedCrouchToStand;                // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedCrouchToProne;                // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedProneToStand;                 // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdjustmentSpeedProneToCrouch;                // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraShakeOnLand;                                 // 0x0180(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPerspectivePreSwap;                              // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPerspectivePostSwap;                             // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFirstPersonADSNotAllowed;                        // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFootIKAnimInstance*                    FootIk;                                            // 0x01C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AdjustmentDecay;                                   // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraHideDistance;                                // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShowDistance;                                // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVUnarmed;                                  // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVStandArmed;                               // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVStand3ADS;                                // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVCrouchArmed;                              // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVCrouch3ADS;                               // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVProneArmed;                               // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVProne3ADS;                                // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVSprinting;                                // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAdjustmentSpeed;                              // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneYawRange;                                     // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x10];                                     // 0x020C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayedADSAfterClimbOrVaultTime;                   // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x4];                                      // 0x0220(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDurationConsideredLong;                 // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x1C];                                     // 0x0228(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadlockTimeStanceChange;                          // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeadlockTimeVault;                                 // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeadlockAdoptRate;                                 // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeadlockZAdjustment;                               // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeadlockZMaxWeight;                                // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       ParentCamera;                                      // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameSpringArmComponent*               TwoArmSetupRight;                                  // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlameSpringArmComponent*               TwoArmSetupBack;                                   // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmLengthUnarmed;                                  // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmLengthUnarmedBuilding;                          // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmLength;                                         // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmLengthADS;                                      // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x4];                                      // 0x0288(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmLengthProne;                                    // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArmLength1ADSTime;                                 // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294[0xC];                                      // 0x0294(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            Arm1ADSTransitionParamEnter;                       // 0x02A0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FViewTargetTransitionParams            Arm1ADSTransitionParamExit;                        // 0x02B0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         ArmClimbVaultArmMultiplier;                        // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Arm1PBBlendSpeed;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Arm1PBBlendExp;                                    // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x4];                                      // 0x02D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ArmRightRotation;                                  // 0x02DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               ArmBackRotation;                                   // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               ArmCameraRotation;                                 // 0x02F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x4];                                      // 0x0300(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShoulderSwapSpeedADS;                              // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShoulderSwapSpeedArmed;                            // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ShoulderSwapSpeedUnarmed;                          // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CameraOriginalMountingPoint;                       // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            CurrentScope;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x38];                                     // 0x0338(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowableShoulderOffsetMultiplier;                 // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThrowableVerticalOffsetAdditive;                   // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   CamManager;                                        // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHumanPlayerCharacter*                  HumanPlayerCharacter;                              // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x14];                                     // 0x03A0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoPitchChecks3;                                   // 0x03B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoPitchChecks3ADS;                                // 0x03B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoPitchChecks1ADS;                                // 0x03B6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnforcePitchChecks3;                              // 0x03B7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnforcePitchChecks3ADS;                           // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnforcePitchChecks1ADS;                           // 0x03B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoPitchChecksStand;                               // 0x03BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoPitchChecksCrouch;                              // 0x03BB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoPitchChecksProne;                               // 0x03BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPitchDeltaZMultiplier;                          // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinPitchBias;                                      // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPitchCheckSetting>             PitchChecks;                                       // 0x03C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MaxRestrictedPitch;                                // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawDebugMinPitchChecks;                          // 0x03DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PronePitchAdjustmentCurve;                         // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchPitchAdjustment;                             // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StandingPitchAdjustment;                           // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x4];                                      // 0x03F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterSurfaceZLimit;                                // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVMixSpeed;                                 // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraFOV                             CameraFOVSettings;                                 // 0x03FC(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCameraFOV                             CameraFOVSettings1P;                               // 0x0414(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x1C];                                     // 0x042C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusPointDecay;                                   // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FocusPointMultiplier;                              // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              FocusPointStrength;                                // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FocusPointIterations;                              // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              FocusPointRotationDeteriorate;                     // 0x045C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcquireHumanPlayerCharacter();
	void DrawDebugCameraLocation(const struct FVector& Location, ENetRole CallerRole);
	void InitADS(bool IsADS);
	void OnBuildingEnter(class AActor* Building);
	void OnBuildingLeave(class AActor* Building);
	void OnBuildingTypeEntered(EInteriorRoomType Type);
	void OnBuildingTypeLeave(EInteriorRoomType Type);
	void OnStableDuringClimb();
	void OnStartClimb();
	void ServerSetShoulder(bool bShoulder);
	void UnblockADSByClimbOrVault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraManagerComponent">();
	}
	static class UCameraManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraManagerComponent>();
	}
};
static_assert(alignof(UCameraManagerComponent) == 0x000008, "Wrong alignment on UCameraManagerComponent");
static_assert(sizeof(UCameraManagerComponent) == 0x000468, "Wrong size on UCameraManagerComponent");
static_assert(offsetof(UCameraManagerComponent, CameraState) == 0x0000C0, "Member 'UCameraManagerComponent::CameraState' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, UsingRightShoulder) == 0x0000C1, "Member 'UCameraManagerComponent::UsingRightShoulder' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZAdjustmentSpeed) == 0x0000C4, "Member 'UCameraManagerComponent::MaxZAdjustmentSpeed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, SpeedDependentHeight) == 0x0000C8, "Member 'UCameraManagerComponent::SpeedDependentHeight' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmForwardOffset) == 0x0000E0, "Member 'UCameraManagerComponent::ArmForwardOffset' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZStand) == 0x0000E4, "Member 'UCameraManagerComponent::MaxZStand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZSmoothnessStand) == 0x0000E8, "Member 'UCameraManagerComponent::MaxZSmoothnessStand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, SpeedDependentHeightCrouch) == 0x0000EC, "Member 'UCameraManagerComponent::SpeedDependentHeightCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmForwardOffsetCrouch) == 0x000104, "Member 'UCameraManagerComponent::ArmForwardOffsetCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZCrouch) == 0x000108, "Member 'UCameraManagerComponent::MaxZCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZSmoothnessCrouch) == 0x00010C, "Member 'UCameraManagerComponent::MaxZSmoothnessCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, SpeedDependentHeightProne) == 0x000110, "Member 'UCameraManagerComponent::SpeedDependentHeightProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmForwardOffsetProne) == 0x000128, "Member 'UCameraManagerComponent::ArmForwardOffsetProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZProne) == 0x00012C, "Member 'UCameraManagerComponent::MaxZProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxZSmoothnessProne) == 0x000130, "Member 'UCameraManagerComponent::MaxZSmoothnessProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PitchLimit) == 0x000134, "Member 'UCameraManagerComponent::PitchLimit' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PitchLimitCrouch) == 0x00013C, "Member 'UCameraManagerComponent::PitchLimitCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PitchLimitProne) == 0x000144, "Member 'UCameraManagerComponent::PitchLimitProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmTravelSpeed) == 0x00014C, "Member 'UCameraManagerComponent::ArmTravelSpeed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, TargetOffsetAdjustmentSpeedLaterally) == 0x00015C, "Member 'UCameraManagerComponent::TargetOffsetAdjustmentSpeedLaterally' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedLaterallyAccelerationRate) == 0x000160, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedLaterallyAccelerationRate' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedAccelerationRate) == 0x000164, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedAccelerationRate' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedStandToCrouch) == 0x000168, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedStandToCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedStandToProne) == 0x00016C, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedStandToProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedCrouchToStand) == 0x000170, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedCrouchToStand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedCrouchToProne) == 0x000174, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedCrouchToProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedProneToStand) == 0x000178, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedProneToStand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OffsetAdjustmentSpeedProneToCrouch) == 0x00017C, "Member 'UCameraManagerComponent::OffsetAdjustmentSpeedProneToCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraShakeOnLand) == 0x000180, "Member 'UCameraManagerComponent::CameraShakeOnLand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OnPerspectivePreSwap) == 0x000190, "Member 'UCameraManagerComponent::OnPerspectivePreSwap' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OnPerspectivePostSwap) == 0x0001A0, "Member 'UCameraManagerComponent::OnPerspectivePostSwap' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, OnFirstPersonADSNotAllowed) == 0x0001B0, "Member 'UCameraManagerComponent::OnFirstPersonADSNotAllowed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FootIk) == 0x0001C0, "Member 'UCameraManagerComponent::FootIk' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, AdjustmentDecay) == 0x0001C8, "Member 'UCameraManagerComponent::AdjustmentDecay' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraHideDistance) == 0x0001CC, "Member 'UCameraManagerComponent::CameraHideDistance' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraShowDistance) == 0x0001D0, "Member 'UCameraManagerComponent::CameraShowDistance' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVUnarmed) == 0x0001D4, "Member 'UCameraManagerComponent::CameraFOVUnarmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVStandArmed) == 0x0001D8, "Member 'UCameraManagerComponent::CameraFOVStandArmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVStand3ADS) == 0x0001DC, "Member 'UCameraManagerComponent::CameraFOVStand3ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVCrouchArmed) == 0x0001E0, "Member 'UCameraManagerComponent::CameraFOVCrouchArmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVCrouch3ADS) == 0x0001E4, "Member 'UCameraManagerComponent::CameraFOVCrouch3ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVProneArmed) == 0x0001E8, "Member 'UCameraManagerComponent::CameraFOVProneArmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVProne3ADS) == 0x0001EC, "Member 'UCameraManagerComponent::CameraFOVProne3ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVSprinting) == 0x0001F0, "Member 'UCameraManagerComponent::CameraFOVSprinting' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PitchAdjustmentSpeed) == 0x0001F4, "Member 'UCameraManagerComponent::PitchAdjustmentSpeed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ProneYawRange) == 0x000208, "Member 'UCameraManagerComponent::ProneYawRange' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, DelayedADSAfterClimbOrVaultTime) == 0x00021C, "Member 'UCameraManagerComponent::DelayedADSAfterClimbOrVaultTime' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, InteractionDurationConsideredLong) == 0x000224, "Member 'UCameraManagerComponent::InteractionDurationConsideredLong' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HeadlockTimeStanceChange) == 0x000244, "Member 'UCameraManagerComponent::HeadlockTimeStanceChange' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HeadlockTimeVault) == 0x000248, "Member 'UCameraManagerComponent::HeadlockTimeVault' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HeadlockAdoptRate) == 0x00024C, "Member 'UCameraManagerComponent::HeadlockAdoptRate' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HeadlockZAdjustment) == 0x000250, "Member 'UCameraManagerComponent::HeadlockZAdjustment' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HeadlockZMaxWeight) == 0x000254, "Member 'UCameraManagerComponent::HeadlockZMaxWeight' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ParentCamera) == 0x000258, "Member 'UCameraManagerComponent::ParentCamera' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, TwoArmSetupRight) == 0x000268, "Member 'UCameraManagerComponent::TwoArmSetupRight' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, TwoArmSetupBack) == 0x000270, "Member 'UCameraManagerComponent::TwoArmSetupBack' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLengthUnarmed) == 0x000278, "Member 'UCameraManagerComponent::ArmLengthUnarmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLengthUnarmedBuilding) == 0x00027C, "Member 'UCameraManagerComponent::ArmLengthUnarmedBuilding' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLength) == 0x000280, "Member 'UCameraManagerComponent::ArmLength' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLengthADS) == 0x000284, "Member 'UCameraManagerComponent::ArmLengthADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLengthProne) == 0x00028C, "Member 'UCameraManagerComponent::ArmLengthProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmLength1ADSTime) == 0x000290, "Member 'UCameraManagerComponent::ArmLength1ADSTime' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, Arm1ADSTransitionParamEnter) == 0x0002A0, "Member 'UCameraManagerComponent::Arm1ADSTransitionParamEnter' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, Arm1ADSTransitionParamExit) == 0x0002B0, "Member 'UCameraManagerComponent::Arm1ADSTransitionParamExit' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmClimbVaultArmMultiplier) == 0x0002C0, "Member 'UCameraManagerComponent::ArmClimbVaultArmMultiplier' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, Arm1PBBlendSpeed) == 0x0002D0, "Member 'UCameraManagerComponent::Arm1PBBlendSpeed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, Arm1PBBlendExp) == 0x0002D4, "Member 'UCameraManagerComponent::Arm1PBBlendExp' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmRightRotation) == 0x0002DC, "Member 'UCameraManagerComponent::ArmRightRotation' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmBackRotation) == 0x0002E8, "Member 'UCameraManagerComponent::ArmBackRotation' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ArmCameraRotation) == 0x0002F4, "Member 'UCameraManagerComponent::ArmCameraRotation' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ShoulderSwapSpeedADS) == 0x000304, "Member 'UCameraManagerComponent::ShoulderSwapSpeedADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ShoulderSwapSpeedArmed) == 0x000308, "Member 'UCameraManagerComponent::ShoulderSwapSpeedArmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ShoulderSwapSpeedUnarmed) == 0x00030C, "Member 'UCameraManagerComponent::ShoulderSwapSpeedUnarmed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraOriginalMountingPoint) == 0x000328, "Member 'UCameraManagerComponent::CameraOriginalMountingPoint' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CurrentScope) == 0x000330, "Member 'UCameraManagerComponent::CurrentScope' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ThrowableShoulderOffsetMultiplier) == 0x000370, "Member 'UCameraManagerComponent::ThrowableShoulderOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, ThrowableVerticalOffsetAdditive) == 0x000374, "Member 'UCameraManagerComponent::ThrowableVerticalOffsetAdditive' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CamManager) == 0x000388, "Member 'UCameraManagerComponent::CamManager' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, HumanPlayerCharacter) == 0x000398, "Member 'UCameraManagerComponent::HumanPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecks3) == 0x0003B4, "Member 'UCameraManagerComponent::bDoPitchChecks3' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecks3ADS) == 0x0003B5, "Member 'UCameraManagerComponent::bDoPitchChecks3ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecks1ADS) == 0x0003B6, "Member 'UCameraManagerComponent::bDoPitchChecks1ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bEnforcePitchChecks3) == 0x0003B7, "Member 'UCameraManagerComponent::bEnforcePitchChecks3' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bEnforcePitchChecks3ADS) == 0x0003B8, "Member 'UCameraManagerComponent::bEnforcePitchChecks3ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bEnforcePitchChecks1ADS) == 0x0003B9, "Member 'UCameraManagerComponent::bEnforcePitchChecks1ADS' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecksStand) == 0x0003BA, "Member 'UCameraManagerComponent::bDoPitchChecksStand' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecksCrouch) == 0x0003BB, "Member 'UCameraManagerComponent::bDoPitchChecksCrouch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDoPitchChecksProne) == 0x0003BC, "Member 'UCameraManagerComponent::bDoPitchChecksProne' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MinPitchDeltaZMultiplier) == 0x0003C0, "Member 'UCameraManagerComponent::MinPitchDeltaZMultiplier' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MinPitchBias) == 0x0003C4, "Member 'UCameraManagerComponent::MinPitchBias' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PitchChecks) == 0x0003C8, "Member 'UCameraManagerComponent::PitchChecks' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, MaxRestrictedPitch) == 0x0003D8, "Member 'UCameraManagerComponent::MaxRestrictedPitch' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, bDrawDebugMinPitchChecks) == 0x0003DC, "Member 'UCameraManagerComponent::bDrawDebugMinPitchChecks' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, PronePitchAdjustmentCurve) == 0x0003E0, "Member 'UCameraManagerComponent::PronePitchAdjustmentCurve' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CrouchPitchAdjustment) == 0x0003E8, "Member 'UCameraManagerComponent::CrouchPitchAdjustment' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, StandingPitchAdjustment) == 0x0003EC, "Member 'UCameraManagerComponent::StandingPitchAdjustment' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, WaterSurfaceZLimit) == 0x0003F4, "Member 'UCameraManagerComponent::WaterSurfaceZLimit' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVMixSpeed) == 0x0003F8, "Member 'UCameraManagerComponent::CameraFOVMixSpeed' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVSettings) == 0x0003FC, "Member 'UCameraManagerComponent::CameraFOVSettings' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, CameraFOVSettings1P) == 0x000414, "Member 'UCameraManagerComponent::CameraFOVSettings1P' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FocusPointDecay) == 0x000448, "Member 'UCameraManagerComponent::FocusPointDecay' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FocusPointMultiplier) == 0x00044C, "Member 'UCameraManagerComponent::FocusPointMultiplier' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FocusPointStrength) == 0x000450, "Member 'UCameraManagerComponent::FocusPointStrength' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FocusPointIterations) == 0x000458, "Member 'UCameraManagerComponent::FocusPointIterations' has a wrong offset!");
static_assert(offsetof(UCameraManagerComponent, FocusPointRotationDeteriorate) == 0x00045C, "Member 'UCameraManagerComponent::FocusPointRotationDeteriorate' has a wrong offset!");

// Class Flame.WeaponCollisionData
// 0x0338 (0x0360 - 0x0028)
class UWeaponCollisionData : public UObject
{
public:
	struct FWeaponCollision                       Collision;                                         // 0x0028(0x0338)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponCollisionData">();
	}
	static class UWeaponCollisionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponCollisionData>();
	}
};
static_assert(alignof(UWeaponCollisionData) == 0x000008, "Wrong alignment on UWeaponCollisionData");
static_assert(sizeof(UWeaponCollisionData) == 0x000360, "Wrong size on UWeaponCollisionData");
static_assert(offsetof(UWeaponCollisionData, Collision) == 0x000028, "Member 'UWeaponCollisionData::Collision' has a wrong offset!");

// Class Flame.WeaponCollisionDatabase
// 0x0050 (0x0078 - 0x0028)
class UWeaponCollisionDatabase final : public UObject
{
public:
	TMap<class UClass*, struct FWeaponCollision>  Weapons;                                           // 0x0028(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponCollisionDatabase">();
	}
	static class UWeaponCollisionDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponCollisionDatabase>();
	}
};
static_assert(alignof(UWeaponCollisionDatabase) == 0x000008, "Wrong alignment on UWeaponCollisionDatabase");
static_assert(sizeof(UWeaponCollisionDatabase) == 0x000078, "Wrong size on UWeaponCollisionDatabase");
static_assert(offsetof(UWeaponCollisionDatabase, Weapons) == 0x000028, "Member 'UWeaponCollisionDatabase::Weapons' has a wrong offset!");

// Class Flame.ClothesHeadgearBottom
// 0x0000 (0x0410 - 0x0410)
class AClothesHeadgearBottom : public AClothesHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesHeadgearBottom">();
	}
	static class AClothesHeadgearBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesHeadgearBottom>();
	}
};
static_assert(alignof(AClothesHeadgearBottom) == 0x000008, "Wrong alignment on AClothesHeadgearBottom");
static_assert(sizeof(AClothesHeadgearBottom) == 0x000410, "Wrong size on AClothesHeadgearBottom");

// Class Flame.EditorRebuildDataStorage
// 0x0050 (0x0078 - 0x0028)
class UEditorRebuildDataStorage final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFloatProperty(class FName Identifier, float Value);

	bool GetFloatProperty(class FName Identifier, float* OutValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorRebuildDataStorage">();
	}
	static class UEditorRebuildDataStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorRebuildDataStorage>();
	}
};
static_assert(alignof(UEditorRebuildDataStorage) == 0x000008, "Wrong alignment on UEditorRebuildDataStorage");
static_assert(sizeof(UEditorRebuildDataStorage) == 0x000078, "Wrong size on UEditorRebuildDataStorage");

// Class Flame.CloudClassConverter
// 0x00B8 (0x00E0 - 0x0028)
class UCloudClassConverter final : public UObject
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FCloudConverterNameInfo> FromClassToName;                                   // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FCloudConverterClassInfo> FromNameToClass;                                   // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudClassConverter">();
	}
	static class UCloudClassConverter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudClassConverter>();
	}
};
static_assert(alignof(UCloudClassConverter) == 0x000008, "Wrong alignment on UCloudClassConverter");
static_assert(sizeof(UCloudClassConverter) == 0x0000E0, "Wrong size on UCloudClassConverter");
static_assert(offsetof(UCloudClassConverter, FromClassToName) == 0x000028, "Member 'UCloudClassConverter::FromClassToName' has a wrong offset!");
static_assert(offsetof(UCloudClassConverter, FromNameToClass) == 0x000078, "Member 'UCloudClassConverter::FromNameToClass' has a wrong offset!");

// Class Flame.CloudDataContainerBase
// 0x0008 (0x0030 - 0x0028)
class UCloudDataContainerBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataContainerBase">();
	}
	static class UCloudDataContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataContainerBase>();
	}
};
static_assert(alignof(UCloudDataContainerBase) == 0x000008, "Wrong alignment on UCloudDataContainerBase");
static_assert(sizeof(UCloudDataContainerBase) == 0x000030, "Wrong size on UCloudDataContainerBase");

// Class Flame.MenuWidget
// 0x0020 (0x02D8 - 0x02B8)
class UMenuWidget : public UFlameWidget
{
public:
	int32                                         HUDElementVisibility;                              // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CheckFPSEnabled;                                   // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FPSZorder;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysCreateNew;                                   // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableMouseOnDestruct;                            // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldLockMouse;                                   // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C7[0x11];                                     // 0x02C7(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnResetToDefaultState();

	uint8 GetHUDElementVisibility() const;
	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuWidget">();
	}
	static class UMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuWidget>();
	}
};
static_assert(alignof(UMenuWidget) == 0x000008, "Wrong alignment on UMenuWidget");
static_assert(sizeof(UMenuWidget) == 0x0002D8, "Wrong size on UMenuWidget");
static_assert(offsetof(UMenuWidget, HUDElementVisibility) == 0x0002B8, "Member 'UMenuWidget::HUDElementVisibility' has a wrong offset!");
static_assert(offsetof(UMenuWidget, CheckFPSEnabled) == 0x0002BC, "Member 'UMenuWidget::CheckFPSEnabled' has a wrong offset!");
static_assert(offsetof(UMenuWidget, FPSZorder) == 0x0002C0, "Member 'UMenuWidget::FPSZorder' has a wrong offset!");
static_assert(offsetof(UMenuWidget, AlwaysCreateNew) == 0x0002C4, "Member 'UMenuWidget::AlwaysCreateNew' has a wrong offset!");
static_assert(offsetof(UMenuWidget, DisableMouseOnDestruct) == 0x0002C5, "Member 'UMenuWidget::DisableMouseOnDestruct' has a wrong offset!");
static_assert(offsetof(UMenuWidget, ShouldLockMouse) == 0x0002C6, "Member 'UMenuWidget::ShouldLockMouse' has a wrong offset!");

// Class Flame.ModalWidget
// 0x0018 (0x02F0 - 0x02D8)
class UModalWidget : public UMenuWidget
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          SetMouseCursorToDefaultOnConstruct;                // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SetMouseCursorToDefaultOnDestruct;                 // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StopNavigation;                                    // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldRestoreFocusAfterDestruct;                   // 0x02EB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableSetFocusBack();
	void SetFocusToModalWidget();
	void UpdatePreviousWidgetFocusPath(class UWidget* InWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModalWidget">();
	}
	static class UModalWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModalWidget>();
	}
};
static_assert(alignof(UModalWidget) == 0x000008, "Wrong alignment on UModalWidget");
static_assert(sizeof(UModalWidget) == 0x0002F0, "Wrong size on UModalWidget");
static_assert(offsetof(UModalWidget, SetMouseCursorToDefaultOnConstruct) == 0x0002E8, "Member 'UModalWidget::SetMouseCursorToDefaultOnConstruct' has a wrong offset!");
static_assert(offsetof(UModalWidget, SetMouseCursorToDefaultOnDestruct) == 0x0002E9, "Member 'UModalWidget::SetMouseCursorToDefaultOnDestruct' has a wrong offset!");
static_assert(offsetof(UModalWidget, StopNavigation) == 0x0002EA, "Member 'UModalWidget::StopNavigation' has a wrong offset!");
static_assert(offsetof(UModalWidget, ShouldRestoreFocusAfterDestruct) == 0x0002EB, "Member 'UModalWidget::ShouldRestoreFocusAfterDestruct' has a wrong offset!");

// Class Flame.CloudDataContainerJsonItems
// 0x0050 (0x0080 - 0x0030)
class UCloudDataContainerJsonItems final : public UCloudDataContainerBase
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataContainerJsonItems">();
	}
	static class UCloudDataContainerJsonItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataContainerJsonItems>();
	}
};
static_assert(alignof(UCloudDataContainerJsonItems) == 0x000008, "Wrong alignment on UCloudDataContainerJsonItems");
static_assert(sizeof(UCloudDataContainerJsonItems) == 0x000080, "Wrong size on UCloudDataContainerJsonItems");

// Class Flame.CloudDataContainerPackedItems
// 0x0020 (0x0050 - 0x0030)
class UCloudDataContainerPackedItems final : public UCloudDataContainerBase
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataContainerPackedItems">();
	}
	static class UCloudDataContainerPackedItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataContainerPackedItems>();
	}
};
static_assert(alignof(UCloudDataContainerPackedItems) == 0x000008, "Wrong alignment on UCloudDataContainerPackedItems");
static_assert(sizeof(UCloudDataContainerPackedItems) == 0x000050, "Wrong size on UCloudDataContainerPackedItems");

// Class Flame.ExtendedFoliageStaticMeshComp
// 0x0010 (0x06D0 - 0x06C0)
class UExtendedFoliageStaticMeshComp : public UFoliageInstancedStaticMeshComponent
{
public:
	class FName                                   VolumeParameterName;                               // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PitchParameterName;                                // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetFoleySoundProperties(float DeltaTime, class AActor* Actor, bool bIsOverlapping, float PreviousVolume, float PreviousPitch, float* Volume, float* Pitch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedFoliageStaticMeshComp">();
	}
	static class UExtendedFoliageStaticMeshComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendedFoliageStaticMeshComp>();
	}
};
static_assert(alignof(UExtendedFoliageStaticMeshComp) == 0x000010, "Wrong alignment on UExtendedFoliageStaticMeshComp");
static_assert(sizeof(UExtendedFoliageStaticMeshComp) == 0x0006D0, "Wrong size on UExtendedFoliageStaticMeshComp");
static_assert(offsetof(UExtendedFoliageStaticMeshComp, VolumeParameterName) == 0x0006B8, "Member 'UExtendedFoliageStaticMeshComp::VolumeParameterName' has a wrong offset!");
static_assert(offsetof(UExtendedFoliageStaticMeshComp, PitchParameterName) == 0x0006C0, "Member 'UExtendedFoliageStaticMeshComp::PitchParameterName' has a wrong offset!");

// Class Flame.CloudDataDownloader
// 0x0010 (0x0038 - 0x0028)
class UCloudDataDownloader final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCloudDataContainerBase*                Container;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataDownloader">();
	}
	static class UCloudDataDownloader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataDownloader>();
	}
};
static_assert(alignof(UCloudDataDownloader) == 0x000008, "Wrong alignment on UCloudDataDownloader");
static_assert(sizeof(UCloudDataDownloader) == 0x000038, "Wrong size on UCloudDataDownloader");
static_assert(offsetof(UCloudDataDownloader, Container) == 0x000030, "Member 'UCloudDataDownloader::Container' has a wrong offset!");

// Class Flame.CloudDataStructureBase
// 0x0008 (0x0030 - 0x0028)
class UCloudDataStructureBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureBase">();
	}
	static class UCloudDataStructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureBase>();
	}
};
static_assert(alignof(UCloudDataStructureBase) == 0x000008, "Wrong alignment on UCloudDataStructureBase");
static_assert(sizeof(UCloudDataStructureBase) == 0x000030, "Wrong size on UCloudDataStructureBase");

// Class Flame.CurveGrenadeExplosionEffect
// 0x0400 (0x0430 - 0x0030)
class UCurveGrenadeExplosionEffect final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x8];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	float GetMaximumDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveGrenadeExplosionEffect">();
	}
	static class UCurveGrenadeExplosionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveGrenadeExplosionEffect>();
	}
};
static_assert(alignof(UCurveGrenadeExplosionEffect) == 0x000008, "Wrong alignment on UCurveGrenadeExplosionEffect");
static_assert(sizeof(UCurveGrenadeExplosionEffect) == 0x000430, "Wrong size on UCurveGrenadeExplosionEffect");
static_assert(offsetof(UCurveGrenadeExplosionEffect, FloatCurves) == 0x000030, "Member 'UCurveGrenadeExplosionEffect::FloatCurves' has a wrong offset!");

// Class Flame.CloudDataStructureConfiguration
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureConfiguration final : public UCloudDataStructureBase
{
public:
	struct FSettingsFromCloud                     Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureConfiguration">();
	}
	static class UCloudDataStructureConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureConfiguration>();
	}
};
static_assert(alignof(UCloudDataStructureConfiguration) == 0x000008, "Wrong alignment on UCloudDataStructureConfiguration");
static_assert(sizeof(UCloudDataStructureConfiguration) == 0x000040, "Wrong size on UCloudDataStructureConfiguration");
static_assert(offsetof(UCloudDataStructureConfiguration, Data) == 0x000030, "Member 'UCloudDataStructureConfiguration::Data' has a wrong offset!");

// Class Flame.WeaponsStorage
// 0x0060 (0x0088 - 0x0028)
class UWeaponsStorage : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AWeapon*>                        StoredWeapons;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_PostChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponsStorage">();
	}
	static class UWeaponsStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponsStorage>();
	}
};
static_assert(alignof(UWeaponsStorage) == 0x000008, "Wrong alignment on UWeaponsStorage");
static_assert(sizeof(UWeaponsStorage) == 0x000088, "Wrong size on UWeaponsStorage");
static_assert(offsetof(UWeaponsStorage, StoredWeapons) == 0x000078, "Member 'UWeaponsStorage::StoredWeapons' has a wrong offset!");

// Class Flame.WeaponsStorageShelter
// 0x0000 (0x0088 - 0x0088)
class UWeaponsStorageShelter final : public UWeaponsStorage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponsStorageShelter">();
	}
	static class UWeaponsStorageShelter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponsStorageShelter>();
	}
};
static_assert(alignof(UWeaponsStorageShelter) == 0x000008, "Wrong alignment on UWeaponsStorageShelter");
static_assert(sizeof(UWeaponsStorageShelter) == 0x000088, "Wrong size on UWeaponsStorageShelter");

// Class Flame.CloudDataStructureCustomizationDefaults
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureCustomizationDefaults final : public UCloudDataStructureBase
{
public:
	struct FCloudCustomizationDefaults            Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureCustomizationDefaults">();
	}
	static class UCloudDataStructureCustomizationDefaults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureCustomizationDefaults>();
	}
};
static_assert(alignof(UCloudDataStructureCustomizationDefaults) == 0x000008, "Wrong alignment on UCloudDataStructureCustomizationDefaults");
static_assert(sizeof(UCloudDataStructureCustomizationDefaults) == 0x000040, "Wrong size on UCloudDataStructureCustomizationDefaults");
static_assert(offsetof(UCloudDataStructureCustomizationDefaults, Data) == 0x000030, "Member 'UCloudDataStructureCustomizationDefaults::Data' has a wrong offset!");

// Class Flame.FlameSlot
// 0x0080 (0x0350 - 0x02D0)
class UFlameSlot : public USelectableWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCodeFocusBlocked;                               // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipNativeFocus;                                  // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFocused;                                        // 0x02E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresFocus;                                    // 0x02E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConfirmActionEnabled;                           // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameButton*                           InteractButton;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlotVisual*                            SlotVisual;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AItem*                                  HandleToGameItem;                                  // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFocusTriggerDelegate;                            // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnButtonClicked(class UButton* Sender);
	void OnButtonFocused(class UButton* Sender);
	void OnButtonUnfocused(class UButton* Sender);
	void OnItemChanged();
	void OnLobbyStateChanged();
	void OnTryFocusSlot();
	void SetItemDescriptor(const struct FInvetoryItemDescriptor& InDescriptor);
	void SetItemType(TSubclassOf<class AItem> ItemClass);
	void SetWeaponInstance(class AWeapon* Weapon);

	const struct FInvetoryItemDescriptor GetItemDescriptor() const;
	class AItem* GetItemObsolete() const;
	TSubclassOf<class AItem> GetItemType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameSlot">();
	}
	static class UFlameSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameSlot>();
	}
};
static_assert(alignof(UFlameSlot) == 0x000008, "Wrong alignment on UFlameSlot");
static_assert(sizeof(UFlameSlot) == 0x000350, "Wrong size on UFlameSlot");
static_assert(offsetof(UFlameSlot, bIsCodeFocusBlocked) == 0x0002E0, "Member 'UFlameSlot::bIsCodeFocusBlocked' has a wrong offset!");
static_assert(offsetof(UFlameSlot, bSkipNativeFocus) == 0x0002E1, "Member 'UFlameSlot::bSkipNativeFocus' has a wrong offset!");
static_assert(offsetof(UFlameSlot, bIsFocused) == 0x0002E2, "Member 'UFlameSlot::bIsFocused' has a wrong offset!");
static_assert(offsetof(UFlameSlot, bRequiresFocus) == 0x0002E3, "Member 'UFlameSlot::bRequiresFocus' has a wrong offset!");
static_assert(offsetof(UFlameSlot, bIsConfirmActionEnabled) == 0x0002E4, "Member 'UFlameSlot::bIsConfirmActionEnabled' has a wrong offset!");
static_assert(offsetof(UFlameSlot, InteractButton) == 0x0002E8, "Member 'UFlameSlot::InteractButton' has a wrong offset!");
static_assert(offsetof(UFlameSlot, SlotVisual) == 0x0002F0, "Member 'UFlameSlot::SlotVisual' has a wrong offset!");
static_assert(offsetof(UFlameSlot, OnClicked) == 0x0002F8, "Member 'UFlameSlot::OnClicked' has a wrong offset!");
static_assert(offsetof(UFlameSlot, HandleToGameItem) == 0x000308, "Member 'UFlameSlot::HandleToGameItem' has a wrong offset!");
static_assert(offsetof(UFlameSlot, OnFocusTriggerDelegate) == 0x000340, "Member 'UFlameSlot::OnFocusTriggerDelegate' has a wrong offset!");

// Class Flame.EquipmentSlot
// 0x0018 (0x0368 - 0x0350)
class UEquipmentSlot : public UFlameSlot
{
public:
	int32                                         Count;                                             // 0x0350(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MetaData;                                          // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECursorMode                                   HoverState;                                        // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECursorMode                                   DisabledState;                                     // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovable;                                       // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoverByBlueprint;                                // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleBackground;                                 // 0x0364(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSlotIcon();

	int32 GetCount() const;
	int32 GetSlotLimitation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSlot">();
	}
	static class UEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSlot>();
	}
};
static_assert(alignof(UEquipmentSlot) == 0x000008, "Wrong alignment on UEquipmentSlot");
static_assert(sizeof(UEquipmentSlot) == 0x000368, "Wrong size on UEquipmentSlot");
static_assert(offsetof(UEquipmentSlot, Count) == 0x000350, "Member 'UEquipmentSlot::Count' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, MetaData) == 0x000354, "Member 'UEquipmentSlot::MetaData' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, HoverState) == 0x000360, "Member 'UEquipmentSlot::HoverState' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, DisabledState) == 0x000361, "Member 'UEquipmentSlot::DisabledState' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, IsRemovable) == 0x000362, "Member 'UEquipmentSlot::IsRemovable' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, IsHoverByBlueprint) == 0x000363, "Member 'UEquipmentSlot::IsHoverByBlueprint' has a wrong offset!");
static_assert(offsetof(UEquipmentSlot, bSimpleBackground) == 0x000364, "Member 'UEquipmentSlot::bSimpleBackground' has a wrong offset!");

// Class Flame.CloudDataStructureImprovementClasses
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureImprovementClasses final : public UCloudDataStructureBase
{
public:
	struct FCloudDataImprovementClassList         Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureImprovementClasses">();
	}
	static class UCloudDataStructureImprovementClasses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureImprovementClasses>();
	}
};
static_assert(alignof(UCloudDataStructureImprovementClasses) == 0x000008, "Wrong alignment on UCloudDataStructureImprovementClasses");
static_assert(sizeof(UCloudDataStructureImprovementClasses) == 0x000040, "Wrong size on UCloudDataStructureImprovementClasses");
static_assert(offsetof(UCloudDataStructureImprovementClasses, Data) == 0x000030, "Member 'UCloudDataStructureImprovementClasses::Data' has a wrong offset!");

// Class Flame.CloudDataStructureImprovementLevels
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureImprovementLevels final : public UCloudDataStructureBase
{
public:
	struct FCloudDataImprovementLevelList         Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureImprovementLevels">();
	}
	static class UCloudDataStructureImprovementLevels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureImprovementLevels>();
	}
};
static_assert(alignof(UCloudDataStructureImprovementLevels) == 0x000008, "Wrong alignment on UCloudDataStructureImprovementLevels");
static_assert(sizeof(UCloudDataStructureImprovementLevels) == 0x000040, "Wrong size on UCloudDataStructureImprovementLevels");
static_assert(offsetof(UCloudDataStructureImprovementLevels, Data) == 0x000030, "Member 'UCloudDataStructureImprovementLevels::Data' has a wrong offset!");

// Class Flame.CloudDataStructureImprovementSlots
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureImprovementSlots final : public UCloudDataStructureBase
{
public:
	struct FCloudDataImprovementSlotList          Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureImprovementSlots">();
	}
	static class UCloudDataStructureImprovementSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureImprovementSlots>();
	}
};
static_assert(alignof(UCloudDataStructureImprovementSlots) == 0x000008, "Wrong alignment on UCloudDataStructureImprovementSlots");
static_assert(sizeof(UCloudDataStructureImprovementSlots) == 0x000040, "Wrong size on UCloudDataStructureImprovementSlots");
static_assert(offsetof(UCloudDataStructureImprovementSlots, Data) == 0x000030, "Member 'UCloudDataStructureImprovementSlots::Data' has a wrong offset!");

// Class Flame.CloudDataStructureImprovementsPerLevel
// 0x0010 (0x0040 - 0x0030)
class UCloudDataStructureImprovementsPerLevel final : public UCloudDataStructureBase
{
public:
	struct FCloudDataImprovementPerLevelList      Data;                                              // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructureImprovementsPerLevel">();
	}
	static class UCloudDataStructureImprovementsPerLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructureImprovementsPerLevel>();
	}
};
static_assert(alignof(UCloudDataStructureImprovementsPerLevel) == 0x000008, "Wrong alignment on UCloudDataStructureImprovementsPerLevel");
static_assert(sizeof(UCloudDataStructureImprovementsPerLevel) == 0x000040, "Wrong size on UCloudDataStructureImprovementsPerLevel");
static_assert(offsetof(UCloudDataStructureImprovementsPerLevel, Data) == 0x000030, "Member 'UCloudDataStructureImprovementsPerLevel::Data' has a wrong offset!");

// Class Flame.FlameAnalyticsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFlameAnalyticsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool LoadAnalytics(class FString* File, class FString* DocumentText, EAnalyticsFileType FileType);
	static bool SaveAnalytics(const class FString& File, const class FString& Text, EAnalyticsFileType FileType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAnalyticsFunctionLibrary">();
	}
	static class UFlameAnalyticsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameAnalyticsFunctionLibrary>();
	}
};
static_assert(alignof(UFlameAnalyticsFunctionLibrary) == 0x000008, "Wrong alignment on UFlameAnalyticsFunctionLibrary");
static_assert(sizeof(UFlameAnalyticsFunctionLibrary) == 0x000028, "Wrong size on UFlameAnalyticsFunctionLibrary");

// Class Flame.CloudDataStructures
// 0x0068 (0x0090 - 0x0028)
class UCloudDataStructures final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECloudStructureTypes, class UCloudDataStructureBase*> Structures;                                        // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UCloudDataStructureBase* DataProviderGetStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject);
	static bool DataProviderLoadAllStructures(bool SkipManualLoad, const class UObject* WorldContextObject);
	static bool DataProviderLoadStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject);
	static bool DataProviderUnLoadAllStructures(bool IncludeNonManual, const class UObject* WorldContextObject);
	static bool DataProviderUnLoadStructure(ECloudStructureTypes StructureType, const class UObject* WorldContextObject);

	class UCloudDataStructureBase* GetStructure(ECloudStructureTypes StructureType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataStructures">();
	}
	static class UCloudDataStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataStructures>();
	}
};
static_assert(alignof(UCloudDataStructures) == 0x000008, "Wrong alignment on UCloudDataStructures");
static_assert(sizeof(UCloudDataStructures) == 0x000090, "Wrong size on UCloudDataStructures");
static_assert(offsetof(UCloudDataStructures, Structures) == 0x000040, "Member 'UCloudDataStructures::Structures' has a wrong offset!");

// Class Flame.CloudDataTables
// 0x0050 (0x0078 - 0x0028)
class UCloudDataTables final : public UObject
{
public:
	TArray<class UDataTableContainerBase*>        DataTableContainers;                               // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDataTable* DataProviderFindTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject);
	static class UDataTable* DataProviderFindTableByName(class FName TableName, const class UObject* WorldContextObject);
	static EDataProviderTableState DataProviderGetTableState(class FName TableName, const class UObject* WorldContextObject);
	static bool DataProviderLoadDataTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject);
	static bool DataProviderLoadDataTableByName(class FName TableName, const class UObject* WorldContextObject);
	static bool DataProviderUnLoadDataTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable, const class UObject* WorldContextObject);
	static bool DataProviderUnLoadDataTableByName(class FName TableName, const class UObject* WorldContextObject);

	class UDataTable* FindTableByAssetTable(const TSoftObjectPtr<class UDataTable> AssetTable) const;
	class UDataTable* FindTableByName(class FName TableName) const;
	EDataProviderTableState GetDataTableState(class FName TableName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataTables">();
	}
	static class UCloudDataTables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataTables>();
	}
};
static_assert(alignof(UCloudDataTables) == 0x000008, "Wrong alignment on UCloudDataTables");
static_assert(sizeof(UCloudDataTables) == 0x000078, "Wrong size on UCloudDataTables");
static_assert(offsetof(UCloudDataTables, DataTableContainers) == 0x000028, "Member 'UCloudDataTables::DataTableContainers' has a wrong offset!");

// Class Flame.CloudGlobalFunctions
// 0x0028 (0x0050 - 0x0028)
class UCloudGlobalFunctions final : public UObject
{
public:
	TWeakObjectPtr<class UCloudSystem>            CloudSystem;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             MapsCloudInfoReceived;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetMapsCloudInfo();
	void GetMapsCloudInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const TArray<struct FMapInfoCloud>& MapsInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudGlobalFunctions">();
	}
	static class UCloudGlobalFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudGlobalFunctions>();
	}
};
static_assert(alignof(UCloudGlobalFunctions) == 0x000008, "Wrong alignment on UCloudGlobalFunctions");
static_assert(sizeof(UCloudGlobalFunctions) == 0x000050, "Wrong size on UCloudGlobalFunctions");
static_assert(offsetof(UCloudGlobalFunctions, CloudSystem) == 0x000028, "Member 'UCloudGlobalFunctions::CloudSystem' has a wrong offset!");
static_assert(offsetof(UCloudGlobalFunctions, MapsCloudInfoReceived) == 0x000040, "Member 'UCloudGlobalFunctions::MapsCloudInfoReceived' has a wrong offset!");

// Class Flame.CloudInitScreen
// 0x0018 (0x02D0 - 0x02B8)
class UCloudInitScreen final : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudInitScreen">();
	}
	static class UCloudInitScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudInitScreen>();
	}
};
static_assert(alignof(UCloudInitScreen) == 0x000008, "Wrong alignment on UCloudInitScreen");
static_assert(sizeof(UCloudInitScreen) == 0x0002D0, "Wrong size on UCloudInitScreen");

// Class Flame.CloudNotificationSystem
// 0x0018 (0x0040 - 0x0028)
class UCloudNotificationSystem : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             NotificationTextTable;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BlueprintDeInit();
	void BlueprintInit();
	class UFlameGameInstance* GetGameInstance();
	void ProcessCloudNotification(const class FString& Userid, const struct FCloudNotificationMessageEvent& NotificationMessageEvent);
	void ShowCloudNotification(const class FString& Userid, const struct FCloudNotificationMessageEvent& NotificationMessageEvent);
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudNotificationSystem">();
	}
	static class UCloudNotificationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudNotificationSystem>();
	}
};
static_assert(alignof(UCloudNotificationSystem) == 0x000008, "Wrong alignment on UCloudNotificationSystem");
static_assert(sizeof(UCloudNotificationSystem) == 0x000040, "Wrong size on UCloudNotificationSystem");
static_assert(offsetof(UCloudNotificationSystem, NotificationTextTable) == 0x000038, "Member 'UCloudNotificationSystem::NotificationTextTable' has a wrong offset!");

// Class Flame.CloudRawDataUtils
// 0x0000 (0x0028 - 0x0028)
class UCloudRawDataUtils final : public UObject
{
public:
	static class UJsonObject* GetDataAsJsonObject(const struct FCloudRawDataInfo& Info);
	static class UJsonValue* GetDataAsJsonValue(const struct FCloudRawDataInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudRawDataUtils">();
	}
	static class UCloudRawDataUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudRawDataUtils>();
	}
};
static_assert(alignof(UCloudRawDataUtils) == 0x000008, "Wrong alignment on UCloudRawDataUtils");
static_assert(sizeof(UCloudRawDataUtils) == 0x000028, "Wrong size on UCloudRawDataUtils");

// Class Flame.CloudSystem
// 0x00F8 (0x0120 - 0x0028)
class UCloudSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UCloudGlobalFunctions*                  GlobalFunctions;                                   // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x70];                                      // 0x0098(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStatusChanged;                                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimespan                              CloudTimeDifference;                               // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class FString GetCloudEnvironment(const class UObject* WorldContextObject);
	static class UCloudGlobalFunctions* GetCloudFunctions(const class UObject* WorldContextObject);
	static struct FDateTime GetCloudTime(const class UObject* WorldContextObject);
	static class FString GetCloudVersion(const class UObject* WorldContextObject);
	static class FString GetUserAnalyticsId(const class UObject* WorldContextObject);
	static class FString GetUserCloudId(const class UObject* WorldContextObject);
	static int32 InvalidCloudRequest(const class UObject* WorldContextObject);
	static bool RequestLogoutFromCloud(const class FText& DisconnectMessage, const class UObject* WorldContextObject);
	static bool SendLogToCloud(ECloudLogSeverity Severity, const class FString& LogCategory, const class FString& Message, class UJsonObject* Data, const class UObject* WorldContextObject);
	static bool SetCloudRequestResultLevel(int32 RequestId, ECloudRequestResultLevel NewLevel, const class UObject* WorldContextObject);

	void CloudSystemStatusChanged__DelegateSignature(ECloudManagerState OldState, ECloudManagerState NewState);

	class FString GetCloudUserName() const;
	ECloudManagerState GetState() const;
	struct FCloudManagerStateInfo GetStateInfo() const;
	class FString GetStateStringFieldFromJson(const class FString& FieldName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudSystem">();
	}
	static class UCloudSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudSystem>();
	}
};
static_assert(alignof(UCloudSystem) == 0x000008, "Wrong alignment on UCloudSystem");
static_assert(sizeof(UCloudSystem) == 0x000120, "Wrong size on UCloudSystem");
static_assert(offsetof(UCloudSystem, GlobalFunctions) == 0x000090, "Member 'UCloudSystem::GlobalFunctions' has a wrong offset!");
static_assert(offsetof(UCloudSystem, OnStatusChanged) == 0x000108, "Member 'UCloudSystem::OnStatusChanged' has a wrong offset!");
static_assert(offsetof(UCloudSystem, CloudTimeDifference) == 0x000118, "Member 'UCloudSystem::CloudTimeDifference' has a wrong offset!");

// Class Flame.CloudSystemSettings
// 0x0A60 (0x0A98 - 0x0038)
class UCloudSystemSettings final : public UDeveloperSettings
{
public:
	struct FCloudRequestAcceptSettings            RequestAcceptSettings;                             // 0x0038(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudUserInfoSettings                 UserInfoSettings;                                  // 0x0058(0x0060)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudMatchSettings                    MatchSettings;                                     // 0x00B8(0x0120)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudInventorySettings                InventorySettings;                                 // 0x01D8(0x0180)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudCustomizationSettings            CustomizationSettings;                             // 0x0358(0x00B0)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudLootBoxesSettings                LootBoxesSettings;                                 // 0x0408(0x0030)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudCraftingSettings                 CraftingSettings;                                  // 0x0438(0x0070)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudShelterSettings                  ShelterSettings;                                   // 0x04A8(0x0070)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudDataStructuresSettings           DataStructuresSettings;                            // 0x0518(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudMarketplaceSettings              MarketplaceSettings;                               // 0x0568(0x0040)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudPlatformStoreSettings            PlatformStoreSettings;                             // 0x05A8(0x00D0)(Edit, Config, NativeAccessSpecifierPublic)
	struct FGameStoreSettings                     GameStoreSettings;                                 // 0x0678(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudUserCountersSettings             UserCountersSettings;                              // 0x06C8(0x0040)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudChallengesSettings               ChallengesSettings;                                // 0x0708(0x0090)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudUserStatsSettings                UserStatsSettings;                                 // 0x0798(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudCharityBoxSettings               CharityBoxSettings;                                // 0x07E8(0x0040)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudUserWipeRewardsSettings          UserWipeRewardsSettings;                           // 0x0828(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudMapRewardsSettings               MapRewardsSettings;                                // 0x0838(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudOnboardingLoginRewardsSettings   OnboardingLoginRewardsSettings;                    // 0x0848(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudWeaponCustomizationsSettings     WeaponCustomizationsSettings;                      // 0x0868(0x0090)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudHeartBeatSettings                HeartBeatSettings;                                 // 0x08F8(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudBattlePassSettings               BattlePassSettings;                                // 0x0908(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudRawDataSettings                  RawDataSettings;                                   // 0x0958(0x00C0)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudStatusSettings                   StatusSettings;                                    // 0x0A18(0x0040)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudMapsSettings                     MapsSettings;                                      // 0x0A58(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudNewsSettings                     NewsSettings;                                      // 0x0A78(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudBoostersSettings                 BoostersSettings;                                  // 0x0A88(0x0010)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudSystemSettings">();
	}
	static class UCloudSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudSystemSettings>();
	}
};
static_assert(alignof(UCloudSystemSettings) == 0x000008, "Wrong alignment on UCloudSystemSettings");
static_assert(sizeof(UCloudSystemSettings) == 0x000A98, "Wrong size on UCloudSystemSettings");
static_assert(offsetof(UCloudSystemSettings, RequestAcceptSettings) == 0x000038, "Member 'UCloudSystemSettings::RequestAcceptSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, UserInfoSettings) == 0x000058, "Member 'UCloudSystemSettings::UserInfoSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, MatchSettings) == 0x0000B8, "Member 'UCloudSystemSettings::MatchSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, InventorySettings) == 0x0001D8, "Member 'UCloudSystemSettings::InventorySettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, CustomizationSettings) == 0x000358, "Member 'UCloudSystemSettings::CustomizationSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, LootBoxesSettings) == 0x000408, "Member 'UCloudSystemSettings::LootBoxesSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, CraftingSettings) == 0x000438, "Member 'UCloudSystemSettings::CraftingSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, ShelterSettings) == 0x0004A8, "Member 'UCloudSystemSettings::ShelterSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, DataStructuresSettings) == 0x000518, "Member 'UCloudSystemSettings::DataStructuresSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, MarketplaceSettings) == 0x000568, "Member 'UCloudSystemSettings::MarketplaceSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, PlatformStoreSettings) == 0x0005A8, "Member 'UCloudSystemSettings::PlatformStoreSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, GameStoreSettings) == 0x000678, "Member 'UCloudSystemSettings::GameStoreSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, UserCountersSettings) == 0x0006C8, "Member 'UCloudSystemSettings::UserCountersSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, ChallengesSettings) == 0x000708, "Member 'UCloudSystemSettings::ChallengesSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, UserStatsSettings) == 0x000798, "Member 'UCloudSystemSettings::UserStatsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, CharityBoxSettings) == 0x0007E8, "Member 'UCloudSystemSettings::CharityBoxSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, UserWipeRewardsSettings) == 0x000828, "Member 'UCloudSystemSettings::UserWipeRewardsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, MapRewardsSettings) == 0x000838, "Member 'UCloudSystemSettings::MapRewardsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, OnboardingLoginRewardsSettings) == 0x000848, "Member 'UCloudSystemSettings::OnboardingLoginRewardsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, WeaponCustomizationsSettings) == 0x000868, "Member 'UCloudSystemSettings::WeaponCustomizationsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, HeartBeatSettings) == 0x0008F8, "Member 'UCloudSystemSettings::HeartBeatSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, BattlePassSettings) == 0x000908, "Member 'UCloudSystemSettings::BattlePassSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, RawDataSettings) == 0x000958, "Member 'UCloudSystemSettings::RawDataSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, StatusSettings) == 0x000A18, "Member 'UCloudSystemSettings::StatusSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, MapsSettings) == 0x000A58, "Member 'UCloudSystemSettings::MapsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, NewsSettings) == 0x000A78, "Member 'UCloudSystemSettings::NewsSettings' has a wrong offset!");
static_assert(offsetof(UCloudSystemSettings, BoostersSettings) == 0x000A88, "Member 'UCloudSystemSettings::BoostersSettings' has a wrong offset!");

// Class Flame.CommoditySpawnManager
// 0x0090 (0x02B0 - 0x0220)
class ACommoditySpawnManager : public AInfo
{
public:
	TSubclassOf<class AActor>                     Group;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AGameModeBase>>      AcceptedGameModes;                                 // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FInt32Interval                         SubObjectsLimit;                                   // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNewDistributionForRemainingCommodities;        // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDepthFirstLootDistributionPerCapacity;            // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableDebugLog;                                   // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManagerCommodityDescriptor>    Commodities;                                       // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	ECommodityManagerSpawnType                    ManagerSpawnType;                                  // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCommoditiesSpawned;                              // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x30];                                     // 0x0270(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     IncompleteDataSceneMarker;                         // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     IncompleteDataInventoryItem;                       // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddCommodity(TSubclassOf<class AActor> Commodity, int32 MinCapacity, int32 MaxCapacity, float MinPriority, float MaxPriority, float SpawnProbability, ECommodityManagerDistributionAlgorithm DistributionAlgorithm);
	int32 ClearCommodities();
	void CommoditiesSpawned__DelegateSignature(bool Result);
	bool RemoveCommodity(int32 CommodityIndex);
	bool SetCommodityCapacity(int32 CommodityIndex, int32 MinCapacity, int32 MaxCapacity);
	bool SetCommodityCapacityMaximum(int32 CommodityIndex, int32 MaxCapacity);
	bool SetCommodityCapacityMinimum(int32 CommodityIndex, int32 MinCapacity);
	bool SetCommodityPriority(int32 CommodityIndex, float MinPriority, float MaxPriority);
	bool SetCommodityPriorityMaximum(int32 CommodityIndex, float MaxPriority);
	bool SetCommodityPriorityMinimum(int32 CommodityIndex, float MinPriority);
	void SpawnCommodities(const TArray<struct FManagerCommodityDescriptor>& InCommodities, bool IncompleteData);

	int32 GetCommodityCapacityMaximum(int32 CommodityIndex) const;
	int32 GetCommodityCapacityMinimum(int32 CommodityIndex) const;
	bool GetCommodityPriorityMaximum(int32 CommodityIndex, float* Value) const;
	bool GetCommodityPriorityMinimum(int32 CommodityIndex, float* Value) const;
	void OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, float SpawnProbabilityIn, int32 CapacityMinIn, int32 CapacityMaxIn, int32 SubObjectsLimitMinIn, int32 SubObjectsLimitMaxIn, float* SpawnProbabilityOut, int32* CapacityMinOut, int32* CapacityMaxOut, int32* SubObjectsLimitMinOut, int32* SubObjectsLimitMaxOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommoditySpawnManager">();
	}
	static class ACommoditySpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommoditySpawnManager>();
	}
};
static_assert(alignof(ACommoditySpawnManager) == 0x000008, "Wrong alignment on ACommoditySpawnManager");
static_assert(sizeof(ACommoditySpawnManager) == 0x0002B0, "Wrong size on ACommoditySpawnManager");
static_assert(offsetof(ACommoditySpawnManager, Group) == 0x000220, "Member 'ACommoditySpawnManager::Group' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, AcceptedGameModes) == 0x000228, "Member 'ACommoditySpawnManager::AcceptedGameModes' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, SubObjectsLimit) == 0x000238, "Member 'ACommoditySpawnManager::SubObjectsLimit' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, bUseNewDistributionForRemainingCommodities) == 0x000240, "Member 'ACommoditySpawnManager::bUseNewDistributionForRemainingCommodities' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, bDepthFirstLootDistributionPerCapacity) == 0x000241, "Member 'ACommoditySpawnManager::bDepthFirstLootDistributionPerCapacity' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, bEnableDebugLog) == 0x000242, "Member 'ACommoditySpawnManager::bEnableDebugLog' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, Commodities) == 0x000248, "Member 'ACommoditySpawnManager::Commodities' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, ManagerSpawnType) == 0x000258, "Member 'ACommoditySpawnManager::ManagerSpawnType' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, OnCommoditiesSpawned) == 0x000260, "Member 'ACommoditySpawnManager::OnCommoditiesSpawned' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, IncompleteDataSceneMarker) == 0x0002A0, "Member 'ACommoditySpawnManager::IncompleteDataSceneMarker' has a wrong offset!");
static_assert(offsetof(ACommoditySpawnManager, IncompleteDataInventoryItem) == 0x0002A8, "Member 'ACommoditySpawnManager::IncompleteDataInventoryItem' has a wrong offset!");

// Class Flame.CommoditySpawnNode
// 0x0050 (0x0250 - 0x0200)
class UCommoditySpawnNode : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     Group;                                             // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             GroupList;                                         // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AGameModeBase>>      AcceptedGameModes;                                 // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FInt32Interval                         SubObjectsLimit;                                   // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCommodityDescriptorNode>       Commodities;                                       // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ParentIdentifier;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, int32 CapacityMinIn, int32 CapacityMaxIn, int32 SubObjectsLimitMinIn, int32 SubObjectsLimitMaxIn, int32* CapacityMinOut, int32* CapacityMaxOut, int32* SubObjectsLimitMinOut, int32* SubObjectsLimitMaxOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommoditySpawnNode">();
	}
	static class UCommoditySpawnNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommoditySpawnNode>();
	}
};
static_assert(alignof(UCommoditySpawnNode) == 0x000010, "Wrong alignment on UCommoditySpawnNode");
static_assert(sizeof(UCommoditySpawnNode) == 0x000250, "Wrong size on UCommoditySpawnNode");
static_assert(offsetof(UCommoditySpawnNode, Group) == 0x0001F8, "Member 'UCommoditySpawnNode::Group' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, GroupList) == 0x000200, "Member 'UCommoditySpawnNode::GroupList' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, AcceptedGameModes) == 0x000210, "Member 'UCommoditySpawnNode::AcceptedGameModes' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, SubObjectsLimit) == 0x000220, "Member 'UCommoditySpawnNode::SubObjectsLimit' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, Commodities) == 0x000228, "Member 'UCommoditySpawnNode::Commodities' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, ParentIdentifier) == 0x000238, "Member 'UCommoditySpawnNode::ParentIdentifier' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnNode, Identifier) == 0x000240, "Member 'UCommoditySpawnNode::Identifier' has a wrong offset!");

// Class Flame.FlameAssetManager
// 0x0150 (0x0178 - 0x0028)
class UFlameAssetManager final : public UObject
{
public:
	float                                         ObjectsTTL;                                        // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenShutdown;                                  // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, float>                   Objects;                                           // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0xF8];                                      // 0x0080(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftClassPtr<class UClass> GetSoftClassReference(TSoftClassPtr<class UClass> Reference);
	static TSoftObjectPtr<class UObject> GetSoftReference(TSoftObjectPtr<class UObject> Reference);
	static class UClass* LoadSoftClassReference(TSoftClassPtr<class UClass> Reference);
	static class UObject* LoadSoftReference(TSoftObjectPtr<class UObject> Reference);

	class UObject* LoadAndTrackSoftClassReference(const TSoftClassPtr<class UClass>& AssetToLoad);
	class UObject* LoadAndTrackSoftReference(const TSoftObjectPtr<class UObject>& AssetToLoad);
	void StreamAsset(TSoftObjectPtr<class UObject> AssetToStream, const TDelegate<void()>& OnAssetLoaded);
	void StreamAssets(const TArray<TSoftObjectPtr<class UObject>>& AssetsToStream, const TDelegate<void()>& OnAssetLoaded);
	void TrackObject(class UObject* Obj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAssetManager">();
	}
	static class UFlameAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameAssetManager>();
	}
};
static_assert(alignof(UFlameAssetManager) == 0x000008, "Wrong alignment on UFlameAssetManager");
static_assert(sizeof(UFlameAssetManager) == 0x000178, "Wrong size on UFlameAssetManager");
static_assert(offsetof(UFlameAssetManager, ObjectsTTL) == 0x000028, "Member 'UFlameAssetManager::ObjectsTTL' has a wrong offset!");
static_assert(offsetof(UFlameAssetManager, bHasBeenShutdown) == 0x00002C, "Member 'UFlameAssetManager::bHasBeenShutdown' has a wrong offset!");
static_assert(offsetof(UFlameAssetManager, Objects) == 0x000030, "Member 'UFlameAssetManager::Objects' has a wrong offset!");

// Class Flame.CommoditySpawnPoint
// 0x00A0 (0x02A0 - 0x0200)
class UCommoditySpawnPoint : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     Group;                                             // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             GroupList;                                         // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AGameModeBase>>      AcceptedGameModes;                                 // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCommodityDescriptorPoint>      Commodities;                                       // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AActor>, struct FAllCommoditiesOfType> CommoditiesPerType;                                // 0x0230(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             SpawnDescriptors;                                  // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   ParentIdentifier;                                  // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddCommodity(TSubclassOf<class AActor> Commodity, int32 MinCapacity, int32 MaxCapacity, float MinPriority, float MaxPriority);
	int32 ClearCommodities();
	bool RemoveCommodity(int32 CommodityIndex);
	bool SetCommodityCapacity(int32 CommodityIndex, int32 MinCapacity, int32 MaxCapacity);
	bool SetCommodityCapacityMaximum(int32 CommodityIndex, int32 MaxCapacity);
	bool SetCommodityCapacityMinimum(int32 CommodityIndex, int32 MinCapacity);
	void SetCommodityMapFromArray();
	bool SetCommodityPriority(int32 CommodityIndex, float MinPriority, float MaxPriority);
	bool SetCommodityPriorityMaximum(int32 CommodityIndex, float MaxPriority);
	bool SetCommodityPriorityMinimum(int32 CommodityIndex, float MinPriority);

	int32 GetCommodityCapacityMaximum(int32 CommodityIndex) const;
	int32 GetCommodityCapacityMinimum(int32 CommodityIndex) const;
	bool GetCommodityPriorityMaximum(int32 CommodityIndex, float* Value) const;
	bool GetCommodityPriorityMinimum(int32 CommodityIndex, float* Value) const;
	void OnCommodityParamsModify(TSubclassOf<class AActor> CommodityType, int32 CapacityMinIn, int32 CapacityMaxIn, int32* CapacityMinOut, int32* CapacityMaxOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommoditySpawnPoint">();
	}
	static class UCommoditySpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommoditySpawnPoint>();
	}
};
static_assert(alignof(UCommoditySpawnPoint) == 0x000010, "Wrong alignment on UCommoditySpawnPoint");
static_assert(sizeof(UCommoditySpawnPoint) == 0x0002A0, "Wrong size on UCommoditySpawnPoint");
static_assert(offsetof(UCommoditySpawnPoint, Group) == 0x0001F8, "Member 'UCommoditySpawnPoint::Group' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, GroupList) == 0x000200, "Member 'UCommoditySpawnPoint::GroupList' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, AcceptedGameModes) == 0x000210, "Member 'UCommoditySpawnPoint::AcceptedGameModes' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, Commodities) == 0x000220, "Member 'UCommoditySpawnPoint::Commodities' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, CommoditiesPerType) == 0x000230, "Member 'UCommoditySpawnPoint::CommoditiesPerType' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, SpawnDescriptors) == 0x000280, "Member 'UCommoditySpawnPoint::SpawnDescriptors' has a wrong offset!");
static_assert(offsetof(UCommoditySpawnPoint, ParentIdentifier) == 0x000290, "Member 'UCommoditySpawnPoint::ParentIdentifier' has a wrong offset!");

// Class Flame.CommonFunctions
// 0x0000 (0x0028 - 0x0028)
class UCommonFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void AddComponentToActor(TSubclassOf<class UActorComponent> ComponentClass, class AActor* Actor, class UActorComponent** OutNewComponent);
	static void AddViewSlaveLocation(const struct FVector& SlaveLocation);
	static void AddViewSlaveLocationForDuration(const struct FVector& SlaveLocation, const float Duration);
	static void CaptureSceneDeferred(class USceneCaptureComponent2D* CaptureComponent);
	static float CubicInterpolation(float Start, float StartTangent, float End, float EndTangent, float A);
	static void EnableMainViewRendering(class APlayerController* Controller, bool bEnabled);
	static void EstimateSceneRenderTargetsSize(class UObject* WorldContextObject, int32* OutSizeX, int32* OutSizeY);
	static void FindComponentBySocketName(const class AActor* Actor, class FName SocketName, TSubclassOf<class USceneComponent> ComponentClass, class USceneComponent** OutComponentWithSocket);
	static struct FVector2D GetActiveTopLevelWindowPositionOnScreen();
	static TArray<TSubclassOf<class AActor>> GetAllUsedChildClassTypes(const class UObject* WorldContextObject, TSubclassOf<class AActor> ParentActorClass);
	static class FString GetBuildConfiguration();
	static class FString GetBuildVersion();
	static class UObject* GetClassDefaultObject(class UClass* Class_0);
	static class FName GetClassDisplayName(const class UObject* Item);
	static float GetCurveValue(class UCurveFloat* Curve, float InValue);
	static int32 GetFrameNumber();
	static float GetLastRenderTime(class UPrimitiveComponent* Component);
	static float GetLastRenderTimeOnScreen(class UPrimitiveComponent* Component);
	static struct FVector2D GetMainWindowPositionOnScreen(class UObject* WorldContextObject);
	static int32 GetNumStreamingTexturesForPrimitive(class UPrimitiveComponent* PrimitiveComponent);
	static float GetRelativeDistanceFromBox(const struct FVector& PointToTest, const struct FVector& BoxExtent, bool bClamped);
	static float GetRelativeDistanceFromCapsule(const struct FVector& PointToTest, float HalfHeight, float Radius, bool bClamped);
	static float GetRelativeDistanceFromSphere(const struct FVector& PointToTest, float Radius, bool bClamped);
	static void GetSceneCaptureShowOnlyComponents(class USceneCaptureComponent2D* CaptureComponent, TArray<class UPrimitiveComponent*>* ShowOnlyComponents);
	static void GetWorldLightingScenarioNames(const class UObject* WorldContextObject, TArray<class FString>* OutNames);
	static float GetWorldTimeInSec(const class UObject* WorldContextObject);
	static bool IsEditor();
	static bool IsShipping();
	static bool IsStreamingTextureForPrimitive(class UPrimitiveComponent* PrimitiveComponent);
	static bool IsStreamingTextureForPrimitives(const TArray<class UPrimitiveComponent*>& PrimitiveComponents);
	static bool IsWorldDetailDropped(const class UObject* WorldContextObject);
	static class USaveGame* LoadSaveGame(const class FString& SaveGameName, int32 UserIdx, TSubclassOf<class USaveGame> SaveGameClass);
	static struct FVector RandomPointInCapsule(float HalfHeight, float Radius);
	static void SetComponentNetAddressable(class UActorComponent* Component);
	static void SetForceMipStreaming(class UPrimitiveComponent* Component, bool bForceMipStreaming);
	static void SetForceMipStreamingForActor(class AActor* Actor, bool bForceMipStreaming);
	static bool SetViewTargetWithBlendShelter(class APlayerController* Target, class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, const struct FVector& SlaveLocation);
	static void StringToClipBoard(const class FString& StringToCopy);
	static struct FVector TransformWorldSpaceToPreSkinnedLocalSpace(class FName BoneName, class UMeshComponent* Component, const struct FVector& WorldPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFunctions">();
	}
	static class UCommonFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFunctions>();
	}
};
static_assert(alignof(UCommonFunctions) == 0x000008, "Wrong alignment on UCommonFunctions");
static_assert(sizeof(UCommonFunctions) == 0x000028, "Wrong size on UCommonFunctions");

// Class Flame.OptionsMenuWidget
// 0x0040 (0x0318 - 0x02D8)
class UOptionsMenuWidget : public UMenuWidget
{
public:
	class FName                                   PageName;                                          // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShowTooltips;                                  // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundEffectElementChange;                          // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHintWidget*                            HintWidget;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetBoolValue(const struct FOptionsElementValue& InValue);
	static float GetFloatValue(const struct FOptionsElementValue& InValue);
	static int32 GetIntValue(const struct FOptionsElementValue& InValue);
	static class FName GetNameValue(const struct FOptionsElementValue& InValue);
	static class FString GetStringValue(const struct FOptionsElementValue& InValue);

	void CommitValues(const TMap<class FName, struct FOptionsElementValue>& InValues, class USaveGame* SaveGame, bool ApplySettings);
	void OnPageHidden();
	void OnPageVisible();
	void SetNewResolution(int32 InResX, int32 InResY, EWindowMode InWindowMode);
	void SetOptionsToDefault();

	TArray<class UOptionsElementWidget*> GetAllOptionsElements() const;
	TArray<class UPanelWidget*> GetAllPanelWidgets() const;
	class FName GetPageName() const;
	class UWidget* GetRootFocusWidget() const;
	TMap<class FName, struct FOptionsElementValue> GetValues(class USaveGame* SaveGame) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsMenuWidget">();
	}
	static class UOptionsMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsMenuWidget>();
	}
};
static_assert(alignof(UOptionsMenuWidget) == 0x000008, "Wrong alignment on UOptionsMenuWidget");
static_assert(sizeof(UOptionsMenuWidget) == 0x000318, "Wrong size on UOptionsMenuWidget");
static_assert(offsetof(UOptionsMenuWidget, PageName) == 0x0002D8, "Member 'UOptionsMenuWidget::PageName' has a wrong offset!");
static_assert(offsetof(UOptionsMenuWidget, bCanShowTooltips) == 0x0002E0, "Member 'UOptionsMenuWidget::bCanShowTooltips' has a wrong offset!");
static_assert(offsetof(UOptionsMenuWidget, SoundEffectElementChange) == 0x0002E8, "Member 'UOptionsMenuWidget::SoundEffectElementChange' has a wrong offset!");
static_assert(offsetof(UOptionsMenuWidget, HintWidget) == 0x0002F0, "Member 'UOptionsMenuWidget::HintWidget' has a wrong offset!");

// Class Flame.FirstTimeOptions
// 0x0008 (0x0320 - 0x0318)
class UFirstTimeOptions final : public UOptionsMenuWidget
{
public:
	class UFlameButton*                           ConfirmButton;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnConfirmPressed(class UButton* Sender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstTimeOptions">();
	}
	static class UFirstTimeOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstTimeOptions>();
	}
};
static_assert(alignof(UFirstTimeOptions) == 0x000008, "Wrong alignment on UFirstTimeOptions");
static_assert(sizeof(UFirstTimeOptions) == 0x000320, "Wrong size on UFirstTimeOptions");
static_assert(offsetof(UFirstTimeOptions, ConfirmButton) == 0x000318, "Member 'UFirstTimeOptions::ConfirmButton' has a wrong offset!");

// Class Flame.AchievementsFunctions
// 0x0000 (0x0028 - 0x0028)
class UAchievementsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void GetCachedAchievements(class UObject* WorldContextObject, class APlayerController* PlayerController, TArray<struct FAchievementStruct>* AchievementsList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementsFunctions">();
	}
	static class UAchievementsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementsFunctions>();
	}
};
static_assert(alignof(UAchievementsFunctions) == 0x000008, "Wrong alignment on UAchievementsFunctions");
static_assert(sizeof(UAchievementsFunctions) == 0x000028, "Wrong size on UAchievementsFunctions");

// Class Flame.StatisticsFunctions
// 0x0000 (0x0028 - 0x0028)
class UStatisticsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void SaveStatisticsArrayToFile(const TArray<class FString>& Lines, const class FString& Filename, const class FString& Directory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatisticsFunctions">();
	}
	static class UStatisticsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatisticsFunctions>();
	}
};
static_assert(alignof(UStatisticsFunctions) == 0x000008, "Wrong alignment on UStatisticsFunctions");
static_assert(sizeof(UStatisticsFunctions) == 0x000028, "Wrong size on UStatisticsFunctions");

// Class Flame.FlameDecalComponent
// 0x0000 (0x0240 - 0x0240)
class UFlameDecalComponent final : public UDecalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameDecalComponent">();
	}
	static class UFlameDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameDecalComponent>();
	}
};
static_assert(alignof(UFlameDecalComponent) == 0x000010, "Wrong alignment on UFlameDecalComponent");
static_assert(sizeof(UFlameDecalComponent) == 0x000240, "Wrong size on UFlameDecalComponent");

// Class Flame.CompositeObstacleDatabaseAsset
// 0x0050 (0x0080 - 0x0030)
class UCompositeObstacleDatabaseAsset final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, class UObstacleAsset*> Links;                                             // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompositeObstacleDatabaseAsset">();
	}
	static class UCompositeObstacleDatabaseAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompositeObstacleDatabaseAsset>();
	}
};
static_assert(alignof(UCompositeObstacleDatabaseAsset) == 0x000008, "Wrong alignment on UCompositeObstacleDatabaseAsset");
static_assert(sizeof(UCompositeObstacleDatabaseAsset) == 0x000080, "Wrong size on UCompositeObstacleDatabaseAsset");
static_assert(offsetof(UCompositeObstacleDatabaseAsset, Links) == 0x000030, "Member 'UCompositeObstacleDatabaseAsset::Links' has a wrong offset!");

// Class Flame.CompositeSplineMeshObstacleActor
// 0x0000 (0x0228 - 0x0228)
class ACompositeSplineMeshObstacleActor final : public ACompositeSplineMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompositeSplineMeshObstacleActor">();
	}
	static class ACompositeSplineMeshObstacleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACompositeSplineMeshObstacleActor>();
	}
};
static_assert(alignof(ACompositeSplineMeshObstacleActor) == 0x000008, "Wrong alignment on ACompositeSplineMeshObstacleActor");
static_assert(sizeof(ACompositeSplineMeshObstacleActor) == 0x000228, "Wrong size on ACompositeSplineMeshObstacleActor");

// Class Flame.CompositeSplineMeshObstacleComponent
// 0x0030 (0x0580 - 0x0550)
class UCompositeSplineMeshObstacleComponent final : public UCompositeSplineMeshComponent
{
public:
	TSoftObjectPtr<class UCompositeObstacleDatabaseAsset> ObstacleDatabaseReference;                         // 0x0550(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompositeSplineMeshObstacleComponent">();
	}
	static class UCompositeSplineMeshObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompositeSplineMeshObstacleComponent>();
	}
};
static_assert(alignof(UCompositeSplineMeshObstacleComponent) == 0x000010, "Wrong alignment on UCompositeSplineMeshObstacleComponent");
static_assert(sizeof(UCompositeSplineMeshObstacleComponent) == 0x000580, "Wrong size on UCompositeSplineMeshObstacleComponent");
static_assert(offsetof(UCompositeSplineMeshObstacleComponent, ObstacleDatabaseReference) == 0x000550, "Member 'UCompositeSplineMeshObstacleComponent::ObstacleDatabaseReference' has a wrong offset!");

// Class Flame.FlameDataSingleton
// 0x0038 (0x0060 - 0x0028)
class UFlameDataSingleton : public UObject
{
public:
	float                                         MaxMovementErgonomicsPenalty;                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStaminaErgonomicsPenalty;                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAimingErgonomicsPenalty;                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnimationsErgonomicsPenalty;                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothWeaponSpeedTransitionTime;                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRaiseTime;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLowerTime;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponHolsterTime;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponUnholsterTime;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTimerForCooldown;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStaminaCost;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandUpStaminaFromCrouchCost;                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandUpStaminaFromProneCost;                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegenerationStopTime;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameDataSingleton">();
	}
	static class UFlameDataSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameDataSingleton>();
	}
};
static_assert(alignof(UFlameDataSingleton) == 0x000008, "Wrong alignment on UFlameDataSingleton");
static_assert(sizeof(UFlameDataSingleton) == 0x000060, "Wrong size on UFlameDataSingleton");
static_assert(offsetof(UFlameDataSingleton, MaxMovementErgonomicsPenalty) == 0x000028, "Member 'UFlameDataSingleton::MaxMovementErgonomicsPenalty' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, MaxStaminaErgonomicsPenalty) == 0x00002C, "Member 'UFlameDataSingleton::MaxStaminaErgonomicsPenalty' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, MaxAimingErgonomicsPenalty) == 0x000030, "Member 'UFlameDataSingleton::MaxAimingErgonomicsPenalty' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, MaxAnimationsErgonomicsPenalty) == 0x000034, "Member 'UFlameDataSingleton::MaxAnimationsErgonomicsPenalty' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, SmoothWeaponSpeedTransitionTime) == 0x000038, "Member 'UFlameDataSingleton::SmoothWeaponSpeedTransitionTime' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, WeaponRaiseTime) == 0x00003C, "Member 'UFlameDataSingleton::WeaponRaiseTime' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, WeaponLowerTime) == 0x000040, "Member 'UFlameDataSingleton::WeaponLowerTime' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, WeaponHolsterTime) == 0x000044, "Member 'UFlameDataSingleton::WeaponHolsterTime' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, WeaponUnholsterTime) == 0x000048, "Member 'UFlameDataSingleton::WeaponUnholsterTime' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, WaitTimerForCooldown) == 0x00004C, "Member 'UFlameDataSingleton::WaitTimerForCooldown' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, JumpStaminaCost) == 0x000050, "Member 'UFlameDataSingleton::JumpStaminaCost' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, StandUpStaminaFromCrouchCost) == 0x000054, "Member 'UFlameDataSingleton::StandUpStaminaFromCrouchCost' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, StandUpStaminaFromProneCost) == 0x000058, "Member 'UFlameDataSingleton::StandUpStaminaFromProneCost' has a wrong offset!");
static_assert(offsetof(UFlameDataSingleton, RegenerationStopTime) == 0x00005C, "Member 'UFlameDataSingleton::RegenerationStopTime' has a wrong offset!");

// Class Flame.CompoundPanelWidget
// 0x0058 (0x0310 - 0x02B8)
class UCompoundPanelWidget : public UFlameWidget
{
public:
	struct FCompoundPanelParameters               Parameters;                                        // 0x02B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGridPanel*                             CompoundPanelRoot;                                 // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompoundPanelWidget">();
	}
	static class UCompoundPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompoundPanelWidget>();
	}
};
static_assert(alignof(UCompoundPanelWidget) == 0x000008, "Wrong alignment on UCompoundPanelWidget");
static_assert(sizeof(UCompoundPanelWidget) == 0x000310, "Wrong size on UCompoundPanelWidget");
static_assert(offsetof(UCompoundPanelWidget, Parameters) == 0x0002B8, "Member 'UCompoundPanelWidget::Parameters' has a wrong offset!");
static_assert(offsetof(UCompoundPanelWidget, CompoundPanelRoot) == 0x000308, "Member 'UCompoundPanelWidget::CompoundPanelRoot' has a wrong offset!");

// Class Flame.Condition
// 0x0000 (0x0028 - 0x0028)
class UCondition final : public UObject
{
public:
	bool Check(const class AActor* ActorInteracting) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Condition">();
	}
	static class UCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCondition>();
	}
};
static_assert(alignof(UCondition) == 0x000008, "Wrong alignment on UCondition");
static_assert(sizeof(UCondition) == 0x000028, "Wrong size on UCondition");

// Class Flame.FlameCheatManager
// 0x0000 (0x0088 - 0x0088)
class UFlameCheatManager : public UCheatManager
{
public:
	void PlayerTransformToClipboard();
	void SetPlayerTransformFromClipboard();
	void SetPlayerTransformFromParams(float PosX, float PosY, float PosZ, float RotX, float RotY, float RotZ, float RotW);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameCheatManager">();
	}
	static class UFlameCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameCheatManager>();
	}
};
static_assert(alignof(UFlameCheatManager) == 0x000008, "Wrong alignment on UFlameCheatManager");
static_assert(sizeof(UFlameCheatManager) == 0x000088, "Wrong size on UFlameCheatManager");

// Class Flame.ConsoleEvents
// 0x0100 (0x0128 - 0x0028)
class UConsoleEvents final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnControllerDisconnectedEvent;                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnControllerReconnectedEvent;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   LastErrorMessage;                                  // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCheckUserPlayOnlineFinishedEvent;                // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCallPlatformLoginAsyncFinishedEvent;             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCheckUserCrossPlayAsyncFinishedEvent;            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserLoginChangedEvent;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReviewCompletedEvent;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x40];                                      // 0x00E8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetDefaultLanguage();

	void CallPlatformLoginAsync();
	void CheckUserCrossPlayAsync();
	void CheckUserPlayOnlineAsync();
	bool IsGameConnected();
	bool IsGamepadConnected();
	void OnCallPlatformLoginAsyncFinished__DelegateSignature(bool bWasSuccessful);
	void OnCheckUserCrossPlayAsyncFinished__DelegateSignature(bool CanUserCrossPlay);
	void OnCheckUserPlayOnlineFinished__DelegateSignature(bool IsUserAllowedPlayOnline);
	void OnControllerDisconnected__DelegateSignature(bool bIsConnection, int32 Userid, int32 ControllerId);
	void OnControllerDisconnectedMessageBoxClosed(EMessageBoxAction Result);
	void OnControllerReconnected__DelegateSignature(int32 Userid);
	void OnReviewCompleted__DelegateSignature(bool Success, int32 ErrorCode, const struct FUserReviewResult& Result);
	void OnUserLoginChanged__DelegateSignature(bool bLogin, int32 GameUserIndex);
	bool OpenReviewScreen();
	void RestartGame();
	void ShowAccountPicker(int32 ControllerIndex);

	bool CanUserCrossPlay() const;
	class FText GetPlayerNickName() const;
	bool IsUserLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleEvents">();
	}
	static class UConsoleEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleEvents>();
	}
};
static_assert(alignof(UConsoleEvents) == 0x000008, "Wrong alignment on UConsoleEvents");
static_assert(sizeof(UConsoleEvents) == 0x000128, "Wrong size on UConsoleEvents");
static_assert(offsetof(UConsoleEvents, OnControllerDisconnectedEvent) == 0x000060, "Member 'UConsoleEvents::OnControllerDisconnectedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnControllerReconnectedEvent) == 0x000070, "Member 'UConsoleEvents::OnControllerReconnectedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, LastErrorMessage) == 0x000080, "Member 'UConsoleEvents::LastErrorMessage' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnCheckUserPlayOnlineFinishedEvent) == 0x000098, "Member 'UConsoleEvents::OnCheckUserPlayOnlineFinishedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnCallPlatformLoginAsyncFinishedEvent) == 0x0000A8, "Member 'UConsoleEvents::OnCallPlatformLoginAsyncFinishedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnCheckUserCrossPlayAsyncFinishedEvent) == 0x0000B8, "Member 'UConsoleEvents::OnCheckUserCrossPlayAsyncFinishedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnUserLoginChangedEvent) == 0x0000C8, "Member 'UConsoleEvents::OnUserLoginChangedEvent' has a wrong offset!");
static_assert(offsetof(UConsoleEvents, OnReviewCompletedEvent) == 0x0000D8, "Member 'UConsoleEvents::OnReviewCompletedEvent' has a wrong offset!");

// Class Flame.WeaponStateFiring
// 0x0000 (0x0078 - 0x0078)
class UWeaponStateFiring : public UItemState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateFiring">();
	}
	static class UWeaponStateFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateFiring>();
	}
};
static_assert(alignof(UWeaponStateFiring) == 0x000008, "Wrong alignment on UWeaponStateFiring");
static_assert(sizeof(UWeaponStateFiring) == 0x000078, "Wrong size on UWeaponStateFiring");

// Class Flame.WeaponStateFiringWithWeapon
// 0x0020 (0x0098 - 0x0078)
class UWeaponStateFiringWithWeapon : public UWeaponStateFiring
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextShotTime;                                      // 0x0080(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastShotTime;                                      // 0x0084(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxShotsToFire;                                    // 0x0088(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShotsFired;                                     // 0x008C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConsumedAmmoInLastShot;                            // 0x0090(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoLeftInMagAfterLastShot;                        // 0x0094(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateFiringWithWeapon">();
	}
	static class UWeaponStateFiringWithWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateFiringWithWeapon>();
	}
};
static_assert(alignof(UWeaponStateFiringWithWeapon) == 0x000008, "Wrong alignment on UWeaponStateFiringWithWeapon");
static_assert(sizeof(UWeaponStateFiringWithWeapon) == 0x000098, "Wrong size on UWeaponStateFiringWithWeapon");
static_assert(offsetof(UWeaponStateFiringWithWeapon, NextShotTime) == 0x000080, "Member 'UWeaponStateFiringWithWeapon::NextShotTime' has a wrong offset!");
static_assert(offsetof(UWeaponStateFiringWithWeapon, LastShotTime) == 0x000084, "Member 'UWeaponStateFiringWithWeapon::LastShotTime' has a wrong offset!");
static_assert(offsetof(UWeaponStateFiringWithWeapon, MaxShotsToFire) == 0x000088, "Member 'UWeaponStateFiringWithWeapon::MaxShotsToFire' has a wrong offset!");
static_assert(offsetof(UWeaponStateFiringWithWeapon, NumShotsFired) == 0x00008C, "Member 'UWeaponStateFiringWithWeapon::NumShotsFired' has a wrong offset!");
static_assert(offsetof(UWeaponStateFiringWithWeapon, ConsumedAmmoInLastShot) == 0x000090, "Member 'UWeaponStateFiringWithWeapon::ConsumedAmmoInLastShot' has a wrong offset!");
static_assert(offsetof(UWeaponStateFiringWithWeapon, AmmoLeftInMagAfterLastShot) == 0x000094, "Member 'UWeaponStateFiringWithWeapon::AmmoLeftInMagAfterLastShot' has a wrong offset!");

// Class Flame.WeaponStateFireSingleShot
// 0x0000 (0x0098 - 0x0098)
class UWeaponStateFireSingleShot final : public UWeaponStateFiringWithWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateFireSingleShot">();
	}
	static class UWeaponStateFireSingleShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateFireSingleShot>();
	}
};
static_assert(alignof(UWeaponStateFireSingleShot) == 0x000008, "Wrong alignment on UWeaponStateFireSingleShot");
static_assert(sizeof(UWeaponStateFireSingleShot) == 0x000098, "Wrong size on UWeaponStateFireSingleShot");

// Class Flame.FlameRichTextBlockImageDecorator
// 0x0000 (0x0030 - 0x0030)
class UFlameRichTextBlockImageDecorator : public URichTextBlockImageDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameRichTextBlockImageDecorator">();
	}
	static class UFlameRichTextBlockImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameRichTextBlockImageDecorator>();
	}
};
static_assert(alignof(UFlameRichTextBlockImageDecorator) == 0x000008, "Wrong alignment on UFlameRichTextBlockImageDecorator");
static_assert(sizeof(UFlameRichTextBlockImageDecorator) == 0x000030, "Wrong size on UFlameRichTextBlockImageDecorator");

// Class Flame.ConsumableItem
// 0x0068 (0x0418 - 0x03B0)
class AConsumableItem : public AItemForBackpack
{
public:
	class UUsableComponent*                       Usable;                                            // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemUseState*                          ConsumingStateServer;                              // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemUseState*                          ConsumingStateLocal;                               // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   UsageLabel;                                        // 0x03C8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ItemUseMontage;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x30];                                     // 0x03E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetTargetUnderCursor();
	bool IsTargetStillValid();
	void OnGotIntoHandsImplementable(class AHumanCharacter* ParentCharacter);
	void OnRep_ItemStateConsuming(class UItemUseState* OldState);
	void OnUngotFromHandsImplementable(class AHumanCharacter* ParentCharacter);
	void OnUsedImplementable(class AHumanCharacter* ParentCharacter);

	bool CanBeUsedOnCertainTarget(const class AActor* Target) const;
	bool CanBeUsedOnTarget() const;
	class AActor* GetCurrentTarget() const;
	bool GetIsCraftable() const;
	bool GetIsEquipableInShelter() const;
	TSubclassOf<class AConsumablePlan> GetPlan() const;
	bool IsUsageInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumableItem">();
	}
	static class AConsumableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConsumableItem>();
	}
};
static_assert(alignof(AConsumableItem) == 0x000008, "Wrong alignment on AConsumableItem");
static_assert(sizeof(AConsumableItem) == 0x000418, "Wrong size on AConsumableItem");
static_assert(offsetof(AConsumableItem, Usable) == 0x0003B0, "Member 'AConsumableItem::Usable' has a wrong offset!");
static_assert(offsetof(AConsumableItem, ConsumingStateServer) == 0x0003B8, "Member 'AConsumableItem::ConsumingStateServer' has a wrong offset!");
static_assert(offsetof(AConsumableItem, ConsumingStateLocal) == 0x0003C0, "Member 'AConsumableItem::ConsumingStateLocal' has a wrong offset!");
static_assert(offsetof(AConsumableItem, UsageLabel) == 0x0003C8, "Member 'AConsumableItem::UsageLabel' has a wrong offset!");
static_assert(offsetof(AConsumableItem, ItemUseMontage) == 0x0003E0, "Member 'AConsumableItem::ItemUseMontage' has a wrong offset!");

// Class Flame.ConsumableItemComponent
// 0x0000 (0x00B0 - 0x00B0)
class UConsumableItemComponent : public UActorComponent
{
public:
	void OnGotIntoHandsImplementable(class AHumanCharacter* ParentCharacter);
	void OnUngotFromHandsImplementable(class AHumanCharacter* ParentCharacter);
	void OnUsedImplementable(class AHumanCharacter* ParentCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumableItemComponent">();
	}
	static class UConsumableItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsumableItemComponent>();
	}
};
static_assert(alignof(UConsumableItemComponent) == 0x000008, "Wrong alignment on UConsumableItemComponent");
static_assert(sizeof(UConsumableItemComponent) == 0x0000B0, "Wrong size on UConsumableItemComponent");

// Class Flame.ContainerWidget
// 0x0010 (0x02C8 - 0x02B8)
class UContainerWidget : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSlotsTriggerConfirmAction;                        // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainsSlot(const class UFlameSlot* InFlameSlot) const;
	class UFlameSlot* GetFocusedSlot() const;
	int32 GetSlotCount() const;
	TArray<class UFlameSlot*> GetSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerWidget">();
	}
	static class UContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerWidget>();
	}
};
static_assert(alignof(UContainerWidget) == 0x000008, "Wrong alignment on UContainerWidget");
static_assert(sizeof(UContainerWidget) == 0x0002C8, "Wrong size on UContainerWidget");
static_assert(offsetof(UContainerWidget, bSlotsTriggerConfirmAction) == 0x0002C0, "Member 'UContainerWidget::bSlotsTriggerConfirmAction' has a wrong offset!");

// Class Flame.DynamicContainerWidget
// 0x0010 (0x02D8 - 0x02C8)
class UDynamicContainerWidget : public UContainerWidget
{
public:
	TSubclassOf<class UFlameSlot>                 ContainerSlotClass;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowNullItems;                                   // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FocusedSlotIndex;                                  // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 AddItemsDescriptors(const class UItemProvider* ItemProvider);
	int32 AddItemsDescriptorsFromArray(const TArray<struct FInvetoryItemDescriptor>& DescriptorArray);
	void ClearSlots();
	void SetSlotClass(TSubclassOf<class UFlameSlot> InSlotClass);
	void SetUserFocusToSlot(int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicContainerWidget">();
	}
	static class UDynamicContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicContainerWidget>();
	}
};
static_assert(alignof(UDynamicContainerWidget) == 0x000008, "Wrong alignment on UDynamicContainerWidget");
static_assert(sizeof(UDynamicContainerWidget) == 0x0002D8, "Wrong size on UDynamicContainerWidget");
static_assert(offsetof(UDynamicContainerWidget, ContainerSlotClass) == 0x0002C8, "Member 'UDynamicContainerWidget::ContainerSlotClass' has a wrong offset!");
static_assert(offsetof(UDynamicContainerWidget, bAllowNullItems) == 0x0002D0, "Member 'UDynamicContainerWidget::bAllowNullItems' has a wrong offset!");
static_assert(offsetof(UDynamicContainerWidget, FocusedSlotIndex) == 0x0002D4, "Member 'UDynamicContainerWidget::FocusedSlotIndex' has a wrong offset!");

// Class Flame.FlameListWidget
// 0x0030 (0x0308 - 0x02D8)
class UFlameListWidget : public UDynamicContainerWidget
{
public:
	class UScrollBox*                             ScrollBox;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviewSlotCount;                                  // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USectionHeaderWidget>       HeaderWidgetClass;                                 // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAddedSlot;                                       // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UWidget* GetWidgetToFocus();
	void UpdateUserFocusBP();
	void UpdateUserFocusDefault();

	TArray<class UFlameSlot*> GetBPSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameListWidget">();
	}
	static class UFlameListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameListWidget>();
	}
};
static_assert(alignof(UFlameListWidget) == 0x000008, "Wrong alignment on UFlameListWidget");
static_assert(sizeof(UFlameListWidget) == 0x000308, "Wrong size on UFlameListWidget");
static_assert(offsetof(UFlameListWidget, ScrollBox) == 0x0002D8, "Member 'UFlameListWidget::ScrollBox' has a wrong offset!");
static_assert(offsetof(UFlameListWidget, PreviewSlotCount) == 0x0002E0, "Member 'UFlameListWidget::PreviewSlotCount' has a wrong offset!");
static_assert(offsetof(UFlameListWidget, HeaderWidgetClass) == 0x0002E8, "Member 'UFlameListWidget::HeaderWidgetClass' has a wrong offset!");
static_assert(offsetof(UFlameListWidget, OnAddedSlot) == 0x0002F8, "Member 'UFlameListWidget::OnAddedSlot' has a wrong offset!");

// Class Flame.ConsumablesCraftingList
// 0x0000 (0x00D0 - 0x00D0)
class UConsumablesCraftingList final : public UCraftingList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumablesCraftingList">();
	}
	static class UConsumablesCraftingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsumablesCraftingList>();
	}
};
static_assert(alignof(UConsumablesCraftingList) == 0x000008, "Wrong alignment on UConsumablesCraftingList");
static_assert(sizeof(UConsumablesCraftingList) == 0x0000D0, "Wrong size on UConsumablesCraftingList");

// Class Flame.WheelSegment
// 0x0020 (0x02D8 - 0x02B8)
class UWheelSegment : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SegmentIndex;                                      // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAngle;                                        // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcSize;                                           // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x02D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void OnDeselect();
	void OnSelect();

	bool CanBeSelected() const;
	float GetAngularDistance(float InAngle) const;
	struct FVector2D GetContentPosition(float InWheelRadius) const;
	struct FLinearColor GetEquipIndicatorColor() const;
	class USelectionWheelComponent* GetWheelComponent() const;
	bool IsAngleInSegment(float InAngle) const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheelSegment">();
	}
	static class UWheelSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheelSegment>();
	}
};
static_assert(alignof(UWheelSegment) == 0x000008, "Wrong alignment on UWheelSegment");
static_assert(sizeof(UWheelSegment) == 0x0002D8, "Wrong size on UWheelSegment");
static_assert(offsetof(UWheelSegment, SegmentIndex) == 0x0002C8, "Member 'UWheelSegment::SegmentIndex' has a wrong offset!");
static_assert(offsetof(UWheelSegment, StartAngle) == 0x0002CC, "Member 'UWheelSegment::StartAngle' has a wrong offset!");
static_assert(offsetof(UWheelSegment, ArcSize) == 0x0002D0, "Member 'UWheelSegment::ArcSize' has a wrong offset!");
static_assert(offsetof(UWheelSegment, bIsSelected) == 0x0002D4, "Member 'UWheelSegment::bIsSelected' has a wrong offset!");

// Class Flame.FlameHUD
// 0x00B8 (0x03C8 - 0x0310)
class AFlameHUD : public AHUD
{
public:
	float                                         NetworkIssuesNotificationDelay;                    // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHUDWidget>                 PlayerHUDClass;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuWidget>                GameMenuClass;                                     // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShelterMainTabControl>     ShelterMainTabControlClass;                        // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuWidget>                LoadoutClass;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatchmakingStatus>         MatchmakingStatusClass;                            // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNotificationListBase>      NotificationListClass;                             // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USubtitleWidget>            SubtitleWidgetClass;                               // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUDWidget*                             HUDWidget;                                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuWidget*                            GameMenuWidget;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShelterMainTabControl*                 ShelterMainTabControlWidget;                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuWidget*                            LoadoutWidget;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMatchmakingStatus*                     MatchmakingStatusWidget;                           // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNotificationListBase*                  NotificationListWidget;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USubtitleWidget*                        SubtitleWidget;                                    // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMenuOpened;                                      // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMenuClosed;                                      // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideLoadout();
	void OnServerConnectionStateImproved();
	void OnServerConnectionStateUpdated(bool bClientHasConnectionIssues);
	void SetHUDVisibility(ESlateVisibility Visibility);
	void ShowLoadout();

	bool ShouldInputAxisBeIgnored(class FName InAxisName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameHUD">();
	}
	static class AFlameHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameHUD>();
	}
};
static_assert(alignof(AFlameHUD) == 0x000008, "Wrong alignment on AFlameHUD");
static_assert(sizeof(AFlameHUD) == 0x0003C8, "Wrong size on AFlameHUD");
static_assert(offsetof(AFlameHUD, NetworkIssuesNotificationDelay) == 0x000310, "Member 'AFlameHUD::NetworkIssuesNotificationDelay' has a wrong offset!");
static_assert(offsetof(AFlameHUD, PlayerHUDClass) == 0x000318, "Member 'AFlameHUD::PlayerHUDClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, GameMenuClass) == 0x000320, "Member 'AFlameHUD::GameMenuClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, ShelterMainTabControlClass) == 0x000328, "Member 'AFlameHUD::ShelterMainTabControlClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, LoadoutClass) == 0x000330, "Member 'AFlameHUD::LoadoutClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, MatchmakingStatusClass) == 0x000338, "Member 'AFlameHUD::MatchmakingStatusClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, NotificationListClass) == 0x000340, "Member 'AFlameHUD::NotificationListClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, SubtitleWidgetClass) == 0x000348, "Member 'AFlameHUD::SubtitleWidgetClass' has a wrong offset!");
static_assert(offsetof(AFlameHUD, HUDWidget) == 0x000350, "Member 'AFlameHUD::HUDWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, GameMenuWidget) == 0x000358, "Member 'AFlameHUD::GameMenuWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, ShelterMainTabControlWidget) == 0x000360, "Member 'AFlameHUD::ShelterMainTabControlWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, LoadoutWidget) == 0x000368, "Member 'AFlameHUD::LoadoutWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, MatchmakingStatusWidget) == 0x000370, "Member 'AFlameHUD::MatchmakingStatusWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, NotificationListWidget) == 0x000378, "Member 'AFlameHUD::NotificationListWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, SubtitleWidget) == 0x000380, "Member 'AFlameHUD::SubtitleWidget' has a wrong offset!");
static_assert(offsetof(AFlameHUD, OnMenuOpened) == 0x000398, "Member 'AFlameHUD::OnMenuOpened' has a wrong offset!");
static_assert(offsetof(AFlameHUD, OnMenuClosed) == 0x0003A8, "Member 'AFlameHUD::OnMenuClosed' has a wrong offset!");

// Class Flame.ConsumableSegment
// 0x0010 (0x02E8 - 0x02D8)
class UConsumableSegment : public UWheelSegment
{
public:
	TSubclassOf<class AConsumableItem>            ConsumableClass;                                   // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             ConsumableSlot;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetConsumableClass(TSubclassOf<class AConsumableItem> InClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumableSegment">();
	}
	static class UConsumableSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsumableSegment>();
	}
};
static_assert(alignof(UConsumableSegment) == 0x000008, "Wrong alignment on UConsumableSegment");
static_assert(sizeof(UConsumableSegment) == 0x0002E8, "Wrong size on UConsumableSegment");
static_assert(offsetof(UConsumableSegment, ConsumableClass) == 0x0002D8, "Member 'UConsumableSegment::ConsumableClass' has a wrong offset!");
static_assert(offsetof(UConsumableSegment, ConsumableSlot) == 0x0002E0, "Member 'UConsumableSegment::ConsumableSlot' has a wrong offset!");

// Class Flame.ConsumablesFunctions
// 0x0000 (0x0028 - 0x0028)
class UConsumablesFunctions final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FAttachedCharacterInfo> GetAllAttachedCharactersInfo(const class AHumanCharacter* OwnerCharacter);
	static struct FAttachedCharacterInfo GetAttachedCharacterInfo(const class AHumanCharacter* AttachedCharacter);
	static struct FAttachedCharacterInfo GetInfoAboutAttachingTarget(const class AHumanCharacter* OwnerCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumablesFunctions">();
	}
	static class UConsumablesFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsumablesFunctions>();
	}
};
static_assert(alignof(UConsumablesFunctions) == 0x000008, "Wrong alignment on UConsumablesFunctions");
static_assert(sizeof(UConsumablesFunctions) == 0x000028, "Wrong size on UConsumablesFunctions");

// Class Flame.Gameplay
// 0x0000 (0x0220 - 0x0220)
class AGameplay : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gameplay">();
	}
	static class AGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplay>();
	}
};
static_assert(alignof(AGameplay) == 0x000008, "Wrong alignment on AGameplay");
static_assert(sizeof(AGameplay) == 0x000220, "Wrong size on AGameplay");

// Class Flame.GameplayStorage
// 0x0010 (0x0230 - 0x0220)
class AGameplayStorage : public AGameplay
{
public:
	FMulticastInlineDelegateProperty_             LootRemovedOnServer;                               // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void OnLootStored(class AItem* Loot);
	void OnLootStoredClass(TSubclassOf<class AItemForBackpack> LootClass, int32 Count);
	void OnLootTaken(class AItem* Loot);
	void OnLootTakenClass(TSubclassOf<class AItemForBackpack> LootClass, int32 Count);
	int32 UnlinkAndDestroyAllStoredItems();

	void OnLootChanged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayStorage">();
	}
	static class AGameplayStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayStorage>();
	}
};
static_assert(alignof(AGameplayStorage) == 0x000008, "Wrong alignment on AGameplayStorage");
static_assert(sizeof(AGameplayStorage) == 0x000230, "Wrong size on AGameplayStorage");
static_assert(offsetof(AGameplayStorage, LootRemovedOnServer) == 0x000220, "Member 'AGameplayStorage::LootRemovedOnServer' has a wrong offset!");

// Class Flame.Lootable
// 0x0010 (0x0240 - 0x0230)
class ALootable : public AGameplayStorage
{
public:
	class ULootOnGroundComponent*                 LootStorage;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLootDistributed;                                  // 0x0238(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x1];                                      // 0x0239(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasUI;                                            // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B[0x5];                                      // 0x023B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LootDistrubuted();
	void OnRep_LootDistributed();
	bool WasPlacedInEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Lootable">();
	}
	static class ALootable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootable>();
	}
};
static_assert(alignof(ALootable) == 0x000008, "Wrong alignment on ALootable");
static_assert(sizeof(ALootable) == 0x000240, "Wrong size on ALootable");
static_assert(offsetof(ALootable, LootStorage) == 0x000230, "Member 'ALootable::LootStorage' has a wrong offset!");
static_assert(offsetof(ALootable, bLootDistributed) == 0x000238, "Member 'ALootable::bLootDistributed' has a wrong offset!");
static_assert(offsetof(ALootable, bHasUI) == 0x00023A, "Member 'ALootable::bHasUI' has a wrong offset!");

// Class Flame.PhysicsLootableActor
// 0x0008 (0x0248 - 0x0240)
class APhysicsLootableActor : public ALootable
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsLootableActor">();
	}
	static class APhysicsLootableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsLootableActor>();
	}
};
static_assert(alignof(APhysicsLootableActor) == 0x000008, "Wrong alignment on APhysicsLootableActor");
static_assert(sizeof(APhysicsLootableActor) == 0x000248, "Wrong size on APhysicsLootableActor");
static_assert(offsetof(APhysicsLootableActor, MeshComponent) == 0x000240, "Member 'APhysicsLootableActor::MeshComponent' has a wrong offset!");

// Class Flame.Grenade
// 0x0058 (0x03F0 - 0x0398)
class AGrenade : public AItem
{
public:
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LocationsOnServer;                                 // 0x03A8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MaxExplosionRadius;                                // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UI_MaxExplosionRadius;                             // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UI_KillzoneRadius;                                 // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToExplosion;                                   // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToLiveAfterDeath;                              // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnTouch;                                   // 0x03CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnTouchAfterTimerExpired;                  // 0x03CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDifuseInWaterDepth;                               // 0x03CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CF[0x1];                                      // 0x03CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDepthForExplosion;                              // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x1C];                                     // 0x03D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastNotifyExplosion(const TArray<struct FExplosionEffect>& ExplosionEffects);
	void OnGrenadeExplode(const TArray<struct FExplosionEffect>& ExplosionEffects);
	void OnImpact(const struct FVector& HitLocation, const struct FVector& NormalImpulse);
	void OnThrow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grenade">();
	}
	static class AGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenade>();
	}
};
static_assert(alignof(AGrenade) == 0x000008, "Wrong alignment on AGrenade");
static_assert(sizeof(AGrenade) == 0x0003F0, "Wrong size on AGrenade");
static_assert(offsetof(AGrenade, LocationsOnServer) == 0x0003A8, "Member 'AGrenade::LocationsOnServer' has a wrong offset!");
static_assert(offsetof(AGrenade, MaxExplosionRadius) == 0x0003B8, "Member 'AGrenade::MaxExplosionRadius' has a wrong offset!");
static_assert(offsetof(AGrenade, UI_MaxExplosionRadius) == 0x0003BC, "Member 'AGrenade::UI_MaxExplosionRadius' has a wrong offset!");
static_assert(offsetof(AGrenade, UI_KillzoneRadius) == 0x0003C0, "Member 'AGrenade::UI_KillzoneRadius' has a wrong offset!");
static_assert(offsetof(AGrenade, TimeToExplosion) == 0x0003C4, "Member 'AGrenade::TimeToExplosion' has a wrong offset!");
static_assert(offsetof(AGrenade, TimeToLiveAfterDeath) == 0x0003C8, "Member 'AGrenade::TimeToLiveAfterDeath' has a wrong offset!");
static_assert(offsetof(AGrenade, bExplodeOnTouch) == 0x0003CC, "Member 'AGrenade::bExplodeOnTouch' has a wrong offset!");
static_assert(offsetof(AGrenade, bExplodeOnTouchAfterTimerExpired) == 0x0003CD, "Member 'AGrenade::bExplodeOnTouchAfterTimerExpired' has a wrong offset!");
static_assert(offsetof(AGrenade, bDifuseInWaterDepth) == 0x0003CE, "Member 'AGrenade::bDifuseInWaterDepth' has a wrong offset!");
static_assert(offsetof(AGrenade, MaxDepthForExplosion) == 0x0003D0, "Member 'AGrenade::MaxDepthForExplosion' has a wrong offset!");

// Class Flame.ControllerInputAnalyzer
// 0x0030 (0x0058 - 0x0028)
class UControllerInputAnalyzer final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerInputAnalyzer">();
	}
	static class UControllerInputAnalyzer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerInputAnalyzer>();
	}
};
static_assert(alignof(UControllerInputAnalyzer) == 0x000008, "Wrong alignment on UControllerInputAnalyzer");
static_assert(sizeof(UControllerInputAnalyzer) == 0x000058, "Wrong size on UControllerInputAnalyzer");

// Class Flame.CraftingConfigManager
// 0x03C0 (0x05E0 - 0x0220)
class ACraftingConfigManager : public AInfo
{
public:
	uint8                                         Pad_220[0x3C0];                                    // 0x0220(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingConfigManager">();
	}
	static class ACraftingConfigManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACraftingConfigManager>();
	}
};
static_assert(alignof(ACraftingConfigManager) == 0x000008, "Wrong alignment on ACraftingConfigManager");
static_assert(sizeof(ACraftingConfigManager) == 0x0005E0, "Wrong size on ACraftingConfigManager");

// Class Flame.CraftingFunctions
// 0x0000 (0x0028 - 0x0028)
class UCraftingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FCloudRequest BoostCraftingItem(ECraftingQueueType Queue, ECloudCraftingBoosterPaymentType PaymentType, class AStash* Stash);
	static bool CanBeCraft(TSubclassOf<class APlan> Plan, const class AStash* Stash);
	static struct FCloudRequest CancelConsumableInQueue(int32 Index_0, const class AStash* Stash);
	static struct FCloudRequest CancelWeaponInQueue(int32 Index_0, const class AStash* Stash);
	static bool CanCraftAmmo(TSubclassOf<class AAmmoItem> AmmoItemClass, class AStash* Stash);
	static bool CanCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash);
	static bool CanCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash);
	static struct FCloudRequest CraftAmmo(TSubclassOf<class AAmmoItem> AmmoClass, int32 Count, class AStash* Stash, TDelegate<void()> UICallback);
	static struct FCloudRequest CraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash, bool IsBoosted, TDelegate<void()> UICallback);
	static struct FCloudRequest CraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash, bool IsBoosted, TDelegate<void()> UICallback);
	static struct FCloudRequest DeconstructAmmo(TSubclassOf<class AAmmoItem> AmmoForDeconstruct, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback);
	static struct FCloudRequest DeconstructConsumable(TSubclassOf<class AConsumableItem> OneConsumable, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback);
	static struct FCloudRequest DeconstructPart(TSubclassOf<class APartItem> PartForDeconstruct, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback);
	static struct FCloudRequest DeconstructWeapon(TSubclassOf<class AWeapon> OneWeapon, int32 Count, const class AStash* Stash, TDelegate<void()> UICallback);
	static TArray<TSubclassOf<class AConsumablePlan>> GetAllUnlockedConsumablePlans(const class AStash* Stash);
	static TArray<TSubclassOf<class AWeaponPlan>> GetAllUnlockedWeaponPlans(const class AStash* Stash);
	static int32 GetAmmoCraftingTimeInSec(TSubclassOf<class AAmmoItem> AmmoClass, const class AStash* Stash);
	static class UTexture2D* GetAmmoIcon(TSubclassOf<class AAmmoItem> AmmoClass, EIconSize Size);
	static class FText GetAmmoName(TSubclassOf<class AAmmoItem> AmmoClass);
	static int32 GetAmmoPrice(TSubclassOf<class AAmmoItem> AmmoClass);
	static int32 GetBonusAmmoForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static int32 GetBonusAmmoForWeaponFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash);
	static int32 GetConsumableCostInParts(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static int32 GetConsumableCostInPartsFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash);
	static int32 GetConsumableCraftingBoosterPrice(TSubclassOf<class AConsumableItem> ItemClass, class AStash* Stash);
	static struct FCloudCraftingQueue GetConsumableCraftingQueue(const class AStash* Stash);
	static class UTexture2D* GetConsumableIcon(TSubclassOf<class AConsumableItem> ConsumableClass, EIconSize Size);
	static struct FCraftingItemStatus GetConsumableInQueueInfo(int32 Index_0, const class AStash* Stash);
	static class FText GetConsumableName(TSubclassOf<class AConsumableItem> ConsumableClass);
	static int32 GetConsumablePartCount(TSubclassOf<class AConsumablePart> ConsumablePartClass, const class AStash* Stash);
	static class UTexture2D* GetConsumablePartIcon(TSubclassOf<class AConsumablePart> ConsumablePartClass, EIconSize Size);
	static class FText GetConsumablePartName(TSubclassOf<class AConsumablePart> ConsumablePartClass);
	static int32 GetConsumablePartPrice(TSubclassOf<class AConsumablePart> ConsumablePartClass);
	static float GetConsumablePartPriceForDeconstruction(TSubclassOf<class AConsumablePart> ConsumablePartClass, const class AStash* Stash);
	static TSubclassOf<class AConsumablePlan> GetConsumablePlan(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static int32 GetConsumablePrice(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static TArray<TSubclassOf<class AConsumablePart>> GetConsumablesPlanParts(TSubclassOf<class AConsumablePlan> ConsumablePlanClass);
	static int32 GetCostForBoostCraftingItem(ECraftingQueueType Queue, class AStash* Stash);
	static class ACraftingConfigManager* GetCraftManager(const class UObject* WorldContextObject);
	static struct FCraftingItemInfo GetCurrentCraftingAmmo(const class AStash* Stash);
	static TSubclassOf<class AAmmoItem> GetCurrentCraftingAmmoClass(const class AStash* Stash);
	static TSubclassOf<class AConsumableItem> GetCurrentCraftingConsumableClass(const class AStash* Stash);
	static struct FCraftingItemInfo GetCurrentCraftingConsumables(const class AStash* Stash);
	static struct FCraftingItemInfo GetCurrentCraftingWeapon(const class AStash* Stash);
	static TSubclassOf<class AWeapon> GetCurrentCraftingWeaponClass(const class AStash* Stash);
	static TSubclassOf<class AItem> GetItemFromCraftingQueue(const struct FCloudCraftingQueue& Queue, const class UObject* WorldContextObject, int32 Index_0);
	static TArray<struct FCloudCraftedItem> GetItemsInConsumableCraftingQueue(const class AStash* Stash);
	static TArray<struct FCloudCraftedItem> GetItemsInWeaponsCraftingQueue(const class AStash* Stash);
	static int32 GetNeededLevelForConsumable(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static int32 GetNeededLevelForConsumableFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash);
	static int32 GetNeededLevelForCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash);
	static int32 GetNeededLevelForCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash);
	static int32 GetNeededLevelForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static int32 GetNeededLevelForWeaponFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash);
	static struct FTimespan GetRemainingAmmoCraftingTime(const class AStash* Stash);
	static struct FTimespan GetRemainingConsumablesCraftingTime(const class AStash* Stash);
	static struct FTimespan GetRemainingCraftingTime(ECraftingQueueType Queue, const class AStash* Stash);
	static struct FTimespan GetRemainingWeaponCraftingTime(const class AStash* Stash);
	static int32 GetTimeToCraftConsumableFromMaterialInSec(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static int32 GetTimeToCraftConsumableFromPartsInSec(TSubclassOf<class AConsumableItem> ConsumableClass, const class AStash* Stash);
	static int32 GetTimeToCraftConsumableFromPartsInSecFromPlan(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash);
	static int32 GetTimeToCraftWeaponFromMaterialInSec(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static int32 GetTimeToCraftWeaponFromPartsInSec(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static int32 GetTimeToCraftWeaponFromPartsInSecFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash);
	static int32 GetWeaponCostInParts(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static int32 GetWeaponCostInPartsFromPlan(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash);
	static int32 GetWeaponCraftingBoosterPrice(TSubclassOf<class AWeapon> ItemClass);
	static struct FCloudCraftingQueue GetWeaponCraftingQueue(const class AStash* Stash);
	static class UTexture2D* GetWeaponIcon(TSubclassOf<class AWeapon> WeaponClass, EIconSize Size);
	static struct FCraftingItemStatus GetWeaponInQueueInfo(int32 Index_0, const class AStash* Stash);
	static class FText GetWeaponName(TSubclassOf<class AWeapon> WeaponClass);
	static int32 GetWeaponPartCount(TSubclassOf<class AWeaponPart> WeaponPartClass, const class AStash* Stash);
	static class UTexture2D* GetWeaponPartIcon(TSubclassOf<class AWeaponPart> WeaponPartClass, EIconSize Size);
	static class FText GetWeaponPartName(TSubclassOf<class AWeaponPart> WeaponPartClass);
	static int32 GetWeaponPartPrice(TSubclassOf<class AWeaponPart> WeaponPartClass);
	static float GetWeaponPartPriceForDeconstruction(TSubclassOf<class AWeaponPart> WeaponPartClass, const class AStash* Stash);
	static TSubclassOf<class AWeaponPlan> GetWeaponPlan(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static TArray<TSubclassOf<class AWeaponPart>> GetWeaponPlanParts(TSubclassOf<class AWeaponPlan> WeaponPlanClass);
	static int32 GetWeaponPrice(TSubclassOf<class AWeapon> WeaponClass, const class AStash* Stash);
	static bool HasLevelForCraftConsumable(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, class AStash* Stash);
	static bool HasLevelForCraftWeapon(TSubclassOf<class AWeaponPlan> WeaponPlanClass, class AStash* Stash);
	static bool IsConsumableCraftable(TSubclassOf<class AConsumableItem> ConsumablePlanClass);
	static bool IsConsumableEquipableFromShelter(TSubclassOf<class AConsumableItem> ConsumablePlanClass);
	static bool IsConsumablePlanUnlocked(TSubclassOf<class AConsumablePlan> ConsumablePlanClass, const class AStash* Stash);
	static bool IsWeaponPlanUnlocked(TSubclassOf<class AWeaponPlan> WeaponPlanClass, const class AStash* Stash);
	static struct FCloudRequest UnlockPlan(TSubclassOf<class APlan> PlanClass, class AStash* Stash);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingFunctions">();
	}
	static class UCraftingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingFunctions>();
	}
};
static_assert(alignof(UCraftingFunctions) == 0x000008, "Wrong alignment on UCraftingFunctions");
static_assert(sizeof(UCraftingFunctions) == 0x000028, "Wrong size on UCraftingFunctions");

// Class Flame.HasItemInterface
// 0x0000 (0x0028 - 0x0028)
class IHasItemInterface final : public IInterface
{
public:
	void ClearItem();
	void SetItemInstance(class AItem* Item);
	void SetItemType(TSubclassOf<class AItem> ItemClass);

	class AItem* GetItemObsolete() const;
	TSubclassOf<class AItem> GetItemType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasItemInterface">();
	}
	static class IHasItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHasItemInterface>();
	}
};
static_assert(alignof(IHasItemInterface) == 0x000008, "Wrong alignment on IHasItemInterface");
static_assert(sizeof(IHasItemInterface) == 0x000028, "Wrong size on IHasItemInterface");

// Class Flame.CraftingTimerManager
// 0x00A8 (0x02C8 - 0x0220)
class ACraftingTimerManager final : public AInfo
{
public:
	int32                                         UpdateTimeInSeconds;                               // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AdditionalSecondsToRealCraftingTime;               // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DelayBeforeReExamineInSec;                         // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x9C];                                     // 0x022C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FDateTime GetCurrentTime() const;
	struct FDateTime GetLastUpdateTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingTimerManager">();
	}
	static class ACraftingTimerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACraftingTimerManager>();
	}
};
static_assert(alignof(ACraftingTimerManager) == 0x000008, "Wrong alignment on ACraftingTimerManager");
static_assert(sizeof(ACraftingTimerManager) == 0x0002C8, "Wrong size on ACraftingTimerManager");
static_assert(offsetof(ACraftingTimerManager, UpdateTimeInSeconds) == 0x000220, "Member 'ACraftingTimerManager::UpdateTimeInSeconds' has a wrong offset!");
static_assert(offsetof(ACraftingTimerManager, AdditionalSecondsToRealCraftingTime) == 0x000224, "Member 'ACraftingTimerManager::AdditionalSecondsToRealCraftingTime' has a wrong offset!");
static_assert(offsetof(ACraftingTimerManager, DelayBeforeReExamineInSec) == 0x000228, "Member 'ACraftingTimerManager::DelayBeforeReExamineInSec' has a wrong offset!");

// Class Flame.CurrencyWidget
// 0x0048 (0x0300 - 0x02B8)
class UCurrencyWidget : public UFlameWidget
{
public:
	int32                                         FoodCount;                                         // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FoodCapacity;                                      // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaterialCount;                                     // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaterialCapacity;                                  // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HardCurrencyCount;                                 // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0xC];                                      // 0x02CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameTextBlock*                        MaterialCountText;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        MaterialCapacityText;                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        FoodCountText;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        FoodCapacityText;                                  // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        HardCurrencyCountText;                             // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnValueChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyWidget">();
	}
	static class UCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrencyWidget>();
	}
};
static_assert(alignof(UCurrencyWidget) == 0x000008, "Wrong alignment on UCurrencyWidget");
static_assert(sizeof(UCurrencyWidget) == 0x000300, "Wrong size on UCurrencyWidget");
static_assert(offsetof(UCurrencyWidget, FoodCount) == 0x0002B8, "Member 'UCurrencyWidget::FoodCount' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, FoodCapacity) == 0x0002BC, "Member 'UCurrencyWidget::FoodCapacity' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, MaterialCount) == 0x0002C0, "Member 'UCurrencyWidget::MaterialCount' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, MaterialCapacity) == 0x0002C4, "Member 'UCurrencyWidget::MaterialCapacity' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, HardCurrencyCount) == 0x0002C8, "Member 'UCurrencyWidget::HardCurrencyCount' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, MaterialCountText) == 0x0002D8, "Member 'UCurrencyWidget::MaterialCountText' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, MaterialCapacityText) == 0x0002E0, "Member 'UCurrencyWidget::MaterialCapacityText' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, FoodCountText) == 0x0002E8, "Member 'UCurrencyWidget::FoodCountText' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, FoodCapacityText) == 0x0002F0, "Member 'UCurrencyWidget::FoodCapacityText' has a wrong offset!");
static_assert(offsetof(UCurrencyWidget, HardCurrencyCountText) == 0x0002F8, "Member 'UCurrencyWidget::HardCurrencyCountText' has a wrong offset!");

// Class Flame.CurveDamageOverDistance
// 0x0080 (0x00B0 - 0x0030)
class UCurveDamageOverDistance final : public UCurveBase
{
public:
	struct FRichCurve                             DamageOverDistanceRatio;                           // 0x0030(0x0080)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveDamageOverDistance">();
	}
	static class UCurveDamageOverDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveDamageOverDistance>();
	}
};
static_assert(alignof(UCurveDamageOverDistance) == 0x000008, "Wrong alignment on UCurveDamageOverDistance");
static_assert(sizeof(UCurveDamageOverDistance) == 0x0000B0, "Wrong size on UCurveDamageOverDistance");
static_assert(offsetof(UCurveDamageOverDistance, DamageOverDistanceRatio) == 0x000030, "Member 'UCurveDamageOverDistance::DamageOverDistanceRatio' has a wrong offset!");

// Class Flame.Mannequin
// 0x0018 (0x0238 - 0x0220)
class AMannequin : public AActor
{
public:
	class UMannequinCustomizationComponent*       Customization;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAudioComponent*>                CurrentSFX;                                        // 0x0228(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void ClearGestureSFX();
	void GetPlayerCurrentOutfitVariantSlots(TArray<struct FCustomizationSlotVariant>& PairsToOverride, TArray<struct FCustomizationSlotVariant>* OutVariantSlotsPairs, bool* bOutSucess);
	bool InitFromCharacterNative(const class AHumanCharacter* SourceCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mannequin">();
	}
	static class AMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMannequin>();
	}
};
static_assert(alignof(AMannequin) == 0x000008, "Wrong alignment on AMannequin");
static_assert(sizeof(AMannequin) == 0x000238, "Wrong size on AMannequin");
static_assert(offsetof(AMannequin, Customization) == 0x000220, "Member 'AMannequin::Customization' has a wrong offset!");
static_assert(offsetof(AMannequin, CurrentSFX) == 0x000228, "Member 'AMannequin::CurrentSFX' has a wrong offset!");

// Class Flame.FlameScalableGridWidget
// 0x0040 (0x0318 - 0x02D8)
class UFlameScalableGridWidget : public UDynamicContainerWidget
{
public:
	class UScrollBox*                             ScrollBox;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviewSlotCount;                                  // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Width;                                             // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UScalableGridRowWidget>     GridRowClass;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                SlotPadding;                                       // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UScalableGridRowWidget*>         GridRows;                                          // 0x0300(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWidth(int32 InWidth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameScalableGridWidget">();
	}
	static class UFlameScalableGridWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameScalableGridWidget>();
	}
};
static_assert(alignof(UFlameScalableGridWidget) == 0x000008, "Wrong alignment on UFlameScalableGridWidget");
static_assert(sizeof(UFlameScalableGridWidget) == 0x000318, "Wrong size on UFlameScalableGridWidget");
static_assert(offsetof(UFlameScalableGridWidget, ScrollBox) == 0x0002D8, "Member 'UFlameScalableGridWidget::ScrollBox' has a wrong offset!");
static_assert(offsetof(UFlameScalableGridWidget, PreviewSlotCount) == 0x0002E0, "Member 'UFlameScalableGridWidget::PreviewSlotCount' has a wrong offset!");
static_assert(offsetof(UFlameScalableGridWidget, Width) == 0x0002E4, "Member 'UFlameScalableGridWidget::Width' has a wrong offset!");
static_assert(offsetof(UFlameScalableGridWidget, GridRowClass) == 0x0002E8, "Member 'UFlameScalableGridWidget::GridRowClass' has a wrong offset!");
static_assert(offsetof(UFlameScalableGridWidget, SlotPadding) == 0x0002F0, "Member 'UFlameScalableGridWidget::SlotPadding' has a wrong offset!");
static_assert(offsetof(UFlameScalableGridWidget, GridRows) == 0x000300, "Member 'UFlameScalableGridWidget::GridRows' has a wrong offset!");

// Class Flame.CurveMeleeArc
// 0x0180 (0x01B0 - 0x0030)
class UCurveMeleeArc final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector GetVectorValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveMeleeArc">();
	}
	static class UCurveMeleeArc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveMeleeArc>();
	}
};
static_assert(alignof(UCurveMeleeArc) == 0x000008, "Wrong alignment on UCurveMeleeArc");
static_assert(sizeof(UCurveMeleeArc) == 0x0001B0, "Wrong size on UCurveMeleeArc");
static_assert(offsetof(UCurveMeleeArc, FloatCurves) == 0x000030, "Member 'UCurveMeleeArc::FloatCurves' has a wrong offset!");

// Class Flame.CurveMovementSpeed
// 0x0300 (0x0330 - 0x0030)
class UCurveMovementSpeed final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x6];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector GetVectorValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveMovementSpeed">();
	}
	static class UCurveMovementSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveMovementSpeed>();
	}
};
static_assert(alignof(UCurveMovementSpeed) == 0x000008, "Wrong alignment on UCurveMovementSpeed");
static_assert(sizeof(UCurveMovementSpeed) == 0x000330, "Wrong size on UCurveMovementSpeed");
static_assert(offsetof(UCurveMovementSpeed, FloatCurves) == 0x000030, "Member 'UCurveMovementSpeed::FloatCurves' has a wrong offset!");

// Class Flame.FlameWorldSettings
// 0x0018 (0x03C0 - 0x03A8)
class AFlameWorldSettings final : public AWorldSettings
{
public:
	float                                         AudioZLevelMin;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioZLevelMax;                                    // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AudioZLevelCurve;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              LevelSoundMix;                                     // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameWorldSettings">();
	}
	static class AFlameWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameWorldSettings>();
	}
};
static_assert(alignof(AFlameWorldSettings) == 0x000008, "Wrong alignment on AFlameWorldSettings");
static_assert(sizeof(AFlameWorldSettings) == 0x0003C0, "Wrong size on AFlameWorldSettings");
static_assert(offsetof(AFlameWorldSettings, AudioZLevelMin) == 0x0003A8, "Member 'AFlameWorldSettings::AudioZLevelMin' has a wrong offset!");
static_assert(offsetof(AFlameWorldSettings, AudioZLevelMax) == 0x0003AC, "Member 'AFlameWorldSettings::AudioZLevelMax' has a wrong offset!");
static_assert(offsetof(AFlameWorldSettings, AudioZLevelCurve) == 0x0003B0, "Member 'AFlameWorldSettings::AudioZLevelCurve' has a wrong offset!");
static_assert(offsetof(AFlameWorldSettings, LevelSoundMix) == 0x0003B8, "Member 'AFlameWorldSettings::LevelSoundMix' has a wrong offset!");

// Class Flame.CurveSlopeSpeed
// 0x0180 (0x01B0 - 0x0030)
class UCurveSlopeSpeed final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector GetVectorValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSlopeSpeed">();
	}
	static class UCurveSlopeSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSlopeSpeed>();
	}
};
static_assert(alignof(UCurveSlopeSpeed) == 0x000008, "Wrong alignment on UCurveSlopeSpeed");
static_assert(sizeof(UCurveSlopeSpeed) == 0x0001B0, "Wrong size on UCurveSlopeSpeed");
static_assert(offsetof(UCurveSlopeSpeed, FloatCurves) == 0x000030, "Member 'UCurveSlopeSpeed::FloatCurves' has a wrong offset!");

// Class Flame.CustomInputFilter
// 0x0038 (0x0258 - 0x0220)
class ACustomInputFilter : public AActor
{
public:
	class UDataTable*                             FiltersTable;                                      // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x30];                                     // 0x0228(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EInputFilterResult CheckFilter(const class AHumanPlayerController* TargetController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomInputFilter">();
	}
	static class ACustomInputFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomInputFilter>();
	}
};
static_assert(alignof(ACustomInputFilter) == 0x000008, "Wrong alignment on ACustomInputFilter");
static_assert(sizeof(ACustomInputFilter) == 0x000258, "Wrong size on ACustomInputFilter");
static_assert(offsetof(ACustomInputFilter, FiltersTable) == 0x000220, "Member 'ACustomInputFilter::FiltersTable' has a wrong offset!");

// Class Flame.FlameSpectatorPawn
// 0x0138 (0x03E0 - 0x02A8)
class AFlameSpectatorPawn : public ASpectatorPawn
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpectatorState                        ServerTarget;                                      // 0x02B0(0x0090)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSpectatorState                        CurrentTarget;                                     // 0x0340(0x0090)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TransitionDelay;                                   // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawDebugLocation(const struct FVector& Location);
	void OnRep_ServerTarget();
	void OnServerTargetChanged();
	void OnTargetChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameSpectatorPawn">();
	}
	static class AFlameSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameSpectatorPawn>();
	}
};
static_assert(alignof(AFlameSpectatorPawn) == 0x000010, "Wrong alignment on AFlameSpectatorPawn");
static_assert(sizeof(AFlameSpectatorPawn) == 0x0003E0, "Wrong size on AFlameSpectatorPawn");
static_assert(offsetof(AFlameSpectatorPawn, ServerTarget) == 0x0002B0, "Member 'AFlameSpectatorPawn::ServerTarget' has a wrong offset!");
static_assert(offsetof(AFlameSpectatorPawn, CurrentTarget) == 0x000340, "Member 'AFlameSpectatorPawn::CurrentTarget' has a wrong offset!");
static_assert(offsetof(AFlameSpectatorPawn, TransitionDelay) == 0x0003D0, "Member 'AFlameSpectatorPawn::TransitionDelay' has a wrong offset!");

// Class Flame.CustomInputRule
// 0x0048 (0x0268 - 0x0220)
class ACustomInputRule : public AActor
{
public:
	class FName                                   WantedActionName;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DoingActionName;                                   // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RulesTable;                                        // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x30];                                     // 0x0238(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EInputRule CustomReactOnInput(const class AHumanPlayerController* TargetController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomInputRule">();
	}
	static class ACustomInputRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomInputRule>();
	}
};
static_assert(alignof(ACustomInputRule) == 0x000008, "Wrong alignment on ACustomInputRule");
static_assert(sizeof(ACustomInputRule) == 0x000268, "Wrong size on ACustomInputRule");
static_assert(offsetof(ACustomInputRule, WantedActionName) == 0x000220, "Member 'ACustomInputRule::WantedActionName' has a wrong offset!");
static_assert(offsetof(ACustomInputRule, DoingActionName) == 0x000228, "Member 'ACustomInputRule::DoingActionName' has a wrong offset!");
static_assert(offsetof(ACustomInputRule, RulesTable) == 0x000230, "Member 'ACustomInputRule::RulesTable' has a wrong offset!");

// Class Flame.ClothesMeshComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UClothesMeshComponent : public UCustomisationMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesMeshComponent">();
	}
	static class UClothesMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClothesMeshComponent>();
	}
};
static_assert(alignof(UClothesMeshComponent) == 0x000010, "Wrong alignment on UClothesMeshComponent");
static_assert(sizeof(UClothesMeshComponent) == 0x000EF0, "Wrong size on UClothesMeshComponent");

// Class Flame.ItemProvider
// 0x0000 (0x0028 - 0x0028)
class UItemProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemProvider">();
	}
	static class UItemProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemProvider>();
	}
};
static_assert(alignof(UItemProvider) == 0x000008, "Wrong alignment on UItemProvider");
static_assert(sizeof(UItemProvider) == 0x000028, "Wrong size on UItemProvider");

// Class Flame.LootSpawnManager
// 0x0000 (0x02B0 - 0x02B0)
class ALootSpawnManager : public ACommoditySpawnManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootSpawnManager">();
	}
	static class ALootSpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootSpawnManager>();
	}
};
static_assert(alignof(ALootSpawnManager) == 0x000008, "Wrong alignment on ALootSpawnManager");
static_assert(sizeof(ALootSpawnManager) == 0x0002B0, "Wrong size on ALootSpawnManager");

// Class Flame.FlameGameSave
// 0x0058 (0x0088 - 0x0030)
class UFlameGameSave final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSaveSucceed;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSaveFailed;                                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFlameGameSave* SaveGameToSlotByPlatform(class UFlameGameInstance* FlameGameInstance, class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex);

	void ReceivedSaveResults(const class FString& SlotName, const int32 UserIndex, bool bSucceeded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameGameSave">();
	}
	static class UFlameGameSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameGameSave>();
	}
};
static_assert(alignof(UFlameGameSave) == 0x000008, "Wrong alignment on UFlameGameSave");
static_assert(sizeof(UFlameGameSave) == 0x000088, "Wrong size on UFlameGameSave");
static_assert(offsetof(UFlameGameSave, OnSaveSucceed) == 0x000030, "Member 'UFlameGameSave::OnSaveSucceed' has a wrong offset!");
static_assert(offsetof(UFlameGameSave, OnSaveFailed) == 0x000040, "Member 'UFlameGameSave::OnSaveFailed' has a wrong offset!");

// Class Flame.InventoryItemProvider
// 0x0030 (0x0058 - 0x0028)
class UInventoryItemProvider : public UItemProvider
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AWeapon>>            AvailableWeaponTypes;                              // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AAmmoItem>>          AvailableAmmoTypes;                                // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetItemStorageComponent(const class UEquipmentStorageComponent* Component);
	void SetPlayerController(const class APlayerController* InController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItemProvider">();
	}
	static class UInventoryItemProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryItemProvider>();
	}
};
static_assert(alignof(UInventoryItemProvider) == 0x000008, "Wrong alignment on UInventoryItemProvider");
static_assert(sizeof(UInventoryItemProvider) == 0x000058, "Wrong size on UInventoryItemProvider");
static_assert(offsetof(UInventoryItemProvider, PlayerController) == 0x000028, "Member 'UInventoryItemProvider::PlayerController' has a wrong offset!");
static_assert(offsetof(UInventoryItemProvider, AvailableWeaponTypes) == 0x000030, "Member 'UInventoryItemProvider::AvailableWeaponTypes' has a wrong offset!");
static_assert(offsetof(UInventoryItemProvider, AvailableAmmoTypes) == 0x000040, "Member 'UInventoryItemProvider::AvailableAmmoTypes' has a wrong offset!");

// Class Flame.Weapon
// 0x0808 (0x0BA0 - 0x0398)
class AWeapon : public AItem
{
public:
	bool                                          HasOptics;                                         // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFirearmWeaponConfiguration            WeaponConfiguration;                               // 0x03A0(0x0418)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FWeaponSightConfiguration              SightConfiguration;                                // 0x07B8(0x0030)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             PreModelSwapMaterials;                             // 0x07E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F8[0x8];                                      // 0x07F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponStateReload*                     ReloadStateServer;                                 // 0x0800(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponStateReload*                     ReloadStateLocal;                                  // 0x0808(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponStateChamberRound*               ChamberStateServer;                                // 0x0810(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponStateChamberRound*               ChamberStateLocal;                                 // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWeaponStateFiring*>             FiringStateServer;                                 // 0x0820(0x0010)(Edit, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UWeaponStateFiring*>             FiringStateLocal;                                  // 0x0830(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWeaponStateMeleeAttack*                MeleeAttackStateServer;                            // 0x0840(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponStateMeleeAttack*                MeleeAttackStateLocal;                             // 0x0848(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCharacterWeaponAnimData>   CharacterAnimDataClass;                            // 0x0850(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_858[0x48];                                     // 0x0858(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponSkinChanged;                               // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ExtraSkinMesh;                                     // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FireMuzzleSocket;                                  // 0x08C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IsLocallyControlledAudioParameterName;             // 0x08C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IsADS1PAudioParameterName;                         // 0x08D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IsADS3PAudioParameterName;                         // 0x08D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AItemSkin>                  SkinClass;                                         // 0x08E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EnvironmentTypeAudioParameterName;                 // 0x08E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   IsEmptyMagazineAudioParameterName;                 // 0x08F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        TriggerAudioComponent;                             // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        BringUpDownAudioComponent;                         // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        Camera1PVAudioComponent;                           // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AimStartEndAudioComponent;                         // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        FireModeSwitchAudioComponent;                      // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AnimClassLink;                                     // 0x0920(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x0948(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMeshLink;                                  // 0x0950(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SkeletalMeshHardRef;                               // 0x0978(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMeshADS;                                   // 0x0980(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SkeletalMeshADSHardRef;                            // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SkeletalMeshADSBlurMask;                           // 0x09B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 MeshADSBlurMaskComponent;                          // 0x09B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantADSTransition;                             // 0x09C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldHideHands1PV;                               // 0x09C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C2[0x6E];                                     // 0x09C2(0x006E)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentADSFovIndex;                                // 0x0A30(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A34[0x68];                                     // 0x0A34(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocketLeft;                                  // 0x0A9C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketRight;                                 // 0x0AA4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AAC[0x4];                                      // 0x0AAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BackSocketARelativeTransform;                      // 0x0AB0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             BackSocketBRelativeTransform;                      // 0x0AE0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             HipSocketARelativeTransform;                       // 0x0B10(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             HipSocketBRelativeTransform;                       // 0x0B40(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B70[0x8];                                      // 0x0B70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FireModeOrder;                                     // 0x0B78(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponFireMode>                FireModes;                                         // 0x0B88(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentFireMode;                                   // 0x0B98(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastFireMode;                                      // 0x0B9C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateParticleSystem(class UParticleSystemComponent* PS, class UParticleSystem* Template);
	class USceneComponent* GetSoundAttachementComponent();
	bool LoadAmmoFromBag();
	void MulticastPlayFireEffects(bool bConsumedAmmo);
	void MulticastPlayMeleeEffects(float Duration);
	void OnRep_CurrentMuzzle();
	void OnRep_Skin(TSubclassOf<class AItemSkin> OldSkinClass);
	void OnRep_WeaponStateChamberRound();
	void OnRep_WeaponStateFiring(TArray<class UWeaponStateFiring*>* OldState);
	void OnRep_WeaponStateMeleeAttack();
	void OnRep_WeaponStateReload();
	void PlayReloadSound(class USoundBase* SoundToPlay);
	void ReceiveFireShot();
	void ReceiveMeleeHit(const struct FHitResult& HitResult);
	float ReloadTimeEmpty();
	float ReloadTimeFull();
	void SetPreviousFireMode();
	bool SetSkinBP(TSubclassOf<class AItemSkin> NewSkinClass);
	void StopMelee();
	void SwapADSModels();
	void UpdateSocketsOverridesAfterOwnerChange();

	bool CanAcceptReplicatedAmmo() const;
	bool CanReload() const;
	class UAimPointComponent* GetAimPointComponent() const;
	bool GetCurrentWeaponFireMode(EWeaponFireType* OutType) const;
	class USkeletalMeshComponent* GetExtraSkinGeometryMesh() const;
	EWeaponInventoryType GetInventoryType() const;
	struct FFlameSkinMaterialInfo GetMaterialInfoImplementation() const;
	class FString GetParentDebugString() const;
	TSubclassOf<class AWeaponPlan> GetPlan() const;
	int32 GetShellImpactMaterialIndex() const;
	class USoundBase* GetShellImpactSound() const;
	const struct FWeaponSightConfiguration GetSightData() const;
	TSoftObjectPtr<class USkeletalMesh> GetSkeletalMeshLink() const;
	TSubclassOf<class AItemSkin> GetSkin() const;
	TSubclassOf<class AAmmoItem> GetSupportedAmmoType() const;
	const struct FFirearmWeaponConfiguration GetWeaponData() const;
	EWeaponType GetWeaponType() const;
	bool IsPrimaryWeapon() const;
	bool IsSecondaryWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Weapon">();
	}
	static class AWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeapon>();
	}
};
static_assert(alignof(AWeapon) == 0x000010, "Wrong alignment on AWeapon");
static_assert(sizeof(AWeapon) == 0x000BA0, "Wrong size on AWeapon");
static_assert(offsetof(AWeapon, HasOptics) == 0x000398, "Member 'AWeapon::HasOptics' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponConfiguration) == 0x0003A0, "Member 'AWeapon::WeaponConfiguration' has a wrong offset!");
static_assert(offsetof(AWeapon, SightConfiguration) == 0x0007B8, "Member 'AWeapon::SightConfiguration' has a wrong offset!");
static_assert(offsetof(AWeapon, PreModelSwapMaterials) == 0x0007E8, "Member 'AWeapon::PreModelSwapMaterials' has a wrong offset!");
static_assert(offsetof(AWeapon, ReloadStateServer) == 0x000800, "Member 'AWeapon::ReloadStateServer' has a wrong offset!");
static_assert(offsetof(AWeapon, ReloadStateLocal) == 0x000808, "Member 'AWeapon::ReloadStateLocal' has a wrong offset!");
static_assert(offsetof(AWeapon, ChamberStateServer) == 0x000810, "Member 'AWeapon::ChamberStateServer' has a wrong offset!");
static_assert(offsetof(AWeapon, ChamberStateLocal) == 0x000818, "Member 'AWeapon::ChamberStateLocal' has a wrong offset!");
static_assert(offsetof(AWeapon, FiringStateServer) == 0x000820, "Member 'AWeapon::FiringStateServer' has a wrong offset!");
static_assert(offsetof(AWeapon, FiringStateLocal) == 0x000830, "Member 'AWeapon::FiringStateLocal' has a wrong offset!");
static_assert(offsetof(AWeapon, MeleeAttackStateServer) == 0x000840, "Member 'AWeapon::MeleeAttackStateServer' has a wrong offset!");
static_assert(offsetof(AWeapon, MeleeAttackStateLocal) == 0x000848, "Member 'AWeapon::MeleeAttackStateLocal' has a wrong offset!");
static_assert(offsetof(AWeapon, CharacterAnimDataClass) == 0x000850, "Member 'AWeapon::CharacterAnimDataClass' has a wrong offset!");
static_assert(offsetof(AWeapon, OnWeaponSkinChanged) == 0x0008A0, "Member 'AWeapon::OnWeaponSkinChanged' has a wrong offset!");
static_assert(offsetof(AWeapon, Mesh) == 0x0008B0, "Member 'AWeapon::Mesh' has a wrong offset!");
static_assert(offsetof(AWeapon, ExtraSkinMesh) == 0x0008B8, "Member 'AWeapon::ExtraSkinMesh' has a wrong offset!");
static_assert(offsetof(AWeapon, FireMuzzleSocket) == 0x0008C0, "Member 'AWeapon::FireMuzzleSocket' has a wrong offset!");
static_assert(offsetof(AWeapon, IsLocallyControlledAudioParameterName) == 0x0008C8, "Member 'AWeapon::IsLocallyControlledAudioParameterName' has a wrong offset!");
static_assert(offsetof(AWeapon, IsADS1PAudioParameterName) == 0x0008D0, "Member 'AWeapon::IsADS1PAudioParameterName' has a wrong offset!");
static_assert(offsetof(AWeapon, IsADS3PAudioParameterName) == 0x0008D8, "Member 'AWeapon::IsADS3PAudioParameterName' has a wrong offset!");
static_assert(offsetof(AWeapon, SkinClass) == 0x0008E0, "Member 'AWeapon::SkinClass' has a wrong offset!");
static_assert(offsetof(AWeapon, EnvironmentTypeAudioParameterName) == 0x0008E8, "Member 'AWeapon::EnvironmentTypeAudioParameterName' has a wrong offset!");
static_assert(offsetof(AWeapon, IsEmptyMagazineAudioParameterName) == 0x0008F0, "Member 'AWeapon::IsEmptyMagazineAudioParameterName' has a wrong offset!");
static_assert(offsetof(AWeapon, TriggerAudioComponent) == 0x0008F8, "Member 'AWeapon::TriggerAudioComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, BringUpDownAudioComponent) == 0x000900, "Member 'AWeapon::BringUpDownAudioComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, Camera1PVAudioComponent) == 0x000908, "Member 'AWeapon::Camera1PVAudioComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, AimStartEndAudioComponent) == 0x000910, "Member 'AWeapon::AimStartEndAudioComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, FireModeSwitchAudioComponent) == 0x000918, "Member 'AWeapon::FireModeSwitchAudioComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimClassLink) == 0x000920, "Member 'AWeapon::AnimClassLink' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimClass) == 0x000948, "Member 'AWeapon::AnimClass' has a wrong offset!");
static_assert(offsetof(AWeapon, SkeletalMeshLink) == 0x000950, "Member 'AWeapon::SkeletalMeshLink' has a wrong offset!");
static_assert(offsetof(AWeapon, SkeletalMeshHardRef) == 0x000978, "Member 'AWeapon::SkeletalMeshHardRef' has a wrong offset!");
static_assert(offsetof(AWeapon, SkeletalMeshADS) == 0x000980, "Member 'AWeapon::SkeletalMeshADS' has a wrong offset!");
static_assert(offsetof(AWeapon, SkeletalMeshADSHardRef) == 0x0009A8, "Member 'AWeapon::SkeletalMeshADSHardRef' has a wrong offset!");
static_assert(offsetof(AWeapon, SkeletalMeshADSBlurMask) == 0x0009B0, "Member 'AWeapon::SkeletalMeshADSBlurMask' has a wrong offset!");
static_assert(offsetof(AWeapon, MeshADSBlurMaskComponent) == 0x0009B8, "Member 'AWeapon::MeshADSBlurMaskComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, bInstantADSTransition) == 0x0009C0, "Member 'AWeapon::bInstantADSTransition' has a wrong offset!");
static_assert(offsetof(AWeapon, bShouldHideHands1PV) == 0x0009C1, "Member 'AWeapon::bShouldHideHands1PV' has a wrong offset!");
static_assert(offsetof(AWeapon, CurrentADSFovIndex) == 0x000A30, "Member 'AWeapon::CurrentADSFovIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, AttachSocketLeft) == 0x000A9C, "Member 'AWeapon::AttachSocketLeft' has a wrong offset!");
static_assert(offsetof(AWeapon, AttachSocketRight) == 0x000AA4, "Member 'AWeapon::AttachSocketRight' has a wrong offset!");
static_assert(offsetof(AWeapon, BackSocketARelativeTransform) == 0x000AB0, "Member 'AWeapon::BackSocketARelativeTransform' has a wrong offset!");
static_assert(offsetof(AWeapon, BackSocketBRelativeTransform) == 0x000AE0, "Member 'AWeapon::BackSocketBRelativeTransform' has a wrong offset!");
static_assert(offsetof(AWeapon, HipSocketARelativeTransform) == 0x000B10, "Member 'AWeapon::HipSocketARelativeTransform' has a wrong offset!");
static_assert(offsetof(AWeapon, HipSocketBRelativeTransform) == 0x000B40, "Member 'AWeapon::HipSocketBRelativeTransform' has a wrong offset!");
static_assert(offsetof(AWeapon, FireModeOrder) == 0x000B78, "Member 'AWeapon::FireModeOrder' has a wrong offset!");
static_assert(offsetof(AWeapon, FireModes) == 0x000B88, "Member 'AWeapon::FireModes' has a wrong offset!");
static_assert(offsetof(AWeapon, CurrentFireMode) == 0x000B98, "Member 'AWeapon::CurrentFireMode' has a wrong offset!");
static_assert(offsetof(AWeapon, LastFireMode) == 0x000B9C, "Member 'AWeapon::LastFireMode' has a wrong offset!");

// Class Flame.FlameUserInterfaceSettings
// 0x0130 (0x0168 - 0x0038)
class UFlameUserInterfaceSettings final : public UDeveloperSettings
{
public:
	TMap<EUILayer, int32>                         LayerZOrderMap;                                    // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AvailableLanguages;                                // 0x0088(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UMessageBoxWidget>          MessageBoxWidgetClass;                             // 0x0098(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInputActionWidget>         MessageBoxActionWidgetClass;                       // 0x00A0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EMessageBoxAction, struct FSoftObjectPath> MessageBoxActionSounds;                            // 0x00A8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UTextNotification>          TextNotificationClass;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNotificationBase>          NetworkIssuesNotificationClass;                    // 0x0100(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerNotification>        PlayerJoinedGroupNotificationClass;                // 0x0108(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerNotification>        PlayerLeftGroupNotificationClass;                  // 0x0110(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerNotification>        PlayerStartedMatchmakingNotificationClass;         // 0x0118(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerNotification>        PlayerCancelledMatchmakingNotificationClass;       // 0x0120(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UModalWidget>               IdleWidgetClass;                                   // 0x0128(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemRarities>              ItemRaritiesClass;                                 // 0x0130(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelDescriptions;                                 // 0x0138(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ColorPaletteTable;                                 // 0x0150(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameUserInterfaceSettings">();
	}
	static class UFlameUserInterfaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameUserInterfaceSettings>();
	}
};
static_assert(alignof(UFlameUserInterfaceSettings) == 0x000008, "Wrong alignment on UFlameUserInterfaceSettings");
static_assert(sizeof(UFlameUserInterfaceSettings) == 0x000168, "Wrong size on UFlameUserInterfaceSettings");
static_assert(offsetof(UFlameUserInterfaceSettings, LayerZOrderMap) == 0x000038, "Member 'UFlameUserInterfaceSettings::LayerZOrderMap' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, AvailableLanguages) == 0x000088, "Member 'UFlameUserInterfaceSettings::AvailableLanguages' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, MessageBoxWidgetClass) == 0x000098, "Member 'UFlameUserInterfaceSettings::MessageBoxWidgetClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, MessageBoxActionWidgetClass) == 0x0000A0, "Member 'UFlameUserInterfaceSettings::MessageBoxActionWidgetClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, MessageBoxActionSounds) == 0x0000A8, "Member 'UFlameUserInterfaceSettings::MessageBoxActionSounds' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, TextNotificationClass) == 0x0000F8, "Member 'UFlameUserInterfaceSettings::TextNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, NetworkIssuesNotificationClass) == 0x000100, "Member 'UFlameUserInterfaceSettings::NetworkIssuesNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, PlayerJoinedGroupNotificationClass) == 0x000108, "Member 'UFlameUserInterfaceSettings::PlayerJoinedGroupNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, PlayerLeftGroupNotificationClass) == 0x000110, "Member 'UFlameUserInterfaceSettings::PlayerLeftGroupNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, PlayerStartedMatchmakingNotificationClass) == 0x000118, "Member 'UFlameUserInterfaceSettings::PlayerStartedMatchmakingNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, PlayerCancelledMatchmakingNotificationClass) == 0x000120, "Member 'UFlameUserInterfaceSettings::PlayerCancelledMatchmakingNotificationClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, IdleWidgetClass) == 0x000128, "Member 'UFlameUserInterfaceSettings::IdleWidgetClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, ItemRaritiesClass) == 0x000130, "Member 'UFlameUserInterfaceSettings::ItemRaritiesClass' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, LevelDescriptions) == 0x000138, "Member 'UFlameUserInterfaceSettings::LevelDescriptions' has a wrong offset!");
static_assert(offsetof(UFlameUserInterfaceSettings, ColorPaletteTable) == 0x000150, "Member 'UFlameUserInterfaceSettings::ColorPaletteTable' has a wrong offset!");

// Class Flame.CustomizableItemProvider
// 0x0008 (0x0060 - 0x0058)
class UCustomizableItemProvider final : public UInventoryItemProvider
{
public:
	int32                                         Filter;                                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFilter(int32 InFilter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizableItemProvider">();
	}
	static class UCustomizableItemProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizableItemProvider>();
	}
};
static_assert(alignof(UCustomizableItemProvider) == 0x000008, "Wrong alignment on UCustomizableItemProvider");
static_assert(sizeof(UCustomizableItemProvider) == 0x000060, "Wrong size on UCustomizableItemProvider");
static_assert(offsetof(UCustomizableItemProvider, Filter) == 0x000058, "Member 'UCustomizableItemProvider::Filter' has a wrong offset!");

// Class Flame.OnlineComponentBase
// 0x0000 (0x00B0 - 0x00B0)
class UOnlineComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineComponentBase">();
	}
	static class UOnlineComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineComponentBase>();
	}
};
static_assert(alignof(UOnlineComponentBase) == 0x000008, "Wrong alignment on UOnlineComponentBase");
static_assert(sizeof(UOnlineComponentBase) == 0x0000B0, "Wrong size on UOnlineComponentBase");

// Class Flame.MarketplaceComponent
// 0x0040 (0x00F0 - 0x00B0)
class UMarketplaceComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             CurrencyForItemBlocked;                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CurrencyForItemUnBlocked;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserBalanceReceived;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PriceListReceived;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 BlockCurrencyForItem(const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku, int32 Quantity, int32 TotalPrice, int32 PriceListGeneration);
	void BlockCurrencyForItemDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku);
	int32 GetPriceList(const class FString& MatchID);
	void GetPriceListDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudPriceList& PriceList);
	int32 GetUserBalance(const class AHumanPlayerController* Player);
	void GetUserBalanceDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const struct FCloudUserBalance& Balance);
	int32 UnBlockCurrencyForItem(const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku);
	void UnBlockCurrencyForItemDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class AHumanPlayerController* Player, const class FString& MatchCloudId, const class FString& ProductSku);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketplaceComponent">();
	}
	static class UMarketplaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketplaceComponent>();
	}
};
static_assert(alignof(UMarketplaceComponent) == 0x000008, "Wrong alignment on UMarketplaceComponent");
static_assert(sizeof(UMarketplaceComponent) == 0x0000F0, "Wrong size on UMarketplaceComponent");
static_assert(offsetof(UMarketplaceComponent, CurrencyForItemBlocked) == 0x0000B0, "Member 'UMarketplaceComponent::CurrencyForItemBlocked' has a wrong offset!");
static_assert(offsetof(UMarketplaceComponent, CurrencyForItemUnBlocked) == 0x0000C0, "Member 'UMarketplaceComponent::CurrencyForItemUnBlocked' has a wrong offset!");
static_assert(offsetof(UMarketplaceComponent, UserBalanceReceived) == 0x0000D0, "Member 'UMarketplaceComponent::UserBalanceReceived' has a wrong offset!");
static_assert(offsetof(UMarketplaceComponent, PriceListReceived) == 0x0000E0, "Member 'UMarketplaceComponent::PriceListReceived' has a wrong offset!");

// Class Flame.LobbyComponent
// 0x00C0 (0x01B0 - 0x00F0)
class ULobbyComponent : public UMarketplaceComponent
{
public:
	class FString                                 LootSKU;                                           // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CrateSKU;                                          // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InsuranceSKU;                                      // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FreeInsuranceSKU;                                  // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ShootoutSKU;                                       // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TicketSKU;                                         // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstantBreakLockSKU;                               // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScoreTeam1SKU;                                     // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ScoreTeam2SKU;                                     // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DoubleXP_SKU;                                      // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DoubleResourcesSKU;                                // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DoublePartsSKU;                                    // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const EBoosterTypes GetBoosterEnumFromSKU(const class FString& BoosterSKU, bool* ValidityCheck) const;
	const class FString GetBoosterSKU(EBoosterTypes Booster) const;
	const int32 GetUsedBoosterTicketCount(EBoosterTypes Booster) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyComponent">();
	}
	static class ULobbyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyComponent>();
	}
};
static_assert(alignof(ULobbyComponent) == 0x000008, "Wrong alignment on ULobbyComponent");
static_assert(sizeof(ULobbyComponent) == 0x0001B0, "Wrong size on ULobbyComponent");
static_assert(offsetof(ULobbyComponent, LootSKU) == 0x0000F0, "Member 'ULobbyComponent::LootSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, CrateSKU) == 0x000100, "Member 'ULobbyComponent::CrateSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, InsuranceSKU) == 0x000110, "Member 'ULobbyComponent::InsuranceSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, FreeInsuranceSKU) == 0x000120, "Member 'ULobbyComponent::FreeInsuranceSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, ShootoutSKU) == 0x000130, "Member 'ULobbyComponent::ShootoutSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, TicketSKU) == 0x000140, "Member 'ULobbyComponent::TicketSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, InstantBreakLockSKU) == 0x000150, "Member 'ULobbyComponent::InstantBreakLockSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, ScoreTeam1SKU) == 0x000160, "Member 'ULobbyComponent::ScoreTeam1SKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, ScoreTeam2SKU) == 0x000170, "Member 'ULobbyComponent::ScoreTeam2SKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, DoubleXP_SKU) == 0x000180, "Member 'ULobbyComponent::DoubleXP_SKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, DoubleResourcesSKU) == 0x000190, "Member 'ULobbyComponent::DoubleResourcesSKU' has a wrong offset!");
static_assert(offsetof(ULobbyComponent, DoublePartsSKU) == 0x0001A0, "Member 'ULobbyComponent::DoublePartsSKU' has a wrong offset!");

// Class Flame.CustomizationBody
// 0x0000 (0x0400 - 0x0400)
class ACustomizationBody : public ACustomization
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationBody">();
	}
	static class ACustomizationBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationBody>();
	}
};
static_assert(alignof(ACustomizationBody) == 0x000008, "Wrong alignment on ACustomizationBody");
static_assert(sizeof(ACustomizationBody) == 0x000400, "Wrong size on ACustomizationBody");

// Class Flame.ProneStepNotify
// 0x0008 (0x0040 - 0x0038)
class UProneStepNotify : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProneStepNotify">();
	}
	static class UProneStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProneStepNotify>();
	}
};
static_assert(alignof(UProneStepNotify) == 0x000008, "Wrong alignment on UProneStepNotify");
static_assert(sizeof(UProneStepNotify) == 0x000040, "Wrong size on UProneStepNotify");

// Class Flame.LeftArmProneStepNotify
// 0x0000 (0x0040 - 0x0040)
class ULeftArmProneStepNotify final : public UProneStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeftArmProneStepNotify">();
	}
	static class ULeftArmProneStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeftArmProneStepNotify>();
	}
};
static_assert(alignof(ULeftArmProneStepNotify) == 0x000008, "Wrong alignment on ULeftArmProneStepNotify");
static_assert(sizeof(ULeftArmProneStepNotify) == 0x000040, "Wrong size on ULeftArmProneStepNotify");

// Class Flame.ClothesUniform
// 0x0000 (0x0400 - 0x0400)
class AClothesUniform : public ACustomizationClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesUniform">();
	}
	static class AClothesUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesUniform>();
	}
};
static_assert(alignof(AClothesUniform) == 0x000008, "Wrong alignment on AClothesUniform");
static_assert(sizeof(AClothesUniform) == 0x000400, "Wrong size on AClothesUniform");

// Class Flame.ClothesUniformSet
// 0x0000 (0x0400 - 0x0400)
class AClothesUniformSet : public AClothesUniform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesUniformSet">();
	}
	static class AClothesUniformSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesUniformSet>();
	}
};
static_assert(alignof(AClothesUniformSet) == 0x000008, "Wrong alignment on AClothesUniformSet");
static_assert(sizeof(AClothesUniformSet) == 0x000400, "Wrong size on AClothesUniformSet");

// Class Flame.FootprintManager
// 0x0020 (0x0240 - 0x0220)
class AFootprintManager final : public AActor
{
public:
	int32                                         MaxFootprintCount;                                 // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootprintLifeTime;                              // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootprintFadeOutTime;                              // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootprintDistance;                              // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFootprintInfo>                 ActiveFootprints;                                  // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class UDecalComponent* AddFootPrint(const struct FVector& Location, const struct FVector& Normal, const struct FVector& Direction, const struct FVector& DecalSize, float OrientationCoef, int32 FrameIdx, class UMaterialInterface* Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootprintManager">();
	}
	static class AFootprintManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFootprintManager>();
	}
};
static_assert(alignof(AFootprintManager) == 0x000008, "Wrong alignment on AFootprintManager");
static_assert(sizeof(AFootprintManager) == 0x000240, "Wrong size on AFootprintManager");
static_assert(offsetof(AFootprintManager, MaxFootprintCount) == 0x000220, "Member 'AFootprintManager::MaxFootprintCount' has a wrong offset!");
static_assert(offsetof(AFootprintManager, MaxFootprintLifeTime) == 0x000224, "Member 'AFootprintManager::MaxFootprintLifeTime' has a wrong offset!");
static_assert(offsetof(AFootprintManager, FootprintFadeOutTime) == 0x000228, "Member 'AFootprintManager::FootprintFadeOutTime' has a wrong offset!");
static_assert(offsetof(AFootprintManager, MaxFootprintDistance) == 0x00022C, "Member 'AFootprintManager::MaxFootprintDistance' has a wrong offset!");
static_assert(offsetof(AFootprintManager, ActiveFootprints) == 0x000230, "Member 'AFootprintManager::ActiveFootprints' has a wrong offset!");

// Class Flame.ClothesBackpack
// 0x0000 (0x0400 - 0x0400)
class AClothesBackpack : public ACustomizationClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesBackpack">();
	}
	static class AClothesBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesBackpack>();
	}
};
static_assert(alignof(AClothesBackpack) == 0x000008, "Wrong alignment on AClothesBackpack");
static_assert(sizeof(AClothesBackpack) == 0x000400, "Wrong size on AClothesBackpack");

// Class Flame.ClothesGloves
// 0x0000 (0x0400 - 0x0400)
class AClothesGloves : public ACustomizationClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesGloves">();
	}
	static class AClothesGloves* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesGloves>();
	}
};
static_assert(alignof(AClothesGloves) == 0x000008, "Wrong alignment on AClothesGloves");
static_assert(sizeof(AClothesGloves) == 0x000400, "Wrong size on AClothesGloves");

// Class Flame.CustomizationGesture
// 0x0000 (0x0400 - 0x0400)
class ACustomizationGesture : public ACustomization
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationGesture">();
	}
	static class ACustomizationGesture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationGesture>();
	}
};
static_assert(alignof(ACustomizationGesture) == 0x000008, "Wrong alignment on ACustomizationGesture");
static_assert(sizeof(ACustomizationGesture) == 0x000400, "Wrong size on ACustomizationGesture");

// Class Flame.MatchmakingStatus
// 0x0060 (0x0318 - 0x02B8)
class UMatchmakingStatus : public UFlameWidget
{
public:
	bool                                          bIsInGroupMode;                                    // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchmakingStatusState                       CurrentState;                                      // 0x02B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowElapsedTime;                                  // 0x02BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0xD];                                      // 0x02BB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeUserCancelled;                               // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LevelName;                                         // 0x02CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     InProgressMaterial;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WarningIcon;                                       // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LevelNameText;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             StatusMessage;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ElapsedTimeText;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 StatusImage;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GroupIcon;                                         // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionCancel;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCancelHold();
	void OnCancelReleased();
	void OnHide();
	void OnMatchmakingCancelled();
	void OnMenuClosed(class UMenuWidget* MenuWidget);
	void OnMenuOpened(class UMenuWidget* MenuWidget);
	void OnPlayerCancelledMatchmaking(const struct FUniqueNetIdRepl& NetId);
	void OnPlayerStartedMatchmaking(const struct FUniqueNetIdRepl& NetId);
	void OnServerFound();
	void OnShow();
	void OnStateChanged();
	void ServerFound();
	void SetLevelName(const class FName& InLevelName);
	void SetMessage(const class FText& InMessage);
	void SetState(EMatchmakingStatusState InState);
	void ShowElapsedTime(bool bInShowElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingStatus">();
	}
	static class UMatchmakingStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingStatus>();
	}
};
static_assert(alignof(UMatchmakingStatus) == 0x000008, "Wrong alignment on UMatchmakingStatus");
static_assert(sizeof(UMatchmakingStatus) == 0x000318, "Wrong size on UMatchmakingStatus");
static_assert(offsetof(UMatchmakingStatus, bIsInGroupMode) == 0x0002B8, "Member 'UMatchmakingStatus::bIsInGroupMode' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, CurrentState) == 0x0002B9, "Member 'UMatchmakingStatus::CurrentState' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, bShowElapsedTime) == 0x0002BA, "Member 'UMatchmakingStatus::bShowElapsedTime' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, bCanBeUserCancelled) == 0x0002C8, "Member 'UMatchmakingStatus::bCanBeUserCancelled' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, LevelName) == 0x0002CC, "Member 'UMatchmakingStatus::LevelName' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, InProgressMaterial) == 0x0002D8, "Member 'UMatchmakingStatus::InProgressMaterial' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, WarningIcon) == 0x0002E0, "Member 'UMatchmakingStatus::WarningIcon' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, LevelNameText) == 0x0002E8, "Member 'UMatchmakingStatus::LevelNameText' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, StatusMessage) == 0x0002F0, "Member 'UMatchmakingStatus::StatusMessage' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, ElapsedTimeText) == 0x0002F8, "Member 'UMatchmakingStatus::ElapsedTimeText' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, StatusImage) == 0x000300, "Member 'UMatchmakingStatus::StatusImage' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, GroupIcon) == 0x000308, "Member 'UMatchmakingStatus::GroupIcon' has a wrong offset!");
static_assert(offsetof(UMatchmakingStatus, ActionCancel) == 0x000310, "Member 'UMatchmakingStatus::ActionCancel' has a wrong offset!");

// Class Flame.FlameSpringArmComponent
// 0x0060 (0x02E0 - 0x0280)
class UFlameSpringArmComponent final : public USpringArmComponent
{
public:
	float                                         ExtendSpeed;                                       // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetractSpeed;                                      // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetractProbeSize;                                  // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmPercentageSpeed;                          // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x9];                                      // 0x0290(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanRetractArm;                                    // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalHorizontalRayOffset;                     // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalHorizontalRayProbeSize;                  // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaxRelativeZ;                                // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRelativeZSmoothness;                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRelativeZSpeed;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehindProbeSize;                                   // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalPushBack;                                // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearTargetArmPercentage();
	void SetArmPercentage(float Percentage);
	void SetMaxRelativeZSettings(const float NewMaxRelativeZ, const float NewSmoothness, const float TransitionSpeed);
	void SetTargetArmPercentage(const float TargetArmPercentage);

	float GetArmPercentage() const;
	bool HasRecentHit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameSpringArmComponent">();
	}
	static class UFlameSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameSpringArmComponent>();
	}
};
static_assert(alignof(UFlameSpringArmComponent) == 0x000010, "Wrong alignment on UFlameSpringArmComponent");
static_assert(sizeof(UFlameSpringArmComponent) == 0x0002E0, "Wrong size on UFlameSpringArmComponent");
static_assert(offsetof(UFlameSpringArmComponent, ExtendSpeed) == 0x000280, "Member 'UFlameSpringArmComponent::ExtendSpeed' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, RetractSpeed) == 0x000284, "Member 'UFlameSpringArmComponent::RetractSpeed' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, RetractProbeSize) == 0x000288, "Member 'UFlameSpringArmComponent::RetractProbeSize' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, TargetArmPercentageSpeed) == 0x00028C, "Member 'UFlameSpringArmComponent::TargetArmPercentageSpeed' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, bCanRetractArm) == 0x000299, "Member 'UFlameSpringArmComponent::bCanRetractArm' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, AdditionalHorizontalRayOffset) == 0x00029C, "Member 'UFlameSpringArmComponent::AdditionalHorizontalRayOffset' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, AdditionalHorizontalRayProbeSize) == 0x0002A0, "Member 'UFlameSpringArmComponent::AdditionalHorizontalRayProbeSize' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, TargetMaxRelativeZ) == 0x0002A4, "Member 'UFlameSpringArmComponent::TargetMaxRelativeZ' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, TargetRelativeZSmoothness) == 0x0002A8, "Member 'UFlameSpringArmComponent::TargetRelativeZSmoothness' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, MaxRelativeZSpeed) == 0x0002AC, "Member 'UFlameSpringArmComponent::MaxRelativeZSpeed' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, BehindProbeSize) == 0x0002B0, "Member 'UFlameSpringArmComponent::BehindProbeSize' has a wrong offset!");
static_assert(offsetof(UFlameSpringArmComponent, AdditionalPushBack) == 0x0002B4, "Member 'UFlameSpringArmComponent::AdditionalPushBack' has a wrong offset!");

// Class Flame.CustomizationFunctions
// 0x0000 (0x0028 - 0x0028)
class UCustomizationFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplyCustomizationOnMannequin(class AHumanPlayerController* Player, class AMannequin* TargetMannequin, const struct FCustomizationContainer& SourceCustomizationsArray);
	static class UTexture2D* CaptureTextureFromRenderTarget(class USceneCaptureComponent2D* SceneCapture, const class FString& TextureName);
	static void ClearCustomizationSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot);
	static TArray<TSubclassOf<class ACustomization>> GetAllCustomizations(class AHumanPlayerController* Player);
	static class UInventoryCustomizationComponent* GetClothesComponent(const class AHumanPlayerController* Player);
	static struct FCustomizationInfo GetCustomizationInfo(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization);
	static struct FCustomizationPair GetCustomizationInSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot);
	static class USkeletalMesh* GetCustomizationMesh(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization);
	static void GetCustomizationPreview(class AHumanPlayerController* Player, class AMannequin* TargetMannequin, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant);
	static TArray<TSubclassOf<class ACustomization>> GetCustomizationsByClass(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Filter);
	static TArray<TSubclassOf<class ACustomizationVariant>> GetCustomizationVariantsForBundle(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationVariantBundle> Bundle);
	static void GetGender(TSubclassOf<class ACustomizationVariant> ArchetypeVariant, TSubclassOf<class AGender>* Gender, bool* IsFemale);
	static TArray<TSubclassOf<class ACustomization>> GetHighlightedCustomizations(class AHumanPlayerController* Player);
	static TArray<TSubclassOf<class ACustomization>> GetOwnedCustomizations(class AHumanPlayerController* Player);
	static TArray<TSubclassOf<class ACustomizationVariant>> GetOwnedCustomizationVariants(class AHumanPlayerController* Player);
	static class UShelterCustomizationComponent* GetWardrobeComponent(const class AHumanPlayerController* Player);
	static bool IsCustomizationCompatibleWithSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationSlot> Slot);
	static bool IsCustomizationSlotAvailable(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot);
	static TArray<TSubclassOf<class ACustomization>> LinkedCustomizationsInNeededSlots(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization);
	static TArray<TSubclassOf<class ACustomizationSlot>> NeededSlotsForCustomization(class AHumanPlayerController* Player, TSubclassOf<class ACustomization> Customization);
	static void SetCustomizationToSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant);
	static void SetGestureToSlot(class AHumanPlayerController* Player, TSubclassOf<class ACustomizationSlot> Slot, TSubclassOf<class ACustomizationVariant> Variant);
	static bool SetMeshFromCustomizationToComponent(class AHumanPlayerController* Player, class UCustomisationMeshComponent* TargetComponent, TSubclassOf<class ACustomization> Customization, TSubclassOf<class ACustomizationVariant> Variant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationFunctions">();
	}
	static class UCustomizationFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationFunctions>();
	}
};
static_assert(alignof(UCustomizationFunctions) == 0x000008, "Wrong alignment on UCustomizationFunctions");
static_assert(sizeof(UCustomizationFunctions) == 0x000028, "Wrong size on UCustomizationFunctions");

// Class Flame.FootStepNotify
// 0x0008 (0x0040 - 0x0038)
class UFootStepNotify : public UAnimNotify
{
public:
	EFootStepMovementType                         FootStepMovementType;                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepNotify">();
	}
	static class UFootStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepNotify>();
	}
};
static_assert(alignof(UFootStepNotify) == 0x000008, "Wrong alignment on UFootStepNotify");
static_assert(sizeof(UFootStepNotify) == 0x000040, "Wrong size on UFootStepNotify");
static_assert(offsetof(UFootStepNotify, FootStepMovementType) == 0x000038, "Member 'UFootStepNotify::FootStepMovementType' has a wrong offset!");

// Class Flame.RightFootStepNotify
// 0x0000 (0x0040 - 0x0040)
class URightFootStepNotify final : public UFootStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightFootStepNotify">();
	}
	static class URightFootStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URightFootStepNotify>();
	}
};
static_assert(alignof(URightFootStepNotify) == 0x000008, "Wrong alignment on URightFootStepNotify");
static_assert(sizeof(URightFootStepNotify) == 0x000040, "Wrong size on URightFootStepNotify");

// Class Flame.CustomizationHair
// 0x0018 (0x0418 - 0x0400)
class ACustomizationHair : public ACustomizationBody
{
public:
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             RulesTable;                                        // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class USkeletalMesh* GetMeshForGenderAndOverlapCustomization(TSubclassOf<class AGender> Gender, TSubclassOf<class ACustomization> Headgear) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHair">();
	}
	static class ACustomizationHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationHair>();
	}
};
static_assert(alignof(ACustomizationHair) == 0x000008, "Wrong alignment on ACustomizationHair");
static_assert(sizeof(ACustomizationHair) == 0x000418, "Wrong size on ACustomizationHair");
static_assert(offsetof(ACustomizationHair, RulesTable) == 0x000410, "Member 'ACustomizationHair::RulesTable' has a wrong offset!");

// Class Flame.EquipmentStorageComponent
// 0x0150 (0x0200 - 0x00B0)
class UEquipmentStorageComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xA0];                                      // 0x00B0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             EventOnStoredBagItem;                              // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             EventOnRemovedBagItem;                             // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             EventOnStoredWeapon;                               // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             EventOnStoredPlan;                                 // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             EventOnRemovedWeapon;                              // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UWeaponsStorage*                        Weapons;                                           // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemsList*                             Collectibles;                                      // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x50];                                     // 0x01B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BlueprintStoreObject(class AItem* OneItem);
	void OnRep_PostChangeItems(class UItemsList* OldContainer);
	void OnRep_PostChangeWeapons(class UWeaponsStorage* OldContainer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentStorageComponent">();
	}
	static class UEquipmentStorageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentStorageComponent>();
	}
};
static_assert(alignof(UEquipmentStorageComponent) == 0x000008, "Wrong alignment on UEquipmentStorageComponent");
static_assert(sizeof(UEquipmentStorageComponent) == 0x000200, "Wrong size on UEquipmentStorageComponent");
static_assert(offsetof(UEquipmentStorageComponent, EventOnStoredBagItem) == 0x000150, "Member 'UEquipmentStorageComponent::EventOnStoredBagItem' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, EventOnRemovedBagItem) == 0x000160, "Member 'UEquipmentStorageComponent::EventOnRemovedBagItem' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, EventOnStoredWeapon) == 0x000170, "Member 'UEquipmentStorageComponent::EventOnStoredWeapon' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, EventOnStoredPlan) == 0x000180, "Member 'UEquipmentStorageComponent::EventOnStoredPlan' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, EventOnRemovedWeapon) == 0x000190, "Member 'UEquipmentStorageComponent::EventOnRemovedWeapon' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, Weapons) == 0x0001A0, "Member 'UEquipmentStorageComponent::Weapons' has a wrong offset!");
static_assert(offsetof(UEquipmentStorageComponent, Collectibles) == 0x0001A8, "Member 'UEquipmentStorageComponent::Collectibles' has a wrong offset!");

// Class Flame.LootOnGroundComponent
// 0x0000 (0x0200 - 0x0200)
class ULootOnGroundComponent : public UEquipmentStorageComponent
{
public:
	bool ClearItems();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootOnGroundComponent">();
	}
	static class ULootOnGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootOnGroundComponent>();
	}
};
static_assert(alignof(ULootOnGroundComponent) == 0x000008, "Wrong alignment on ULootOnGroundComponent");
static_assert(sizeof(ULootOnGroundComponent) == 0x000200, "Wrong size on ULootOnGroundComponent");

// Class Flame.CorpseOnGroundComponent
// 0x0000 (0x0200 - 0x0200)
class UCorpseOnGroundComponent final : public ULootOnGroundComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorpseOnGroundComponent">();
	}
	static class UCorpseOnGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorpseOnGroundComponent>();
	}
};
static_assert(alignof(UCorpseOnGroundComponent) == 0x000008, "Wrong alignment on UCorpseOnGroundComponent");
static_assert(sizeof(UCorpseOnGroundComponent) == 0x000200, "Wrong size on UCorpseOnGroundComponent");

// Class Flame.CustomizationSettings
// 0x0040 (0x0078 - 0x0038)
class UCustomizationSettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        TableWithHairData;                                 // 0x0038(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        TableWithHeadgearData;                             // 0x0050(0x0018)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithHairDataLink;                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TableWithHeadgearDataLink;                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSettings">();
	}
	static class UCustomizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSettings>();
	}
};
static_assert(alignof(UCustomizationSettings) == 0x000008, "Wrong alignment on UCustomizationSettings");
static_assert(sizeof(UCustomizationSettings) == 0x000078, "Wrong size on UCustomizationSettings");
static_assert(offsetof(UCustomizationSettings, TableWithHairData) == 0x000038, "Member 'UCustomizationSettings::TableWithHairData' has a wrong offset!");
static_assert(offsetof(UCustomizationSettings, TableWithHeadgearData) == 0x000050, "Member 'UCustomizationSettings::TableWithHeadgearData' has a wrong offset!");
static_assert(offsetof(UCustomizationSettings, TableWithHairDataLink) == 0x000068, "Member 'UCustomizationSettings::TableWithHairDataLink' has a wrong offset!");
static_assert(offsetof(UCustomizationSettings, TableWithHeadgearDataLink) == 0x000070, "Member 'UCustomizationSettings::TableWithHeadgearDataLink' has a wrong offset!");

// Class Flame.GameControlComponent
// 0x0008 (0x00B8 - 0x00B0)
class UGameControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameControlComponent">();
	}
	static class UGameControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameControlComponent>();
	}
};
static_assert(alignof(UGameControlComponent) == 0x000008, "Wrong alignment on UGameControlComponent");
static_assert(sizeof(UGameControlComponent) == 0x0000B8, "Wrong size on UGameControlComponent");

// Class Flame.CustomizationSlot
// 0x0010 (0x03A8 - 0x0398)
class ACustomizationSlot : public AItem
{
public:
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMandatory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlot">();
	}
	static class ACustomizationSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlot>();
	}
};
static_assert(alignof(ACustomizationSlot) == 0x000008, "Wrong alignment on ACustomizationSlot");
static_assert(sizeof(ACustomizationSlot) == 0x0003A8, "Wrong size on ACustomizationSlot");

// Class Flame.CustomizationSlotArchetype
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotArchetype : public ACustomizationSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotArchetype">();
	}
	static class ACustomizationSlotArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotArchetype>();
	}
};
static_assert(alignof(ACustomizationSlotArchetype) == 0x000008, "Wrong alignment on ACustomizationSlotArchetype");
static_assert(sizeof(ACustomizationSlotArchetype) == 0x0003A8, "Wrong size on ACustomizationSlotArchetype");

// Class Flame.LeftLegProneStepNotify
// 0x0000 (0x0040 - 0x0040)
class ULeftLegProneStepNotify final : public UProneStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeftLegProneStepNotify">();
	}
	static class ULeftLegProneStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeftLegProneStepNotify>();
	}
};
static_assert(alignof(ULeftLegProneStepNotify) == 0x000008, "Wrong alignment on ULeftLegProneStepNotify");
static_assert(sizeof(ULeftLegProneStepNotify) == 0x000040, "Wrong size on ULeftLegProneStepNotify");

// Class Flame.CustomizationSlotBody
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotBody : public ACustomizationSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotBody">();
	}
	static class ACustomizationSlotBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotBody>();
	}
};
static_assert(alignof(ACustomizationSlotBody) == 0x000008, "Wrong alignment on ACustomizationSlotBody");
static_assert(sizeof(ACustomizationSlotBody) == 0x0003A8, "Wrong size on ACustomizationSlotBody");

// Class Flame.CustomizationSlotHead
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotHead : public ACustomizationSlotBody
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotHead">();
	}
	static class ACustomizationSlotHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotHead>();
	}
};
static_assert(alignof(ACustomizationSlotHead) == 0x000008, "Wrong alignment on ACustomizationSlotHead");
static_assert(sizeof(ACustomizationSlotHead) == 0x0003A8, "Wrong size on ACustomizationSlotHead");

// Class Flame.CustomizationSlotHair
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotHair : public ACustomizationSlotBody
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotHair">();
	}
	static class ACustomizationSlotHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotHair>();
	}
};
static_assert(alignof(ACustomizationSlotHair) == 0x000008, "Wrong alignment on ACustomizationSlotHair");
static_assert(sizeof(ACustomizationSlotHair) == 0x0003A8, "Wrong size on ACustomizationSlotHair");

// Class Flame.CustomizationSlotClothes
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotClothes : public ACustomizationSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotClothes">();
	}
	static class ACustomizationSlotClothes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotClothes>();
	}
};
static_assert(alignof(ACustomizationSlotClothes) == 0x000008, "Wrong alignment on ACustomizationSlotClothes");
static_assert(sizeof(ACustomizationSlotClothes) == 0x0003A8, "Wrong size on ACustomizationSlotClothes");

// Class Flame.ClothesSlotUniform
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotUniform : public ACustomizationSlotClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotUniform">();
	}
	static class AClothesSlotUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotUniform>();
	}
};
static_assert(alignof(AClothesSlotUniform) == 0x000008, "Wrong alignment on AClothesSlotUniform");
static_assert(sizeof(AClothesSlotUniform) == 0x0003A8, "Wrong size on AClothesSlotUniform");

// Class Flame.ClothesSlotHeadgear
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotHeadgear : public ACustomizationSlotClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotHeadgear">();
	}
	static class AClothesSlotHeadgear* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotHeadgear>();
	}
};
static_assert(alignof(AClothesSlotHeadgear) == 0x000008, "Wrong alignment on AClothesSlotHeadgear");
static_assert(sizeof(AClothesSlotHeadgear) == 0x0003A8, "Wrong size on AClothesSlotHeadgear");

// Class Flame.GamepadIconWidget
// 0x0098 (0x0350 - 0x02B8)
class UGamepadIconWidget : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 GamepadIcon;                                       // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputIcon                                    Icon;                                              // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoldable;                                       // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldTime;                                          // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsumeActions;                                   // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x17];                                     // 0x02D1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundOnPress;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundOnHold;                                       // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundOnRelease;                                    // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHold;                                            // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReleased;                                        // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEnabled;                                         // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDisabled;                                        // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void ConsumeActions(const bool InValue);
	void NativeOnActionHold();
	void NativeOnActionPressed();
	void NativeOnActionReleased();
	void NativeOnDisabled();
	void NativeOnEnabled();
	void OnActionHold();
	void OnActionPressed();
	void OnActionReleased();
	void SetHoldTime(float TimeInSeconds);
	void SetIcon(const EInputIcon InIcon, const bool bInIsHoldable);
	void UpdateIconMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadIconWidget">();
	}
	static class UGamepadIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadIconWidget>();
	}
};
static_assert(alignof(UGamepadIconWidget) == 0x000008, "Wrong alignment on UGamepadIconWidget");
static_assert(sizeof(UGamepadIconWidget) == 0x000350, "Wrong size on UGamepadIconWidget");
static_assert(offsetof(UGamepadIconWidget, GamepadIcon) == 0x0002C0, "Member 'UGamepadIconWidget::GamepadIcon' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, Icon) == 0x0002C8, "Member 'UGamepadIconWidget::Icon' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, bIsHoldable) == 0x0002C9, "Member 'UGamepadIconWidget::bIsHoldable' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, HoldTime) == 0x0002CC, "Member 'UGamepadIconWidget::HoldTime' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, bConsumeActions) == 0x0002D0, "Member 'UGamepadIconWidget::bConsumeActions' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, SoundOnPress) == 0x0002E8, "Member 'UGamepadIconWidget::SoundOnPress' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, SoundOnHold) == 0x0002F0, "Member 'UGamepadIconWidget::SoundOnHold' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, SoundOnRelease) == 0x0002F8, "Member 'UGamepadIconWidget::SoundOnRelease' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, OnPressed) == 0x000300, "Member 'UGamepadIconWidget::OnPressed' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, OnHold) == 0x000310, "Member 'UGamepadIconWidget::OnHold' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, OnReleased) == 0x000320, "Member 'UGamepadIconWidget::OnReleased' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, OnEnabled) == 0x000330, "Member 'UGamepadIconWidget::OnEnabled' has a wrong offset!");
static_assert(offsetof(UGamepadIconWidget, OnDisabled) == 0x000340, "Member 'UGamepadIconWidget::OnDisabled' has a wrong offset!");

// Class Flame.GamepadChoiceWidget
// 0x0030 (0x0380 - 0x0350)
class UGamepadChoiceWidget final : public UGamepadIconWidget
{
public:
	class FString                                 Separator;                                         // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColor;                                       // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedColor;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetSelectedIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadChoiceWidget">();
	}
	static class UGamepadChoiceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadChoiceWidget>();
	}
};
static_assert(alignof(UGamepadChoiceWidget) == 0x000008, "Wrong alignment on UGamepadChoiceWidget");
static_assert(sizeof(UGamepadChoiceWidget) == 0x000380, "Wrong size on UGamepadChoiceWidget");
static_assert(offsetof(UGamepadChoiceWidget, Separator) == 0x000350, "Member 'UGamepadChoiceWidget::Separator' has a wrong offset!");
static_assert(offsetof(UGamepadChoiceWidget, NormalColor) == 0x000360, "Member 'UGamepadChoiceWidget::NormalColor' has a wrong offset!");
static_assert(offsetof(UGamepadChoiceWidget, SelectedColor) == 0x000370, "Member 'UGamepadChoiceWidget::SelectedColor' has a wrong offset!");

// Class Flame.ClothesSlotHeadgearTop
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotHeadgearTop : public AClothesSlotHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotHeadgearTop">();
	}
	static class AClothesSlotHeadgearTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotHeadgearTop>();
	}
};
static_assert(alignof(AClothesSlotHeadgearTop) == 0x000008, "Wrong alignment on AClothesSlotHeadgearTop");
static_assert(sizeof(AClothesSlotHeadgearTop) == 0x0003A8, "Wrong size on AClothesSlotHeadgearTop");

// Class Flame.ClothesSlotHeadgearMiddle
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotHeadgearMiddle : public AClothesSlotHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotHeadgearMiddle">();
	}
	static class AClothesSlotHeadgearMiddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotHeadgearMiddle>();
	}
};
static_assert(alignof(AClothesSlotHeadgearMiddle) == 0x000008, "Wrong alignment on AClothesSlotHeadgearMiddle");
static_assert(sizeof(AClothesSlotHeadgearMiddle) == 0x0003A8, "Wrong size on AClothesSlotHeadgearMiddle");

// Class Flame.FirstPersonFunctions
// 0x0000 (0x0028 - 0x0028)
class UFirstPersonFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector ConvertWorldToFirstPerson(const struct FVector& WorldPos, const struct FMinimalViewInfo& ViewInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonFunctions">();
	}
	static class UFirstPersonFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstPersonFunctions>();
	}
};
static_assert(alignof(UFirstPersonFunctions) == 0x000008, "Wrong alignment on UFirstPersonFunctions");
static_assert(sizeof(UFirstPersonFunctions) == 0x000028, "Wrong size on UFirstPersonFunctions");

// Class Flame.ClothesSlotHeadgearBottom
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotHeadgearBottom : public AClothesSlotHeadgear
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotHeadgearBottom">();
	}
	static class AClothesSlotHeadgearBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotHeadgearBottom>();
	}
};
static_assert(alignof(AClothesSlotHeadgearBottom) == 0x000008, "Wrong alignment on AClothesSlotHeadgearBottom");
static_assert(sizeof(AClothesSlotHeadgearBottom) == 0x0003A8, "Wrong size on AClothesSlotHeadgearBottom");

// Class Flame.RoundLoadedNotify
// 0x0000 (0x0038 - 0x0038)
class URoundLoadedNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoundLoadedNotify">();
	}
	static class URoundLoadedNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoundLoadedNotify>();
	}
};
static_assert(alignof(URoundLoadedNotify) == 0x000008, "Wrong alignment on URoundLoadedNotify");
static_assert(sizeof(URoundLoadedNotify) == 0x000038, "Wrong size on URoundLoadedNotify");

// Class Flame.ClothesSlotBackpack
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotBackpack : public ACustomizationSlotClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotBackpack">();
	}
	static class AClothesSlotBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotBackpack>();
	}
};
static_assert(alignof(AClothesSlotBackpack) == 0x000008, "Wrong alignment on AClothesSlotBackpack");
static_assert(sizeof(AClothesSlotBackpack) == 0x0003A8, "Wrong size on AClothesSlotBackpack");

// Class Flame.ClothesSlotGloves
// 0x0000 (0x03A8 - 0x03A8)
class AClothesSlotGloves : public ACustomizationSlotClothes
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothesSlotGloves">();
	}
	static class AClothesSlotGloves* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothesSlotGloves>();
	}
};
static_assert(alignof(AClothesSlotGloves) == 0x000008, "Wrong alignment on AClothesSlotGloves");
static_assert(sizeof(AClothesSlotGloves) == 0x0003A8, "Wrong size on AClothesSlotGloves");

// Class Flame.CustomizationSlotGesture
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGesture : public ACustomizationSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGesture">();
	}
	static class ACustomizationSlotGesture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGesture>();
	}
};
static_assert(alignof(ACustomizationSlotGesture) == 0x000008, "Wrong alignment on ACustomizationSlotGesture");
static_assert(sizeof(ACustomizationSlotGesture) == 0x0003A8, "Wrong size on ACustomizationSlotGesture");

// Class Flame.CustomizationSlotGestureTop
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureTop : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureTop">();
	}
	static class ACustomizationSlotGestureTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureTop>();
	}
};
static_assert(alignof(ACustomizationSlotGestureTop) == 0x000008, "Wrong alignment on ACustomizationSlotGestureTop");
static_assert(sizeof(ACustomizationSlotGestureTop) == 0x0003A8, "Wrong size on ACustomizationSlotGestureTop");

// Class Flame.CustomizationSlotGestureTopRight
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureTopRight : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureTopRight">();
	}
	static class ACustomizationSlotGestureTopRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureTopRight>();
	}
};
static_assert(alignof(ACustomizationSlotGestureTopRight) == 0x000008, "Wrong alignment on ACustomizationSlotGestureTopRight");
static_assert(sizeof(ACustomizationSlotGestureTopRight) == 0x0003A8, "Wrong size on ACustomizationSlotGestureTopRight");

// Class Flame.GameStorePurchaseHandler
// 0x0058 (0x0080 - 0x0028)
class UGameStorePurchaseHandler : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStorePurchaseHandler">();
	}
	static class UGameStorePurchaseHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStorePurchaseHandler>();
	}
};
static_assert(alignof(UGameStorePurchaseHandler) == 0x000008, "Wrong alignment on UGameStorePurchaseHandler");
static_assert(sizeof(UGameStorePurchaseHandler) == 0x000080, "Wrong size on UGameStorePurchaseHandler");

// Class Flame.CustomizationSlotGestureRight
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureRight : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureRight">();
	}
	static class ACustomizationSlotGestureRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureRight>();
	}
};
static_assert(alignof(ACustomizationSlotGestureRight) == 0x000008, "Wrong alignment on ACustomizationSlotGestureRight");
static_assert(sizeof(ACustomizationSlotGestureRight) == 0x0003A8, "Wrong size on ACustomizationSlotGestureRight");

// Class Flame.CustomizationSlotGestureBottomRight
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureBottomRight : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureBottomRight">();
	}
	static class ACustomizationSlotGestureBottomRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureBottomRight>();
	}
};
static_assert(alignof(ACustomizationSlotGestureBottomRight) == 0x000008, "Wrong alignment on ACustomizationSlotGestureBottomRight");
static_assert(sizeof(ACustomizationSlotGestureBottomRight) == 0x0003A8, "Wrong size on ACustomizationSlotGestureBottomRight");

// Class Flame.CustomizationSlotGestureBottom
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureBottom : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureBottom">();
	}
	static class ACustomizationSlotGestureBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureBottom>();
	}
};
static_assert(alignof(ACustomizationSlotGestureBottom) == 0x000008, "Wrong alignment on ACustomizationSlotGestureBottom");
static_assert(sizeof(ACustomizationSlotGestureBottom) == 0x0003A8, "Wrong size on ACustomizationSlotGestureBottom");

// Class Flame.CustomizationSlotGestureBottomLeft
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureBottomLeft : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureBottomLeft">();
	}
	static class ACustomizationSlotGestureBottomLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureBottomLeft>();
	}
};
static_assert(alignof(ACustomizationSlotGestureBottomLeft) == 0x000008, "Wrong alignment on ACustomizationSlotGestureBottomLeft");
static_assert(sizeof(ACustomizationSlotGestureBottomLeft) == 0x0003A8, "Wrong size on ACustomizationSlotGestureBottomLeft");

// Class Flame.GameMenuTeamScreen
// 0x0040 (0x0318 - 0x02D8)
class UGameMenuTeamScreen : public UMenuWidget
{
public:
	class UInputActionWidget*                     ActionInvite;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        ActionInviteDescription;                           // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionLeave;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        ActionLeaveDescription;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGroupMemberListWidget*                 PlayerList;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SpecialActionsPanel;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     SpecialActionTutorial;                             // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSkipTutorial();
	void OnStartMatchmaking();
	void OnStartTutorial();

	bool IsInviteAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuTeamScreen">();
	}
	static class UGameMenuTeamScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuTeamScreen>();
	}
};
static_assert(alignof(UGameMenuTeamScreen) == 0x000008, "Wrong alignment on UGameMenuTeamScreen");
static_assert(sizeof(UGameMenuTeamScreen) == 0x000318, "Wrong size on UGameMenuTeamScreen");
static_assert(offsetof(UGameMenuTeamScreen, ActionInvite) == 0x0002D8, "Member 'UGameMenuTeamScreen::ActionInvite' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, ActionInviteDescription) == 0x0002E0, "Member 'UGameMenuTeamScreen::ActionInviteDescription' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, ActionLeave) == 0x0002E8, "Member 'UGameMenuTeamScreen::ActionLeave' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, ActionLeaveDescription) == 0x0002F0, "Member 'UGameMenuTeamScreen::ActionLeaveDescription' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, PlayerList) == 0x0002F8, "Member 'UGameMenuTeamScreen::PlayerList' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, SpecialActionsPanel) == 0x000300, "Member 'UGameMenuTeamScreen::SpecialActionsPanel' has a wrong offset!");
static_assert(offsetof(UGameMenuTeamScreen, SpecialActionTutorial) == 0x000308, "Member 'UGameMenuTeamScreen::SpecialActionTutorial' has a wrong offset!");

// Class Flame.CustomizationSlotGestureLeft
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureLeft : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureLeft">();
	}
	static class ACustomizationSlotGestureLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureLeft>();
	}
};
static_assert(alignof(ACustomizationSlotGestureLeft) == 0x000008, "Wrong alignment on ACustomizationSlotGestureLeft");
static_assert(sizeof(ACustomizationSlotGestureLeft) == 0x0003A8, "Wrong size on ACustomizationSlotGestureLeft");

// Class Flame.CustomizationSlotGestureTopLeft
// 0x0000 (0x03A8 - 0x03A8)
class ACustomizationSlotGestureTopLeft : public ACustomizationSlotGesture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotGestureTopLeft">();
	}
	static class ACustomizationSlotGestureTopLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationSlotGestureTopLeft>();
	}
};
static_assert(alignof(ACustomizationSlotGestureTopLeft) == 0x000008, "Wrong alignment on ACustomizationSlotGestureTopLeft");
static_assert(sizeof(ACustomizationSlotGestureTopLeft) == 0x0003A8, "Wrong size on ACustomizationSlotGestureTopLeft");

// Class Flame.GameStoreOffers
// 0x0040 (0x0068 - 0x0028)
class UGameStoreOffers final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameStoreData                         StoredData;                                        // 0x0040(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStoreOffersStateChanged;                     // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GameStoreOffersStateChanged__DelegateSignature(EGameStoreOffersState OldState, EGameStoreOffersState NewState);
	void OnPlatformStoreOffersChanges(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState);
	bool StartDownloadOfOffers();

	const struct FGameStoreData GetGameStoreData() const;
	const struct FGameStoreProductInfo GetGameStoreProductInfo(const struct FGameStoreProductId& ProductId, bool* ProductFound) const;
	const struct FGameStoreProductInfo GetGameStoreProductInfoById(const class FString& ProductId, bool* ProductFound) const;
	const struct FGameStoreInfo GetGameStoreSlotInfo(const class FString& StoreName, bool* StoreFound) const;
	EGameStoreOffersState GetOffersManagerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStoreOffers">();
	}
	static class UGameStoreOffers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStoreOffers>();
	}
};
static_assert(alignof(UGameStoreOffers) == 0x000008, "Wrong alignment on UGameStoreOffers");
static_assert(sizeof(UGameStoreOffers) == 0x000068, "Wrong size on UGameStoreOffers");
static_assert(offsetof(UGameStoreOffers, StoredData) == 0x000040, "Member 'UGameStoreOffers::StoredData' has a wrong offset!");
static_assert(offsetof(UGameStoreOffers, OnGameStoreOffersStateChanged) == 0x000058, "Member 'UGameStoreOffers::OnGameStoreOffersStateChanged' has a wrong offset!");

// Class Flame.CustomizationVariant
// 0x00A0 (0x0438 - 0x0398)
class ACustomizationVariant : public AItem
{
public:
	uint8                                         Pad_398[0x50];                                     // 0x0398(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class ACustomizationArchetype>, struct FCustomizatinMaterials> ArchetypeMaterialOverrides;                        // 0x03E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FCustomizatinMaterials GetArchetypeMaterialOverrides(TSubclassOf<class ACustomizationArchetype> Archetype) const;
	TSubclassOf<class ACustomizationVariantBundle> GetCustomizationBundle() const;
	TSubclassOf<class ACustomization> GetCustomizationClass() const;
	ESoundTextureType GetSoundTexture() const;
	EVoiceModifierType GetVoiceModifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationVariant">();
	}
	static class ACustomizationVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationVariant>();
	}
};
static_assert(alignof(ACustomizationVariant) == 0x000008, "Wrong alignment on ACustomizationVariant");
static_assert(sizeof(ACustomizationVariant) == 0x000438, "Wrong size on ACustomizationVariant");
static_assert(offsetof(ACustomizationVariant, ArchetypeMaterialOverrides) == 0x0003E8, "Member 'ACustomizationVariant::ArchetypeMaterialOverrides' has a wrong offset!");

// Class Flame.CustomizationGestureVariant
// 0x0020 (0x0458 - 0x0438)
class ACustomizationGestureVariant : public ACustomizationVariant
{
public:
	uint8                                         Pad_438[0x20];                                     // 0x0438(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimMontage* GetAnimationMontage() const;
	class UAnimSequence* GetShelterPreviewStaticPose() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationGestureVariant">();
	}
	static class ACustomizationGestureVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationGestureVariant>();
	}
};
static_assert(alignof(ACustomizationGestureVariant) == 0x000008, "Wrong alignment on ACustomizationGestureVariant");
static_assert(sizeof(ACustomizationGestureVariant) == 0x000458, "Wrong size on ACustomizationGestureVariant");

// Class Flame.GesturesConfig
// 0x0050 (0x0078 - 0x0028)
class UGesturesConfig final : public UObject
{
public:
	TMap<class FName, struct FGestureDesc>        Items;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GesturesConfig">();
	}
	static class UGesturesConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGesturesConfig>();
	}
};
static_assert(alignof(UGesturesConfig) == 0x000008, "Wrong alignment on UGesturesConfig");
static_assert(sizeof(UGesturesConfig) == 0x000078, "Wrong size on UGesturesConfig");
static_assert(offsetof(UGesturesConfig, Items) == 0x000028, "Member 'UGesturesConfig::Items' has a wrong offset!");

// Class Flame.CustomizationVariantBundle
// 0x0000 (0x0398 - 0x0398)
class ACustomizationVariantBundle : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationVariantBundle">();
	}
	static class ACustomizationVariantBundle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationVariantBundle>();
	}
};
static_assert(alignof(ACustomizationVariantBundle) == 0x000008, "Wrong alignment on ACustomizationVariantBundle");
static_assert(sizeof(ACustomizationVariantBundle) == 0x000398, "Wrong size on ACustomizationVariantBundle");

// Class Flame.GameStoreSellingPoints
// 0x0298 (0x02C0 - 0x0028)
class UGameStoreSellingPoints : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameStoreSellingPointsData            SellingPoints;                                     // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FSortedSellingpoints                   FilteredSellingPoints;                             // 0x0090(0x0210)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStoreSellingPointsStateChanged;              // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GameStoreSellingPointsStateChanged__DelegateSignature(EGameStoreSellingPointsState OldState, EGameStoreSellingPointsState NewState);
	struct FSortedSellingpoints GetSellingPointsFilteredDebug(class AHumanPlayerController* Player, const struct FDateTime& NowTime);
	struct FSortedSellingpoints GetSellingPointsFilteredOwnedAndActive(class AHumanPlayerController* Player);
	bool StartDownloadOfSellingPoints();

	const struct FGameStoreSellingPointInfo GetGameSellingPointInfoForItem(const TSubclassOf<class AItem> Item, bool* ProductFound) const;
	const struct FGameStoreSellingPointsData GetSellingPointsData() const;
	EGameStoreSellingPointsState GetSellingPointsManagerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStoreSellingPoints">();
	}
	static class UGameStoreSellingPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStoreSellingPoints>();
	}
};
static_assert(alignof(UGameStoreSellingPoints) == 0x000008, "Wrong alignment on UGameStoreSellingPoints");
static_assert(sizeof(UGameStoreSellingPoints) == 0x0002C0, "Wrong size on UGameStoreSellingPoints");
static_assert(offsetof(UGameStoreSellingPoints, SellingPoints) == 0x000040, "Member 'UGameStoreSellingPoints::SellingPoints' has a wrong offset!");
static_assert(offsetof(UGameStoreSellingPoints, FilteredSellingPoints) == 0x000090, "Member 'UGameStoreSellingPoints::FilteredSellingPoints' has a wrong offset!");
static_assert(offsetof(UGameStoreSellingPoints, OnGameStoreSellingPointsStateChanged) == 0x0002B0, "Member 'UGameStoreSellingPoints::OnGameStoreSellingPointsStateChanged' has a wrong offset!");

// Class Flame.UpdateableWidget
// 0x0040 (0x0318 - 0x02D8)
class UUpdateableWidget : public UMenuWidget
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USelectableWidget*                      SelectedSlotFrom;                                  // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USelectableWidget*                      SelectedSlotTo;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryView                                CurrentView;                                       // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x17];                                     // 0x02F1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnOperationSucceeded;                              // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void OnModelUpdate();
	void OnViewUpdate();
	void ResetSelection();
	void UpdateView();

	bool IsViewUpdateNecessary() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateableWidget">();
	}
	static class UUpdateableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateableWidget>();
	}
};
static_assert(alignof(UUpdateableWidget) == 0x000008, "Wrong alignment on UUpdateableWidget");
static_assert(sizeof(UUpdateableWidget) == 0x000318, "Wrong size on UUpdateableWidget");
static_assert(offsetof(UUpdateableWidget, SelectedSlotFrom) == 0x0002E0, "Member 'UUpdateableWidget::SelectedSlotFrom' has a wrong offset!");
static_assert(offsetof(UUpdateableWidget, SelectedSlotTo) == 0x0002E8, "Member 'UUpdateableWidget::SelectedSlotTo' has a wrong offset!");
static_assert(offsetof(UUpdateableWidget, CurrentView) == 0x0002F0, "Member 'UUpdateableWidget::CurrentView' has a wrong offset!");
static_assert(offsetof(UUpdateableWidget, OnOperationSucceeded) == 0x000308, "Member 'UUpdateableWidget::OnOperationSucceeded' has a wrong offset!");

// Class Flame.CustomizeCharacterScreen
// 0x0000 (0x0318 - 0x0318)
class UCustomizeCharacterScreen final : public UUpdateableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizeCharacterScreen">();
	}
	static class UCustomizeCharacterScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizeCharacterScreen>();
	}
};
static_assert(alignof(UCustomizeCharacterScreen) == 0x000008, "Wrong alignment on UCustomizeCharacterScreen");
static_assert(sizeof(UCustomizeCharacterScreen) == 0x000318, "Wrong size on UCustomizeCharacterScreen");

// Class Flame.DataProvider
// 0x0058 (0x0080 - 0x0028)
class UDataProvider final : public UObject
{
public:
	class UCloudDataTables*                       CloudDataTables;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCloudClassConverter*                   ClassConverter;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCloudDataStructures*                   CloudDataStructures;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCloudDataDownloader*                   CloudDataDownloader;                               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDataProviderStateChanged;                        // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                AsyncWidget;                                       // 0x0078(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UCloudDataStructures* GetCloudStructures(const class UObject* WorldContextObject);
	static class UCloudDataTables* GetCloudTables(const class UObject* WorldContextObject);
	static class UDataProvider* GetDataProvider(const class UObject* WorldContextObject);

	void DataProviderStateChanged__DelegateSignature(EDataProviderState OldState, EDataProviderState NewState);

	class FString GetDataVersion() const;
	EDataProviderState GetState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataProvider">();
	}
	static class UDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataProvider>();
	}
};
static_assert(alignof(UDataProvider) == 0x000008, "Wrong alignment on UDataProvider");
static_assert(sizeof(UDataProvider) == 0x000080, "Wrong size on UDataProvider");
static_assert(offsetof(UDataProvider, CloudDataTables) == 0x000028, "Member 'UDataProvider::CloudDataTables' has a wrong offset!");
static_assert(offsetof(UDataProvider, ClassConverter) == 0x000030, "Member 'UDataProvider::ClassConverter' has a wrong offset!");
static_assert(offsetof(UDataProvider, CloudDataStructures) == 0x000038, "Member 'UDataProvider::CloudDataStructures' has a wrong offset!");
static_assert(offsetof(UDataProvider, CloudDataDownloader) == 0x000040, "Member 'UDataProvider::CloudDataDownloader' has a wrong offset!");
static_assert(offsetof(UDataProvider, OnDataProviderStateChanged) == 0x000068, "Member 'UDataProvider::OnDataProviderStateChanged' has a wrong offset!");
static_assert(offsetof(UDataProvider, AsyncWidget) == 0x000078, "Member 'UDataProvider::AsyncWidget' has a wrong offset!");

// Class Flame.DataProviderSettings
// 0x0070 (0x00A8 - 0x0038)
class UDataProviderSettings final : public UDeveloperSettings
{
public:
	struct FCloudDataDownloaderConfig             DataDownloader;                                    // 0x0038(0x0040)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudDataTablesConfig                 Tables;                                            // 0x0078(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudDataStructuresConfig             Structures;                                        // 0x0088(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FCloudClassConverterConfig             ClassConverter;                                    // 0x0098(0x0010)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataProviderSettings">();
	}
	static class UDataProviderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataProviderSettings>();
	}
};
static_assert(alignof(UDataProviderSettings) == 0x000008, "Wrong alignment on UDataProviderSettings");
static_assert(sizeof(UDataProviderSettings) == 0x0000A8, "Wrong size on UDataProviderSettings");
static_assert(offsetof(UDataProviderSettings, DataDownloader) == 0x000038, "Member 'UDataProviderSettings::DataDownloader' has a wrong offset!");
static_assert(offsetof(UDataProviderSettings, Tables) == 0x000078, "Member 'UDataProviderSettings::Tables' has a wrong offset!");
static_assert(offsetof(UDataProviderSettings, Structures) == 0x000088, "Member 'UDataProviderSettings::Structures' has a wrong offset!");
static_assert(offsetof(UDataProviderSettings, ClassConverter) == 0x000098, "Member 'UDataProviderSettings::ClassConverter' has a wrong offset!");

// Class Flame.Gender
// 0x0000 (0x0398 - 0x0398)
class AGender : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gender">();
	}
	static class AGender* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGender>();
	}
};
static_assert(alignof(AGender) == 0x000008, "Wrong alignment on AGender");
static_assert(sizeof(AGender) == 0x000398, "Wrong size on AGender");

// Class Flame.GenderMale
// 0x0000 (0x0398 - 0x0398)
class AGenderMale : public AGender
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenderMale">();
	}
	static class AGenderMale* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenderMale>();
	}
};
static_assert(alignof(AGenderMale) == 0x000008, "Wrong alignment on AGenderMale");
static_assert(sizeof(AGenderMale) == 0x000398, "Wrong size on AGenderMale");

// Class Flame.DataTableContainerBase
// 0x0070 (0x0098 - 0x0028)
class UDataTableContainerBase : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTable;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x38];                                      // 0x0060(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableContainerBase">();
	}
	static class UDataTableContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableContainerBase>();
	}
};
static_assert(alignof(UDataTableContainerBase) == 0x000008, "Wrong alignment on UDataTableContainerBase");
static_assert(sizeof(UDataTableContainerBase) == 0x000098, "Wrong size on UDataTableContainerBase");
static_assert(offsetof(UDataTableContainerBase, DataTable) == 0x000058, "Member 'UDataTableContainerBase::DataTable' has a wrong offset!");

// Class Flame.DataTableContainerAsset
// 0x0008 (0x00A0 - 0x0098)
class UDataTableContainerAsset final : public UDataTableContainerBase
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableContainerAsset">();
	}
	static class UDataTableContainerAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableContainerAsset>();
	}
};
static_assert(alignof(UDataTableContainerAsset) == 0x000008, "Wrong alignment on UDataTableContainerAsset");
static_assert(sizeof(UDataTableContainerAsset) == 0x0000A0, "Wrong size on UDataTableContainerAsset");

// Class Flame.PlayerListWidget
// 0x00A0 (0x0358 - 0x02B8)
class UPlayerListWidget : public UFlameWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerClicked;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerInfoWidget>          PlayerInfoWidgetClass;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           PlayerList;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x80];                                     // 0x02D8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayer(const struct FUniqueNetIdRepl& InPlayerNetId);
	void NativeOnPlayerClicked(class UListButtonWidget* ListButtonWidget);
	void NativeOnPlayerFocused(class UListButtonWidget* ListButtonWidget);
	void OnPlayerAdded(class UPlayerInfoWidget* AddedWidget);
	void RemoveAllPlayers();
	void RemovePlayer(const struct FUniqueNetIdRepl& InPlayerNetId);

	const struct FUniqueNetIdRepl GetFocusedPlayer() const;
	int32 GetPlayerCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerListWidget">();
	}
	static class UPlayerListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerListWidget>();
	}
};
static_assert(alignof(UPlayerListWidget) == 0x000008, "Wrong alignment on UPlayerListWidget");
static_assert(sizeof(UPlayerListWidget) == 0x000358, "Wrong size on UPlayerListWidget");
static_assert(offsetof(UPlayerListWidget, OnPlayerClicked) == 0x0002B8, "Member 'UPlayerListWidget::OnPlayerClicked' has a wrong offset!");
static_assert(offsetof(UPlayerListWidget, PlayerInfoWidgetClass) == 0x0002C8, "Member 'UPlayerListWidget::PlayerInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerListWidget, PlayerList) == 0x0002D0, "Member 'UPlayerListWidget::PlayerList' has a wrong offset!");

// Class Flame.GroupMemberListWidget
// 0x0000 (0x0358 - 0x0358)
class UGroupMemberListWidget : public UPlayerListWidget
{
public:
	void OnPlayerChangedState(const struct FUniqueNetIdRepl& NetId, EClientGroupState OldState, EClientGroupState NewState);
	void OnPlayerJoined(const struct FUniqueNetIdRepl& NetId, const class FString& GroupId);
	void OnPlayerLeft(const struct FUniqueNetIdRepl& NetId, const class FString& GroupId);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupMemberListWidget">();
	}
	static class UGroupMemberListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupMemberListWidget>();
	}
};
static_assert(alignof(UGroupMemberListWidget) == 0x000008, "Wrong alignment on UGroupMemberListWidget");
static_assert(sizeof(UGroupMemberListWidget) == 0x000358, "Wrong size on UGroupMemberListWidget");

// Class Flame.DataTableContainerCloud
// 0x0068 (0x0100 - 0x0098)
class UDataTableContainerCloud final : public UDataTableContainerBase
{
public:
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableContainerCloud">();
	}
	static class UDataTableContainerCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableContainerCloud>();
	}
};
static_assert(alignof(UDataTableContainerCloud) == 0x000008, "Wrong alignment on UDataTableContainerCloud");
static_assert(sizeof(UDataTableContainerCloud) == 0x000100, "Wrong size on UDataTableContainerCloud");

// Class Flame.GlintComponent
// 0x0030 (0x0230 - 0x0200)
class UGlintComponent : public USceneComponent
{
public:
	struct FGlintSettings                         Settings;                                          // 0x01F8(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PreGlintDelegate;                                  // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlintComponent">();
	}
	static class UGlintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlintComponent>();
	}
};
static_assert(alignof(UGlintComponent) == 0x000010, "Wrong alignment on UGlintComponent");
static_assert(sizeof(UGlintComponent) == 0x000230, "Wrong size on UGlintComponent");
static_assert(offsetof(UGlintComponent, Settings) == 0x0001F8, "Member 'UGlintComponent::Settings' has a wrong offset!");
static_assert(offsetof(UGlintComponent, PreGlintDelegate) == 0x000218, "Member 'UGlintComponent::PreGlintDelegate' has a wrong offset!");

// Class Flame.DefaultInventoryComponent
// 0x0028 (0x0128 - 0x0100)
class UDefaultInventoryComponent final : public UStoredItemsComponent
{
public:
	EDefaultInventoryLoadMode                     LoadMode;                                          // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDefaultInventoryLoadMode                     StashLoadMode;                                     // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AProjectileWeapon>          PrimaryWeaponA;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AProjectileWeapon>          PrimaryWeaponB;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWeapon>                    SecondaryWeaponA;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWeapon>                    SecondaryWeaponB;                                  // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultInventoryComponent">();
	}
	static class UDefaultInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultInventoryComponent>();
	}
};
static_assert(alignof(UDefaultInventoryComponent) == 0x000008, "Wrong alignment on UDefaultInventoryComponent");
static_assert(sizeof(UDefaultInventoryComponent) == 0x000128, "Wrong size on UDefaultInventoryComponent");
static_assert(offsetof(UDefaultInventoryComponent, LoadMode) == 0x000100, "Member 'UDefaultInventoryComponent::LoadMode' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryComponent, StashLoadMode) == 0x000101, "Member 'UDefaultInventoryComponent::StashLoadMode' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryComponent, PrimaryWeaponA) == 0x000108, "Member 'UDefaultInventoryComponent::PrimaryWeaponA' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryComponent, PrimaryWeaponB) == 0x000110, "Member 'UDefaultInventoryComponent::PrimaryWeaponB' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryComponent, SecondaryWeaponA) == 0x000118, "Member 'UDefaultInventoryComponent::SecondaryWeaponA' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryComponent, SecondaryWeaponB) == 0x000120, "Member 'UDefaultInventoryComponent::SecondaryWeaponB' has a wrong offset!");

// Class Flame.Gate
// 0x0028 (0x0248 - 0x0220)
class AGate final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0228(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMultiplayer;                                    // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerToTravel;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelTravel();
	void Travel(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gate">();
	}
	static class AGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGate>();
	}
};
static_assert(alignof(AGate) == 0x000008, "Wrong alignment on AGate");
static_assert(sizeof(AGate) == 0x000248, "Wrong size on AGate");
static_assert(offsetof(AGate, MapName) == 0x000228, "Member 'AGate::MapName' has a wrong offset!");
static_assert(offsetof(AGate, bIsMultiplayer) == 0x000238, "Member 'AGate::bIsMultiplayer' has a wrong offset!");
static_assert(offsetof(AGate, PlayerToTravel) == 0x000240, "Member 'AGate::PlayerToTravel' has a wrong offset!");

// Class Flame.DefaultLinkedCustomizationComponent
// 0x0070 (0x0120 - 0x00B0)
class UDefaultLinkedCustomizationComponent final : public UActorComponent
{
public:
	TSubclassOf<class ACustomizationVariant>      Archetype;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      Backpack;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      Gloves;                                            // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      HeadgearBottom;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      HeadgearMiddle;                                    // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      HeadgearTop;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationVariant>      Uniform;                                           // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACustomizationSlotArchetype> ArchetypeSlot;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotBackpack>       BackpackSlot;                                      // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotGloves>         GlovesSlot;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotHeadgearBottom> HeadgearBottomSlot;                                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotHeadgearMiddle> HeadgearMiddleSlot;                                // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotHeadgearTop>    HeadgearTopSlot;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AClothesSlotUniform>        UniformSlot;                                       // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultLinkedCustomizationComponent">();
	}
	static class UDefaultLinkedCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultLinkedCustomizationComponent>();
	}
};
static_assert(alignof(UDefaultLinkedCustomizationComponent) == 0x000008, "Wrong alignment on UDefaultLinkedCustomizationComponent");
static_assert(sizeof(UDefaultLinkedCustomizationComponent) == 0x000120, "Wrong size on UDefaultLinkedCustomizationComponent");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, Archetype) == 0x0000B0, "Member 'UDefaultLinkedCustomizationComponent::Archetype' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, Backpack) == 0x0000B8, "Member 'UDefaultLinkedCustomizationComponent::Backpack' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, Gloves) == 0x0000C0, "Member 'UDefaultLinkedCustomizationComponent::Gloves' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearBottom) == 0x0000C8, "Member 'UDefaultLinkedCustomizationComponent::HeadgearBottom' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearMiddle) == 0x0000D0, "Member 'UDefaultLinkedCustomizationComponent::HeadgearMiddle' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearTop) == 0x0000D8, "Member 'UDefaultLinkedCustomizationComponent::HeadgearTop' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, Uniform) == 0x0000E0, "Member 'UDefaultLinkedCustomizationComponent::Uniform' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, ArchetypeSlot) == 0x0000E8, "Member 'UDefaultLinkedCustomizationComponent::ArchetypeSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, BackpackSlot) == 0x0000F0, "Member 'UDefaultLinkedCustomizationComponent::BackpackSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, GlovesSlot) == 0x0000F8, "Member 'UDefaultLinkedCustomizationComponent::GlovesSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearBottomSlot) == 0x000100, "Member 'UDefaultLinkedCustomizationComponent::HeadgearBottomSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearMiddleSlot) == 0x000108, "Member 'UDefaultLinkedCustomizationComponent::HeadgearMiddleSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, HeadgearTopSlot) == 0x000110, "Member 'UDefaultLinkedCustomizationComponent::HeadgearTopSlot' has a wrong offset!");
static_assert(offsetof(UDefaultLinkedCustomizationComponent, UniformSlot) == 0x000118, "Member 'UDefaultLinkedCustomizationComponent::UniformSlot' has a wrong offset!");

// Class Flame.DefaultStashComponent
// 0x0100 (0x0260 - 0x0160)
class UDefaultStashComponent final : public UDefaultLootComponent
{
public:
	EDefaultInventoryLoadMode                     LoadMode;                                          // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceMaterials;                                 // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ResourceFood;                                      // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ResourceCurrency;                                  // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AWeaponPlan>, int32>   PlansWeapon;                                       // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AConsumablePlan>, int32> PlansConsumables;                                  // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AToken>, int32>        Tokens;                                            // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultStashComponent">();
	}
	static class UDefaultStashComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultStashComponent>();
	}
};
static_assert(alignof(UDefaultStashComponent) == 0x000008, "Wrong alignment on UDefaultStashComponent");
static_assert(sizeof(UDefaultStashComponent) == 0x000260, "Wrong size on UDefaultStashComponent");
static_assert(offsetof(UDefaultStashComponent, LoadMode) == 0x000160, "Member 'UDefaultStashComponent::LoadMode' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, ResourceMaterials) == 0x000164, "Member 'UDefaultStashComponent::ResourceMaterials' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, ResourceFood) == 0x000168, "Member 'UDefaultStashComponent::ResourceFood' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, ResourceCurrency) == 0x00016C, "Member 'UDefaultStashComponent::ResourceCurrency' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, PlansWeapon) == 0x000170, "Member 'UDefaultStashComponent::PlansWeapon' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, PlansConsumables) == 0x0001C0, "Member 'UDefaultStashComponent::PlansConsumables' has a wrong offset!");
static_assert(offsetof(UDefaultStashComponent, Tokens) == 0x000210, "Member 'UDefaultStashComponent::Tokens' has a wrong offset!");

// Class Flame.SelectionWheel
// 0x00D8 (0x0390 - 0x02B8)
class USelectionWheel : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESelectionWheelType                           WheelType;                                         // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWheelSegment*>                  WheelSegments;                                     // 0x02C8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         MinimumInputVectorLength;                          // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasEmptyState;                                     // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RawInputX;                                         // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RawInputY;                                         // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalInputX;                                       // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalInputY;                                       // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCursorYPos;                                 // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCursorXPos;                                 // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseMoveMagnitude;                                // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputAngle;                                        // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedSegment;                                   // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EquippedItemIndex;                                 // 0x0304(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelRadius;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponSegment>             WeaponSegmentClass;                                // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UConsumableSegment>         ConsumableSegmentClass;                            // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGestureSegment>            GestureSegmentClass;                               // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              WheelMaterial;                                     // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultGapSharpness;                               // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultGapThickness;                               // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSelectionWheelGapProperties>   OverrideGapProperties;                             // 0x0338(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SegmentRootPanel;                                  // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 WheelBackgroundImage;                              // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DirectionMarker;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        Description;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        SmallDescription;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDirectionMarker;                              // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DirectionMarkerTint;                               // 0x0374(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              DirectionMarkerMaterial;                           // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateSelectedSegment();
	void ActivateWheel();
	void CloseWheel();
	TArray<class UWheelSegment*> CreateConsumableSegments();
	TArray<class UWheelSegment*> CreateDevSegments();
	TArray<class UWheelSegment*> CreateGestureSegments();
	TArray<class UWheelSegment*> CreateToolSegments();
	TArray<class UWheelSegment*> CreateWeaponSegments();
	void ProcessDesktopAxisWheel();
	void ProcessDesktopAxisWheelQuadrant();
	void ProcessInputAxisX(float Value);
	void ProcessInputAxisY(float Value);
	void SelectSegment(int32 Index_0);
	void SetDescription(const class FText& InDescription, ESlateVisibility InVisibility);
	void SetEquippedItemIndex(int32 Index_0);
	void SetSmallDescription(const class FText& InDescription, ESlateVisibility InVisibility);

	int32 GetAngleOffset() const;
	class USelectionWheelComponent* GetWheelComponent() const;
	const TArray<class UWheelSegment*> GetWheelSegments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionWheel">();
	}
	static class USelectionWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectionWheel>();
	}
};
static_assert(alignof(USelectionWheel) == 0x000008, "Wrong alignment on USelectionWheel");
static_assert(sizeof(USelectionWheel) == 0x000390, "Wrong size on USelectionWheel");
static_assert(offsetof(USelectionWheel, WheelType) == 0x0002C0, "Member 'USelectionWheel::WheelType' has a wrong offset!");
static_assert(offsetof(USelectionWheel, WheelSegments) == 0x0002C8, "Member 'USelectionWheel::WheelSegments' has a wrong offset!");
static_assert(offsetof(USelectionWheel, MinimumInputVectorLength) == 0x0002D8, "Member 'USelectionWheel::MinimumInputVectorLength' has a wrong offset!");
static_assert(offsetof(USelectionWheel, HasEmptyState) == 0x0002DC, "Member 'USelectionWheel::HasEmptyState' has a wrong offset!");
static_assert(offsetof(USelectionWheel, RawInputX) == 0x0002E0, "Member 'USelectionWheel::RawInputX' has a wrong offset!");
static_assert(offsetof(USelectionWheel, RawInputY) == 0x0002E4, "Member 'USelectionWheel::RawInputY' has a wrong offset!");
static_assert(offsetof(USelectionWheel, TotalInputX) == 0x0002E8, "Member 'USelectionWheel::TotalInputX' has a wrong offset!");
static_assert(offsetof(USelectionWheel, TotalInputY) == 0x0002EC, "Member 'USelectionWheel::TotalInputY' has a wrong offset!");
static_assert(offsetof(USelectionWheel, CurrentCursorYPos) == 0x0002F0, "Member 'USelectionWheel::CurrentCursorYPos' has a wrong offset!");
static_assert(offsetof(USelectionWheel, CurrentCursorXPos) == 0x0002F4, "Member 'USelectionWheel::CurrentCursorXPos' has a wrong offset!");
static_assert(offsetof(USelectionWheel, MouseMoveMagnitude) == 0x0002F8, "Member 'USelectionWheel::MouseMoveMagnitude' has a wrong offset!");
static_assert(offsetof(USelectionWheel, InputAngle) == 0x0002FC, "Member 'USelectionWheel::InputAngle' has a wrong offset!");
static_assert(offsetof(USelectionWheel, SelectedSegment) == 0x000300, "Member 'USelectionWheel::SelectedSegment' has a wrong offset!");
static_assert(offsetof(USelectionWheel, EquippedItemIndex) == 0x000304, "Member 'USelectionWheel::EquippedItemIndex' has a wrong offset!");
static_assert(offsetof(USelectionWheel, WheelRadius) == 0x000308, "Member 'USelectionWheel::WheelRadius' has a wrong offset!");
static_assert(offsetof(USelectionWheel, WeaponSegmentClass) == 0x000310, "Member 'USelectionWheel::WeaponSegmentClass' has a wrong offset!");
static_assert(offsetof(USelectionWheel, ConsumableSegmentClass) == 0x000318, "Member 'USelectionWheel::ConsumableSegmentClass' has a wrong offset!");
static_assert(offsetof(USelectionWheel, GestureSegmentClass) == 0x000320, "Member 'USelectionWheel::GestureSegmentClass' has a wrong offset!");
static_assert(offsetof(USelectionWheel, WheelMaterial) == 0x000328, "Member 'USelectionWheel::WheelMaterial' has a wrong offset!");
static_assert(offsetof(USelectionWheel, DefaultGapSharpness) == 0x000330, "Member 'USelectionWheel::DefaultGapSharpness' has a wrong offset!");
static_assert(offsetof(USelectionWheel, DefaultGapThickness) == 0x000334, "Member 'USelectionWheel::DefaultGapThickness' has a wrong offset!");
static_assert(offsetof(USelectionWheel, OverrideGapProperties) == 0x000338, "Member 'USelectionWheel::OverrideGapProperties' has a wrong offset!");
static_assert(offsetof(USelectionWheel, SegmentRootPanel) == 0x000348, "Member 'USelectionWheel::SegmentRootPanel' has a wrong offset!");
static_assert(offsetof(USelectionWheel, WheelBackgroundImage) == 0x000350, "Member 'USelectionWheel::WheelBackgroundImage' has a wrong offset!");
static_assert(offsetof(USelectionWheel, DirectionMarker) == 0x000358, "Member 'USelectionWheel::DirectionMarker' has a wrong offset!");
static_assert(offsetof(USelectionWheel, Description) == 0x000360, "Member 'USelectionWheel::Description' has a wrong offset!");
static_assert(offsetof(USelectionWheel, SmallDescription) == 0x000368, "Member 'USelectionWheel::SmallDescription' has a wrong offset!");
static_assert(offsetof(USelectionWheel, bShowDirectionMarker) == 0x000370, "Member 'USelectionWheel::bShowDirectionMarker' has a wrong offset!");
static_assert(offsetof(USelectionWheel, DirectionMarkerTint) == 0x000374, "Member 'USelectionWheel::DirectionMarkerTint' has a wrong offset!");
static_assert(offsetof(USelectionWheel, DirectionMarkerMaterial) == 0x000388, "Member 'USelectionWheel::DirectionMarkerMaterial' has a wrong offset!");

// Class Flame.DirectionRestrictedInteractionComponent
// 0x0018 (0x0190 - 0x0178)
class UDirectionRestrictedInteractionComponent final : public UInteractionItemComponent
{
public:
	struct FVector                                EnforcedDirection;                                 // 0x0178(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnforcedDot;                                       // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableEnforceInteraction;                         // 0x0188(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveEnforcedInteractionAngle();
	void SetEnforcedInteractionAngle(const struct FVector& Direction, const float DotRestriction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionRestrictedInteractionComponent">();
	}
	static class UDirectionRestrictedInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionRestrictedInteractionComponent>();
	}
};
static_assert(alignof(UDirectionRestrictedInteractionComponent) == 0x000008, "Wrong alignment on UDirectionRestrictedInteractionComponent");
static_assert(sizeof(UDirectionRestrictedInteractionComponent) == 0x000190, "Wrong size on UDirectionRestrictedInteractionComponent");
static_assert(offsetof(UDirectionRestrictedInteractionComponent, EnforcedDirection) == 0x000178, "Member 'UDirectionRestrictedInteractionComponent::EnforcedDirection' has a wrong offset!");
static_assert(offsetof(UDirectionRestrictedInteractionComponent, EnforcedDot) == 0x000184, "Member 'UDirectionRestrictedInteractionComponent::EnforcedDot' has a wrong offset!");
static_assert(offsetof(UDirectionRestrictedInteractionComponent, bEnableEnforceInteraction) == 0x000188, "Member 'UDirectionRestrictedInteractionComponent::bEnableEnforceInteraction' has a wrong offset!");

// Class Flame.OptionsElementCheckbox
// 0x0018 (0x03C0 - 0x03A8)
class UOptionsElementCheckbox : public UOptionsElementWidget
{
public:
	class UFlameCheckBox*                         CheckBox;                                          // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCheckStateChangedDelegate;                       // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void OnCheckStateChanged(bool bIsChecked);
	void ToggleState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsElementCheckbox">();
	}
	static class UOptionsElementCheckbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsElementCheckbox>();
	}
};
static_assert(alignof(UOptionsElementCheckbox) == 0x000008, "Wrong alignment on UOptionsElementCheckbox");
static_assert(sizeof(UOptionsElementCheckbox) == 0x0003C0, "Wrong size on UOptionsElementCheckbox");
static_assert(offsetof(UOptionsElementCheckbox, CheckBox) == 0x0003A8, "Member 'UOptionsElementCheckbox::CheckBox' has a wrong offset!");
static_assert(offsetof(UOptionsElementCheckbox, OnCheckStateChangedDelegate) == 0x0003B0, "Member 'UOptionsElementCheckbox::OnCheckStateChangedDelegate' has a wrong offset!");

// Class Flame.DoorDouble
// 0x0018 (0x0388 - 0x0370)
class ADoorDouble : public ADoor
{
public:
	class UStaticMeshComponent*                   AltStaticMesh;                                     // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        AltPivot;                                          // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoubleDoorType                               DoubleDoorType;                                    // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorDouble">();
	}
	static class ADoorDouble* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorDouble>();
	}
};
static_assert(alignof(ADoorDouble) == 0x000008, "Wrong alignment on ADoorDouble");
static_assert(sizeof(ADoorDouble) == 0x000388, "Wrong size on ADoorDouble");
static_assert(offsetof(ADoorDouble, AltStaticMesh) == 0x000370, "Member 'ADoorDouble::AltStaticMesh' has a wrong offset!");
static_assert(offsetof(ADoorDouble, AltPivot) == 0x000378, "Member 'ADoorDouble::AltPivot' has a wrong offset!");
static_assert(offsetof(ADoorDouble, DoubleDoorType) == 0x000380, "Member 'ADoorDouble::DoubleDoorType' has a wrong offset!");

// Class Flame.ProjectileComponent
// 0x0040 (0x00F0 - 0x00B0)
class UProjectileComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLifetimeUpdated;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitHandled;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimedEvent;                                      // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStopMoving;                                      // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileComponent">();
	}
	static class UProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileComponent>();
	}
};
static_assert(alignof(UProjectileComponent) == 0x000008, "Wrong alignment on UProjectileComponent");
static_assert(sizeof(UProjectileComponent) == 0x0000F0, "Wrong size on UProjectileComponent");
static_assert(offsetof(UProjectileComponent, OnLifetimeUpdated) == 0x0000B0, "Member 'UProjectileComponent::OnLifetimeUpdated' has a wrong offset!");
static_assert(offsetof(UProjectileComponent, OnHitHandled) == 0x0000C0, "Member 'UProjectileComponent::OnHitHandled' has a wrong offset!");
static_assert(offsetof(UProjectileComponent, OnTimedEvent) == 0x0000D0, "Member 'UProjectileComponent::OnTimedEvent' has a wrong offset!");
static_assert(offsetof(UProjectileComponent, OnStopMoving) == 0x0000E0, "Member 'UProjectileComponent::OnStopMoving' has a wrong offset!");

// Class Flame.EditorActor
// 0x0000 (0x0220 - 0x0220)
class AEditorActor : public AActor
{
public:
	void PostRebuildBuildings(const TMap<class FName, float>& Data);
	void PreRebuildBuildings(class UEditorRebuildDataStorage* Data);

	class FName GenerateEditorActorIdentifier() const;
	void GetRebuildReferencedTags(TSet<class FName>& OutNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorActor">();
	}
	static class AEditorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEditorActor>();
	}
};
static_assert(alignof(AEditorActor) == 0x000008, "Wrong alignment on AEditorActor");
static_assert(sizeof(AEditorActor) == 0x000220, "Wrong size on AEditorActor");

// Class Flame.EnvQueryTest_IsShootable
// 0x0040 (0x0238 - 0x01F8)
class UEnvQueryTest_IsShootable final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          TraceData;                                         // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ItemHeightOffset;                                  // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsShootable">();
	}
	static class UEnvQueryTest_IsShootable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsShootable>();
	}
};
static_assert(alignof(UEnvQueryTest_IsShootable) == 0x000008, "Wrong alignment on UEnvQueryTest_IsShootable");
static_assert(sizeof(UEnvQueryTest_IsShootable) == 0x000238, "Wrong size on UEnvQueryTest_IsShootable");
static_assert(offsetof(UEnvQueryTest_IsShootable, TraceData) == 0x0001F8, "Member 'UEnvQueryTest_IsShootable::TraceData' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsShootable, Context) == 0x000228, "Member 'UEnvQueryTest_IsShootable::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsShootable, ItemHeightOffset) == 0x000230, "Member 'UEnvQueryTest_IsShootable::ItemHeightOffset' has a wrong offset!");

// Class Flame.ThrowableConsumable
// 0x0080 (0x0498 - 0x0418)
class AThrowableConsumable : public AConsumableItem
{
public:
	uint8                                         Pad_418[0x24];                                     // 0x0418(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowStrength;                                     // 0x043C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalOffset;                                  // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasAiming;                                        // 0x0444(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParamThrowStrength;                                // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamClimaxAngle;                                  // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamAdditionalAngle;                              // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamAdditionalAngleNoAim;                         // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamVelocityFalloffMultiplier;                    // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamNoAimStrengthMultiplier;                      // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UsageLabelAiming;                                  // 0x0468(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAimingArcSpline*                       AimingArcComp;                                     // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ThrowableClass;                                    // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadius;                                  // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateAimingArc();
	void ClientOnUsed();
	void CreateArcBP();
	void DestroyArcBP();
	void HideArcManually();
	void OnAimingChanged(const bool ShowArc);
	void OnThrown(class AActor* ThrownActor);
	void UpdateThrowParams(bool WasAiming);

	const float GetThrowStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowableConsumable">();
	}
	static class AThrowableConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowableConsumable>();
	}
};
static_assert(alignof(AThrowableConsumable) == 0x000008, "Wrong alignment on AThrowableConsumable");
static_assert(sizeof(AThrowableConsumable) == 0x000498, "Wrong size on AThrowableConsumable");
static_assert(offsetof(AThrowableConsumable, ThrowStrength) == 0x00043C, "Member 'AThrowableConsumable::ThrowStrength' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, AdditionalOffset) == 0x000440, "Member 'AThrowableConsumable::AdditionalOffset' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, bWasAiming) == 0x000444, "Member 'AThrowableConsumable::bWasAiming' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamThrowStrength) == 0x000448, "Member 'AThrowableConsumable::ParamThrowStrength' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamClimaxAngle) == 0x00044C, "Member 'AThrowableConsumable::ParamClimaxAngle' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamAdditionalAngle) == 0x000450, "Member 'AThrowableConsumable::ParamAdditionalAngle' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamAdditionalAngleNoAim) == 0x000454, "Member 'AThrowableConsumable::ParamAdditionalAngleNoAim' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamVelocityFalloffMultiplier) == 0x000458, "Member 'AThrowableConsumable::ParamVelocityFalloffMultiplier' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ParamNoAimStrengthMultiplier) == 0x00045C, "Member 'AThrowableConsumable::ParamNoAimStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, UsageLabelAiming) == 0x000468, "Member 'AThrowableConsumable::UsageLabelAiming' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, AimingArcComp) == 0x000480, "Member 'AThrowableConsumable::AimingArcComp' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ThrowableClass) == 0x000488, "Member 'AThrowableConsumable::ThrowableClass' has a wrong offset!");
static_assert(offsetof(AThrowableConsumable, ProjectileRadius) == 0x000490, "Member 'AThrowableConsumable::ProjectileRadius' has a wrong offset!");

// Class Flame.PlatformTools
// 0x0028 (0x0050 - 0x0028)
class UPlatformTools final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             SystemUserProfileClosed;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetUserAuthTokenFinished;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GetUserAuthToken__DelegateSignature(const struct FUniqueNetIdRepl& LocalUserId, const class FString& UserAuthToken);
	bool OpenSystemUserProfile(const struct FUniqueNetIdRepl& RequestorId, const struct FUniqueNetIdRepl& ProfileToShowId);
	void SystemUserProfileClosed__DelegateSignature();

	class FString GetEnvironmentTypeName() const;
	class FString GetSandboxName() const;
	bool GetUserAuthToken(const struct FUniqueNetIdRepl& ProfileId) const;
	class FString GetUserHash(int32 ControllerId) const;
	bool IsLicenseActive() const;
	bool IsRunningTrial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformTools">();
	}
	static class UPlatformTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformTools>();
	}
};
static_assert(alignof(UPlatformTools) == 0x000008, "Wrong alignment on UPlatformTools");
static_assert(sizeof(UPlatformTools) == 0x000050, "Wrong size on UPlatformTools");
static_assert(offsetof(UPlatformTools, SystemUserProfileClosed) == 0x000030, "Member 'UPlatformTools::SystemUserProfileClosed' has a wrong offset!");
static_assert(offsetof(UPlatformTools, GetUserAuthTokenFinished) == 0x000040, "Member 'UPlatformTools::GetUserAuthTokenFinished' has a wrong offset!");

// Class Flame.EquipWeaponModalWidget
// 0x0020 (0x0310 - 0x02F0)
class UEquipWeaponModalWidget : public UModalWidget
{
public:
	class AWeapon*                                WeaponToEquip;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoToEquipCount;                                  // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoToCraftCount;                                  // 0x02FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionConfirm;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionClose;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActionClosePressed();
	void OnActionConfirmPressed();
	void SetAmmoToCraftCount(int32 InCount);
	void SetAmmoToEquipCount(int32 InCount);

	TSubclassOf<class AAmmoItem> GetAmmoClass() const;
	int32 GetAmmoToCraftCount() const;
	int32 GetAmmoToEquipCount() const;
	class AWeapon* GetWeaponToEquip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipWeaponModalWidget">();
	}
	static class UEquipWeaponModalWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipWeaponModalWidget>();
	}
};
static_assert(alignof(UEquipWeaponModalWidget) == 0x000008, "Wrong alignment on UEquipWeaponModalWidget");
static_assert(sizeof(UEquipWeaponModalWidget) == 0x000310, "Wrong size on UEquipWeaponModalWidget");
static_assert(offsetof(UEquipWeaponModalWidget, WeaponToEquip) == 0x0002F0, "Member 'UEquipWeaponModalWidget::WeaponToEquip' has a wrong offset!");
static_assert(offsetof(UEquipWeaponModalWidget, AmmoToEquipCount) == 0x0002F8, "Member 'UEquipWeaponModalWidget::AmmoToEquipCount' has a wrong offset!");
static_assert(offsetof(UEquipWeaponModalWidget, AmmoToCraftCount) == 0x0002FC, "Member 'UEquipWeaponModalWidget::AmmoToCraftCount' has a wrong offset!");
static_assert(offsetof(UEquipWeaponModalWidget, ActionConfirm) == 0x000300, "Member 'UEquipWeaponModalWidget::ActionConfirm' has a wrong offset!");
static_assert(offsetof(UEquipWeaponModalWidget, ActionClose) == 0x000308, "Member 'UEquipWeaponModalWidget::ActionClose' has a wrong offset!");

// Class Flame.EventSystem
// 0x0008 (0x0030 - 0x0028)
class UEventSystem : public UObject
{
public:
	class UFlameGameInstance*                     GameInstance;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BlueprintInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSystem">();
	}
	static class UEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSystem>();
	}
};
static_assert(alignof(UEventSystem) == 0x000008, "Wrong alignment on UEventSystem");
static_assert(sizeof(UEventSystem) == 0x000030, "Wrong size on UEventSystem");
static_assert(offsetof(UEventSystem, GameInstance) == 0x000028, "Member 'UEventSystem::GameInstance' has a wrong offset!");

// Class Flame.UpdateInterface
// 0x0000 (0x0028 - 0x0028)
class IUpdateInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateInterface">();
	}
	static class IUpdateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUpdateInterface>();
	}
};
static_assert(alignof(IUpdateInterface) == 0x000008, "Wrong alignment on IUpdateInterface");
static_assert(sizeof(IUpdateInterface) == 0x000028, "Wrong size on IUpdateInterface");

// Class Flame.ExplosionComponent
// 0x0098 (0x0148 - 0x00B0)
class UExplosionComponent : public UActorComponent
{
public:
	EExplosionEffects                             EffectImpactingHitMarker;                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 EffectHitMarkerColor;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExplosionOffsetLocation;                           // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         AffectedItemClasses;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UCurveGrenadeExplosionEffect*           ExplosionCurveEffect;                              // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, float>                 DamagePercentageThroughMaterial;                   // 0x00E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class AItem>                      ItemType;                                          // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExplosionCompleted;                              // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	float CalculateExposure(class AActor* InstigatingActor, class AActor* ActorToBeDestroyed, const struct FVector& ExplosionLocation, float MaxThickness);
	void Explode(float MaxExplosionRadius, TArray<struct FExplosionEffect>* ExplosionEffect, const EDamageType DamageType);
	void MulticastNotifyExplosion(const TArray<struct FExplosionEffect>& ExplosionEffects);
	void OnExplosionComponentExplode(const TArray<struct FExplosionEffect>& ExplosionEffects);
	void ProccessExplosion(const struct FVector& Location, float ExplosionRadius, class AController* InstigatorController);
	TArray<class AActor*> ProcessExplosionInteractions(class AActor* InstigatingActor, const struct FVector& ExplosionLocation, float MaxExplosionRadius);

	struct FVector GetExplosionLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionComponent">();
	}
	static class UExplosionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionComponent>();
	}
};
static_assert(alignof(UExplosionComponent) == 0x000008, "Wrong alignment on UExplosionComponent");
static_assert(sizeof(UExplosionComponent) == 0x000148, "Wrong size on UExplosionComponent");
static_assert(offsetof(UExplosionComponent, EffectImpactingHitMarker) == 0x0000B0, "Member 'UExplosionComponent::EffectImpactingHitMarker' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, EffectHitMarkerColor) == 0x0000B4, "Member 'UExplosionComponent::EffectHitMarkerColor' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ExplosionOffsetLocation) == 0x0000B8, "Member 'UExplosionComponent::ExplosionOffsetLocation' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, AffectedItemClasses) == 0x0000C8, "Member 'UExplosionComponent::AffectedItemClasses' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ExplosionCurveEffect) == 0x0000D8, "Member 'UExplosionComponent::ExplosionCurveEffect' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, DamagePercentageThroughMaterial) == 0x0000E0, "Member 'UExplosionComponent::DamagePercentageThroughMaterial' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ItemType) == 0x000130, "Member 'UExplosionComponent::ItemType' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, OnExplosionCompleted) == 0x000138, "Member 'UExplosionComponent::OnExplosionCompleted' has a wrong offset!");

// Class Flame.ExtendedStandardLibraryFunctions
// 0x0000 (0x0028 - 0x0028)
class UExtendedStandardLibraryFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool GreaterEqualStringString(const class FString& A, const class FString& B);
	static bool GreaterStringString(const class FString& A, const class FString& B);
	static bool LessEqualStringString(const class FString& A, const class FString& B);
	static bool LessStringString(const class FString& A, const class FString& B);
	static class FString MaxString(const class FString& A, const class FString& B);
	static class FString MinString(const class FString& A, const class FString& B);
	static TArray<uint8> SortByteArray(const TArray<uint8>& ByteArray, const bool Reversed);
	static void SortByteArrayDirectly(TArray<uint8>& ByteArray, const bool Reversed);
	static TArray<TSubclassOf<class UObject>> SortClassArray(const TArray<TSubclassOf<class UObject>>& ClassArray, TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)> Comparator, const bool Reversed);
	static void SortClassArrayDirectly(TArray<TSubclassOf<class UObject>>& ClassArray, TDelegate<void(TSubclassOf<class UObject> ClassA, TSubclassOf<class UObject> ClassB, bool* Result)> Comparator, const bool Reversed);
	static TArray<struct FDateTime> SortDateTimeArray(const TArray<struct FDateTime>& DateTimeArray, const bool Reversed);
	static void SortDateTimeArrayDirectly(TArray<struct FDateTime>& DateTimeArray, const bool Reversed);
	static TArray<float> SortFloatArray(const TArray<float>& FloatArray, const bool Reversed);
	static void SortFloatArrayDirectly(TArray<float>& FloatArray, const bool Reversed);
	static TArray<int32> SortIntegerArray(const TArray<int32>& IntegerArray, const bool Reversed);
	static void SortIntegerArrayDirectly(TArray<int32>& IntegerArray, const bool Reversed);
	static TArray<class UObject*> SortObjectArray(const TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed);
	static void SortObjectArrayDirectly(TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed);
	static TArray<class FString> SortStringArray(const TArray<class FString>& StringArray, const bool Reversed);
	static void SortStringArrayDirectly(TArray<class FString>& StringArray, const bool Reversed);
	static TArray<struct FTimespan> SortTimespanArray(const TArray<struct FTimespan>& TimespanArray, const bool Reversed);
	static void SortTimespanArrayDirectly(TArray<struct FTimespan>& TimespanArray, const bool Reversed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedStandardLibraryFunctions">();
	}
	static class UExtendedStandardLibraryFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendedStandardLibraryFunctions>();
	}
};
static_assert(alignof(UExtendedStandardLibraryFunctions) == 0x000008, "Wrong alignment on UExtendedStandardLibraryFunctions");
static_assert(sizeof(UExtendedStandardLibraryFunctions) == 0x000028, "Wrong size on UExtendedStandardLibraryFunctions");

// Class Flame.WaterComponent
// 0x0040 (0x00F0 - 0x00B0)
class UWaterComponent final : public UActorComponent
{
public:
	struct FVector                                WaterFlow;                                         // 0x00B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHumanCharacter*>                OverlappedCharacters;                              // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FVector                                StartLoc;                                          // 0x00D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EndLoc;                                            // 0x00DC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWaterType                                    WaterType;                                         // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void SetStartEndLocations(const struct FVector& StartLocation, const struct FVector& EndLocation);
	void SetSurfaceHeight(float SurfaceHeight);
	void SetWaterType(const EWaterType Type);

	float GetDepth(const struct FVector& InPoint) const;
	float GetMaxDepthAtPoint(const struct FVector& Point) const;
	struct FVector GetSurfacePoint(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterComponent">();
	}
	static class UWaterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterComponent>();
	}
};
static_assert(alignof(UWaterComponent) == 0x000008, "Wrong alignment on UWaterComponent");
static_assert(sizeof(UWaterComponent) == 0x0000F0, "Wrong size on UWaterComponent");
static_assert(offsetof(UWaterComponent, WaterFlow) == 0x0000B0, "Member 'UWaterComponent::WaterFlow' has a wrong offset!");
static_assert(offsetof(UWaterComponent, OverlappedCharacters) == 0x0000C0, "Member 'UWaterComponent::OverlappedCharacters' has a wrong offset!");
static_assert(offsetof(UWaterComponent, StartLoc) == 0x0000D0, "Member 'UWaterComponent::StartLoc' has a wrong offset!");
static_assert(offsetof(UWaterComponent, EndLoc) == 0x0000DC, "Member 'UWaterComponent::EndLoc' has a wrong offset!");
static_assert(offsetof(UWaterComponent, WaterType) == 0x0000E8, "Member 'UWaterComponent::WaterType' has a wrong offset!");

// Class Flame.FlameAchievementsSystem
// 0x0008 (0x0030 - 0x0028)
class UFlameAchievementsSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CacheAchievements(class APlayerController* PlayerController);
	void GetCachedAchievementProgress(class APlayerController* PlayerController, class FName AchievementName, bool* bAchievementFound, float* Progress);
	bool IsAchievementSystemValid();
	bool ResetAchievements();
	bool WriteAchievementProgress(class APlayerController* PlayerController, class FName AchievementName, float Progress, int32 UserTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAchievementsSystem">();
	}
	static class UFlameAchievementsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameAchievementsSystem>();
	}
};
static_assert(alignof(UFlameAchievementsSystem) == 0x000008, "Wrong alignment on UFlameAchievementsSystem");
static_assert(sizeof(UFlameAchievementsSystem) == 0x000030, "Wrong size on UFlameAchievementsSystem");

// Class Flame.FlameAIController
// 0x0010 (0x0338 - 0x0328)
class AFlameAIController : public AAIController
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionComponent*                 AIPerception;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetPerceptionActive() const;
	bool IsEnemy(const class AActor* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAIController">();
	}
	static class AFlameAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameAIController>();
	}
};
static_assert(alignof(AFlameAIController) == 0x000008, "Wrong alignment on AFlameAIController");
static_assert(sizeof(AFlameAIController) == 0x000338, "Wrong size on AFlameAIController");
static_assert(offsetof(AFlameAIController, AIPerception) == 0x000330, "Member 'AFlameAIController::AIPerception' has a wrong offset!");

// Class Flame.OnlineShelterComponent
// 0x0018 (0x00C8 - 0x00B0)
class UOnlineShelterComponent final : public UOnlineComponentBase
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineShelterComponent">();
	}
	static class UOnlineShelterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineShelterComponent>();
	}
};
static_assert(alignof(UOnlineShelterComponent) == 0x000008, "Wrong alignment on UOnlineShelterComponent");
static_assert(sizeof(UOnlineShelterComponent) == 0x0000C8, "Wrong size on UOnlineShelterComponent");

// Class Flame.FlameAnimInstance
// 0x0190 (0x0450 - 0x02C0)
class UFlameAnimInstance final : public UAnimInstance
{
public:
	float                                         MoveForward;                                       // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRight;                                         // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirection;                                 // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Azimuth;                                           // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Altitude;                                          // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyWeight;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperOverAllBody;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStance                                       StanceVal;                                         // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProneAiming;                                       // 0x02D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Downed;                                            // 0x02DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseJiggleBones;                                   // 0x02DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpperBodyState                               UpperState;                                        // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELowerBodyState                               LowerState;                                        // 0x02DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimAggregate                         AnimsAggr;                                         // 0x02E0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpStart;                                         // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoop;                                          // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEnd;                                           // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlameDirectParams                     Runtime;                                           // 0x0338(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTorsoPars                             Torso;                                             // 0x0368(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimActionPars                        VerticalMovement;                                  // 0x0398(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class AHumanCharacter*                        Human;                                             // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x88];                                     // 0x03C8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AnimDone(int32 MachineIndex, int32 StateIndex);
	bool AnimRemaining(int32 MachineIndex, int32 StateIndex, float Remaining);
	bool IsLowerState(ELowerBodyState Value);
	bool IsStance(EStance Value);
	bool IsUpperState(EUpperBodyState Value);
	bool NotLowerState(ELowerBodyState Value);
	bool NotStance(EStance Value);
	bool NotUpperState(EUpperBodyState Value);
	void PrintDiagnostic(bool AllowPreview);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAnimInstance">();
	}
	static class UFlameAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameAnimInstance>();
	}
};
static_assert(alignof(UFlameAnimInstance) == 0x000010, "Wrong alignment on UFlameAnimInstance");
static_assert(sizeof(UFlameAnimInstance) == 0x000450, "Wrong size on UFlameAnimInstance");
static_assert(offsetof(UFlameAnimInstance, MoveForward) == 0x0002B8, "Member 'UFlameAnimInstance::MoveForward' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, MoveRight) == 0x0002BC, "Member 'UFlameAnimInstance::MoveRight' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, MovementSpeed) == 0x0002C0, "Member 'UFlameAnimInstance::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, MovementDirection) == 0x0002C4, "Member 'UFlameAnimInstance::MovementDirection' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Azimuth) == 0x0002C8, "Member 'UFlameAnimInstance::Azimuth' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Altitude) == 0x0002CC, "Member 'UFlameAnimInstance::Altitude' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, UpperBodyWeight) == 0x0002D0, "Member 'UFlameAnimInstance::UpperBodyWeight' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, UpperOverAllBody) == 0x0002D4, "Member 'UFlameAnimInstance::UpperOverAllBody' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, StanceVal) == 0x0002D8, "Member 'UFlameAnimInstance::StanceVal' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, ProneAiming) == 0x0002D9, "Member 'UFlameAnimInstance::ProneAiming' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Downed) == 0x0002DA, "Member 'UFlameAnimInstance::Downed' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, bUseJiggleBones) == 0x0002DB, "Member 'UFlameAnimInstance::bUseJiggleBones' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, UpperState) == 0x0002DC, "Member 'UFlameAnimInstance::UpperState' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, LowerState) == 0x0002DD, "Member 'UFlameAnimInstance::LowerState' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, AnimsAggr) == 0x0002E0, "Member 'UFlameAnimInstance::AnimsAggr' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, JumpStart) == 0x000320, "Member 'UFlameAnimInstance::JumpStart' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, JumpLoop) == 0x000328, "Member 'UFlameAnimInstance::JumpLoop' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, JumpEnd) == 0x000330, "Member 'UFlameAnimInstance::JumpEnd' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Runtime) == 0x000338, "Member 'UFlameAnimInstance::Runtime' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Torso) == 0x000368, "Member 'UFlameAnimInstance::Torso' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, VerticalMovement) == 0x000398, "Member 'UFlameAnimInstance::VerticalMovement' has a wrong offset!");
static_assert(offsetof(UFlameAnimInstance, Human) == 0x0003C0, "Member 'UFlameAnimInstance::Human' has a wrong offset!");

// Class Flame.ShelterMap
// 0x0008 (0x02E0 - 0x02D8)
class UShelterMap : public UMenuWidget
{
public:
	class UInputActionWidget*                     ActionPlay;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsMatchmakingAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterMap">();
	}
	static class UShelterMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterMap>();
	}
};
static_assert(alignof(UShelterMap) == 0x000008, "Wrong alignment on UShelterMap");
static_assert(sizeof(UShelterMap) == 0x0002E0, "Wrong size on UShelterMap");
static_assert(offsetof(UShelterMap, ActionPlay) == 0x0002D8, "Member 'UShelterMap::ActionPlay' has a wrong offset!");

// Class Flame.FlameRunTestCommandlet
// 0x0000 (0x0080 - 0x0080)
class UFlameRunTestCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameRunTestCommandlet">();
	}
	static class UFlameRunTestCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameRunTestCommandlet>();
	}
};
static_assert(alignof(UFlameRunTestCommandlet) == 0x000008, "Wrong alignment on UFlameRunTestCommandlet");
static_assert(sizeof(UFlameRunTestCommandlet) == 0x000080, "Wrong size on UFlameRunTestCommandlet");

// Class Flame.FlameGameInstance
// 0x0618 (0x07C0 - 0x01A8)
class UFlameGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x318];                                    // 0x01A8(0x0318)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICoreObject*                          UICoreObject;                                      // 0x04C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProfilePictureCache*                   ProfilePictureCache;                               // 0x04C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNotificationSystem*                    NotificationSystem;                                // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCloudSystem*                           CloudSystem;                                       // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCloudSystem>               CloudSystemClass;                                  // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformStoreSystem*                   PlatformStoreSystem;                               // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlatformStoreSystem>       PlatformStoreSystemClass;                          // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformTools*                         PlatformTools;                                     // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlatformTools>             PlatformToolsClass;                                // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameStoreSystem*                       GameStoreSystem;                                   // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameStoreSystem>           GameStoreSystemClass;                              // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardSystem*                     LeaderboardSystem;                                 // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULeaderboardSystem>         LeaderboardSystemClass;                            // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeartBeatSystemBase*                   HeartBeatSystem;                                   // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSaveSystem*                       FlameSaveSystem;                                   // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingManager*                           PingManager;                                       // 0x0538(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataProvider*                          DataProvider;                                      // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDataProvider>              DataProviderClass;                                 // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UServerJoinHandler*                     ServerJoinHandler;                                 // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGroupSystem*                           GroupSystem;                                       // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnalyticsManager*                      AnalyticsManager;                                  // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnalyticsManager>          AnalyticsManagerClass;                             // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleEvents*                         ConsoleEvents;                                     // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichPresence*                          RichPresence;                                      // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameAchievementsSystem*               AchievementsSystem;                                // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameAssetManager*                     AssetManager;                                      // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameObjectPoolManager*                ObjectPoolManager;                                 // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UServerAuthorityConfig*                 ServerAuthorityConfig;                             // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEventSystem>               EventSystemClass;                                  // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AChallengeManager>          ChallengeManagerClass;                             // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBattlePassSystem>          BattlePassSystemClass;                             // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCloudNotificationSystem>   CloudNotificationSystemClass;                      // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMapsManager>               MapsManagerClass;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEventSystem*                           EventSystem;                                       // 0x05C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AChallengeManager*                      ChallengeManager;                                  // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattlePassSystem*                      BattlePassSystem;                                  // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCloudNotificationSystem*               CloudNotificationSystem;                           // 0x05E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapsManager*                           MapsManager;                                       // 0x05E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AppVersionMajor;                                   // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppVersionMinor;                                   // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppVersionBugfix;                                  // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildNumber;                                       // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PCInputVersionNumber;                              // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanMinimizeWindow;                                 // 0x0604(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_605[0xB];                                      // 0x0605(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastMatchID;                                       // 0x0610(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputModeChanged;                                // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlatformStoreInitFinished;                       // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x20];                                     // 0x0640(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformToolsSteam*                    OverlayListener;                                   // 0x0660(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x4];                                      // 0x0668(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedResolutionIndex;                           // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x8];                                      // 0x0670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialShadersToCompile;                           // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestShadersRemaining;                              // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestTotalShaders;                                  // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSimulatingPSOCache;                              // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_685[0x3];                                      // 0x0685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPSOCacheCompleteDelegate;                        // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPSOCacheSkipDelegate;                            // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFPSOCacheProgressDelegate;                       // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CacheLoadingTime;                                  // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFlamePlatform, class UClass*>           DefaultOptionSaveGameClasses;                      // 0x06C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSaveGameChangeNotifyDelegate;                    // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVideoSettingsChangeDelegate;                     // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQualitySettingsChangeDelegate;                   // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeyboardSettingsChangeDelegate;                  // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPCControlsChange;                                // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameSettingsChangedDelegate;                     // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerConnectionStateUpdated;                    // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CloudGeneration;                                   // 0x0780(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalHC;                                           // 0x0784(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCloudPriceListItem>            LobbyPriceList;                                    // 0x0788(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USaveGame*                              OptionsSaveGame;                                   // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveGame*                              QueuedOptionsSaveGame;                             // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A8[0x18];                                     // 0x07A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFlameAchievementsSystem* GetAchievementsSystem(const class UObject* WorldContextObject);
	static class UFlameAssetManager* GetAssetManagerSystem(const class UObject* WorldContextObject);
	static class UBattlePassSystem* GetBattlePassSystem(const class UObject* WorldContextObject);
	static class AChallengeManager* GetChallengeManager(const class UObject* WorldContextObject);
	static class UCloudSystem* GetCloudSystem(const class UObject* WorldContextObject);
	static class UConsoleEvents* GetConsoleEvents(const class UObject* WorldContextObject);
	static ENintendoSwitchOperationMode GetCurrentNintendoSwitchOperationMode();
	static class UEventSystem* GetEventSystem(const class UObject* WorldContextObject);
	static class UFlameGameInstance* GetFlameGameInstance(const class UObject* WorldContextObject);
	static class UGameStoreSystem* GetGameStoreSystem(const class UObject* WorldContextObject);
	static class UGroupSystem* GetGroupSystem(const class UObject* WorldContextObject);
	static class AHumanPlayerController* GetHumanPlayerControllerByControllerId(int32 ID, const class UObject* WorldContextObject);
	static class ULeaderboardSystem* GetLeaderboardSystem(const class UObject* WorldContextObject);
	static class UMapsManager* GetMapsManager(const class UObject* WorldContextObject);
	static class UPlatformStoreSystem* GetPlatformStoreSystem(const class UObject* WorldContextObject);
	static class UPlatformTools* GetPlatformTools(const class UObject* WorldContextObject);
	static class UFlameObjectPoolManager* GetPoolingManagerSystem(const class UObject* WorldContextObject);
	static class URichPresence* GetRichPresence(const class UObject* WorldContextObject);
	static class UServerAuthorityConfig* GetServerAuthorityConfig(const class UObject* WorldContextObject);
	static class UPlatformToolsSteam* GetSteamTools(const class UObject* WorldContextObject);
	static int32 GetUserControllerId(const class UObject* WorldContextObject);
	static void InitDataProvider(const class UObject* WorldContextObject);
	static bool IsAutotestRunning(const class UObject* WorldContextObject);
	static bool LoginToCloud(const class UObject* WorldContextObject);
	static bool LogOutFromCloud(const class UObject* WorldContextObject, ECloudManagerLogoutReason ELogoutReason);

	void AchievementsReset();
	void AchievementsSetProgress(class FName AchievementName, float Progress);
	void ApplyBenchmarkResult();
	void ApplyShouldRecompileSettings(class UOptionsSaveGame* OptionSaveGame);
	void CancelMatchmaking();
	void ChangeAxisMappingData();
	void ChangeDisplayMonitor(int32 MonitorNumber);
	void CheckFPSEnabled(int32 ZOrder, bool CreateNew);
	void CheckInputModification();
	void ClearOptionsSaveGame();
	void ComputeClientPings();
	void DebugAudioLocations();
	void DebugAudioParameters();
	void DelayMinimize();
	void EnableMinimizeAfterDuration();
	void FadeOutLoadingSound(float FadeOutTimeOverride);
	void FlushQueuedOptionsSaveGameToDisk();
	class UGameUserSettings* GetCachedUserSettings();
	class FString GetCPUBrandName();
	int32 GetCPUCores();
	class FString GetCPUVendorName();
	class UOptionsSaveGame* GetDefaultOptionsSaveGame();
	class FString GetGPUBrandName();
	const EInputMode GetLastInputMode();
	class USoundBase* GetLoadingSound(float TimeToTravel, const class FName& LevelName, float* FadeInTime, float* FadeOutTime, float* FadeOutDelay);
	int32 GetNumMonitors();
	class USaveGame* GetOptionsSaveGame();
	bool GetPerformanceModeEnabled();
	int32 GetWindowMode();
	void GroupInvite();
	void GroupLeave();
	void GroupSimulate(const class FString& GroupId, int32 GroupSize);
	bool HasPSONumPrecompilesActive();
	bool HasPSONumPrecompilesRemaining();
	void InitChallengeManager();
	void InitPostDataReadySystems();
	void InitSettingsProfileSystems();
	bool IsOnSteamDeck();
	bool IsPerfModeSupported();
	bool IsRunningSteam();
	bool IsWindowModeBorderless();
	void LLMMemReport();
	void MinimizeWindow();
	void OnCheckUserCrossPlayFinished(bool CanUserCrossPlay);
	void OnCloudSystemStateChanged(ECloudManagerState OldState, ECloudManagerState NewState);
	void OnDataProviderStateChanged(EDataProviderState OldState, EDataProviderState NewState);
	void OnNetworkFailure(class UWorld* InWorld, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString);
	void OnPlatformStoreOverlayActivated(bool bIsActive);
	void OnPostLoadMap(class UWorld* NewWorld);
	void OnTravelFailure(class UWorld* InWorld, ETravelFailure FailureType, const class FString& ErrorString);
	void PCControlsChanged();
	bool PerfModeChanged();
	void PlayLoadingSound(const class FName& LevelName);
	void ProcessPSOCacheWait();
	void ReloadOptionsSaveGame(bool bSkipReset);
	void RunHardwareTestCache();
	void RunPSOCachingProcess();
	void SetLastMatchID(const class FString& NewMatchID);
	void SetLastMatchMakingMatchID(const class FString& MatchID);
	void SetNumberOfPlayedGames(int32 NumberOfPlayedGames);
	void SetOptionsMenuShutdown();
	void SetPerformanceMode(bool Value);
	void SetPSOCacheBackground();
	void SetPSOCacheData();
	void SetPSOCacheFast();
	void SetPSOCacheSave();
	void ShowGameWindow();
	void ShowGroupSystemInfo();
	void ShowLocalPlayers();
	void ShowResolution();
	void Shutdown();
	void SimulateOnPlatformStoreOverlayDeActivated();
	void SkipPSOCachingProcess();
	void StartLoadingSoundFadeOutCountdown(float FadeOutDelayTimeOverride, float FadeOutTimeOverride);
	void StartMatchmaking(const class FString& Map, const class FString& GameMode, bool bForceParty);
	void StopLoadingSoundFadeOutCountdown();
	void ToggleFullScreen();

	bool CanBeCanceledMatchmaking() const;
	class FText GetAllFormattedVersions() const;
	class UFlameAssetManager* GetAssetManager() const;
	class FText GetFormattedVersion() const;
	class FText GetFormattedVersionForUI() const;
	class FString GetLastGameModeAlias() const;
	class FString GetLastMatchID() const;
	class FString GetLastMatchMakingMatchID() const;
	class UAudioComponent* GetLoadingSoundAudioComponent() const;
	class FString GetMatchmakingGameMode() const;
	class USaveGame* LoadPlayerOptionsSaveGameFromDisk() const;
	bool MatchmakingInProgress() const;
	bool SafeSyncDeleteGameFromSlot(const class FString& SlotName, const int32 UserIndex) const;
	class USaveGame* SafeSyncLoadGameFromSlot(const class FString& SlotName, const int32 UserIndex) const;
	bool SafeSyncSaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameGameInstance">();
	}
	static class UFlameGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameGameInstance>();
	}
};
static_assert(alignof(UFlameGameInstance) == 0x000008, "Wrong alignment on UFlameGameInstance");
static_assert(sizeof(UFlameGameInstance) == 0x0007C0, "Wrong size on UFlameGameInstance");
static_assert(offsetof(UFlameGameInstance, UICoreObject) == 0x0004C0, "Member 'UFlameGameInstance::UICoreObject' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ProfilePictureCache) == 0x0004C8, "Member 'UFlameGameInstance::ProfilePictureCache' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, NotificationSystem) == 0x0004D0, "Member 'UFlameGameInstance::NotificationSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CloudSystem) == 0x0004D8, "Member 'UFlameGameInstance::CloudSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CloudSystemClass) == 0x0004E0, "Member 'UFlameGameInstance::CloudSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PlatformStoreSystem) == 0x0004E8, "Member 'UFlameGameInstance::PlatformStoreSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PlatformStoreSystemClass) == 0x0004F0, "Member 'UFlameGameInstance::PlatformStoreSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PlatformTools) == 0x0004F8, "Member 'UFlameGameInstance::PlatformTools' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PlatformToolsClass) == 0x000500, "Member 'UFlameGameInstance::PlatformToolsClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, GameStoreSystem) == 0x000508, "Member 'UFlameGameInstance::GameStoreSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, GameStoreSystemClass) == 0x000510, "Member 'UFlameGameInstance::GameStoreSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, LeaderboardSystem) == 0x000518, "Member 'UFlameGameInstance::LeaderboardSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, LeaderboardSystemClass) == 0x000520, "Member 'UFlameGameInstance::LeaderboardSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, HeartBeatSystem) == 0x000528, "Member 'UFlameGameInstance::HeartBeatSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, FlameSaveSystem) == 0x000530, "Member 'UFlameGameInstance::FlameSaveSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PingManager) == 0x000538, "Member 'UFlameGameInstance::PingManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, DataProvider) == 0x000540, "Member 'UFlameGameInstance::DataProvider' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, DataProviderClass) == 0x000548, "Member 'UFlameGameInstance::DataProviderClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ServerJoinHandler) == 0x000550, "Member 'UFlameGameInstance::ServerJoinHandler' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, GroupSystem) == 0x000558, "Member 'UFlameGameInstance::GroupSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AnalyticsManager) == 0x000560, "Member 'UFlameGameInstance::AnalyticsManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AnalyticsManagerClass) == 0x000568, "Member 'UFlameGameInstance::AnalyticsManagerClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ConsoleEvents) == 0x000570, "Member 'UFlameGameInstance::ConsoleEvents' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, RichPresence) == 0x000578, "Member 'UFlameGameInstance::RichPresence' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AchievementsSystem) == 0x000580, "Member 'UFlameGameInstance::AchievementsSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AssetManager) == 0x000588, "Member 'UFlameGameInstance::AssetManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ObjectPoolManager) == 0x000590, "Member 'UFlameGameInstance::ObjectPoolManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ServerAuthorityConfig) == 0x000598, "Member 'UFlameGameInstance::ServerAuthorityConfig' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, EventSystemClass) == 0x0005A0, "Member 'UFlameGameInstance::EventSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ChallengeManagerClass) == 0x0005A8, "Member 'UFlameGameInstance::ChallengeManagerClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, BattlePassSystemClass) == 0x0005B0, "Member 'UFlameGameInstance::BattlePassSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CloudNotificationSystemClass) == 0x0005B8, "Member 'UFlameGameInstance::CloudNotificationSystemClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, MapsManagerClass) == 0x0005C0, "Member 'UFlameGameInstance::MapsManagerClass' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, EventSystem) == 0x0005C8, "Member 'UFlameGameInstance::EventSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, ChallengeManager) == 0x0005D0, "Member 'UFlameGameInstance::ChallengeManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, BattlePassSystem) == 0x0005D8, "Member 'UFlameGameInstance::BattlePassSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CloudNotificationSystem) == 0x0005E0, "Member 'UFlameGameInstance::CloudNotificationSystem' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, MapsManager) == 0x0005E8, "Member 'UFlameGameInstance::MapsManager' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AppVersionMajor) == 0x0005F0, "Member 'UFlameGameInstance::AppVersionMajor' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AppVersionMinor) == 0x0005F4, "Member 'UFlameGameInstance::AppVersionMinor' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, AppVersionBugfix) == 0x0005F8, "Member 'UFlameGameInstance::AppVersionBugfix' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, BuildNumber) == 0x0005FC, "Member 'UFlameGameInstance::BuildNumber' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, PCInputVersionNumber) == 0x000600, "Member 'UFlameGameInstance::PCInputVersionNumber' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CanMinimizeWindow) == 0x000604, "Member 'UFlameGameInstance::CanMinimizeWindow' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, LastMatchID) == 0x000610, "Member 'UFlameGameInstance::LastMatchID' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnInputModeChanged) == 0x000620, "Member 'UFlameGameInstance::OnInputModeChanged' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnPlatformStoreInitFinished) == 0x000630, "Member 'UFlameGameInstance::OnPlatformStoreInitFinished' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OverlayListener) == 0x000660, "Member 'UFlameGameInstance::OverlayListener' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, SelectedResolutionIndex) == 0x00066C, "Member 'UFlameGameInstance::SelectedResolutionIndex' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, InitialShadersToCompile) == 0x000678, "Member 'UFlameGameInstance::InitialShadersToCompile' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, TestShadersRemaining) == 0x00067C, "Member 'UFlameGameInstance::TestShadersRemaining' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, TestTotalShaders) == 0x000680, "Member 'UFlameGameInstance::TestTotalShaders' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, IsSimulatingPSOCache) == 0x000684, "Member 'UFlameGameInstance::IsSimulatingPSOCache' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnPSOCacheCompleteDelegate) == 0x000688, "Member 'UFlameGameInstance::OnPSOCacheCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnPSOCacheSkipDelegate) == 0x000698, "Member 'UFlameGameInstance::OnPSOCacheSkipDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnFPSOCacheProgressDelegate) == 0x0006A8, "Member 'UFlameGameInstance::OnFPSOCacheProgressDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CacheLoadingTime) == 0x0006B8, "Member 'UFlameGameInstance::CacheLoadingTime' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, DefaultOptionSaveGameClasses) == 0x0006C0, "Member 'UFlameGameInstance::DefaultOptionSaveGameClasses' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnSaveGameChangeNotifyDelegate) == 0x000710, "Member 'UFlameGameInstance::OnSaveGameChangeNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnVideoSettingsChangeDelegate) == 0x000720, "Member 'UFlameGameInstance::OnVideoSettingsChangeDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnQualitySettingsChangeDelegate) == 0x000730, "Member 'UFlameGameInstance::OnQualitySettingsChangeDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnKeyboardSettingsChangeDelegate) == 0x000740, "Member 'UFlameGameInstance::OnKeyboardSettingsChangeDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnPCControlsChange) == 0x000750, "Member 'UFlameGameInstance::OnPCControlsChange' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnGameSettingsChangedDelegate) == 0x000760, "Member 'UFlameGameInstance::OnGameSettingsChangedDelegate' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OnServerConnectionStateUpdated) == 0x000770, "Member 'UFlameGameInstance::OnServerConnectionStateUpdated' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, CloudGeneration) == 0x000780, "Member 'UFlameGameInstance::CloudGeneration' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, TotalHC) == 0x000784, "Member 'UFlameGameInstance::TotalHC' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, LobbyPriceList) == 0x000788, "Member 'UFlameGameInstance::LobbyPriceList' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, OptionsSaveGame) == 0x000798, "Member 'UFlameGameInstance::OptionsSaveGame' has a wrong offset!");
static_assert(offsetof(UFlameGameInstance, QueuedOptionsSaveGame) == 0x0007A0, "Member 'UFlameGameInstance::QueuedOptionsSaveGame' has a wrong offset!");

// Class Flame.OptionsMenuManager
// 0x0010 (0x0038 - 0x0028)
class UOptionsMenuManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddElementToStack(class UOptionsElementWidget* Element, bool bIsPending, class FName Page);
	static void AddManuallyToStack(class FName Identifier, const struct FOptionsElementValue& Values, bool bIsPending, class FName Page);
	static void ApplyStack(class FName Page, class UOptionsMenuWidget* OptionsMenuWidget, class USaveGame* SaveGame);
	static void ClearStack(class FName Page);
	static bool HasStack(class FName Page);
	static void RemoveWidgetReferences(class FName Page);
	static void RevertStack(class FName Page, class UOptionsMenuWidget* OptionsMenuWidget, class USaveGame* SaveGame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsMenuManager">();
	}
	static class UOptionsMenuManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsMenuManager>();
	}
};
static_assert(alignof(UOptionsMenuManager) == 0x000008, "Wrong alignment on UOptionsMenuManager");
static_assert(sizeof(UOptionsMenuManager) == 0x000038, "Wrong size on UOptionsMenuManager");

// Class Flame.NavLinkClimbComponent
// 0x0000 (0x0190 - 0x0190)
class UNavLinkClimbComponent final : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkClimbComponent">();
	}
	static class UNavLinkClimbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkClimbComponent>();
	}
};
static_assert(alignof(UNavLinkClimbComponent) == 0x000008, "Wrong alignment on UNavLinkClimbComponent");
static_assert(sizeof(UNavLinkClimbComponent) == 0x000190, "Wrong size on UNavLinkClimbComponent");

// Class Flame.FlameGameSession
// 0x0020 (0x0258 - 0x0238)
class AFlameGameSession final : public AGameSession
{
public:
	uint8                                         Pad_238[0x20];                                     // 0x0238(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameGameSession">();
	}
	static class AFlameGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameGameSession>();
	}
};
static_assert(alignof(AFlameGameSession) == 0x000008, "Wrong alignment on AFlameGameSession");
static_assert(sizeof(AFlameGameSession) == 0x000258, "Wrong size on AFlameGameSession");

// Class Flame.FlameGridWidget
// 0x0018 (0x02F0 - 0x02D8)
class UFlameGridWidget : public UDynamicContainerWidget
{
public:
	class UUniformGridPanel*                      GridPanel;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviewWidth;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviewHeight;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Width;                                             // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Height;                                            // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetGridDimensions(int32 GridWidth, int32 GridHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameGridWidget">();
	}
	static class UFlameGridWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameGridWidget>();
	}
};
static_assert(alignof(UFlameGridWidget) == 0x000008, "Wrong alignment on UFlameGridWidget");
static_assert(sizeof(UFlameGridWidget) == 0x0002F0, "Wrong size on UFlameGridWidget");
static_assert(offsetof(UFlameGridWidget, GridPanel) == 0x0002D8, "Member 'UFlameGridWidget::GridPanel' has a wrong offset!");
static_assert(offsetof(UFlameGridWidget, PreviewWidth) == 0x0002E0, "Member 'UFlameGridWidget::PreviewWidth' has a wrong offset!");
static_assert(offsetof(UFlameGridWidget, PreviewHeight) == 0x0002E4, "Member 'UFlameGridWidget::PreviewHeight' has a wrong offset!");
static_assert(offsetof(UFlameGridWidget, Width) == 0x0002E8, "Member 'UFlameGridWidget::Width' has a wrong offset!");
static_assert(offsetof(UFlameGridWidget, Height) == 0x0002EC, "Member 'UFlameGridWidget::Height' has a wrong offset!");

// Class Flame.QRDisplayer
// 0x0000 (0x02B8 - 0x02B8)
class UQRDisplayer : public UFlameWidget
{
public:
	class UTexture2D* GenerateQrCode(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QRDisplayer">();
	}
	static class UQRDisplayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQRDisplayer>();
	}
};
static_assert(alignof(UQRDisplayer) == 0x000008, "Wrong alignment on UQRDisplayer");
static_assert(sizeof(UQRDisplayer) == 0x0002B8, "Wrong size on UQRDisplayer");

// Class Flame.FlameInputKeySelector
// 0x0620 (0x0728 - 0x0108)
class UFlameInputKeySelector final : public UWidget
{
public:
	struct FButtonStyle                           WidgetStyle;                                       // 0x0108(0x0278)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        TextStyle;                                         // 0x0380(0x0270)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInputChord                            SelectedKey;                                       // 0x05F0(0x0020)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x0610(0x0058)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Margin;                                            // 0x0668(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0678(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KeySelectionText;                                  // 0x0688(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   NoKeySpecifiedText;                                // 0x06A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAllowModifierKeys;                                // 0x06B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGamepadKeys;                                 // 0x06B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BA[0x6];                                      // 0x06BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           EscapeKeys;                                        // 0x06C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseLongName;                                      // 0x06D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAllCaps;                                       // 0x06D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D2[0x6];                                      // 0x06D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AdditionalKeyText;                                 // 0x06D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETextJustify                                  TextJustification;                                 // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F1[0x7];                                      // 0x06F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnKeySelected;                                     // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsSelectingKeyChanged;                           // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_718[0x10];                                     // 0x0718(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetSelectorTextDesiredSize();
	void OnIsSelectingKeyChanged__DelegateSignature();
	void OnKeySelected__DelegateSignature(const struct FInputChord& SelectedKey_0);
	void SetAdditionalKeyText(const class FText& InAdditionalKeyText);
	void SetAllowGamepadKeys(bool bInAllowGamepadKeys);
	void SetAllowModifierKeys(bool bInAllowModifierKeys);
	void SetEscapeKeys(const TArray<struct FKey>& InKeys);
	void SetKeySelectionText(const class FText& InKeySelectionText);
	void SetNoKeySpecifiedText(const class FText& InNoKeySpecifiedText);
	void SetSelectedKey(const struct FInputChord& InSelectedKey);
	void SetTextBlockVisibility(const ESlateVisibility InVisibility);
	void SynchronizeProperties();

	bool GetIsSelectingKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameInputKeySelector">();
	}
	static class UFlameInputKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameInputKeySelector>();
	}
};
static_assert(alignof(UFlameInputKeySelector) == 0x000008, "Wrong alignment on UFlameInputKeySelector");
static_assert(sizeof(UFlameInputKeySelector) == 0x000728, "Wrong size on UFlameInputKeySelector");
static_assert(offsetof(UFlameInputKeySelector, WidgetStyle) == 0x000108, "Member 'UFlameInputKeySelector::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, TextStyle) == 0x000380, "Member 'UFlameInputKeySelector::TextStyle' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, SelectedKey) == 0x0005F0, "Member 'UFlameInputKeySelector::SelectedKey' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, Font) == 0x000610, "Member 'UFlameInputKeySelector::Font' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, Margin) == 0x000668, "Member 'UFlameInputKeySelector::Margin' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, ColorAndOpacity) == 0x000678, "Member 'UFlameInputKeySelector::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, KeySelectionText) == 0x000688, "Member 'UFlameInputKeySelector::KeySelectionText' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, NoKeySpecifiedText) == 0x0006A0, "Member 'UFlameInputKeySelector::NoKeySpecifiedText' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, bAllowModifierKeys) == 0x0006B8, "Member 'UFlameInputKeySelector::bAllowModifierKeys' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, bAllowGamepadKeys) == 0x0006B9, "Member 'UFlameInputKeySelector::bAllowGamepadKeys' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, EscapeKeys) == 0x0006C0, "Member 'UFlameInputKeySelector::EscapeKeys' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, bUseLongName) == 0x0006D0, "Member 'UFlameInputKeySelector::bUseLongName' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, bUseAllCaps) == 0x0006D1, "Member 'UFlameInputKeySelector::bUseAllCaps' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, AdditionalKeyText) == 0x0006D8, "Member 'UFlameInputKeySelector::AdditionalKeyText' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, TextJustification) == 0x0006F0, "Member 'UFlameInputKeySelector::TextJustification' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, OnKeySelected) == 0x0006F8, "Member 'UFlameInputKeySelector::OnKeySelected' has a wrong offset!");
static_assert(offsetof(UFlameInputKeySelector, OnIsSelectingKeyChanged) == 0x000708, "Member 'UFlameInputKeySelector::OnIsSelectingKeyChanged' has a wrong offset!");

// Class Flame.OnboardingLoginRewardsComponent
// 0x0020 (0x00D0 - 0x00B0)
class UOnboardingLoginRewardsComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetOnboardingLoginRewardsFinished;                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClaimOnboardingLoginRewardsFinished;               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 ClaimOnboardingLoginRewards(class AHumanPlayerController* Player);
	void ClaimOnboardingLoginRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudClaimOnboardingLoginRewardsResult& Data);
	int32 GetOnboardingLoginRewards(class AHumanPlayerController* Player);
	void GetOnboardingLoginRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetOnboardingLoginRewardsResult& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingLoginRewardsComponent">();
	}
	static class UOnboardingLoginRewardsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnboardingLoginRewardsComponent>();
	}
};
static_assert(alignof(UOnboardingLoginRewardsComponent) == 0x000008, "Wrong alignment on UOnboardingLoginRewardsComponent");
static_assert(sizeof(UOnboardingLoginRewardsComponent) == 0x0000D0, "Wrong size on UOnboardingLoginRewardsComponent");
static_assert(offsetof(UOnboardingLoginRewardsComponent, GetOnboardingLoginRewardsFinished) == 0x0000B0, "Member 'UOnboardingLoginRewardsComponent::GetOnboardingLoginRewardsFinished' has a wrong offset!");
static_assert(offsetof(UOnboardingLoginRewardsComponent, ClaimOnboardingLoginRewardsFinished) == 0x0000C0, "Member 'UOnboardingLoginRewardsComponent::ClaimOnboardingLoginRewardsFinished' has a wrong offset!");

// Class Flame.FlameLevelScriptActor
// 0x0000 (0x0228 - 0x0228)
class AFlameLevelScriptActor : public ALevelScriptActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameLevelScriptActor">();
	}
	static class AFlameLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameLevelScriptActor>();
	}
};
static_assert(alignof(AFlameLevelScriptActor) == 0x000008, "Wrong alignment on AFlameLevelScriptActor");
static_assert(sizeof(AFlameLevelScriptActor) == 0x000228, "Wrong size on AFlameLevelScriptActor");

// Class Flame.PlayerStartFlame
// 0x0038 (0x0288 - 0x0250)
class APlayerStartFlame : public APlayerStart
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PlayerStartTags;                                   // 0x0258(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0xF];                                      // 0x0279(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartFlame">();
	}
	static class APlayerStartFlame* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartFlame>();
	}
};
static_assert(alignof(APlayerStartFlame) == 0x000008, "Wrong alignment on APlayerStartFlame");
static_assert(sizeof(APlayerStartFlame) == 0x000288, "Wrong size on APlayerStartFlame");
static_assert(offsetof(APlayerStartFlame, PlayerStartTags) == 0x000258, "Member 'APlayerStartFlame::PlayerStartTags' has a wrong offset!");
static_assert(offsetof(APlayerStartFlame, bIsEnabled) == 0x000278, "Member 'APlayerStartFlame::bIsEnabled' has a wrong offset!");

// Class Flame.FlameLocomotionInstance
// 0x00A0 (0x0360 - 0x02C0)
class UFlameLocomotionInstance final : public UAnimInstance
{
public:
	class AHumanCharacter*                        Human;                                             // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AzimuthTwitchGuard;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedTwitchGuard;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontBackSwitchDuration;                           // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchToForwardStateAfter;                         // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontBackSwitchSpeed;                              // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpeedMode                                    SpeedMode;                                         // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLocomotionStateDef                    LocomAssets;                                       // 0x02E0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurrentLocomotionAssetSet             CurrentAssets;                                     // 0x0318(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDir;                                          // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSpeed(ESpeedMode Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameLocomotionInstance">();
	}
	static class UFlameLocomotionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameLocomotionInstance>();
	}
};
static_assert(alignof(UFlameLocomotionInstance) == 0x000010, "Wrong alignment on UFlameLocomotionInstance");
static_assert(sizeof(UFlameLocomotionInstance) == 0x000360, "Wrong size on UFlameLocomotionInstance");
static_assert(offsetof(UFlameLocomotionInstance, Human) == 0x0002B8, "Member 'UFlameLocomotionInstance::Human' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, AzimuthTwitchGuard) == 0x0002C0, "Member 'UFlameLocomotionInstance::AzimuthTwitchGuard' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, SpeedTwitchGuard) == 0x0002C8, "Member 'UFlameLocomotionInstance::SpeedTwitchGuard' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, FrontBackSwitchDuration) == 0x0002D0, "Member 'UFlameLocomotionInstance::FrontBackSwitchDuration' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, SwitchToForwardStateAfter) == 0x0002D4, "Member 'UFlameLocomotionInstance::SwitchToForwardStateAfter' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, FrontBackSwitchSpeed) == 0x0002D8, "Member 'UFlameLocomotionInstance::FrontBackSwitchSpeed' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, SpeedMode) == 0x0002DC, "Member 'UFlameLocomotionInstance::SpeedMode' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, LocomAssets) == 0x0002E0, "Member 'UFlameLocomotionInstance::LocomAssets' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, CurrentAssets) == 0x000318, "Member 'UFlameLocomotionInstance::CurrentAssets' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, Speed) == 0x000338, "Member 'UFlameLocomotionInstance::Speed' has a wrong offset!");
static_assert(offsetof(UFlameLocomotionInstance, BlendDir) == 0x00033C, "Member 'UFlameLocomotionInstance::BlendDir' has a wrong offset!");

// Class Flame.FlamePoolObject
// 0x0000 (0x0028 - 0x0028)
class IFlamePoolObject final : public IInterface
{
public:
	void OnPoolDespawn();
	void OnPoolSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamePoolObject">();
	}
	static class IFlamePoolObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlamePoolObject>();
	}
};
static_assert(alignof(IFlamePoolObject) == 0x000008, "Wrong alignment on IFlamePoolObject");
static_assert(sizeof(IFlamePoolObject) == 0x000028, "Wrong size on IFlamePoolObject");

// Class Flame.FlameObjectPoolManager
// 0x00A0 (0x00C8 - 0x0028)
class UFlameObjectPoolManager final : public UObject
{
public:
	float                                         ObjectsTTL;                                        // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FPoolItems>        Pool;                                              // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x48];                                      // 0x0080(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* Create(class UClass* Class_0);
	class UObject* Get(class UClass* Class_0);
	void OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources);
	void PutBack(class UObject* Object, float LifeSpan);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameObjectPoolManager">();
	}
	static class UFlameObjectPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameObjectPoolManager>();
	}
};
static_assert(alignof(UFlameObjectPoolManager) == 0x000008, "Wrong alignment on UFlameObjectPoolManager");
static_assert(sizeof(UFlameObjectPoolManager) == 0x0000C8, "Wrong size on UFlameObjectPoolManager");
static_assert(offsetof(UFlameObjectPoolManager, ObjectsTTL) == 0x000028, "Member 'UFlameObjectPoolManager::ObjectsTTL' has a wrong offset!");
static_assert(offsetof(UFlameObjectPoolManager, Pool) == 0x000030, "Member 'UFlameObjectPoolManager::Pool' has a wrong offset!");

// Class Flame.OnlineRawDataComponent
// 0x0060 (0x0110 - 0x00B0)
class UOnlineRawDataComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetCloudRawDataAllUsersOrderedFinished;            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetCloudRawDataAllUsersFinished;                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetCloudAllRawDataForUserFinished;                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetCloudRawDataKeyFinished;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SetCloudRawDataKeyFinished;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClearCloudRawKeyDataFinished;                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 ClearCloudRawKeyData(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName);
	void ClearCloudRawKeyDataDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	int32 GetCloudAllRawDataForUser(class AHumanPlayerController* Player);
	void GetCloudAllRawDataForUserDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetAllRawDataForUserResult& Data);
	int32 GetCloudRawDataAllUsers(const class FString& CategoryName, const class FString& KeyName);
	void GetCloudRawDataAllUsersDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataAllUsersResult& Data);
	int32 GetCloudRawDataAllUsersOrdered(const class FString& CategoryName, const class FString& KeyName, EGetAllRawDataOrder Order, const class FString& SortValue, int32 PageIndex, int32 PageSize);
	void GetCloudRawDataAllUsersOrderedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataAllUsersOrderedResult& Data);
	int32 GetCloudRawDataKey(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName);
	void GetCloudRawDataKeyDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetRawDataKeyResult& Data);
	int32 SetCloudRawDataKey(class AHumanPlayerController* Player, const class FString& CategoryName, const class FString& KeyName, const class UJsonValue* Data);
	void SetCloudRawDataKeyDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudRawDataInfo& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineRawDataComponent">();
	}
	static class UOnlineRawDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineRawDataComponent>();
	}
};
static_assert(alignof(UOnlineRawDataComponent) == 0x000008, "Wrong alignment on UOnlineRawDataComponent");
static_assert(sizeof(UOnlineRawDataComponent) == 0x000110, "Wrong size on UOnlineRawDataComponent");
static_assert(offsetof(UOnlineRawDataComponent, GetCloudRawDataAllUsersOrderedFinished) == 0x0000B0, "Member 'UOnlineRawDataComponent::GetCloudRawDataAllUsersOrderedFinished' has a wrong offset!");
static_assert(offsetof(UOnlineRawDataComponent, GetCloudRawDataAllUsersFinished) == 0x0000C0, "Member 'UOnlineRawDataComponent::GetCloudRawDataAllUsersFinished' has a wrong offset!");
static_assert(offsetof(UOnlineRawDataComponent, GetCloudAllRawDataForUserFinished) == 0x0000D0, "Member 'UOnlineRawDataComponent::GetCloudAllRawDataForUserFinished' has a wrong offset!");
static_assert(offsetof(UOnlineRawDataComponent, GetCloudRawDataKeyFinished) == 0x0000E0, "Member 'UOnlineRawDataComponent::GetCloudRawDataKeyFinished' has a wrong offset!");
static_assert(offsetof(UOnlineRawDataComponent, SetCloudRawDataKeyFinished) == 0x0000F0, "Member 'UOnlineRawDataComponent::SetCloudRawDataKeyFinished' has a wrong offset!");
static_assert(offsetof(UOnlineRawDataComponent, ClearCloudRawKeyDataFinished) == 0x000100, "Member 'UOnlineRawDataComponent::ClearCloudRawKeyDataFinished' has a wrong offset!");

// Class Flame.OptionsSaveGame
// 0x01C8 (0x01F0 - 0x0028)
class UOptionsSaveGame : public USaveGame
{
public:
	struct FAudioPlayerSettings                   AudioSettings;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVideoSaveSettings                     VideoSettings;                                     // 0x0040(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FStickInputSettings                    StickInputSettings;                                // 0x00A0(0x0090)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAimAssistSettings                     AimAssistSettings;                                 // 0x0130(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMotionAimSettings                     MotionAimSettings;                                 // 0x013C(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMouseSettings                         MouseSettings;                                     // 0x0150(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKeyboardSettings                      KeyboardSettings;                                  // 0x0178(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMiscInputSettings                     MiscInputSettings;                                 // 0x0190(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameSaveSettings                      GameSettings;                                      // 0x01A0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x01E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        Revision;                                          // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static float GetGlobalSafeZoneScale();

	void ApplyMouseSettings(class APlayerController* PC);
	void ClearAllKeyBindings(bool IsRightHanded, const struct FKey& Key);
	class FString GetQualitySettingsLevel();
	void SaveKeyBinding(class FName Name_0, bool IsRightHanded, const struct FKey& Key1, const struct FKey& Key2);

	const struct FGameSaveSettings GetGameSettings() const;
	const struct FVideoSaveSettings GetVideoSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsSaveGame">();
	}
	static class UOptionsSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsSaveGame>();
	}
};
static_assert(alignof(UOptionsSaveGame) == 0x000008, "Wrong alignment on UOptionsSaveGame");
static_assert(sizeof(UOptionsSaveGame) == 0x0001F0, "Wrong size on UOptionsSaveGame");
static_assert(offsetof(UOptionsSaveGame, AudioSettings) == 0x000028, "Member 'UOptionsSaveGame::AudioSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, VideoSettings) == 0x000040, "Member 'UOptionsSaveGame::VideoSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, StickInputSettings) == 0x0000A0, "Member 'UOptionsSaveGame::StickInputSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, AimAssistSettings) == 0x000130, "Member 'UOptionsSaveGame::AimAssistSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, MotionAimSettings) == 0x00013C, "Member 'UOptionsSaveGame::MotionAimSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, MouseSettings) == 0x000150, "Member 'UOptionsSaveGame::MouseSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, KeyboardSettings) == 0x000178, "Member 'UOptionsSaveGame::KeyboardSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, MiscInputSettings) == 0x000190, "Member 'UOptionsSaveGame::MiscInputSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, GameSettings) == 0x0001A0, "Member 'UOptionsSaveGame::GameSettings' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, UserIndex) == 0x0001E8, "Member 'UOptionsSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UOptionsSaveGame, Revision) == 0x0001EC, "Member 'UOptionsSaveGame::Revision' has a wrong offset!");

// Class Flame.PlayVoiceSoundNotify
// 0x0020 (0x0058 - 0x0038)
class UPlayVoiceSoundNotify final : public UAnimNotify
{
public:
	class USoundBase*                             MaleSound;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FemaleSound;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGesture;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VoiceSoundType;                                    // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatTime;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayVoiceSoundNotify">();
	}
	static class UPlayVoiceSoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayVoiceSoundNotify>();
	}
};
static_assert(alignof(UPlayVoiceSoundNotify) == 0x000008, "Wrong alignment on UPlayVoiceSoundNotify");
static_assert(sizeof(UPlayVoiceSoundNotify) == 0x000058, "Wrong size on UPlayVoiceSoundNotify");
static_assert(offsetof(UPlayVoiceSoundNotify, MaleSound) == 0x000038, "Member 'UPlayVoiceSoundNotify::MaleSound' has a wrong offset!");
static_assert(offsetof(UPlayVoiceSoundNotify, FemaleSound) == 0x000040, "Member 'UPlayVoiceSoundNotify::FemaleSound' has a wrong offset!");
static_assert(offsetof(UPlayVoiceSoundNotify, bIsGesture) == 0x000048, "Member 'UPlayVoiceSoundNotify::bIsGesture' has a wrong offset!");
static_assert(offsetof(UPlayVoiceSoundNotify, VoiceSoundType) == 0x00004C, "Member 'UPlayVoiceSoundNotify::VoiceSoundType' has a wrong offset!");
static_assert(offsetof(UPlayVoiceSoundNotify, RepeatTime) == 0x000054, "Member 'UPlayVoiceSoundNotify::RepeatTime' has a wrong offset!");

// Class Flame.FlameAsyncSaveSystem
// 0x0028 (0x0050 - 0x0028)
class UFlameAsyncSaveSystem final : public UFlameSaveSystem
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameAsyncSaveSystem">();
	}
	static class UFlameAsyncSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameAsyncSaveSystem>();
	}
};
static_assert(alignof(UFlameAsyncSaveSystem) == 0x000008, "Wrong alignment on UFlameAsyncSaveSystem");
static_assert(sizeof(UFlameAsyncSaveSystem) == 0x000050, "Wrong size on UFlameAsyncSaveSystem");

// Class Flame.FlameGameLoad
// 0x0050 (0x0080 - 0x0030)
class UFlameGameLoad final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnLoadSucceed;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadFailed;                                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFlameGameLoad* LoadGameFromSlotByPlatform(class UFlameGameInstance* FlameGameInstance, const class FString& SlotName, const int32 UserIndex);

	void ReceivedLoadResults(class USaveGame* SaveGameObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameGameLoad">();
	}
	static class UFlameGameLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlameGameLoad>();
	}
};
static_assert(alignof(UFlameGameLoad) == 0x000008, "Wrong alignment on UFlameGameLoad");
static_assert(sizeof(UFlameGameLoad) == 0x000080, "Wrong size on UFlameGameLoad");
static_assert(offsetof(UFlameGameLoad, OnLoadSucceed) == 0x000030, "Member 'UFlameGameLoad::OnLoadSucceed' has a wrong offset!");
static_assert(offsetof(UFlameGameLoad, OnLoadFailed) == 0x000040, "Member 'UFlameGameLoad::OnLoadFailed' has a wrong offset!");

// Class Flame.FlameSpectator
// 0x0068 (0x0310 - 0x02A8)
class AFlameSpectator final : public ASpectatorPawn
{
public:
	float                                         AfterBurnerSpeedUp;                                // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraArm;                                         // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AFlameHUD*                              FlameHUD;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SpectateTarget;                                    // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSpectateTargetChanged(class AHumanCharacter* NewTarget);
	void OnSpectateTargetRemoved();
	void ReceiveTravel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameSpectator">();
	}
	static class AFlameSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameSpectator>();
	}
};
static_assert(alignof(AFlameSpectator) == 0x000008, "Wrong alignment on AFlameSpectator");
static_assert(sizeof(AFlameSpectator) == 0x000310, "Wrong size on AFlameSpectator");
static_assert(offsetof(AFlameSpectator, AfterBurnerSpeedUp) == 0x0002A8, "Member 'AFlameSpectator::AfterBurnerSpeedUp' has a wrong offset!");
static_assert(offsetof(AFlameSpectator, Camera) == 0x0002B0, "Member 'AFlameSpectator::Camera' has a wrong offset!");
static_assert(offsetof(AFlameSpectator, CameraArm) == 0x0002B8, "Member 'AFlameSpectator::CameraArm' has a wrong offset!");
static_assert(offsetof(AFlameSpectator, FlameHUD) == 0x000300, "Member 'AFlameSpectator::FlameHUD' has a wrong offset!");
static_assert(offsetof(AFlameSpectator, SpectateTarget) == 0x000308, "Member 'AFlameSpectator::SpectateTarget' has a wrong offset!");

// Class Flame.FlameStaticActor
// 0x0008 (0x0228 - 0x0220)
class AFlameStaticActor : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlameStaticActor">();
	}
	static class AFlameStaticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlameStaticActor>();
	}
};
static_assert(alignof(AFlameStaticActor) == 0x000008, "Wrong alignment on AFlameStaticActor");
static_assert(sizeof(AFlameStaticActor) == 0x000228, "Wrong size on AFlameStaticActor");
static_assert(offsetof(AFlameStaticActor, StaticMeshComponent) == 0x000220, "Member 'AFlameStaticActor::StaticMeshComponent' has a wrong offset!");

// Class Flame.FootIKAnimInstance
// 0x0080 (0x0340 - 0x02C0)
class UFootIKAnimInstance : public UAnimInstance
{
public:
	bool                                          bDoFeetIK;                                         // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoIKRootIK;                                       // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebug;                                            // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BB[0x1];                                      // 0x02BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDownHeight;                                     // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxUpHeight;                                       // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HipOffset;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightPosition;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftPosition;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateRateMoving;                                  // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateRateIdle;                                    // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateRateHipsMoving;                              // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateRateHipsIdle;                                // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FootOffset;                                        // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HipAddOffset;                                      // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RayLength;                                         // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               RightFootRot;                                      // 0x02EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               LeftFootRot;                                       // 0x02F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bIsMoving;                                         // 0x0304(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_305[0xB];                                      // 0x0305(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    RightSocket;                                       // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshSocket*                    LeftSocket;                                        // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               IkRootRotation;                                    // 0x0320(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         SimulatedHipOffset;                                // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootIKAnimInstance">();
	}
	static class UFootIKAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootIKAnimInstance>();
	}
};
static_assert(alignof(UFootIKAnimInstance) == 0x000010, "Wrong alignment on UFootIKAnimInstance");
static_assert(sizeof(UFootIKAnimInstance) == 0x000340, "Wrong size on UFootIKAnimInstance");
static_assert(offsetof(UFootIKAnimInstance, bDoFeetIK) == 0x0002B8, "Member 'UFootIKAnimInstance::bDoFeetIK' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, bDoIKRootIK) == 0x0002B9, "Member 'UFootIKAnimInstance::bDoIKRootIK' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, bDebug) == 0x0002BA, "Member 'UFootIKAnimInstance::bDebug' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, MaxDownHeight) == 0x0002BC, "Member 'UFootIKAnimInstance::MaxDownHeight' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, MaxUpHeight) == 0x0002C0, "Member 'UFootIKAnimInstance::MaxUpHeight' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, HipOffset) == 0x0002C4, "Member 'UFootIKAnimInstance::HipOffset' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, RightPosition) == 0x0002C8, "Member 'UFootIKAnimInstance::RightPosition' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, LeftPosition) == 0x0002CC, "Member 'UFootIKAnimInstance::LeftPosition' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, UpdateRateMoving) == 0x0002D0, "Member 'UFootIKAnimInstance::UpdateRateMoving' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, UpdateRateIdle) == 0x0002D4, "Member 'UFootIKAnimInstance::UpdateRateIdle' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, UpdateRateHipsMoving) == 0x0002D8, "Member 'UFootIKAnimInstance::UpdateRateHipsMoving' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, UpdateRateHipsIdle) == 0x0002DC, "Member 'UFootIKAnimInstance::UpdateRateHipsIdle' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, FootOffset) == 0x0002E0, "Member 'UFootIKAnimInstance::FootOffset' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, HipAddOffset) == 0x0002E4, "Member 'UFootIKAnimInstance::HipAddOffset' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, RayLength) == 0x0002E8, "Member 'UFootIKAnimInstance::RayLength' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, RightFootRot) == 0x0002EC, "Member 'UFootIKAnimInstance::RightFootRot' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, LeftFootRot) == 0x0002F8, "Member 'UFootIKAnimInstance::LeftFootRot' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, bIsMoving) == 0x000304, "Member 'UFootIKAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, RightSocket) == 0x000310, "Member 'UFootIKAnimInstance::RightSocket' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, LeftSocket) == 0x000318, "Member 'UFootIKAnimInstance::LeftSocket' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, IkRootRotation) == 0x000320, "Member 'UFootIKAnimInstance::IkRootRotation' has a wrong offset!");
static_assert(offsetof(UFootIKAnimInstance, SimulatedHipOffset) == 0x00032C, "Member 'UFootIKAnimInstance::SimulatedHipOffset' has a wrong offset!");

// Class Flame.FootStepComponent
// 0x0000 (0x00B0 - 0x00B0)
class UFootStepComponent : public UActorComponent
{
public:
	void OnFootStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EFootStepLegIndex FootStepLegIndex, EFootStepMovementType FootStepMovementType);
	void OnLadderStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EPhysicalSurface SurfaceType, ELadderStepLimbIndex LadderStepLimbIndex);
	void OnPlayerEnterWater();
	void OnPlayerExitWater();
	void OnPlayerInWaterTick();
	void OnProneStep(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, EProneStepLimbIndex ProneStepLimbIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepComponent">();
	}
	static class UFootStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepComponent>();
	}
};
static_assert(alignof(UFootStepComponent) == 0x000008, "Wrong alignment on UFootStepComponent");
static_assert(sizeof(UFootStepComponent) == 0x0000B0, "Wrong size on UFootStepComponent");

// Class Flame.LeftFootStepNotify
// 0x0000 (0x0040 - 0x0040)
class ULeftFootStepNotify final : public UFootStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeftFootStepNotify">();
	}
	static class ULeftFootStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeftFootStepNotify>();
	}
};
static_assert(alignof(ULeftFootStepNotify) == 0x000008, "Wrong alignment on ULeftFootStepNotify");
static_assert(sizeof(ULeftFootStepNotify) == 0x000040, "Wrong size on ULeftFootStepNotify");

// Class Flame.ShelterStash
// 0x0108 (0x0420 - 0x0318)
class UShelterStash : public UUpdateableWidget
{
public:
	struct FLinearColor                           EnabledGamepadActionColor;                         // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DisabledGamepadActionColor;                        // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMatchmakingInProgress;                          // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStashState                                   CurrentState;                                      // 0x0339(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStashState                                   PrePreviewState;                                   // 0x033A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B[0x5];                                      // 0x033B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameSlot*                             FocusedSlot;                                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USwapWeaponsWidget>         SwapWeaponsWidgetClass;                            // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwapWeaponsWidget*                     SwapWeaponsWidget;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeapon*                                WeaponInBagToSwap;                                 // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEquipWeaponModalWidget>    EquipWeaponWidgetClass;                            // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipWeaponModalWidget*                EquipWeaponWidget;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameGridWidget*                       BackpackGrid;                                      // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        StashTitle;                                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        LeftPane;                                          // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           StashRootMenu;                                     // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameListWidget*                       CurrentList;                                       // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameListWidget*                       StashList;                                         // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameListWidget*                       AmmoList;                                          // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameListWidget*                       WeaponList;                                        // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponContainerWidget*                 WeaponContainer;                                   // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemInfoWidget*                        ItemInfoWidget;                                    // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        MatchmakingInProgressMessage;                      // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionEquip;                                       // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputChoiceWidget*                     ChoiceAmount;                                      // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionCraft;                                       // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionViewModel;                                   // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionClose;                                       // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URawItemProvider*                       BackpackItemProvider;                              // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShelterStashItemProvider*              StashItemProvider;                                 // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseItemPreviewScreen(TSubclassOf<class AItem> InPreviewedItem);
	void EmptyBackpackToStash();
	void EnterSubmenu(const struct FStashViewContext& InContext);
	void LeaveSubmenu();
	void OnEquipWeaponAfterSwapClosed(class UFlameWidget* FlameWidget);
	void OnEquipWeaponClosed(class UFlameWidget* FlameWidget);
	void OnItemPreviewClosed(TSubclassOf<class AItem> InPreviewedItem);
	void OnItemPreviewOpened(TSubclassOf<class AItem> InItemToPreview);
	void OnLocked();
	void OnSubmenuEntered(const struct FStashViewContext& InContext);
	void OnSubmenuLeft(EInventoryView InView);
	void OnSwapWeaponsClosed(class UFlameWidget* FlameWidget);
	void OnUnlocked();
	void OnViewChanged(EInventoryView InView);
	void OpenItemPreviewScreen(TSubclassOf<class AItem> InItemToPreview);
	void SelectFlameSlot(class UFlameSlot* InFlameSlot, EInputIcon InInputAction);
	void SetView(EInventoryView View);

	bool IsLocked() const;
	bool ShouldOpenEquipWeaponModalWidget(class AWeapon* InWeaponToEquip) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterStash">();
	}
	static class UShelterStash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterStash>();
	}
};
static_assert(alignof(UShelterStash) == 0x000008, "Wrong alignment on UShelterStash");
static_assert(sizeof(UShelterStash) == 0x000420, "Wrong size on UShelterStash");
static_assert(offsetof(UShelterStash, EnabledGamepadActionColor) == 0x000318, "Member 'UShelterStash::EnabledGamepadActionColor' has a wrong offset!");
static_assert(offsetof(UShelterStash, DisabledGamepadActionColor) == 0x000328, "Member 'UShelterStash::DisabledGamepadActionColor' has a wrong offset!");
static_assert(offsetof(UShelterStash, bIsMatchmakingInProgress) == 0x000338, "Member 'UShelterStash::bIsMatchmakingInProgress' has a wrong offset!");
static_assert(offsetof(UShelterStash, CurrentState) == 0x000339, "Member 'UShelterStash::CurrentState' has a wrong offset!");
static_assert(offsetof(UShelterStash, PrePreviewState) == 0x00033A, "Member 'UShelterStash::PrePreviewState' has a wrong offset!");
static_assert(offsetof(UShelterStash, FocusedSlot) == 0x000340, "Member 'UShelterStash::FocusedSlot' has a wrong offset!");
static_assert(offsetof(UShelterStash, SwapWeaponsWidgetClass) == 0x000348, "Member 'UShelterStash::SwapWeaponsWidgetClass' has a wrong offset!");
static_assert(offsetof(UShelterStash, SwapWeaponsWidget) == 0x000350, "Member 'UShelterStash::SwapWeaponsWidget' has a wrong offset!");
static_assert(offsetof(UShelterStash, WeaponInBagToSwap) == 0x000358, "Member 'UShelterStash::WeaponInBagToSwap' has a wrong offset!");
static_assert(offsetof(UShelterStash, EquipWeaponWidgetClass) == 0x000360, "Member 'UShelterStash::EquipWeaponWidgetClass' has a wrong offset!");
static_assert(offsetof(UShelterStash, EquipWeaponWidget) == 0x000368, "Member 'UShelterStash::EquipWeaponWidget' has a wrong offset!");
static_assert(offsetof(UShelterStash, BackpackGrid) == 0x000378, "Member 'UShelterStash::BackpackGrid' has a wrong offset!");
static_assert(offsetof(UShelterStash, StashTitle) == 0x000380, "Member 'UShelterStash::StashTitle' has a wrong offset!");
static_assert(offsetof(UShelterStash, LeftPane) == 0x000388, "Member 'UShelterStash::LeftPane' has a wrong offset!");
static_assert(offsetof(UShelterStash, StashRootMenu) == 0x000390, "Member 'UShelterStash::StashRootMenu' has a wrong offset!");
static_assert(offsetof(UShelterStash, CurrentList) == 0x000398, "Member 'UShelterStash::CurrentList' has a wrong offset!");
static_assert(offsetof(UShelterStash, StashList) == 0x0003A0, "Member 'UShelterStash::StashList' has a wrong offset!");
static_assert(offsetof(UShelterStash, AmmoList) == 0x0003A8, "Member 'UShelterStash::AmmoList' has a wrong offset!");
static_assert(offsetof(UShelterStash, WeaponList) == 0x0003B0, "Member 'UShelterStash::WeaponList' has a wrong offset!");
static_assert(offsetof(UShelterStash, WeaponContainer) == 0x0003B8, "Member 'UShelterStash::WeaponContainer' has a wrong offset!");
static_assert(offsetof(UShelterStash, ItemInfoWidget) == 0x0003C0, "Member 'UShelterStash::ItemInfoWidget' has a wrong offset!");
static_assert(offsetof(UShelterStash, MatchmakingInProgressMessage) == 0x0003C8, "Member 'UShelterStash::MatchmakingInProgressMessage' has a wrong offset!");
static_assert(offsetof(UShelterStash, ActionEquip) == 0x0003D0, "Member 'UShelterStash::ActionEquip' has a wrong offset!");
static_assert(offsetof(UShelterStash, ChoiceAmount) == 0x0003D8, "Member 'UShelterStash::ChoiceAmount' has a wrong offset!");
static_assert(offsetof(UShelterStash, ActionCraft) == 0x0003E0, "Member 'UShelterStash::ActionCraft' has a wrong offset!");
static_assert(offsetof(UShelterStash, ActionViewModel) == 0x0003E8, "Member 'UShelterStash::ActionViewModel' has a wrong offset!");
static_assert(offsetof(UShelterStash, ActionClose) == 0x0003F0, "Member 'UShelterStash::ActionClose' has a wrong offset!");
static_assert(offsetof(UShelterStash, BackpackItemProvider) == 0x0003F8, "Member 'UShelterStash::BackpackItemProvider' has a wrong offset!");
static_assert(offsetof(UShelterStash, StashItemProvider) == 0x000400, "Member 'UShelterStash::StashItemProvider' has a wrong offset!");

// Class Flame.RightArmProneStepNotify
// 0x0000 (0x0040 - 0x0040)
class URightArmProneStepNotify final : public UProneStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightArmProneStepNotify">();
	}
	static class URightArmProneStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URightArmProneStepNotify>();
	}
};
static_assert(alignof(URightArmProneStepNotify) == 0x000008, "Wrong alignment on URightArmProneStepNotify");
static_assert(sizeof(URightArmProneStepNotify) == 0x000040, "Wrong size on URightArmProneStepNotify");

// Class Flame.RightLegProneStepNotify
// 0x0000 (0x0040 - 0x0040)
class URightLegProneStepNotify final : public UProneStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightLegProneStepNotify">();
	}
	static class URightLegProneStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<URightLegProneStepNotify>();
	}
};
static_assert(alignof(URightLegProneStepNotify) == 0x000008, "Wrong alignment on URightLegProneStepNotify");
static_assert(sizeof(URightLegProneStepNotify) == 0x000040, "Wrong size on URightLegProneStepNotify");

// Class Flame.LeaderboardHandlerBase
// 0x0040 (0x0068 - 0x0028)
class ULeaderboardHandlerBase : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardHandlerBase">();
	}
	static class ULeaderboardHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardHandlerBase>();
	}
};
static_assert(alignof(ULeaderboardHandlerBase) == 0x000008, "Wrong alignment on ULeaderboardHandlerBase");
static_assert(sizeof(ULeaderboardHandlerBase) == 0x000068, "Wrong size on ULeaderboardHandlerBase");

// Class Flame.LeaderboardReadBoardBase
// 0x0038 (0x00A0 - 0x0068)
class ULeaderboardReadBoardBase : public ULeaderboardHandlerBase
{
public:
	struct FLeaderboardReadContext                BoardContext;                                      // 0x0068(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x24];                                      // 0x007C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardBase">();
	}
	static class ULeaderboardReadBoardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardBase>();
	}
};
static_assert(alignof(ULeaderboardReadBoardBase) == 0x000008, "Wrong alignment on ULeaderboardReadBoardBase");
static_assert(sizeof(ULeaderboardReadBoardBase) == 0x0000A0, "Wrong size on ULeaderboardReadBoardBase");
static_assert(offsetof(ULeaderboardReadBoardBase, BoardContext) == 0x000068, "Member 'ULeaderboardReadBoardBase::BoardContext' has a wrong offset!");

// Class Flame.LeaderboardReadBoardBaseLocal
// 0x0040 (0x00E0 - 0x00A0)
class ULeaderboardReadBoardBaseLocal : public ULeaderboardReadBoardBase
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardBaseLocal">();
	}
	static class ULeaderboardReadBoardBaseLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardBaseLocal>();
	}
};
static_assert(alignof(ULeaderboardReadBoardBaseLocal) == 0x000008, "Wrong alignment on ULeaderboardReadBoardBaseLocal");
static_assert(sizeof(ULeaderboardReadBoardBaseLocal) == 0x0000E0, "Wrong size on ULeaderboardReadBoardBaseLocal");

// Class Flame.LadderStepNotify
// 0x0008 (0x0040 - 0x0038)
class ULadderStepNotify : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderStepNotify">();
	}
	static class ULadderStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderStepNotify>();
	}
};
static_assert(alignof(ULadderStepNotify) == 0x000008, "Wrong alignment on ULadderStepNotify");
static_assert(sizeof(ULadderStepNotify) == 0x000040, "Wrong size on ULadderStepNotify");

// Class Flame.ArmLadderStepNotify
// 0x0000 (0x0040 - 0x0040)
class UArmLadderStepNotify final : public ULadderStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmLadderStepNotify">();
	}
	static class UArmLadderStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmLadderStepNotify>();
	}
};
static_assert(alignof(UArmLadderStepNotify) == 0x000008, "Wrong alignment on UArmLadderStepNotify");
static_assert(sizeof(UArmLadderStepNotify) == 0x000040, "Wrong size on UArmLadderStepNotify");

// Class Flame.LegLadderStepNotify
// 0x0000 (0x0040 - 0x0040)
class ULegLadderStepNotify final : public ULadderStepNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegLadderStepNotify">();
	}
	static class ULegLadderStepNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegLadderStepNotify>();
	}
};
static_assert(alignof(ULegLadderStepNotify) == 0x000008, "Wrong alignment on ULegLadderStepNotify");
static_assert(sizeof(ULegLadderStepNotify) == 0x000040, "Wrong size on ULegLadderStepNotify");

// Class Flame.SimulateAIMovement
// 0x0000 (0x00A8 - 0x00A8)
class USimulateAIMovement final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimulateAIMovement">();
	}
	static class USimulateAIMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimulateAIMovement>();
	}
};
static_assert(alignof(USimulateAIMovement) == 0x000008, "Wrong alignment on USimulateAIMovement");
static_assert(sizeof(USimulateAIMovement) == 0x0000A8, "Wrong size on USimulateAIMovement");

// Class Flame.FriendInfo
// 0x0010 (0x0038 - 0x0028)
class UFriendInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetDisplayName() const;
	class FString GetRealName() const;
	bool GetUserAttribute(const class FString& AttrName, class FString* OutAttrValue) const;
	struct FUniqueNetIdRepl GetUserId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendInfo">();
	}
	static class UFriendInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendInfo>();
	}
};
static_assert(alignof(UFriendInfo) == 0x000008, "Wrong alignment on UFriendInfo");
static_assert(sizeof(UFriendInfo) == 0x000038, "Wrong size on UFriendInfo");

// Class Flame.GameControlManager
// 0x0020 (0x0240 - 0x0220)
class AGameControlManager final : public AInfo
{
public:
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameControlManager">();
	}
	static class AGameControlManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameControlManager>();
	}
};
static_assert(alignof(AGameControlManager) == 0x000008, "Wrong alignment on AGameControlManager");
static_assert(sizeof(AGameControlManager) == 0x000240, "Wrong size on AGameControlManager");

// Class Flame.GameControlSpawnComponent
// 0x0010 (0x0210 - 0x0200)
class UGameControlSpawnComponent final : public USceneComponent
{
public:
	bool                                          HideActorGraphics;                                 // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F9[0x17];                                     // 0x01F9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetSpawnPointLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameControlSpawnComponent">();
	}
	static class UGameControlSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameControlSpawnComponent>();
	}
};
static_assert(alignof(UGameControlSpawnComponent) == 0x000010, "Wrong alignment on UGameControlSpawnComponent");
static_assert(sizeof(UGameControlSpawnComponent) == 0x000210, "Wrong size on UGameControlSpawnComponent");
static_assert(offsetof(UGameControlSpawnComponent, HideActorGraphics) == 0x0001F8, "Member 'UGameControlSpawnComponent::HideActorGraphics' has a wrong offset!");

// Class Flame.GameMenuOptionsScreen
// 0x0000 (0x02D8 - 0x02D8)
class UGameMenuOptionsScreen : public UMenuWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuOptionsScreen">();
	}
	static class UGameMenuOptionsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuOptionsScreen>();
	}
};
static_assert(alignof(UGameMenuOptionsScreen) == 0x000008, "Wrong alignment on UGameMenuOptionsScreen");
static_assert(sizeof(UGameMenuOptionsScreen) == 0x0002D8, "Wrong size on UGameMenuOptionsScreen");

// Class Flame.GameModeFlame
// 0x00E8 (0x03F0 - 0x0308)
class AGameModeFlame : public AGameMode
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UsedPIEStart;                                      // 0x0310(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALootable>                  CorpseContainerClass;                              // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpawningDistance;                               // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpawningDistance;                               // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawningDistanceRetryFactor;                       // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPreferredPlayerSpawnCount;                      // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerGroupsManager>       PlayerGroupsManagerClass;                          // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGlintManager>              WeaponGlintManagerClass;                           // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatorManager>          SpectatorManagerClass;                             // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameModeTags;                                      // 0x0348(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class APlayerStartPrimary*>            PlayerStarts;                                      // 0x0368(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APlayerStartPrimary*>            UsedPlayerStarts;                                  // 0x0378(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPlayerGroupsManager*                   PlayerGroupsManager;                               // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGlintManager*                          GlintManager;                                      // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASpectatorManager*                      SpectatorManager;                                  // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AHumanPlayerController*, struct FTimerHandle> SendToShelterHandles;                              // 0x03A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool CheckEncroachment(class AActor* FoundPlayerStart, class AController* Player);
	int32 GetMatchStartAfter();
	class ASpectatorManager* GetOrCreateSpectatorManager();
	bool GetPlayerCanRestart(class APlayerController* PlayerController);
	void GetTeammates(class AHumanPlayerController* Player, TArray<class AHumanPlayerController*>* OutControllerList);
	void OnLeftMatch(class AHumanPlayerController* Controller);
	void OnMatchInfoMatchStarted(const struct FCloudRequestResult& RequestResult, const class FString& MatchID);
	bool OnPlayerDied(class AHumanCharacter* Player, class AHumanCharacter* Killer);
	void OnPlayerRespawned(class AHumanPlayerController* Player);
	void OnSpectatorHasNobodyToSpectate(class AHumanPlayerController* Player);
	void PlayerSendToShelter(class AHumanPlayerController* Player);
	void PlayerSendToShelterWithDelay(class AHumanPlayerController* Player, float Delay);
	int32 PreparePrimaryStartsForPlayers();
	class APlayerStartFlame* SelectNextPrimaryStartForPlayer(class AController* Player);
	bool ShouldStartMatchBP();

	TArray<class APlayerState*> GetInactivePlayerStates() const;
	int32 GetMaxPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeFlame">();
	}
	static class AGameModeFlame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeFlame>();
	}
};
static_assert(alignof(AGameModeFlame) == 0x000008, "Wrong alignment on AGameModeFlame");
static_assert(sizeof(AGameModeFlame) == 0x0003F0, "Wrong size on AGameModeFlame");
static_assert(offsetof(AGameModeFlame, UsedPIEStart) == 0x000310, "Member 'AGameModeFlame::UsedPIEStart' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, CorpseContainerClass) == 0x000318, "Member 'AGameModeFlame::CorpseContainerClass' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, MinSpawningDistance) == 0x000320, "Member 'AGameModeFlame::MinSpawningDistance' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, MaxSpawningDistance) == 0x000324, "Member 'AGameModeFlame::MaxSpawningDistance' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, SpawningDistanceRetryFactor) == 0x000328, "Member 'AGameModeFlame::SpawningDistanceRetryFactor' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, MaxPreferredPlayerSpawnCount) == 0x00032C, "Member 'AGameModeFlame::MaxPreferredPlayerSpawnCount' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, PlayerGroupsManagerClass) == 0x000330, "Member 'AGameModeFlame::PlayerGroupsManagerClass' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, WeaponGlintManagerClass) == 0x000338, "Member 'AGameModeFlame::WeaponGlintManagerClass' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, SpectatorManagerClass) == 0x000340, "Member 'AGameModeFlame::SpectatorManagerClass' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, GameModeTags) == 0x000348, "Member 'AGameModeFlame::GameModeTags' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, PlayerStarts) == 0x000368, "Member 'AGameModeFlame::PlayerStarts' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, UsedPlayerStarts) == 0x000378, "Member 'AGameModeFlame::UsedPlayerStarts' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, PlayerGroupsManager) == 0x000388, "Member 'AGameModeFlame::PlayerGroupsManager' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, GlintManager) == 0x000390, "Member 'AGameModeFlame::GlintManager' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, SpectatorManager) == 0x000398, "Member 'AGameModeFlame::SpectatorManager' has a wrong offset!");
static_assert(offsetof(AGameModeFlame, SendToShelterHandles) == 0x0003A0, "Member 'AGameModeFlame::SendToShelterHandles' has a wrong offset!");

// Class Flame.PlayFooleySoundNotify
// 0x0018 (0x0050 - 0x0038)
class UPlayFooleySoundNotify final : public UAnimNotify
{
public:
	class USoundBase*                             FooleySound;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WeaponRattleSound;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayFooleySoundNotify">();
	}
	static class UPlayFooleySoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayFooleySoundNotify>();
	}
};
static_assert(alignof(UPlayFooleySoundNotify) == 0x000008, "Wrong alignment on UPlayFooleySoundNotify");
static_assert(sizeof(UPlayFooleySoundNotify) == 0x000050, "Wrong size on UPlayFooleySoundNotify");
static_assert(offsetof(UPlayFooleySoundNotify, FooleySound) == 0x000038, "Member 'UPlayFooleySoundNotify::FooleySound' has a wrong offset!");
static_assert(offsetof(UPlayFooleySoundNotify, WeaponRattleSound) == 0x000040, "Member 'UPlayFooleySoundNotify::WeaponRattleSound' has a wrong offset!");
static_assert(offsetof(UPlayFooleySoundNotify, VolumeMultiplier) == 0x000048, "Member 'UPlayFooleySoundNotify::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UPlayFooleySoundNotify, PitchMultiplier) == 0x00004C, "Member 'UPlayFooleySoundNotify::PitchMultiplier' has a wrong offset!");

// Class Flame.GamepadActionWidget
// 0x0028 (0x0378 - 0x0350)
class UGamepadActionWidget final : public UGamepadIconWidget
{
public:
	class FText                                   Name_0;                                            // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bForceUppercase;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             ActionName;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetActionName(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadActionWidget">();
	}
	static class UGamepadActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadActionWidget>();
	}
};
static_assert(alignof(UGamepadActionWidget) == 0x000008, "Wrong alignment on UGamepadActionWidget");
static_assert(sizeof(UGamepadActionWidget) == 0x000378, "Wrong size on UGamepadActionWidget");
static_assert(offsetof(UGamepadActionWidget, Name_0) == 0x000350, "Member 'UGamepadActionWidget::Name_0' has a wrong offset!");
static_assert(offsetof(UGamepadActionWidget, bForceUppercase) == 0x000368, "Member 'UGamepadActionWidget::bForceUppercase' has a wrong offset!");
static_assert(offsetof(UGamepadActionWidget, ActionName) == 0x000370, "Member 'UGamepadActionWidget::ActionName' has a wrong offset!");

// Class Flame.GameplayActionsComponent
// 0x0038 (0x00E8 - 0x00B0)
class UGameplayActionsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ItemChangedStartEvent;                             // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayActionsComponent">();
	}
	static class UGameplayActionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayActionsComponent>();
	}
};
static_assert(alignof(UGameplayActionsComponent) == 0x000008, "Wrong alignment on UGameplayActionsComponent");
static_assert(sizeof(UGameplayActionsComponent) == 0x0000E8, "Wrong size on UGameplayActionsComponent");
static_assert(offsetof(UGameplayActionsComponent, ItemChangedStartEvent) == 0x0000D8, "Member 'UGameplayActionsComponent::ItemChangedStartEvent' has a wrong offset!");

// Class Flame.WeaponEquipmentSlot
// 0x0008 (0x0370 - 0x0368)
class UWeaponEquipmentSlot : public UEquipmentSlot
{
public:
	class UFlameTextBlock*                        WeaponName;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateWeaponName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponEquipmentSlot">();
	}
	static class UWeaponEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponEquipmentSlot>();
	}
};
static_assert(alignof(UWeaponEquipmentSlot) == 0x000008, "Wrong alignment on UWeaponEquipmentSlot");
static_assert(sizeof(UWeaponEquipmentSlot) == 0x000370, "Wrong size on UWeaponEquipmentSlot");
static_assert(offsetof(UWeaponEquipmentSlot, WeaponName) == 0x000368, "Member 'UWeaponEquipmentSlot::WeaponName' has a wrong offset!");

// Class Flame.GameplaySettings
// 0x0028 (0x0060 - 0x0038)
class UGameplaySettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        TableWithItemCategories;                           // 0x0038(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExhibitionAccountXUIDs;                            // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplaySettings">();
	}
	static class UGameplaySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplaySettings>();
	}
};
static_assert(alignof(UGameplaySettings) == 0x000008, "Wrong alignment on UGameplaySettings");
static_assert(sizeof(UGameplaySettings) == 0x000060, "Wrong size on UGameplaySettings");
static_assert(offsetof(UGameplaySettings, TableWithItemCategories) == 0x000038, "Member 'UGameplaySettings::TableWithItemCategories' has a wrong offset!");
static_assert(offsetof(UGameplaySettings, ExhibitionAccountXUIDs) == 0x000050, "Member 'UGameplaySettings::ExhibitionAccountXUIDs' has a wrong offset!");

// Class Flame.GameStateFlame
// 0x0090 (0x0320 - 0x0290)
class AGameStateFlame : public AGameState
{
public:
	TArray<struct FFlameSkinInfo>                 SkinsInfo;                                         // 0x0290(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FInactivePlayerInfo>            InactivePlayerInfos;                               // 0x02A0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         PlayerCount;                                       // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPlayers;                                        // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoStartTime;                                     // 0x02B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMachineMode                                  MachineMode;                                       // 0x02BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNetStatsRecording;                              // 0x02BD(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE[0xA];                                      // 0x02BE(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABulletManager>             BulletManagerClass;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACraftingConfigManager>     CraftingConfigManagerClass;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFootprintManager>          FootPrintManagerClass;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABulletManager*                         BulletManager;                                     // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeaponConfigManager*                   WeaponConfigManager;                               // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACraftingConfigManager*                 CraftingConfigManager;                             // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFootprintManager*                      FootprintManager;                                  // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShootingPrediction;                            // 0x0300(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABiSignificanceManagerImpl*             BiSiginificanceManager;                            // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MatchID;                                           // 0x0310(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_MatchId();

	struct FInactivePlayerInfo FindInactivePlayerInfo(const struct FUniqueNetIdRepl& InNetId) const;
	struct FCloudMatchSettingsInfo GetCloudMatchSettingsInfo() const;
	EFlamePlatform GetPlatformFromPlayerId(int32 PlayerId, bool* bIsActive) const;
	int32 GetRemainingStartAfterSeconds() const;
	struct FUniqueNetIdRepl GetUniqueNetIdFromPlayerId(int32 PlayerId, bool* bIsActive) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateFlame">();
	}
	static class AGameStateFlame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateFlame>();
	}
};
static_assert(alignof(AGameStateFlame) == 0x000008, "Wrong alignment on AGameStateFlame");
static_assert(sizeof(AGameStateFlame) == 0x000320, "Wrong size on AGameStateFlame");
static_assert(offsetof(AGameStateFlame, SkinsInfo) == 0x000290, "Member 'AGameStateFlame::SkinsInfo' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, InactivePlayerInfos) == 0x0002A0, "Member 'AGameStateFlame::InactivePlayerInfos' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, PlayerCount) == 0x0002B0, "Member 'AGameStateFlame::PlayerCount' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, MinPlayers) == 0x0002B4, "Member 'AGameStateFlame::MinPlayers' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, AutoStartTime) == 0x0002B8, "Member 'AGameStateFlame::AutoStartTime' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, MachineMode) == 0x0002BC, "Member 'AGameStateFlame::MachineMode' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, bIsNetStatsRecording) == 0x0002BD, "Member 'AGameStateFlame::bIsNetStatsRecording' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, BulletManagerClass) == 0x0002C8, "Member 'AGameStateFlame::BulletManagerClass' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, CraftingConfigManagerClass) == 0x0002D0, "Member 'AGameStateFlame::CraftingConfigManagerClass' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, FootPrintManagerClass) == 0x0002D8, "Member 'AGameStateFlame::FootPrintManagerClass' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, BulletManager) == 0x0002E0, "Member 'AGameStateFlame::BulletManager' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, WeaponConfigManager) == 0x0002E8, "Member 'AGameStateFlame::WeaponConfigManager' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, CraftingConfigManager) == 0x0002F0, "Member 'AGameStateFlame::CraftingConfigManager' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, FootprintManager) == 0x0002F8, "Member 'AGameStateFlame::FootprintManager' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, bUseShootingPrediction) == 0x000300, "Member 'AGameStateFlame::bUseShootingPrediction' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, BiSiginificanceManager) == 0x000308, "Member 'AGameStateFlame::BiSiginificanceManager' has a wrong offset!");
static_assert(offsetof(AGameStateFlame, MatchID) == 0x000310, "Member 'AGameStateFlame::MatchID' has a wrong offset!");

// Class Flame.ProfilePictureCache
// 0x0110 (0x0138 - 0x0028)
class UProfilePictureCache final : public UObject
{
public:
	TMap<struct FUniqueNetIdRepl, class UTexture2DDynamic*> CachedPictures;                                    // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, class UProfilePictureQuery*> QueriesInProgress;                                 // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, class FName>    CachedNonfriendsNames;                             // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDownloadStarted;                                 // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDownloadCompleted;                               // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	class UTexture2DDynamic* GetOrQueryProfilePicture(const struct FUniqueNetIdRepl& NetId);
	void OnQueryCompleted(const struct FUniqueNetIdRepl& PlayerNetId, class UTexture2DDynamic* ProfilePicture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfilePictureCache">();
	}
	static class UProfilePictureCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfilePictureCache>();
	}
};
static_assert(alignof(UProfilePictureCache) == 0x000008, "Wrong alignment on UProfilePictureCache");
static_assert(sizeof(UProfilePictureCache) == 0x000138, "Wrong size on UProfilePictureCache");
static_assert(offsetof(UProfilePictureCache, CachedPictures) == 0x000028, "Member 'UProfilePictureCache::CachedPictures' has a wrong offset!");
static_assert(offsetof(UProfilePictureCache, QueriesInProgress) == 0x000078, "Member 'UProfilePictureCache::QueriesInProgress' has a wrong offset!");
static_assert(offsetof(UProfilePictureCache, CachedNonfriendsNames) == 0x0000C8, "Member 'UProfilePictureCache::CachedNonfriendsNames' has a wrong offset!");
static_assert(offsetof(UProfilePictureCache, OnDownloadStarted) == 0x000118, "Member 'UProfilePictureCache::OnDownloadStarted' has a wrong offset!");
static_assert(offsetof(UProfilePictureCache, OnDownloadCompleted) == 0x000128, "Member 'UProfilePictureCache::OnDownloadCompleted' has a wrong offset!");

// Class Flame.GameStoreProducts
// 0x0040 (0x0068 - 0x0028)
class UGameStoreProducts final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameStoreProductInfoList              ProductList;                                       // 0x0040(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStoreProductsStateChanged;                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GameStoreProductsStateChanged__DelegateSignature(EGameStoreProductsState OldState, EGameStoreProductsState NewState);
	void OnPlatformStoreOffersChanges(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState);
	bool StartDownloadOfProducts();

	const struct FGameStoreProductInfo GetGameStoreProductInfo(const struct FGameStoreProductId& ProductId, bool* ProductFound) const;
	const struct FGameStoreProductInfo GetGameStoreProductInfoById(const class FString& ProductId, bool* ProductFound) const;
	const struct FGameStoreProductInfoList GetProductList() const;
	EGameStoreProductsState GetProductsManagerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStoreProducts">();
	}
	static class UGameStoreProducts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStoreProducts>();
	}
};
static_assert(alignof(UGameStoreProducts) == 0x000008, "Wrong alignment on UGameStoreProducts");
static_assert(sizeof(UGameStoreProducts) == 0x000068, "Wrong size on UGameStoreProducts");
static_assert(offsetof(UGameStoreProducts, ProductList) == 0x000040, "Member 'UGameStoreProducts::ProductList' has a wrong offset!");
static_assert(offsetof(UGameStoreProducts, OnGameStoreProductsStateChanged) == 0x000058, "Member 'UGameStoreProducts::OnGameStoreProductsStateChanged' has a wrong offset!");

// Class Flame.GameStorePurchases
// 0x0040 (0x0068 - 0x0028)
class UGameStorePurchases final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStorePurchasesStateChanged;                  // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GameStorePurchasesStateChanged__DelegateSignature(EGameStorePurchasesState OldState, EGameStorePurchasesState NewState);
	bool StartDownloadOfPurchaseList();

	struct FGameStorePurchaseItemInfo FindPurchasedItem(const struct FGameStoreProductId& ProductId, bool* ItemFound) const;
	const struct FGameStorePurchasesInfo GetGameStoreData() const;
	EGameStorePurchasesState GetPurchasesManagerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStorePurchases">();
	}
	static class UGameStorePurchases* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStorePurchases>();
	}
};
static_assert(alignof(UGameStorePurchases) == 0x000008, "Wrong alignment on UGameStorePurchases");
static_assert(sizeof(UGameStorePurchases) == 0x000068, "Wrong size on UGameStorePurchases");
static_assert(offsetof(UGameStorePurchases, OnGameStorePurchasesStateChanged) == 0x000058, "Member 'UGameStorePurchases::OnGameStorePurchasesStateChanged' has a wrong offset!");

// Class Flame.ShelterUIFunctions
// 0x0000 (0x0028 - 0x0028)
class UShelterUIFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCraftable(TSubclassOf<class AItem> InItemClass, const class APlayerController* InPlayerController, bool bCheckQueue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterUIFunctions">();
	}
	static class UShelterUIFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterUIFunctions>();
	}
};
static_assert(alignof(UShelterUIFunctions) == 0x000008, "Wrong alignment on UShelterUIFunctions");
static_assert(sizeof(UShelterUIFunctions) == 0x000028, "Wrong size on UShelterUIFunctions");

// Class Flame.GameStoreSystem
// 0x00A0 (0x00C8 - 0x0028)
class UGameStoreSystem : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameStoreOffers*                       StoreOffers;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameStoreOffers>           StoreOffersClass;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameStoreProducts*                     StoreProducts;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameStoreProducts>         StoreProductsClass;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameStoreSellingPoints*                StoreSellingPoints;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameStoreSellingPoints>    StoreSellingPointsClass;                           // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameStorePurchases*                    StorePurchases;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameStorePurchases>        StorePurchasesClass;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameStorePurchaseHandler*              PurchaseRequest;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x30];                                      // 0x0088(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStorePurchase;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static int32 GetGameStoreInvalidPurchaseRequestId();
	static class UGameStoreOffers* GetGameStoreOffersManager(const class UObject* WorldContextObject);
	static class UGameStoreProducts* GetGameStoreProductsManager(const class UObject* WorldContextObject);
	static class UGameStorePurchases* GetGameStorePurchasesManager(const class UObject* WorldContextObject);
	static class UGameStoreSellingPoints* GetGameStoreSellingPointsManager(const class UObject* WorldContextObject);

	void OnGameStorePurchase__DelegateSignature(EGameStorePurchaseType PurchaseType, const struct FUniqueNetIdRepl& InUserId, const int32 PurchaseRequestId, const struct FGameStoreProductId& RequestedProductId, const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult, const bool PurchaseListRefreshed);
	void OnPurchaseSignaledToCloud(const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult);
	int32 RefreshStoreRequest(const struct FUniqueNetIdRepl& InUserId, EGameStoreTransactionSource PurchaseSource);
	int32 StartPurchaseRequest(const struct FUniqueNetIdRepl& InUserId, const struct FGameStoreProductInfo& Product, EGameStoreTransactionSource PurchaseSource, const class FString& MicrotransactionDescription);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStoreSystem">();
	}
	static class UGameStoreSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStoreSystem>();
	}
};
static_assert(alignof(UGameStoreSystem) == 0x000008, "Wrong alignment on UGameStoreSystem");
static_assert(sizeof(UGameStoreSystem) == 0x0000C8, "Wrong size on UGameStoreSystem");
static_assert(offsetof(UGameStoreSystem, StoreOffers) == 0x000040, "Member 'UGameStoreSystem::StoreOffers' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StoreOffersClass) == 0x000048, "Member 'UGameStoreSystem::StoreOffersClass' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StoreProducts) == 0x000050, "Member 'UGameStoreSystem::StoreProducts' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StoreProductsClass) == 0x000058, "Member 'UGameStoreSystem::StoreProductsClass' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StoreSellingPoints) == 0x000060, "Member 'UGameStoreSystem::StoreSellingPoints' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StoreSellingPointsClass) == 0x000068, "Member 'UGameStoreSystem::StoreSellingPointsClass' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StorePurchases) == 0x000070, "Member 'UGameStoreSystem::StorePurchases' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, StorePurchasesClass) == 0x000078, "Member 'UGameStoreSystem::StorePurchasesClass' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, PurchaseRequest) == 0x000080, "Member 'UGameStoreSystem::PurchaseRequest' has a wrong offset!");
static_assert(offsetof(UGameStoreSystem, OnGameStorePurchase) == 0x0000B8, "Member 'UGameStoreSystem::OnGameStorePurchase' has a wrong offset!");

// Class Flame.TemporaryToolComponent
// 0x0030 (0x00E0 - 0x00B0)
class UTemporaryToolComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class ATool>>              ToolClasses;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UChildActorComponent*>           Tools;                                             // 0x00C0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ATool*                                  CurrentTool;                                       // 0x00D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PostChangeTool(class ATool* LastTool);
	void RequestToolEquip(const class ATool* ToolToEquip);
	void RequestToolUnequip();
	void ServerAskForEquipTool(class ATool* ToolToEquip);

	class ATool* GetCurrentTool() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemporaryToolComponent">();
	}
	static class UTemporaryToolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTemporaryToolComponent>();
	}
};
static_assert(alignof(UTemporaryToolComponent) == 0x000008, "Wrong alignment on UTemporaryToolComponent");
static_assert(sizeof(UTemporaryToolComponent) == 0x0000E0, "Wrong size on UTemporaryToolComponent");
static_assert(offsetof(UTemporaryToolComponent, ToolClasses) == 0x0000B0, "Member 'UTemporaryToolComponent::ToolClasses' has a wrong offset!");
static_assert(offsetof(UTemporaryToolComponent, Tools) == 0x0000C0, "Member 'UTemporaryToolComponent::Tools' has a wrong offset!");
static_assert(offsetof(UTemporaryToolComponent, CurrentTool) == 0x0000D0, "Member 'UTemporaryToolComponent::CurrentTool' has a wrong offset!");

// Class Flame.GenderFemale
// 0x0000 (0x0398 - 0x0398)
class AGenderFemale : public AGender
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenderFemale">();
	}
	static class AGenderFemale* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenderFemale>();
	}
};
static_assert(alignof(AGenderFemale) == 0x000008, "Wrong alignment on AGenderFemale");
static_assert(sizeof(AGenderFemale) == 0x000398, "Wrong size on AGenderFemale");

// Class Flame.GestureSegment
// 0x0010 (0x02E8 - 0x02D8)
class UGestureSegment : public UWheelSegment
{
public:
	TSubclassOf<class ACustomizationSlotGesture>  GestureSlotClass;                                  // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             GestureSlot;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetGestureSlotClass(TSubclassOf<class ACustomizationSlotGesture> InClass);

	class UAnimMontage* GetAnimationMontage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestureSegment">();
	}
	static class UGestureSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestureSegment>();
	}
};
static_assert(alignof(UGestureSegment) == 0x000008, "Wrong alignment on UGestureSegment");
static_assert(sizeof(UGestureSegment) == 0x0002E8, "Wrong size on UGestureSegment");
static_assert(offsetof(UGestureSegment, GestureSlotClass) == 0x0002D8, "Member 'UGestureSegment::GestureSlotClass' has a wrong offset!");
static_assert(offsetof(UGestureSegment, GestureSlot) == 0x0002E0, "Member 'UGestureSegment::GestureSlot' has a wrong offset!");

// Class Flame.SpectatorManager
// 0x0130 (0x0350 - 0x0220)
class ASpectatorManager : public AActor
{
public:
	TArray<struct FSpectatorOldCharacter>         OldCharacters;                                     // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AHumanPlayerController*                 EventFor;                                          // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AHumanPlayerController*, class AHumanCharacter*> Minds;                                             // 0x0238(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<class AHumanPlayerController*, struct FSpectatorState> SpectatorBodyMapping;                              // 0x0288(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpectatorRules>                SpectatorRules;                                    // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          CanSpectateSelfIfLastDying;                        // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AController*, class AActor*>       LeaveQueue;                                        // 0x02F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AHumanPlayerController*>         TeammateCache;                                     // 0x0340(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool NewEvent(ESpectateEvent Event, class AHumanPlayerController* SubjectMind, class AActor* Parameter, const struct FTransform& Fallback);
	void OnPlayerDied(class AHumanCharacter* DeceasedBody, class AHumanCharacter* KillerBody);
	void OnPlayerLeft(class AHumanPlayerController* Controller);
	void OnPlayerRespawned(class AHumanPlayerController* Controller);
	void OnUnableToSpectate(class AHumanPlayerController* SubjectMind);
	void ProcessSpectatorEvent(ESpectateEvent Event, class AActor* Parameter, const struct FTransform& Fallback);
	void RegisterPlayer(class AHumanCharacter* PlayerMind);
	void RegisterPlayerController(class AHumanPlayerController* Controller);
	void ReplaceTargets(class AHumanCharacter* OldHumanCharacter, class AActor* OldActor, const struct FTransform& OldTransform, const struct FSpectatorState& NewTarget);
	void ReplaceTargetsWithRecommendation(class AActor* Param);
	bool StopSpectating();
	bool SuggestSpectatorTarget(class AHumanCharacter* Character, class AActor* Actor, const struct FTransform& Transform);
	void UnregisterPlayerController(class AHumanPlayerController* Controller);

	bool CanBodySpectateTarget(class AFlameSpectatorPawn* SelfBody, class AActor* Target) const;
	bool CanMindSpectateTarget(const class AHumanPlayerController* SelfMind, const class AActor* Target) const;
	void GetSpectatorCandidatesFromRules(class AHumanPlayerController* Controller, const struct FSpectatorRules& Rules, TArray<class AActor*>* OutActors, class AActor* Param) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorManager">();
	}
	static class ASpectatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatorManager>();
	}
};
static_assert(alignof(ASpectatorManager) == 0x000008, "Wrong alignment on ASpectatorManager");
static_assert(sizeof(ASpectatorManager) == 0x000350, "Wrong size on ASpectatorManager");
static_assert(offsetof(ASpectatorManager, OldCharacters) == 0x000220, "Member 'ASpectatorManager::OldCharacters' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, EventFor) == 0x000230, "Member 'ASpectatorManager::EventFor' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, Minds) == 0x000238, "Member 'ASpectatorManager::Minds' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, SpectatorBodyMapping) == 0x000288, "Member 'ASpectatorManager::SpectatorBodyMapping' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, SpectatorRules) == 0x0002D8, "Member 'ASpectatorManager::SpectatorRules' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, CanSpectateSelfIfLastDying) == 0x0002E8, "Member 'ASpectatorManager::CanSpectateSelfIfLastDying' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, LeaveQueue) == 0x0002F0, "Member 'ASpectatorManager::LeaveQueue' has a wrong offset!");
static_assert(offsetof(ASpectatorManager, TeammateCache) == 0x000340, "Member 'ASpectatorManager::TeammateCache' has a wrong offset!");

// Class Flame.GlintManager
// 0x0028 (0x0248 - 0x0220)
class AGlintManager final : public AActor
{
public:
	float                                         MinimumDistanceSq;                                 // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistanceSq;                                 // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGlintPlayerState>              GlintStates;                                       // 0x0228(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AHumanPlayerController*>         Controllers;                                       // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlintManager">();
	}
	static class AGlintManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlintManager>();
	}
};
static_assert(alignof(AGlintManager) == 0x000008, "Wrong alignment on AGlintManager");
static_assert(sizeof(AGlintManager) == 0x000248, "Wrong size on AGlintManager");
static_assert(offsetof(AGlintManager, MinimumDistanceSq) == 0x000220, "Member 'AGlintManager::MinimumDistanceSq' has a wrong offset!");
static_assert(offsetof(AGlintManager, MaximumDistanceSq) == 0x000224, "Member 'AGlintManager::MaximumDistanceSq' has a wrong offset!");
static_assert(offsetof(AGlintManager, GlintStates) == 0x000228, "Member 'AGlintManager::GlintStates' has a wrong offset!");
static_assert(offsetof(AGlintManager, Controllers) == 0x000238, "Member 'AGlintManager::Controllers' has a wrong offset!");

// Class Flame.GlobalLevelAmbienceBase
// 0x0050 (0x0278 - 0x0228)
class AGlobalLevelAmbienceBase : public AAmbientSoundExtended
{
public:
	uint8                                         Pad_228[0x50];                                     // 0x0228(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalLevelAmbienceBase">();
	}
	static class AGlobalLevelAmbienceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlobalLevelAmbienceBase>();
	}
};
static_assert(alignof(AGlobalLevelAmbienceBase) == 0x000008, "Wrong alignment on AGlobalLevelAmbienceBase");
static_assert(sizeof(AGlobalLevelAmbienceBase) == 0x000278, "Wrong size on AGlobalLevelAmbienceBase");

// Class Flame.GlovesComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UGlovesComponent : public UClothesMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlovesComponent">();
	}
	static class UGlovesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlovesComponent>();
	}
};
static_assert(alignof(UGlovesComponent) == 0x000010, "Wrong alignment on UGlovesComponent");
static_assert(sizeof(UGlovesComponent) == 0x000EF0, "Wrong size on UGlovesComponent");

// Class Flame.TutorialAIManager
// 0x0180 (0x03A0 - 0x0220)
class ATutorialAIManager : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnPursuitSceneStarted;                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllAIsDied;                                      // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AHumanAICharacter>          TutorialAIClass;                                   // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x50];                                     // 0x0248(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETutorialAIID, class ATutorialAIDataProvider*> AIPursuitSceneInitializationData;                  // 0x0298(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<ETutorialAIID, class ATutorialAIDataProvider*> AIInitializationData;                              // 0x02E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         AmountOfMagazinesToSpawn;                          // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BTreePursuitScene;                                 // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BTreeActionSequence;                               // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BTreeAfterActionSequence;                          // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PursuitSceneTrigger;                               // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PursuitSceneFinishTrigger;                         // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ActionSequenceTrigger;                             // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          IdleShootingTrigger;                               // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InvisibleWallForBullets;                           // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x20];                                     // 0x0380(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanupAndRespawnCurrentAIs();
	void InitializeAIOnBP(class AHumanAICharacter* AI, const struct FTutorialAIInitializationData& InitializationDataForBP);
	void OnActionSequenceOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnAIDied(class AHumanCharacter* DiedCharacter, class AHumanCharacter* KillerCharacter);
	void OnIdleShootingOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPursuitSceneFinishOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPursuitSceneOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void StartActionSequenceOverride();

	ETutorialAIState GetCurrentTutorialAIManagerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAIManager">();
	}
	static class ATutorialAIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialAIManager>();
	}
};
static_assert(alignof(ATutorialAIManager) == 0x000008, "Wrong alignment on ATutorialAIManager");
static_assert(sizeof(ATutorialAIManager) == 0x0003A0, "Wrong size on ATutorialAIManager");
static_assert(offsetof(ATutorialAIManager, OnPursuitSceneStarted) == 0x000220, "Member 'ATutorialAIManager::OnPursuitSceneStarted' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, OnAllAIsDied) == 0x000230, "Member 'ATutorialAIManager::OnAllAIsDied' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, TutorialAIClass) == 0x000240, "Member 'ATutorialAIManager::TutorialAIClass' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, AIPursuitSceneInitializationData) == 0x000298, "Member 'ATutorialAIManager::AIPursuitSceneInitializationData' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, AIInitializationData) == 0x0002E8, "Member 'ATutorialAIManager::AIInitializationData' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, AmountOfMagazinesToSpawn) == 0x000338, "Member 'ATutorialAIManager::AmountOfMagazinesToSpawn' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, BTreePursuitScene) == 0x000340, "Member 'ATutorialAIManager::BTreePursuitScene' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, BTreeActionSequence) == 0x000348, "Member 'ATutorialAIManager::BTreeActionSequence' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, BTreeAfterActionSequence) == 0x000350, "Member 'ATutorialAIManager::BTreeAfterActionSequence' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, PursuitSceneTrigger) == 0x000358, "Member 'ATutorialAIManager::PursuitSceneTrigger' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, PursuitSceneFinishTrigger) == 0x000360, "Member 'ATutorialAIManager::PursuitSceneFinishTrigger' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, ActionSequenceTrigger) == 0x000368, "Member 'ATutorialAIManager::ActionSequenceTrigger' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, IdleShootingTrigger) == 0x000370, "Member 'ATutorialAIManager::IdleShootingTrigger' has a wrong offset!");
static_assert(offsetof(ATutorialAIManager, InvisibleWallForBullets) == 0x000378, "Member 'ATutorialAIManager::InvisibleWallForBullets' has a wrong offset!");

// Class Flame.GroupSystem
// 0x0318 (0x0340 - 0x0028)
class UGroupSystem final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             UpdateFriendsListFinished;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerJoinedGroup;                                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerLeavedGroup;                                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerStartMatchmaking;                            // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerCancelMatchmaking;                           // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerStateChangedDelegate;                        // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlayerFailedJoinGroup;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             QueryBlockedPlayersFinished;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x280];                                     // 0x00C0(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateSession(const class FString& SessionName);
	bool GetMemberList(TMap<struct FUniqueNetIdRepl, struct FClientStateSync>* Members);
	void Invite();
	void Leave();
	void OnPlayerFailedJoinGroup(const struct FUniqueNetIdRepl& Userid);
	void OnPlayerJoinedGroup(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId);
	void OnPlayerLeftGroup(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId);
	void PlayerCancelMatchmakingDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid);
	void PlayerFailedJoinGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid);
	void PlayerJoinedGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId);
	void PlayerLeavedGroupDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const class FString& GroupId);
	void PlayerStartMatchmakingDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid);
	void PlayerStateChangedDelegate__DelegateSignature(const struct FUniqueNetIdRepl& Userid, EClientGroupState OldState, EClientGroupState NewState);
	bool QueryBlockedPlayers();
	void QueryBlockedPlayersDelegate__DelegateSignature(const struct FUpdateFriendsListResult& Result);
	bool UpdateFriendsList();
	void UpdateFriendsListDelegate__DelegateSignature(const struct FUpdateFriendsListResult& Result);

	const TMap<struct FUniqueNetIdRepl, class UFriendInfo*> GetBlockedPlayers() const;
	const TMap<struct FUniqueNetIdRepl, class UFriendInfo*> GetFriendsList() const;
	int32 GetGroupSize() const;
	class FString GetGroupUniqueId() const;
	struct FUniqueNetIdRepl GetLocalUserUniqueId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupSystem">();
	}
	static class UGroupSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupSystem>();
	}
};
static_assert(alignof(UGroupSystem) == 0x000008, "Wrong alignment on UGroupSystem");
static_assert(sizeof(UGroupSystem) == 0x000340, "Wrong size on UGroupSystem");
static_assert(offsetof(UGroupSystem, UpdateFriendsListFinished) == 0x000028, "Member 'UGroupSystem::UpdateFriendsListFinished' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerJoinedGroup) == 0x000038, "Member 'UGroupSystem::PlayerJoinedGroup' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerLeavedGroup) == 0x000048, "Member 'UGroupSystem::PlayerLeavedGroup' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerStartMatchmaking) == 0x000058, "Member 'UGroupSystem::PlayerStartMatchmaking' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerCancelMatchmaking) == 0x000068, "Member 'UGroupSystem::PlayerCancelMatchmaking' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerStateChangedDelegate) == 0x000078, "Member 'UGroupSystem::PlayerStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UGroupSystem, PlayerFailedJoinGroup) == 0x000088, "Member 'UGroupSystem::PlayerFailedJoinGroup' has a wrong offset!");
static_assert(offsetof(UGroupSystem, QueryBlockedPlayersFinished) == 0x0000B0, "Member 'UGroupSystem::QueryBlockedPlayersFinished' has a wrong offset!");

// Class Flame.Stash
// 0x0058 (0x0278 - 0x0220)
class AStash : public AActor
{
public:
	class UStashComponent*                        Storage;                                           // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnImprovementUpgradeFinished;                      // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnImprovementUpgradeStarted;                       // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnShelterLevelChanged;                             // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnImprovementChanged;                              // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             ShelterImprovementsCloudLoadedAuthority;           // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stash">();
	}
	static class AStash* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStash>();
	}
};
static_assert(alignof(AStash) == 0x000008, "Wrong alignment on AStash");
static_assert(sizeof(AStash) == 0x000278, "Wrong size on AStash");
static_assert(offsetof(AStash, Storage) == 0x000220, "Member 'AStash::Storage' has a wrong offset!");
static_assert(offsetof(AStash, OnImprovementUpgradeFinished) == 0x000228, "Member 'AStash::OnImprovementUpgradeFinished' has a wrong offset!");
static_assert(offsetof(AStash, OnImprovementUpgradeStarted) == 0x000238, "Member 'AStash::OnImprovementUpgradeStarted' has a wrong offset!");
static_assert(offsetof(AStash, OnShelterLevelChanged) == 0x000248, "Member 'AStash::OnShelterLevelChanged' has a wrong offset!");
static_assert(offsetof(AStash, OnImprovementChanged) == 0x000258, "Member 'AStash::OnImprovementChanged' has a wrong offset!");
static_assert(offsetof(AStash, ShelterImprovementsCloudLoadedAuthority) == 0x000268, "Member 'AStash::ShelterImprovementsCloudLoadedAuthority' has a wrong offset!");

// Class Flame.HasOwner
// 0x0000 (0x0028 - 0x0028)
class IHasOwner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasOwner">();
	}
	static class IHasOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHasOwner>();
	}
};
static_assert(alignof(IHasOwner) == 0x000008, "Wrong alignment on IHasOwner");
static_assert(sizeof(IHasOwner) == 0x000028, "Wrong size on IHasOwner");

// Class Flame.PlatformStoreOfferInfo
// 0x0000 (0x0028 - 0x0028)
class UPlatformStoreOfferInfo : public UObject
{
public:
	int32 GetBaseAmount() const;
	int32 GetBonusAmount() const;
	class FString GetCurrencyCode() const;
	class FText GetDescription() const;
	class FText GetDisplayPrice() const;
	const struct FGameStoreProductId GetGameStoreProductId() const;
	class FText GetLongDescription() const;
	int32 GetNumericPrice() const;
	class FText GetPriceText() const;
	class FString GetProductId() const;
	int32 GetRegularPrice() const;
	class FText GetRegularPriceText() const;
	const TArray<class FString> GetTags() const;
	class FText GetTaxMessage() const;
	class FText GetTitle() const;
	bool IsPurchaseable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfo">();
	}
	static class UPlatformStoreOfferInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfo>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfo) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfo");
static_assert(sizeof(UPlatformStoreOfferInfo) == 0x000028, "Wrong size on UPlatformStoreOfferInfo");

// Class Flame.PlatformStoreOfferInfoXbox
// 0x0040 (0x0068 - 0x0028)
class UPlatformStoreOfferInfoXbox final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoXbox">();
	}
	static class UPlatformStoreOfferInfoXbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoXbox>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoXbox) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoXbox");
static_assert(sizeof(UPlatformStoreOfferInfoXbox) == 0x000068, "Wrong size on UPlatformStoreOfferInfoXbox");

// Class Flame.HasSubObjects
// 0x0000 (0x0028 - 0x0028)
class IHasSubObjects final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasSubObjects">();
	}
	static class IHasSubObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHasSubObjects>();
	}
};
static_assert(alignof(IHasSubObjects) == 0x000008, "Wrong alignment on IHasSubObjects");
static_assert(sizeof(IHasSubObjects) == 0x000028, "Wrong size on IHasSubObjects");

// Class Flame.HeadComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UHeadComponent : public UCustomisationMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadComponent">();
	}
	static class UHeadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadComponent>();
	}
};
static_assert(alignof(UHeadComponent) == 0x000010, "Wrong alignment on UHeadComponent");
static_assert(sizeof(UHeadComponent) == 0x000EF0, "Wrong size on UHeadComponent");

// Class Flame.HairComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UHairComponent : public UCustomisationMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HairComponent">();
	}
	static class UHairComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHairComponent>();
	}
};
static_assert(alignof(UHairComponent) == 0x000010, "Wrong alignment on UHairComponent");
static_assert(sizeof(UHairComponent) == 0x000EF0, "Wrong size on UHairComponent");

// Class Flame.LeaderboardWriteBoardBase
// 0x0020 (0x0088 - 0x0068)
class ULeaderboardWriteBoardBase : public ULeaderboardHandlerBase
{
public:
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardBase">();
	}
	static class ULeaderboardWriteBoardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardBase>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardBase) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardBase");
static_assert(sizeof(ULeaderboardWriteBoardBase) == 0x000088, "Wrong size on ULeaderboardWriteBoardBase");

// Class Flame.LeaderboardWriteBoardDev
// 0x0020 (0x00A8 - 0x0088)
class ULeaderboardWriteBoardDev final : public ULeaderboardWriteBoardBase
{
public:
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardDev">();
	}
	static class ULeaderboardWriteBoardDev* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardDev>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardDev) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardDev");
static_assert(sizeof(ULeaderboardWriteBoardDev) == 0x0000A8, "Wrong size on ULeaderboardWriteBoardDev");

// Class Flame.HeadgearLowerComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UHeadgearLowerComponent : public UClothesMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadgearLowerComponent">();
	}
	static class UHeadgearLowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadgearLowerComponent>();
	}
};
static_assert(alignof(UHeadgearLowerComponent) == 0x000010, "Wrong alignment on UHeadgearLowerComponent");
static_assert(sizeof(UHeadgearLowerComponent) == 0x000EF0, "Wrong size on UHeadgearLowerComponent");

// Class Flame.AnimationMirrorData
// 0x0060 (0x0088 - 0x0028)
class UAnimationMirrorData final : public UObject
{
public:
	EMirrorDir                                    MirrorAxis_Rot;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorDir                                    RightAxis;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorDir                                    PelvisMirrorAxis_Rot;                              // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorDir                                    PelvisRightAxis;                                   // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x5C];                                      // 0x002C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHumanMappedMirrorBones(const TArray<struct FHumanMirrorMap>& MirrorData, const class USkeleton* Skeleton);
	void SetMirrorMappedBone(const class FName bone_name, const class FName Mirror_bone_name, const EMirrorDir Mirror_axis, const EMirrorDir Right_axis);
	void SetMirrorMappedData(const TArray<class FName>& PMirrorData, const TArray<EMirrorDir>& PMirrorAxisData, const TArray<EMirrorDir>& PRightAxisData);
	void SetPelvisBoneName(const class FName bone_name);

	TArray<EMirrorDir> GetBoneMirrorAxisDataStructure() const;
	TArray<class FName> GetBoneMirrorDataStructure() const;
	TArray<EMirrorDir> GetBoneRightAxisDataStructure() const;
	class FName GetMirrorMappedBone(const class FName bone_name) const;
	class FName GetPelvisBoneName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationMirrorData">();
	}
	static class UAnimationMirrorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationMirrorData>();
	}
};
static_assert(alignof(UAnimationMirrorData) == 0x000008, "Wrong alignment on UAnimationMirrorData");
static_assert(sizeof(UAnimationMirrorData) == 0x000088, "Wrong size on UAnimationMirrorData");
static_assert(offsetof(UAnimationMirrorData, MirrorAxis_Rot) == 0x000028, "Member 'UAnimationMirrorData::MirrorAxis_Rot' has a wrong offset!");
static_assert(offsetof(UAnimationMirrorData, RightAxis) == 0x000029, "Member 'UAnimationMirrorData::RightAxis' has a wrong offset!");
static_assert(offsetof(UAnimationMirrorData, PelvisMirrorAxis_Rot) == 0x00002A, "Member 'UAnimationMirrorData::PelvisMirrorAxis_Rot' has a wrong offset!");
static_assert(offsetof(UAnimationMirrorData, PelvisRightAxis) == 0x00002B, "Member 'UAnimationMirrorData::PelvisRightAxis' has a wrong offset!");

// Class Flame.HeadgearMiddleComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UHeadgearMiddleComponent : public UClothesMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadgearMiddleComponent">();
	}
	static class UHeadgearMiddleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadgearMiddleComponent>();
	}
};
static_assert(alignof(UHeadgearMiddleComponent) == 0x000010, "Wrong alignment on UHeadgearMiddleComponent");
static_assert(sizeof(UHeadgearMiddleComponent) == 0x000EF0, "Wrong size on UHeadgearMiddleComponent");

// Class Flame.HeadgearUpperComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UHeadgearUpperComponent : public UClothesMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadgearUpperComponent">();
	}
	static class UHeadgearUpperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadgearUpperComponent>();
	}
};
static_assert(alignof(UHeadgearUpperComponent) == 0x000010, "Wrong alignment on UHeadgearUpperComponent");
static_assert(sizeof(UHeadgearUpperComponent) == 0x000EF0, "Wrong size on UHeadgearUpperComponent");

// Class Flame.HealingConsumable
// 0x0000 (0x0418 - 0x0418)
class AHealingConsumable : public AConsumableItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealingConsumable">();
	}
	static class AHealingConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHealingConsumable>();
	}
};
static_assert(alignof(AHealingConsumable) == 0x000008, "Wrong alignment on AHealingConsumable");
static_assert(sizeof(AHealingConsumable) == 0x000418, "Wrong size on AHealingConsumable");

// Class Flame.InventoryCustomizationComponent
// 0x0108 (0x01B8 - 0x00B0)
class UInventoryCustomizationComponent : public UActorComponent
{
public:
	EDefaultInventoryLoadMode                     LoadMode;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECustomzationChangedMode                      ChangeMode;                                        // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             CloudLoadedAuthority;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedClient;                                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CustomizationsReplicated;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizationPairWithSlot>     LinkedCustomizations;                              // 0x00F0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ACustomizationVariant>      DefaultArchetypeVariant;                           // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACustomizationArchetype>    DefaultArchetype;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultUniformMesh;                                // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultUniformMeshFemale;                          // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACustomizationVariant>      DefaultUniform;                                    // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACustomizationVariant>      DefaultBackpack;                                   // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultBackpackMesh;                               // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultBackpackMeshFemale;                         // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultGlovesMeshMale;                             // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultGlovesMeshFemale;                           // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ACustomization>, TSubclassOf<class ACustomizationSlot>> MajorSlotForCustomizationMap;                      // 0x0150(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACustomizationSlot>> SlotsToUpdate;                                     // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearVoiceModifierOverride();
	void InheritDefaults(const class UInventoryCustomizationComponent* Source);
	void InheritSlots(const class UInventoryCustomizationComponent* Source);
	void OnRep_PostChange(const TArray<struct FCustomizationPairWithSlot>& OldCustomizations);
	void SetVoiceModifierOverride(EVoiceModifierType VoiceMod);

	TSubclassOf<class ACustomizationArchetype> GetArchetype() const;
	TSubclassOf<class ACustomizationVariant> GetArchetypeVariant() const;
	ESoundTextureType GetBagSoundTexture() const;
	struct FCustomizationPair GetCustomizationInSlot(TSubclassOf<class ACustomizationSlot> Slot) const;
	TSubclassOf<class AGender> GetGender() const;
	TSubclassOf<class ACustomizationSlot> GetMajorSlotForCustomization(TSubclassOf<class ACustomization> OneCustomization) const;
	ESoundTextureType GetUniformSoundTexture() const;
	EVoiceModifierType GetVoiceModifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryCustomizationComponent">();
	}
	static class UInventoryCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryCustomizationComponent>();
	}
};
static_assert(alignof(UInventoryCustomizationComponent) == 0x000008, "Wrong alignment on UInventoryCustomizationComponent");
static_assert(sizeof(UInventoryCustomizationComponent) == 0x0001B8, "Wrong size on UInventoryCustomizationComponent");
static_assert(offsetof(UInventoryCustomizationComponent, LoadMode) == 0x0000B0, "Member 'UInventoryCustomizationComponent::LoadMode' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, ChangeMode) == 0x0000B1, "Member 'UInventoryCustomizationComponent::ChangeMode' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, CloudLoadedAuthority) == 0x0000B8, "Member 'UInventoryCustomizationComponent::CloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, CloudLoadedClient) == 0x0000C8, "Member 'UInventoryCustomizationComponent::CloudLoadedClient' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, CustomizationsReplicated) == 0x0000D8, "Member 'UInventoryCustomizationComponent::CustomizationsReplicated' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, LinkedCustomizations) == 0x0000F0, "Member 'UInventoryCustomizationComponent::LinkedCustomizations' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultArchetypeVariant) == 0x000100, "Member 'UInventoryCustomizationComponent::DefaultArchetypeVariant' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultArchetype) == 0x000108, "Member 'UInventoryCustomizationComponent::DefaultArchetype' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultUniformMesh) == 0x000110, "Member 'UInventoryCustomizationComponent::DefaultUniformMesh' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultUniformMeshFemale) == 0x000118, "Member 'UInventoryCustomizationComponent::DefaultUniformMeshFemale' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultUniform) == 0x000120, "Member 'UInventoryCustomizationComponent::DefaultUniform' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultBackpack) == 0x000128, "Member 'UInventoryCustomizationComponent::DefaultBackpack' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultBackpackMesh) == 0x000130, "Member 'UInventoryCustomizationComponent::DefaultBackpackMesh' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultBackpackMeshFemale) == 0x000138, "Member 'UInventoryCustomizationComponent::DefaultBackpackMeshFemale' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultGlovesMeshMale) == 0x000140, "Member 'UInventoryCustomizationComponent::DefaultGlovesMeshMale' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, DefaultGlovesMeshFemale) == 0x000148, "Member 'UInventoryCustomizationComponent::DefaultGlovesMeshFemale' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, MajorSlotForCustomizationMap) == 0x000150, "Member 'UInventoryCustomizationComponent::MajorSlotForCustomizationMap' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationComponent, SlotsToUpdate) == 0x0001A0, "Member 'UInventoryCustomizationComponent::SlotsToUpdate' has a wrong offset!");

// Class Flame.MannequinCustomizationComponent
// 0x0000 (0x01B8 - 0x01B8)
class UMannequinCustomizationComponent final : public UInventoryCustomizationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MannequinCustomizationComponent">();
	}
	static class UMannequinCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMannequinCustomizationComponent>();
	}
};
static_assert(alignof(UMannequinCustomizationComponent) == 0x000008, "Wrong alignment on UMannequinCustomizationComponent");
static_assert(sizeof(UMannequinCustomizationComponent) == 0x0001B8, "Wrong size on UMannequinCustomizationComponent");

// Class Flame.HealthComponent
// 0x0050 (0x0100 - 0x00B0)
class UHealthComponent final : public UActorComponent
{
public:
	float                                         CurrentHealth;                                     // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTrueHealth;                                 // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTempHealth;                                 // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMaxHealth;                                  // 0x00BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDeathThreshold;                             // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHealth;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathThreshold;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AlmostDeadThreshold;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeavilyWoundedThreshold;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WoundedThreshold;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealthAfterDowned;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RegenerationRate;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OneHitDamage;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StunnedTime;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDead;                                           // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInvincible;                                     // 0x00E9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsIncapacitated;                                  // 0x00EA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EB[0x9];                                       // 0x00EB(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          SpawnLootAfterDead;                                // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F5[0xB];                                       // 0x00F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AddTempHealth(const float Amount);
	float AddTrueHealth(const float Amount);
	float ApplyDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, const class AActor* DamageCauser, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> ItemClass, EDamageType DamageType);
	float ApplyHeal(const float HealAmount, const EHealthType HealingType);
	void ClientEndDownState();
	void ClientStartDownState();
	void ClientStartStunnedState();
	void KillPlayer(EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem);
	bool ResetComponent();
	void ResetDeathThreshold();
	void ResetMaxHealth();
	void SetDeathThreshold(const float NewMaxDamage);
	bool SetInvincibility(const bool NewInvincibility);
	void SetMaxHealth(const float NewMaxHealth);
	void SetTempHealth(const float NewTempHealth);
	void SetTemporaryInvincibility(const float Duration);
	void SetTrueHealth(const float NewTrueHealth);

	float GetDeathThreshold() const;
	float GetDownedHealthFraction() const;
	float GetDownedHealthFractionInitial() const;
	float GetDownedHealthPercentage() const;
	float GetDownedHealthPercentageInitial() const;
	float GetHealth() const;
	float GetHealthFraction() const;
	float GetHealthFractionInitial() const;
	float GetHealthPercentage() const;
	float GetHealthPercentageInitial() const;
	EHealthStatus GetHealthStatus(bool IncludeSpecialStates) const;
	float GetHeavilyWoundedThreshold() const;
	float GetInitialDeathThreshold() const;
	float GetInitialMaxHealth() const;
	bool GetInvincibility() const;
	bool GetIsDead() const;
	bool GetIsDown() const;
	bool GetIsIncapacitated() const;
	bool GetIsStunned() const;
	float GetMaxHealth() const;
	float GetTempHealth() const;
	float GetTempHealthFractionInitial() const;
	float GetTrueHealth() const;
	float GetTrueHealthFractionInitial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x000100, "Wrong size on UHealthComponent");
static_assert(offsetof(UHealthComponent, CurrentHealth) == 0x0000B0, "Member 'UHealthComponent::CurrentHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, CurrentTrueHealth) == 0x0000B4, "Member 'UHealthComponent::CurrentTrueHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, CurrentTempHealth) == 0x0000B8, "Member 'UHealthComponent::CurrentTempHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, CurrentMaxHealth) == 0x0000BC, "Member 'UHealthComponent::CurrentMaxHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, CurrentDeathThreshold) == 0x0000C0, "Member 'UHealthComponent::CurrentDeathThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponent, MaxHealth) == 0x0000C4, "Member 'UHealthComponent::MaxHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, DeathThreshold) == 0x0000C8, "Member 'UHealthComponent::DeathThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponent, AlmostDeadThreshold) == 0x0000CC, "Member 'UHealthComponent::AlmostDeadThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponent, HeavilyWoundedThreshold) == 0x0000D0, "Member 'UHealthComponent::HeavilyWoundedThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponent, WoundedThreshold) == 0x0000D4, "Member 'UHealthComponent::WoundedThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponent, HealthAfterDowned) == 0x0000D8, "Member 'UHealthComponent::HealthAfterDowned' has a wrong offset!");
static_assert(offsetof(UHealthComponent, RegenerationRate) == 0x0000DC, "Member 'UHealthComponent::RegenerationRate' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OneHitDamage) == 0x0000E0, "Member 'UHealthComponent::OneHitDamage' has a wrong offset!");
static_assert(offsetof(UHealthComponent, StunnedTime) == 0x0000E4, "Member 'UHealthComponent::StunnedTime' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIsDead) == 0x0000E8, "Member 'UHealthComponent::bIsDead' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIsInvincible) == 0x0000E9, "Member 'UHealthComponent::bIsInvincible' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIsIncapacitated) == 0x0000EA, "Member 'UHealthComponent::bIsIncapacitated' has a wrong offset!");
static_assert(offsetof(UHealthComponent, SpawnLootAfterDead) == 0x0000F4, "Member 'UHealthComponent::SpawnLootAfterDead' has a wrong offset!");

// Class Flame.PlatformStorePurchaseHandlerBase
// 0x0050 (0x0078 - 0x0028)
class UPlatformStorePurchaseHandlerBase : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCloudSystem*                           CloudSystem;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStorePurchaseHandlerBase">();
	}
	static class UPlatformStorePurchaseHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStorePurchaseHandlerBase>();
	}
};
static_assert(alignof(UPlatformStorePurchaseHandlerBase) == 0x000008, "Wrong alignment on UPlatformStorePurchaseHandlerBase");
static_assert(sizeof(UPlatformStorePurchaseHandlerBase) == 0x000078, "Wrong size on UPlatformStorePurchaseHandlerBase");
static_assert(offsetof(UPlatformStorePurchaseHandlerBase, CloudSystem) == 0x000050, "Member 'UPlatformStorePurchaseHandlerBase::CloudSystem' has a wrong offset!");

// Class Flame.HealthComponentSimple
// 0x0020 (0x00D0 - 0x00B0)
class UHealthComponentSimple final : public UActorComponent
{
public:
	float                                         CurrentHealth;                                     // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMaxHealth;                                  // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDeathThreshold;                             // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHealth;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathThreshold;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDead;                                           // 0x00C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5[0xB];                                       // 0x00C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ApplyDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AHumanCharacter* InstigatingCharacter, class AActor* DamageCauser);
	void SetHealth(const float NewHealth);
	void SetIsDead(const bool NewIsDead);
	void SetMaxHealth(const float NewMaxHealth);

	float GetHealth() const;
	bool GetIsDead() const;
	float GetMaxHealth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponentSimple">();
	}
	static class UHealthComponentSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponentSimple>();
	}
};
static_assert(alignof(UHealthComponentSimple) == 0x000008, "Wrong alignment on UHealthComponentSimple");
static_assert(sizeof(UHealthComponentSimple) == 0x0000D0, "Wrong size on UHealthComponentSimple");
static_assert(offsetof(UHealthComponentSimple, CurrentHealth) == 0x0000B0, "Member 'UHealthComponentSimple::CurrentHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponentSimple, CurrentMaxHealth) == 0x0000B4, "Member 'UHealthComponentSimple::CurrentMaxHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponentSimple, CurrentDeathThreshold) == 0x0000B8, "Member 'UHealthComponentSimple::CurrentDeathThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponentSimple, MaxHealth) == 0x0000BC, "Member 'UHealthComponentSimple::MaxHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponentSimple, DeathThreshold) == 0x0000C0, "Member 'UHealthComponentSimple::DeathThreshold' has a wrong offset!");
static_assert(offsetof(UHealthComponentSimple, bIsDead) == 0x0000C4, "Member 'UHealthComponentSimple::bIsDead' has a wrong offset!");

// Class Flame.HeartBeatSystemBase
// 0x0000 (0x0028 - 0x0028)
class UHeartBeatSystemBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartBeatSystemBase">();
	}
	static class UHeartBeatSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartBeatSystemBase>();
	}
};
static_assert(alignof(UHeartBeatSystemBase) == 0x000008, "Wrong alignment on UHeartBeatSystemBase");
static_assert(sizeof(UHeartBeatSystemBase) == 0x000028, "Wrong size on UHeartBeatSystemBase");

// Class Flame.HeartBeatSystemServer
// 0x0018 (0x0040 - 0x0028)
class UHeartBeatSystemServer final : public UHeartBeatSystemBase
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartBeatSystemServer">();
	}
	static class UHeartBeatSystemServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartBeatSystemServer>();
	}
};
static_assert(alignof(UHeartBeatSystemServer) == 0x000008, "Wrong alignment on UHeartBeatSystemServer");
static_assert(sizeof(UHeartBeatSystemServer) == 0x000040, "Wrong size on UHeartBeatSystemServer");

// Class Flame.LinkedWeapons
// 0x0058 (0x00E0 - 0x0088)
class ULinkedWeapons final : public UWeaponsStorage
{
public:
	uint8                                         Pad_88[0x58];                                      // 0x0088(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddWeapon(class AWeapon* Weapon, EEventHandlerMode Mode);

	EWeaponSlotType FindWeapon(const class AWeapon* Weapon) const;
	class AWeapon* GetWeapon(EWeaponSlotType SlotType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkedWeapons">();
	}
	static class ULinkedWeapons* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULinkedWeapons>();
	}
};
static_assert(alignof(ULinkedWeapons) == 0x000008, "Wrong alignment on ULinkedWeapons");
static_assert(sizeof(ULinkedWeapons) == 0x0000E0, "Wrong size on ULinkedWeapons");

// Class Flame.HeartBeatSystemSettings
// 0x0048 (0x0080 - 0x0038)
class UHeartBeatSystemSettings final : public UDeveloperSettings
{
public:
	float                                         HeartBeatUpdateInterval;                           // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeartBeatUpdateIntervalCmd;                        // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultiplayServerIdCmd;                              // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultiplayMachineIdCmd;                             // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VirtualTypeCmd;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartBeatSystemSettings">();
	}
	static class UHeartBeatSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartBeatSystemSettings>();
	}
};
static_assert(alignof(UHeartBeatSystemSettings) == 0x000008, "Wrong alignment on UHeartBeatSystemSettings");
static_assert(sizeof(UHeartBeatSystemSettings) == 0x000080, "Wrong size on UHeartBeatSystemSettings");
static_assert(offsetof(UHeartBeatSystemSettings, HeartBeatUpdateInterval) == 0x000038, "Member 'UHeartBeatSystemSettings::HeartBeatUpdateInterval' has a wrong offset!");
static_assert(offsetof(UHeartBeatSystemSettings, HeartBeatUpdateIntervalCmd) == 0x000040, "Member 'UHeartBeatSystemSettings::HeartBeatUpdateIntervalCmd' has a wrong offset!");
static_assert(offsetof(UHeartBeatSystemSettings, MultiplayServerIdCmd) == 0x000050, "Member 'UHeartBeatSystemSettings::MultiplayServerIdCmd' has a wrong offset!");
static_assert(offsetof(UHeartBeatSystemSettings, MultiplayMachineIdCmd) == 0x000060, "Member 'UHeartBeatSystemSettings::MultiplayMachineIdCmd' has a wrong offset!");
static_assert(offsetof(UHeartBeatSystemSettings, VirtualTypeCmd) == 0x000070, "Member 'UHeartBeatSystemSettings::VirtualTypeCmd' has a wrong offset!");

// Class Flame.LeaderboardHandlersManager
// 0x0088 (0x00B0 - 0x0028)
class ULeaderboardHandlersManager final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULeaderboardHandlerBase*>        RequestQueue;                                      // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x44];                                      // 0x0058(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         API_CallLimit_XBOX;                                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         API_CallLimit_PLAYSTATION;                         // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         API_CallLimit_SWITCH;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         API_CallLimit_Default;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardHandlersManager">();
	}
	static class ULeaderboardHandlersManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardHandlersManager>();
	}
};
static_assert(alignof(ULeaderboardHandlersManager) == 0x000008, "Wrong alignment on ULeaderboardHandlersManager");
static_assert(sizeof(ULeaderboardHandlersManager) == 0x0000B0, "Wrong size on ULeaderboardHandlersManager");
static_assert(offsetof(ULeaderboardHandlersManager, RequestQueue) == 0x000048, "Member 'ULeaderboardHandlersManager::RequestQueue' has a wrong offset!");
static_assert(offsetof(ULeaderboardHandlersManager, API_CallLimit_XBOX) == 0x00009C, "Member 'ULeaderboardHandlersManager::API_CallLimit_XBOX' has a wrong offset!");
static_assert(offsetof(ULeaderboardHandlersManager, API_CallLimit_PLAYSTATION) == 0x0000A0, "Member 'ULeaderboardHandlersManager::API_CallLimit_PLAYSTATION' has a wrong offset!");
static_assert(offsetof(ULeaderboardHandlersManager, API_CallLimit_SWITCH) == 0x0000A4, "Member 'ULeaderboardHandlersManager::API_CallLimit_SWITCH' has a wrong offset!");
static_assert(offsetof(ULeaderboardHandlersManager, API_CallLimit_Default) == 0x0000A8, "Member 'ULeaderboardHandlersManager::API_CallLimit_Default' has a wrong offset!");

// Class Flame.HintWidget
// 0x0008 (0x02C0 - 0x02B8)
class UHintWidget : public UFlameWidget
{
public:
	class UPlatformTextBlock*                     HintText;                                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetHintText(const class FText& InText);
	void SetHintTexts(const TMap<EFlamePlatform, class FText>& InTexts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintWidget">();
	}
	static class UHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintWidget>();
	}
};
static_assert(alignof(UHintWidget) == 0x000008, "Wrong alignment on UHintWidget");
static_assert(sizeof(UHintWidget) == 0x0002C0, "Wrong size on UHintWidget");
static_assert(offsetof(UHintWidget, HintText) == 0x0002B8, "Member 'UHintWidget::HintText' has a wrong offset!");

// Class Flame.HUDWidget
// 0x0040 (0x02F8 - 0x02B8)
class UHUDWidget : public UFlameWidget
{
public:
	class UFlameWidget*                           HealthBar;                                         // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           WeaponInfo;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           Compass;                                           // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           GameInfo;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           Crosshair;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           GameplayIndicators;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           ConsumableIndicators;                              // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameWidget*                           ControlsInfo;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Show(bool bShowHUD);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDWidget">();
	}
	static class UHUDWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDWidget>();
	}
};
static_assert(alignof(UHUDWidget) == 0x000008, "Wrong alignment on UHUDWidget");
static_assert(sizeof(UHUDWidget) == 0x0002F8, "Wrong size on UHUDWidget");
static_assert(offsetof(UHUDWidget, HealthBar) == 0x0002B8, "Member 'UHUDWidget::HealthBar' has a wrong offset!");
static_assert(offsetof(UHUDWidget, WeaponInfo) == 0x0002C0, "Member 'UHUDWidget::WeaponInfo' has a wrong offset!");
static_assert(offsetof(UHUDWidget, Compass) == 0x0002C8, "Member 'UHUDWidget::Compass' has a wrong offset!");
static_assert(offsetof(UHUDWidget, GameInfo) == 0x0002D0, "Member 'UHUDWidget::GameInfo' has a wrong offset!");
static_assert(offsetof(UHUDWidget, Crosshair) == 0x0002D8, "Member 'UHUDWidget::Crosshair' has a wrong offset!");
static_assert(offsetof(UHUDWidget, GameplayIndicators) == 0x0002E0, "Member 'UHUDWidget::GameplayIndicators' has a wrong offset!");
static_assert(offsetof(UHUDWidget, ConsumableIndicators) == 0x0002E8, "Member 'UHUDWidget::ConsumableIndicators' has a wrong offset!");
static_assert(offsetof(UHUDWidget, ControlsInfo) == 0x0002F0, "Member 'UHUDWidget::ControlsInfo' has a wrong offset!");

// Class Flame.HumanAICharacter
// 0x0060 (0x0C60 - 0x0C00)
class AHumanAICharacter : public AHumanCharacter
{
public:
	class AAIPatrolPath*                          PatrolPath;                                        // 0x0C00(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class AItemForBackpack>, int32> LootToSpawn;                                       // 0x0C10(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void IsCharacterInSight(class AHumanCharacter* EnemyCharacter, bool CheckShootable, bool* OutInSight, bool* OutShootable, struct FVector* OutShootableLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanAICharacter">();
	}
	static class AHumanAICharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanAICharacter>();
	}
};
static_assert(alignof(AHumanAICharacter) == 0x000010, "Wrong alignment on AHumanAICharacter");
static_assert(sizeof(AHumanAICharacter) == 0x000C60, "Wrong size on AHumanAICharacter");
static_assert(offsetof(AHumanAICharacter, PatrolPath) == 0x000C00, "Member 'AHumanAICharacter::PatrolPath' has a wrong offset!");
static_assert(offsetof(AHumanAICharacter, LootToSpawn) == 0x000C10, "Member 'AHumanAICharacter::LootToSpawn' has a wrong offset!");

// Class Flame.MeleeWeapon
// 0x0010 (0x0BB0 - 0x0BA0)
class AMeleeWeapon : public AWeapon
{
public:
	bool                                          bRunDiags;                                         // 0x0BA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA1[0xF];                                      // 0x0BA1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeapon">();
	}
	static class AMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeapon>();
	}
};
static_assert(alignof(AMeleeWeapon) == 0x000010, "Wrong alignment on AMeleeWeapon");
static_assert(sizeof(AMeleeWeapon) == 0x000BB0, "Wrong size on AMeleeWeapon");
static_assert(offsetof(AMeleeWeapon, bRunDiags) == 0x000BA0, "Member 'AMeleeWeapon::bRunDiags' has a wrong offset!");

// Class Flame.HumanAnimCollection
// 0x1048 (0x1078 - 0x0030)
class UHumanAnimCollection final : public UDataAsset
{
public:
	TMap<EAnimWeaponType, struct FBipedalCollection> StandCollection;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FBipedalCollection> CrouchCollection;                                  // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBipedalAimed                          StandingAimed;                                     // 0x00D0(0x02D0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBipedalAimed                          CrouchingAimed;                                    // 0x03A0(0x02D0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FAimedCollection> StandAimed;                                        // 0x0670(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FAimedCollection> CrouchAimed;                                       // 0x06C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct Flame::FProne                          Prone;                                             // 0x0710(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransition                            TransitionRifle;                                   // 0x0810(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransition                            TransitionPistol;                                  // 0x0840(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransition                            TransitionUnarmed;                                 // 0x0870(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FTransitionDirection> TransitionCollection;                              // 0x08A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEquipItems                            EquippingItems;                                    // 0x08F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVerticalMovement                      VerticalMovement;                                  // 0x0918(0x0140)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMelee                                 Melee;                                             // 0x0A58(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRecoilCollection                      Recoil;                                            // 0x0A88(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EWeaponType, class UAnimSequence*>       RecoilCollection;                                  // 0x0AC8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDamageCollections                     DamageCollections;                                 // 0x0B18(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInteractionCollection                 Interactions;                                      // 0x0C38(0x0210)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSpecificGestures                      GesturesCollection;                                // 0x0E48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStaggerReactionsCollection            StaggerReactionsUnarmed;                           // 0x0E50(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FStaggerReactionsCollection            StaggerReactionsArmed;                             // 0x0F10(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWaterCollection                       WaterCollection;                                   // 0x0FD0(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanAnimCollection">();
	}
	static class UHumanAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanAnimCollection>();
	}
};
static_assert(alignof(UHumanAnimCollection) == 0x000008, "Wrong alignment on UHumanAnimCollection");
static_assert(sizeof(UHumanAnimCollection) == 0x001078, "Wrong size on UHumanAnimCollection");
static_assert(offsetof(UHumanAnimCollection, StandCollection) == 0x000030, "Member 'UHumanAnimCollection::StandCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, CrouchCollection) == 0x000080, "Member 'UHumanAnimCollection::CrouchCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, StandingAimed) == 0x0000D0, "Member 'UHumanAnimCollection::StandingAimed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, CrouchingAimed) == 0x0003A0, "Member 'UHumanAnimCollection::CrouchingAimed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, StandAimed) == 0x000670, "Member 'UHumanAnimCollection::StandAimed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, CrouchAimed) == 0x0006C0, "Member 'UHumanAnimCollection::CrouchAimed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, Prone) == 0x000710, "Member 'UHumanAnimCollection::Prone' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, TransitionRifle) == 0x000810, "Member 'UHumanAnimCollection::TransitionRifle' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, TransitionPistol) == 0x000840, "Member 'UHumanAnimCollection::TransitionPistol' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, TransitionUnarmed) == 0x000870, "Member 'UHumanAnimCollection::TransitionUnarmed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, TransitionCollection) == 0x0008A0, "Member 'UHumanAnimCollection::TransitionCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, EquippingItems) == 0x0008F0, "Member 'UHumanAnimCollection::EquippingItems' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, VerticalMovement) == 0x000918, "Member 'UHumanAnimCollection::VerticalMovement' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, Melee) == 0x000A58, "Member 'UHumanAnimCollection::Melee' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, Recoil) == 0x000A88, "Member 'UHumanAnimCollection::Recoil' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, RecoilCollection) == 0x000AC8, "Member 'UHumanAnimCollection::RecoilCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, DamageCollections) == 0x000B18, "Member 'UHumanAnimCollection::DamageCollections' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, Interactions) == 0x000C38, "Member 'UHumanAnimCollection::Interactions' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, GesturesCollection) == 0x000E48, "Member 'UHumanAnimCollection::GesturesCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, StaggerReactionsUnarmed) == 0x000E50, "Member 'UHumanAnimCollection::StaggerReactionsUnarmed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, StaggerReactionsArmed) == 0x000F10, "Member 'UHumanAnimCollection::StaggerReactionsArmed' has a wrong offset!");
static_assert(offsetof(UHumanAnimCollection, WaterCollection) == 0x000FD0, "Member 'UHumanAnimCollection::WaterCollection' has a wrong offset!");

// Class Flame.HumanAnimConfig
// 0x06D0 (0x06F8 - 0x0028)
class UHumanAnimConfig final : public UObject
{
public:
	class UAnimSequence*                          DontCrash;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponCategoryAnimationData           Unarmed;                                           // 0x0030(0x01A8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponCategoryAnimationData           Rifle;                                             // 0x01D8(0x01A8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponCategoryAnimationData           Pistol;                                            // 0x0380(0x01A8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponCategoryAnimationData           Knife;                                             // 0x0528(0x01A8)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGesturesConfig>            Gestures;                                          // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVerticalAnimConfig>        Vertical;                                          // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRifleSetForEverything;                          // 0x06E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E1[0x17];                                     // 0x06E1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanAnimConfig">();
	}
	static class UHumanAnimConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanAnimConfig>();
	}
};
static_assert(alignof(UHumanAnimConfig) == 0x000008, "Wrong alignment on UHumanAnimConfig");
static_assert(sizeof(UHumanAnimConfig) == 0x0006F8, "Wrong size on UHumanAnimConfig");
static_assert(offsetof(UHumanAnimConfig, DontCrash) == 0x000028, "Member 'UHumanAnimConfig::DontCrash' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Unarmed) == 0x000030, "Member 'UHumanAnimConfig::Unarmed' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Rifle) == 0x0001D8, "Member 'UHumanAnimConfig::Rifle' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Pistol) == 0x000380, "Member 'UHumanAnimConfig::Pistol' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Knife) == 0x000528, "Member 'UHumanAnimConfig::Knife' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Gestures) == 0x0006D0, "Member 'UHumanAnimConfig::Gestures' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, Vertical) == 0x0006D8, "Member 'UHumanAnimConfig::Vertical' has a wrong offset!");
static_assert(offsetof(UHumanAnimConfig, UseRifleSetForEverything) == 0x0006E0, "Member 'UHumanAnimConfig::UseRifleSetForEverything' has a wrong offset!");

// Class Flame.AimingMetaData
// 0x0018 (0x0040 - 0x0028)
class UAimingMetaData final : public UAnimMetaData
{
public:
	struct FVector                                SpineLocation;                                     // 0x0028(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HandLocation;                                      // 0x0034(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetHandLocation(const struct FVector& Location) const;
	void SetSpineLocation(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimingMetaData">();
	}
	static class UAimingMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimingMetaData>();
	}
};
static_assert(alignof(UAimingMetaData) == 0x000008, "Wrong alignment on UAimingMetaData");
static_assert(sizeof(UAimingMetaData) == 0x000040, "Wrong size on UAimingMetaData");
static_assert(offsetof(UAimingMetaData, SpineLocation) == 0x000028, "Member 'UAimingMetaData::SpineLocation' has a wrong offset!");
static_assert(offsetof(UAimingMetaData, HandLocation) == 0x000034, "Member 'UAimingMetaData::HandLocation' has a wrong offset!");

// Class Flame.PersistentItem
// 0x0000 (0x0398 - 0x0398)
class APersistentItem : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentItem">();
	}
	static class APersistentItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersistentItem>();
	}
};
static_assert(alignof(APersistentItem) == 0x000008, "Wrong alignment on APersistentItem");
static_assert(sizeof(APersistentItem) == 0x000398, "Wrong size on APersistentItem");

// Class Flame.PersistentItemArmor
// 0x0020 (0x03B8 - 0x0398)
class APersistentItemArmor : public APersistentItem
{
public:
	EDamageType                                   AffectedDamageType;                                // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterHitZone>                     CoveredZones;                                      // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         Durability;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDurability;                                 // 0x03B4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetDurabilityRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentItemArmor">();
	}
	static class APersistentItemArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersistentItemArmor>();
	}
};
static_assert(alignof(APersistentItemArmor) == 0x000008, "Wrong alignment on APersistentItemArmor");
static_assert(sizeof(APersistentItemArmor) == 0x0003B8, "Wrong size on APersistentItemArmor");
static_assert(offsetof(APersistentItemArmor, AffectedDamageType) == 0x000398, "Member 'APersistentItemArmor::AffectedDamageType' has a wrong offset!");
static_assert(offsetof(APersistentItemArmor, CoveredZones) == 0x0003A0, "Member 'APersistentItemArmor::CoveredZones' has a wrong offset!");
static_assert(offsetof(APersistentItemArmor, Durability) == 0x0003B0, "Member 'APersistentItemArmor::Durability' has a wrong offset!");
static_assert(offsetof(APersistentItemArmor, CurrentDurability) == 0x0003B4, "Member 'APersistentItemArmor::CurrentDurability' has a wrong offset!");

// Class Flame.HumanAnimInstace
// 0x0780 (0x0A40 - 0x02C0)
class UHumanAnimInstace : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMoving;                                         // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunningThreshold;                                  // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RunningInputThreshold;                             // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Velocity;                                          // 0x02CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Speed;                                             // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeanAngle;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeanRate;                                          // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlopeAngle;                                        // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneSlopeAngle;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneUpperBodyAngle;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                HipAdjustment;                                     // 0x02F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ProneVelocity;                                     // 0x02FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RootYaw;                                           // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowerBodyRootYaw;                                  // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsForward;                                        // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForeGrip;                                         // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStance                                       CurrentStance;                                     // 0x0312(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTempUsingConsumable;                              // 0x0313(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTransition;                                       // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionIdleAlpha;                               // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LookRotation;                                      // 0x031C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         LadderHipPitch;                                    // 0x0328(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationTimeRegular;                               // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationTimeAimed;                                 // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationTimeADS;                                   // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationAcceleration;                              // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMachineGunStance;                                 // 0x033C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoAdditive;                                       // 0x033D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33E[0x2];                                      // 0x033E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRotationSpeed;                                  // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x8];                                      // 0x0344(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDeltaMultiplier;                           // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHumanCharacter*                        Character;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForwardThresholdAngle;                             // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLookAt;                                        // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnifeLayer;                                        // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasJumped;                                        // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFalling;                                        // 0x0365(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLongFall;                                         // 0x0366(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_367[0x1];                                      // 0x0367(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallEvaluation;                                    // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LandingAlpha;                                      // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLanded;                                           // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AItem*                                  CurrentItem;                                       // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWeapon*                                CurrentWeapon;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWeaponType                                   CurrentWeaponType;                                 // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELocomotionType                               LocomotionType;                                    // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELocomotionType                               StopLocomotionType;                                // 0x038A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38B[0x1];                                      // 0x038B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPushBack;                                       // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAiming;                                         // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasATool;                                         // 0x0399(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAimBlocked;                                     // 0x039A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponPushBack;                                    // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasInFirstPerson;                                 // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECardinalDirection                            MovementDirection;                                 // 0x03A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimHands                                     AimingHands;                                       // 0x03A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RaisingTime;                                       // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowerTime;                                         // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForwardMovementAngle;                              // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightMovementAngle;                                // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftMovementAngle;                                 // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BackwardMovementAngle;                             // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementAngleMax;                                  // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasRightHandEffector;                             // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasRightHandStandAimEffector;                     // 0x03C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasRightHandCrouchAimEffector;                    // 0x03C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasRightHandProneAimEffector;                     // 0x03C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasWeaponEffector;                                // 0x03C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseRightHandSK;                                   // 0x03C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseWeaponSK;                                      // 0x03C6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLeftHandSK;                                    // 0x03C7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLeftHandEffector;                              // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAimActive;                                        // 0x03C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisabledAiming;                                   // 0x03CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CB[0x5];                                      // 0x03CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightHandEffector;                                 // 0x03D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             RightHandEffectorStandAim;                         // 0x0400(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             RightHandEffectorCrouchAim;                        // 0x0430(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             RightHandEffectorProneAim;                         // 0x0460(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             LeftHandEffector;                                  // 0x0490(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             WeaponEffector;                                    // 0x04C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             WeaponTransform;                                   // 0x04F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bPushDownHand;                                     // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_521[0x1];                                      // 0x0521(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebug;                                            // 0x0522(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugStopping;                                    // 0x0523(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInABPWindow;                                    // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERotationType                                 RotationType;                                      // 0x0525(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWeaponType                                   BaseType;                                          // 0x0526(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECardinalDirection                            CurrentProneDirection;                             // 0x0527(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimActionType                               CurrentAnimAction;                                 // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInWeaponAction;                                 // 0x0529(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFullBodyMode                                 FullBodyMode;                                      // 0x052A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInMelee;                                        // 0x052B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInWater;                                        // 0x052C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52D[0x3];                                      // 0x052D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterCoverage;                                     // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeRotation;                                     // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActionInBlendingTime;                              // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeInBlendingTime;                               // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultInBlendingTime;                             // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GestureBlendOutTime;                               // 0x0544(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSimpleAction;                                     // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoStaminaAdditive;                                // 0x0549(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasStarted;                                       // 0x054A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEndStart;                                         // 0x054B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTime;                                         // 0x054C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasFirstStep;                                     // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipStart;                                        // 0x0551(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_552[0x2];                                      // 0x0552(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceYaw;                                    // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StopTime;                                          // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentWeaponID;                                   // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimWeaponType                               CurrentAnimWeaponType;                             // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceThreshold;                              // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTurning;                                        // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceTime;                                   // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoMirror;                                         // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClimbingLadder;                                   // 0x0571(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LadderPitchValue;                                  // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LadderTimeUp;                                      // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LadderTimeDown;                                    // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMovingOnLadder;                                 // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGoingUp;                                        // 0x0581(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSliding;                                        // 0x0582(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClimbOrVault;                                     // 0x0583(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAutonomous;                                     // 0x0584(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExitStop;                                         // 0x0585(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_586[0x2];                                      // 0x0586(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimAtPointPurelyAesthetic;                         // 0x0588(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OrientationWarpRate;                               // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScaleHeadDown;                                    // 0x0598(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDead;                                           // 0x0599(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59A[0x2];                                      // 0x059A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegularRunRate;                                    // 0x059C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               InteractionDirection;                              // 0x05A0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	EAnimInteraction                              InteractionType;                                   // 0x05AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsArmed;                                          // 0x05AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5AE[0x2];                                      // 0x05AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDisableWeaponAlpha;                     // 0x05B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B4[0xA4];                                     // 0x05B4(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Skeleton;                                          // 0x0658(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x20];                                     // 0x0660(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UHumanAnimCollection*                   AnimationCollection;                               // 0x0680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimOffsetBlendSpace1D*                 MeleeAim;                                          // 0x0690(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   LookAt;                                            // 0x0698(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          BaseIdleStand;                                     // 0x06A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          BaseIdleCrouch;                                    // 0x06A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpperBodyAlpha;                                    // 0x06B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B4[0x4];                                      // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BodyIdleStand;                                     // 0x06B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                            RegularJogForwardStand;                            // 0x06C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogLeftFWDStand;                            // 0x06C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogRightFWDStand;                           // 0x06D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogLeftBWDStand;                            // 0x06D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogRightBWDStand;                           // 0x06E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogBackStand;                               // 0x06E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogForwardStand;                              // 0x06F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogLeftStand;                                 // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogRightStand;                                // 0x0700(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogBackStand;                                 // 0x0708(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JogForwardRate;                                    // 0x0710(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            RegularWalkForwardStand;                           // 0x0718(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkLeftFWDStand;                           // 0x0720(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkRightFWDStand;                          // 0x0728(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkLeftBWDStand;                           // 0x0730(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkRightBWDStand;                          // 0x0738(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkBackStand;                              // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkForwardStand;                             // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkLeftStand;                                // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkRightStand;                               // 0x0758(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkBackStand;                                // 0x0760(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkForwardRate;                                   // 0x0768(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopWalkRate;                                      // 0x076C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                            LoopSprint;                                        // 0x0770(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SprintForwardRate;                                 // 0x0778(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          UpperBodyIdleCrouch;                               // 0x0780(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                            RegularJogForwardCrouch;                           // 0x0788(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogLeftFWDCrouch;                           // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogRightFWDCrouch;                          // 0x0798(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogLeftBWDCrouch;                           // 0x07A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogRightBWDCrouch;                          // 0x07A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularJogBackCrouch;                              // 0x07B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogForwardCrouch;                             // 0x07B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogLeftCrouch;                                // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogRightCrouch;                               // 0x07C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedJogBackCrouch;                                // 0x07D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchJogForwardRate;                              // 0x07D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7DC[0x4];                                      // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            RegularWalkForwardCrouch;                          // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkLeftFWDCrouch;                          // 0x07E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkRightFWDCrouch;                         // 0x07F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkLeftBWDCrouch;                          // 0x07F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkRightBWDCrouch;                         // 0x0800(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          RegularWalkBackCrouch;                             // 0x0808(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkForwardCrouch;                            // 0x0810(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkLeftCrouch;                               // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkRightCrouch;                              // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimedWalkBackCrouch;                               // 0x0828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchWalkForwardRate;                             // 0x0830(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          BaseProneForward;                                  // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          BaseProneLeft;                                     // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          BaseProneRight;                                    // 0x0848(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          BaseProneBack;                                     // 0x0850(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace1D*                          UpperProne;                                        // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   ProneAim;                                          // 0x0860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          ProneIdle;                                         // 0x0868(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace*                            ProneMovement;                                     // 0x0870(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimingStand;                                       // 0x0878(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimBlockedStand;                                   // 0x0880(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace1D*                          AimPullBack;                                       // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   AimAtStand;                                        // 0x0890(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimingCrouch;                                      // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimBlockedCrouch;                                  // 0x08A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimHipCrouch;                                      // 0x08A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   AimAtCrouch;                                       // 0x08B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimMoveRightCrouch;                                // 0x08B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AimMoveLeftCrouch;                                 // 0x08C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   AimAt;                                             // 0x08C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D0[0x38];                                     // 0x08D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ArmsAdditiveIdle;                                  // 0x0908(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bArmAdditiveIdle;                                  // 0x0910(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_911[0x7];                                      // 0x0911(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ArmsAdditiveProne;                                 // 0x0918(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoArmAdditiveProne;                               // 0x0920(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_921[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ArmsAdditiveAim;                                   // 0x0928(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bArmAdditveAim;                                    // 0x0930(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_931[0x7];                                      // 0x0931(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ArmsAdditiveHip;                                   // 0x0938(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bArmAdditiveHip;                                   // 0x0940(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_941[0x7];                                      // 0x0941(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          JumpStartIdle;                                     // 0x0948(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace1D*                          JumpStartMoving;                                   // 0x0950(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpDirection;                                     // 0x0958(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            JumpFall;                                          // 0x0960(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          JumpLongFall;                                      // 0x0968(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          FirstPersonWeapon;                                 // 0x0970(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          StartSequence;                                     // 0x0978(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          StopSequence;                                      // 0x0980(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          InteractionStart;                                  // 0x0990(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          InteractionEnd;                                    // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          InteractionLoop;                                   // 0x09A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          InteractionAction;                                 // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          InteractionLayer;                                  // 0x09B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          HandOverride;                                      // 0x09B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          TurnInPlace;                                       // 0x09C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpace1D*                          TurnInPlaceBlendSpace;                             // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderClimbUpLoop_Straight;                        // 0x09D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderClimbUpLoop_Incline;                         // 0x09D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderClimbDownLoop_Straight;                      // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderClimbDownLoop_Incline;                       // 0x09E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderSlide_Straight;                              // 0x09F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LadderSlide_Incline;                               // 0x09F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterIdle;                                         // 0x0A00(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterForward;                                      // 0x0A08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterRightForward;                                 // 0x0A10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterRightBackward;                                // 0x0A18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterLeftForward;                                  // 0x0A20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterLeftBackward;                                 // 0x0A28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          WaterBack;                                         // 0x0A30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A38[0x8];                                      // 0x0A38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ItemInHandsChanged();
	void BP_StopMapGesture();
	bool CanUseLeftHandIK();
	bool CanUseLeftHandIK_BP();
	void ChangeEquipSection(const int32 NextSectionID);
	void ChangeGender(bool bIsaMale);
	void ChangePlayRateOnSectionChange(const float PlayRate);
	void CheatResetRootYaw();
	void DisableHandIK();
	void EnableHandIK();
	void EnableRegularFullBody(const bool bEnableIK);
	void EndClimb();
	void EndWeaponAction(const bool bEnableIK);
	void ForceOrientToYaw(const float OrientationYaw);
	bool IsaToolConsumable(class AItem* ItemInHands);
	void ItemChange(class UGameplayActionsComponent* Sender, class AItem* OldItem, class AItem* NewItem);
	void MatchStartTimerAnim();
	void NotifyIsAiming_BP();
	void NotifyStoppedAiming_BP();
	void OrientToYaw(const float OrientationYaw);
	void PlayMapGesture();
	void PutAwayMap();
	void ResetTheNotifyKeys();
	void SetAimingDisabled(const bool Disabled);
	void SetAnimations();
	void SetAnimCollection(const class UHumanAnimCollection* AnimColleciton);
	void SetDefaultAnimCollection();
	void SetDoAdditive(const bool bAdditive);
	void SetHandEffector(struct FTransform* Effector, const class FName SocketName, bool* HasEffector, bool* UpdateNeeded);
	void SetIK();
	void SetIKValues();
	void SetLeftHandIK(const bool bIsOn, const EAnimationNotifyIKViewType AnimationNotifyIKViewType);
	void SetRightHandIK(const bool bIsOn, const EAnimationNotifyIKViewType AnimationNotifyIKViewType);
	void SetStaminaAdditive(const bool bStaminaAdd);
	void SetWeaponSK(const bool bIsOn);
	void StartLinkedInteraction(const struct FCompoundActionCollection& InteractionCollection, const bool DisableWeapon, const bool StopInteractionAlways);
	void StartOneShotInteraction(class UAnimMontage* InteractionMontage);
	void StartSlideLadder();
	void StartWeaponAction_BP(const float Time);
	void StopAnyAction_BP();
	void StopClimbingLadder();
	void StopGesture(class UAnimMontage* Montage, bool bInterrupted);
	void StopGestureHead(class UAnimMontage* Montage, bool bInterrupted);
	void StopInteraction();
	void StopMapGesture();
	void StopSlideLadder();
	void StopTransition(class UAnimMontage* CurrentTransitionMontage, bool bInterrupted);
	void StopUsingItem(class AHumanCharacter* SenderCharacter, class AItem* OneConsumable, EItemActionFinishedState Status);
	void UsingItem(class AHumanCharacter* SenderCharacter, class AItem* UsingItem_0, float NeededTimeForInteraction);

	struct FVector GetRootForwardVector() const;
	bool LocomotionIdle() const;
	float MapPullOutLength() const;
	float MapPutAwayLength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanAnimInstace">();
	}
	static class UHumanAnimInstace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanAnimInstace>();
	}
};
static_assert(alignof(UHumanAnimInstace) == 0x000010, "Wrong alignment on UHumanAnimInstace");
static_assert(sizeof(UHumanAnimInstace) == 0x000A40, "Wrong size on UHumanAnimInstace");
static_assert(offsetof(UHumanAnimInstace, bIsMoving) == 0x0002C0, "Member 'UHumanAnimInstace::bIsMoving' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RunningThreshold) == 0x0002C4, "Member 'UHumanAnimInstace::RunningThreshold' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RunningInputThreshold) == 0x0002C8, "Member 'UHumanAnimInstace::RunningInputThreshold' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, Velocity) == 0x0002CC, "Member 'UHumanAnimInstace::Velocity' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, Speed) == 0x0002D8, "Member 'UHumanAnimInstace::Speed' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LeanAngle) == 0x0002DC, "Member 'UHumanAnimInstace::LeanAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LeanRate) == 0x0002E0, "Member 'UHumanAnimInstace::LeanRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, SlopeAngle) == 0x0002E4, "Member 'UHumanAnimInstace::SlopeAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneSlopeAngle) == 0x0002E8, "Member 'UHumanAnimInstace::ProneSlopeAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneUpperBodyAngle) == 0x0002EC, "Member 'UHumanAnimInstace::ProneUpperBodyAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, HipAdjustment) == 0x0002F0, "Member 'UHumanAnimInstace::HipAdjustment' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneVelocity) == 0x0002FC, "Member 'UHumanAnimInstace::ProneVelocity' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RootYaw) == 0x000308, "Member 'UHumanAnimInstace::RootYaw' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LowerBodyRootYaw) == 0x00030C, "Member 'UHumanAnimInstace::LowerBodyRootYaw' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsForward) == 0x000310, "Member 'UHumanAnimInstace::bIsForward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bForeGrip) == 0x000311, "Member 'UHumanAnimInstace::bForeGrip' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentStance) == 0x000312, "Member 'UHumanAnimInstace::CurrentStance' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bTempUsingConsumable) == 0x000313, "Member 'UHumanAnimInstace::bTempUsingConsumable' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bTransition) == 0x000314, "Member 'UHumanAnimInstace::bTransition' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LocomotionIdleAlpha) == 0x000318, "Member 'UHumanAnimInstace::LocomotionIdleAlpha' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LookRotation) == 0x00031C, "Member 'UHumanAnimInstace::LookRotation' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderHipPitch) == 0x000328, "Member 'UHumanAnimInstace::LadderHipPitch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationTimeRegular) == 0x00032C, "Member 'UHumanAnimInstace::RotationTimeRegular' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationTimeAimed) == 0x000330, "Member 'UHumanAnimInstace::RotationTimeAimed' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationTimeADS) == 0x000334, "Member 'UHumanAnimInstace::RotationTimeADS' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationAcceleration) == 0x000338, "Member 'UHumanAnimInstace::RotationAcceleration' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bMachineGunStance) == 0x00033C, "Member 'UHumanAnimInstace::bMachineGunStance' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDoAdditive) == 0x00033D, "Member 'UHumanAnimInstace::bDoAdditive' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MaxRotationSpeed) == 0x000340, "Member 'UHumanAnimInstace::MaxRotationSpeed' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationDeltaMultiplier) == 0x00034C, "Member 'UHumanAnimInstace::RotationDeltaMultiplier' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, Character) == 0x000350, "Member 'UHumanAnimInstace::Character' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ForwardThresholdAngle) == 0x000358, "Member 'UHumanAnimInstace::ForwardThresholdAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bUseLookAt) == 0x00035C, "Member 'UHumanAnimInstace::bUseLookAt' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, KnifeLayer) == 0x000360, "Member 'UHumanAnimInstace::KnifeLayer' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasJumped) == 0x000364, "Member 'UHumanAnimInstace::bHasJumped' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsFalling) == 0x000365, "Member 'UHumanAnimInstace::bIsFalling' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bLongFall) == 0x000366, "Member 'UHumanAnimInstace::bLongFall' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, FallEvaluation) == 0x000368, "Member 'UHumanAnimInstace::FallEvaluation' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LandingAlpha) == 0x00036C, "Member 'UHumanAnimInstace::LandingAlpha' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bLanded) == 0x000370, "Member 'UHumanAnimInstace::bLanded' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentItem) == 0x000378, "Member 'UHumanAnimInstace::CurrentItem' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentWeapon) == 0x000380, "Member 'UHumanAnimInstace::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentWeaponType) == 0x000388, "Member 'UHumanAnimInstace::CurrentWeaponType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LocomotionType) == 0x000389, "Member 'UHumanAnimInstace::LocomotionType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, StopLocomotionType) == 0x00038A, "Member 'UHumanAnimInstace::StopLocomotionType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MaxPushBack) == 0x00038C, "Member 'UHumanAnimInstace::MaxPushBack' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsAiming) == 0x000398, "Member 'UHumanAnimInstace::bIsAiming' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasATool) == 0x000399, "Member 'UHumanAnimInstace::bHasATool' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsAimBlocked) == 0x00039A, "Member 'UHumanAnimInstace::bIsAimBlocked' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WeaponPushBack) == 0x00039C, "Member 'UHumanAnimInstace::WeaponPushBack' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bWasInFirstPerson) == 0x0003A0, "Member 'UHumanAnimInstace::bWasInFirstPerson' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MovementDirection) == 0x0003A1, "Member 'UHumanAnimInstace::MovementDirection' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimingHands) == 0x0003A2, "Member 'UHumanAnimInstace::AimingHands' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RaisingTime) == 0x0003A4, "Member 'UHumanAnimInstace::RaisingTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LowerTime) == 0x0003A8, "Member 'UHumanAnimInstace::LowerTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ForwardMovementAngle) == 0x0003AC, "Member 'UHumanAnimInstace::ForwardMovementAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RightMovementAngle) == 0x0003B0, "Member 'UHumanAnimInstace::RightMovementAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LeftMovementAngle) == 0x0003B4, "Member 'UHumanAnimInstace::LeftMovementAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BackwardMovementAngle) == 0x0003B8, "Member 'UHumanAnimInstace::BackwardMovementAngle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MovementAngleMax) == 0x0003BC, "Member 'UHumanAnimInstace::MovementAngleMax' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasRightHandEffector) == 0x0003C0, "Member 'UHumanAnimInstace::bHasRightHandEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasRightHandStandAimEffector) == 0x0003C1, "Member 'UHumanAnimInstace::bHasRightHandStandAimEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasRightHandCrouchAimEffector) == 0x0003C2, "Member 'UHumanAnimInstace::bHasRightHandCrouchAimEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasRightHandProneAimEffector) == 0x0003C3, "Member 'UHumanAnimInstace::bHasRightHandProneAimEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasWeaponEffector) == 0x0003C4, "Member 'UHumanAnimInstace::bHasWeaponEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bUseRightHandSK) == 0x0003C5, "Member 'UHumanAnimInstace::bUseRightHandSK' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bUseWeaponSK) == 0x0003C6, "Member 'UHumanAnimInstace::bUseWeaponSK' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bUseLeftHandSK) == 0x0003C7, "Member 'UHumanAnimInstace::bUseLeftHandSK' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasLeftHandEffector) == 0x0003C8, "Member 'UHumanAnimInstace::bHasLeftHandEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bAimActive) == 0x0003C9, "Member 'UHumanAnimInstace::bAimActive' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDisabledAiming) == 0x0003CA, "Member 'UHumanAnimInstace::bDisabledAiming' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RightHandEffector) == 0x0003D0, "Member 'UHumanAnimInstace::RightHandEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RightHandEffectorStandAim) == 0x000400, "Member 'UHumanAnimInstace::RightHandEffectorStandAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RightHandEffectorCrouchAim) == 0x000430, "Member 'UHumanAnimInstace::RightHandEffectorCrouchAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RightHandEffectorProneAim) == 0x000460, "Member 'UHumanAnimInstace::RightHandEffectorProneAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LeftHandEffector) == 0x000490, "Member 'UHumanAnimInstace::LeftHandEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WeaponEffector) == 0x0004C0, "Member 'UHumanAnimInstace::WeaponEffector' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WeaponTransform) == 0x0004F0, "Member 'UHumanAnimInstace::WeaponTransform' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bPushDownHand) == 0x000520, "Member 'UHumanAnimInstace::bPushDownHand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDebug) == 0x000522, "Member 'UHumanAnimInstace::bDebug' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDebugStopping) == 0x000523, "Member 'UHumanAnimInstace::bDebugStopping' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsInABPWindow) == 0x000524, "Member 'UHumanAnimInstace::bIsInABPWindow' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RotationType) == 0x000525, "Member 'UHumanAnimInstace::RotationType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseType) == 0x000526, "Member 'UHumanAnimInstace::BaseType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentProneDirection) == 0x000527, "Member 'UHumanAnimInstace::CurrentProneDirection' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentAnimAction) == 0x000528, "Member 'UHumanAnimInstace::CurrentAnimAction' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsInWeaponAction) == 0x000529, "Member 'UHumanAnimInstace::bIsInWeaponAction' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, FullBodyMode) == 0x00052A, "Member 'UHumanAnimInstace::FullBodyMode' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsInMelee) == 0x00052B, "Member 'UHumanAnimInstace::bIsInMelee' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsInWater) == 0x00052C, "Member 'UHumanAnimInstace::bIsInWater' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterCoverage) == 0x000530, "Member 'UHumanAnimInstace::WaterCoverage' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MeleeRotation) == 0x000534, "Member 'UHumanAnimInstace::MeleeRotation' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ActionInBlendingTime) == 0x000538, "Member 'UHumanAnimInstace::ActionInBlendingTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MeleeInBlendingTime) == 0x00053C, "Member 'UHumanAnimInstace::MeleeInBlendingTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, DefaultInBlendingTime) == 0x000540, "Member 'UHumanAnimInstace::DefaultInBlendingTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, GestureBlendOutTime) == 0x000544, "Member 'UHumanAnimInstace::GestureBlendOutTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bSimpleAction) == 0x000548, "Member 'UHumanAnimInstace::bSimpleAction' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDoStaminaAdditive) == 0x000549, "Member 'UHumanAnimInstace::bDoStaminaAdditive' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasStarted) == 0x00054A, "Member 'UHumanAnimInstace::bHasStarted' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bEndStart) == 0x00054B, "Member 'UHumanAnimInstace::bEndStart' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, StartTime) == 0x00054C, "Member 'UHumanAnimInstace::StartTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bHasFirstStep) == 0x000550, "Member 'UHumanAnimInstace::bHasFirstStep' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bSkipStart) == 0x000551, "Member 'UHumanAnimInstace::bSkipStart' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, TurnInPlaceYaw) == 0x000554, "Member 'UHumanAnimInstace::TurnInPlaceYaw' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, StopTime) == 0x000558, "Member 'UHumanAnimInstace::StopTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentWeaponID) == 0x00055C, "Member 'UHumanAnimInstace::CurrentWeaponID' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CurrentAnimWeaponType) == 0x000560, "Member 'UHumanAnimInstace::CurrentAnimWeaponType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, TurnInPlaceThreshold) == 0x000564, "Member 'UHumanAnimInstace::TurnInPlaceThreshold' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsTurning) == 0x000568, "Member 'UHumanAnimInstace::bIsTurning' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, TurnInPlaceTime) == 0x00056C, "Member 'UHumanAnimInstace::TurnInPlaceTime' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDoMirror) == 0x000570, "Member 'UHumanAnimInstace::bDoMirror' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bClimbingLadder) == 0x000571, "Member 'UHumanAnimInstace::bClimbingLadder' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderPitchValue) == 0x000574, "Member 'UHumanAnimInstace::LadderPitchValue' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderTimeUp) == 0x000578, "Member 'UHumanAnimInstace::LadderTimeUp' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderTimeDown) == 0x00057C, "Member 'UHumanAnimInstace::LadderTimeDown' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsMovingOnLadder) == 0x000580, "Member 'UHumanAnimInstace::bIsMovingOnLadder' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsGoingUp) == 0x000581, "Member 'UHumanAnimInstace::bIsGoingUp' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsSliding) == 0x000582, "Member 'UHumanAnimInstace::bIsSliding' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bClimbOrVault) == 0x000583, "Member 'UHumanAnimInstace::bClimbOrVault' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsAutonomous) == 0x000584, "Member 'UHumanAnimInstace::bIsAutonomous' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bExitStop) == 0x000585, "Member 'UHumanAnimInstace::bExitStop' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimAtPointPurelyAesthetic) == 0x000588, "Member 'UHumanAnimInstace::AimAtPointPurelyAesthetic' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, OrientationWarpRate) == 0x000594, "Member 'UHumanAnimInstace::OrientationWarpRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bScaleHeadDown) == 0x000598, "Member 'UHumanAnimInstace::bScaleHeadDown' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsDead) == 0x000599, "Member 'UHumanAnimInstace::bIsDead' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularRunRate) == 0x00059C, "Member 'UHumanAnimInstace::RegularRunRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionDirection) == 0x0005A0, "Member 'UHumanAnimInstace::InteractionDirection' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionType) == 0x0005AC, "Member 'UHumanAnimInstace::InteractionType' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bIsArmed) == 0x0005AD, "Member 'UHumanAnimInstace::bIsArmed' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionDisableWeaponAlpha) == 0x0005B0, "Member 'UHumanAnimInstace::InteractionDisableWeaponAlpha' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, Skeleton) == 0x000658, "Member 'UHumanAnimInstace::Skeleton' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AnimationCollection) == 0x000680, "Member 'UHumanAnimInstace::AnimationCollection' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, MeleeAim) == 0x000690, "Member 'UHumanAnimInstace::MeleeAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LookAt) == 0x000698, "Member 'UHumanAnimInstace::LookAt' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseIdleStand) == 0x0006A0, "Member 'UHumanAnimInstace::BaseIdleStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseIdleCrouch) == 0x0006A8, "Member 'UHumanAnimInstace::BaseIdleCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, UpperBodyAlpha) == 0x0006B0, "Member 'UHumanAnimInstace::UpperBodyAlpha' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BodyIdleStand) == 0x0006B8, "Member 'UHumanAnimInstace::BodyIdleStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogForwardStand) == 0x0006C0, "Member 'UHumanAnimInstace::RegularJogForwardStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogLeftFWDStand) == 0x0006C8, "Member 'UHumanAnimInstace::RegularJogLeftFWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogRightFWDStand) == 0x0006D0, "Member 'UHumanAnimInstace::RegularJogRightFWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogLeftBWDStand) == 0x0006D8, "Member 'UHumanAnimInstace::RegularJogLeftBWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogRightBWDStand) == 0x0006E0, "Member 'UHumanAnimInstace::RegularJogRightBWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogBackStand) == 0x0006E8, "Member 'UHumanAnimInstace::RegularJogBackStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogForwardStand) == 0x0006F0, "Member 'UHumanAnimInstace::AimedJogForwardStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogLeftStand) == 0x0006F8, "Member 'UHumanAnimInstace::AimedJogLeftStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogRightStand) == 0x000700, "Member 'UHumanAnimInstace::AimedJogRightStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogBackStand) == 0x000708, "Member 'UHumanAnimInstace::AimedJogBackStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JogForwardRate) == 0x000710, "Member 'UHumanAnimInstace::JogForwardRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkForwardStand) == 0x000718, "Member 'UHumanAnimInstace::RegularWalkForwardStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkLeftFWDStand) == 0x000720, "Member 'UHumanAnimInstace::RegularWalkLeftFWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkRightFWDStand) == 0x000728, "Member 'UHumanAnimInstace::RegularWalkRightFWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkLeftBWDStand) == 0x000730, "Member 'UHumanAnimInstace::RegularWalkLeftBWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkRightBWDStand) == 0x000738, "Member 'UHumanAnimInstace::RegularWalkRightBWDStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkBackStand) == 0x000740, "Member 'UHumanAnimInstace::RegularWalkBackStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkForwardStand) == 0x000748, "Member 'UHumanAnimInstace::AimedWalkForwardStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkLeftStand) == 0x000750, "Member 'UHumanAnimInstace::AimedWalkLeftStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkRightStand) == 0x000758, "Member 'UHumanAnimInstace::AimedWalkRightStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkBackStand) == 0x000760, "Member 'UHumanAnimInstace::AimedWalkBackStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WalkForwardRate) == 0x000768, "Member 'UHumanAnimInstace::WalkForwardRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LoopWalkRate) == 0x00076C, "Member 'UHumanAnimInstace::LoopWalkRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LoopSprint) == 0x000770, "Member 'UHumanAnimInstace::LoopSprint' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, SprintForwardRate) == 0x000778, "Member 'UHumanAnimInstace::SprintForwardRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, UpperBodyIdleCrouch) == 0x000780, "Member 'UHumanAnimInstace::UpperBodyIdleCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogForwardCrouch) == 0x000788, "Member 'UHumanAnimInstace::RegularJogForwardCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogLeftFWDCrouch) == 0x000790, "Member 'UHumanAnimInstace::RegularJogLeftFWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogRightFWDCrouch) == 0x000798, "Member 'UHumanAnimInstace::RegularJogRightFWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogLeftBWDCrouch) == 0x0007A0, "Member 'UHumanAnimInstace::RegularJogLeftBWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogRightBWDCrouch) == 0x0007A8, "Member 'UHumanAnimInstace::RegularJogRightBWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularJogBackCrouch) == 0x0007B0, "Member 'UHumanAnimInstace::RegularJogBackCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogForwardCrouch) == 0x0007B8, "Member 'UHumanAnimInstace::AimedJogForwardCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogLeftCrouch) == 0x0007C0, "Member 'UHumanAnimInstace::AimedJogLeftCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogRightCrouch) == 0x0007C8, "Member 'UHumanAnimInstace::AimedJogRightCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedJogBackCrouch) == 0x0007D0, "Member 'UHumanAnimInstace::AimedJogBackCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CrouchJogForwardRate) == 0x0007D8, "Member 'UHumanAnimInstace::CrouchJogForwardRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkForwardCrouch) == 0x0007E0, "Member 'UHumanAnimInstace::RegularWalkForwardCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkLeftFWDCrouch) == 0x0007E8, "Member 'UHumanAnimInstace::RegularWalkLeftFWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkRightFWDCrouch) == 0x0007F0, "Member 'UHumanAnimInstace::RegularWalkRightFWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkLeftBWDCrouch) == 0x0007F8, "Member 'UHumanAnimInstace::RegularWalkLeftBWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkRightBWDCrouch) == 0x000800, "Member 'UHumanAnimInstace::RegularWalkRightBWDCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, RegularWalkBackCrouch) == 0x000808, "Member 'UHumanAnimInstace::RegularWalkBackCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkForwardCrouch) == 0x000810, "Member 'UHumanAnimInstace::AimedWalkForwardCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkLeftCrouch) == 0x000818, "Member 'UHumanAnimInstace::AimedWalkLeftCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkRightCrouch) == 0x000820, "Member 'UHumanAnimInstace::AimedWalkRightCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimedWalkBackCrouch) == 0x000828, "Member 'UHumanAnimInstace::AimedWalkBackCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, CrouchWalkForwardRate) == 0x000830, "Member 'UHumanAnimInstace::CrouchWalkForwardRate' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseProneForward) == 0x000838, "Member 'UHumanAnimInstace::BaseProneForward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseProneLeft) == 0x000840, "Member 'UHumanAnimInstace::BaseProneLeft' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseProneRight) == 0x000848, "Member 'UHumanAnimInstace::BaseProneRight' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, BaseProneBack) == 0x000850, "Member 'UHumanAnimInstace::BaseProneBack' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, UpperProne) == 0x000858, "Member 'UHumanAnimInstace::UpperProne' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneAim) == 0x000860, "Member 'UHumanAnimInstace::ProneAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneIdle) == 0x000868, "Member 'UHumanAnimInstace::ProneIdle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ProneMovement) == 0x000870, "Member 'UHumanAnimInstace::ProneMovement' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimingStand) == 0x000878, "Member 'UHumanAnimInstace::AimingStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimBlockedStand) == 0x000880, "Member 'UHumanAnimInstace::AimBlockedStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimPullBack) == 0x000888, "Member 'UHumanAnimInstace::AimPullBack' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimAtStand) == 0x000890, "Member 'UHumanAnimInstace::AimAtStand' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimingCrouch) == 0x000898, "Member 'UHumanAnimInstace::AimingCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimBlockedCrouch) == 0x0008A0, "Member 'UHumanAnimInstace::AimBlockedCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimHipCrouch) == 0x0008A8, "Member 'UHumanAnimInstace::AimHipCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimAtCrouch) == 0x0008B0, "Member 'UHumanAnimInstace::AimAtCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimMoveRightCrouch) == 0x0008B8, "Member 'UHumanAnimInstace::AimMoveRightCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimMoveLeftCrouch) == 0x0008C0, "Member 'UHumanAnimInstace::AimMoveLeftCrouch' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, AimAt) == 0x0008C8, "Member 'UHumanAnimInstace::AimAt' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ArmsAdditiveIdle) == 0x000908, "Member 'UHumanAnimInstace::ArmsAdditiveIdle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bArmAdditiveIdle) == 0x000910, "Member 'UHumanAnimInstace::bArmAdditiveIdle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ArmsAdditiveProne) == 0x000918, "Member 'UHumanAnimInstace::ArmsAdditiveProne' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bDoArmAdditiveProne) == 0x000920, "Member 'UHumanAnimInstace::bDoArmAdditiveProne' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ArmsAdditiveAim) == 0x000928, "Member 'UHumanAnimInstace::ArmsAdditiveAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bArmAdditveAim) == 0x000930, "Member 'UHumanAnimInstace::bArmAdditveAim' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, ArmsAdditiveHip) == 0x000938, "Member 'UHumanAnimInstace::ArmsAdditiveHip' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, bArmAdditiveHip) == 0x000940, "Member 'UHumanAnimInstace::bArmAdditiveHip' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JumpStartIdle) == 0x000948, "Member 'UHumanAnimInstace::JumpStartIdle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JumpStartMoving) == 0x000950, "Member 'UHumanAnimInstace::JumpStartMoving' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JumpDirection) == 0x000958, "Member 'UHumanAnimInstace::JumpDirection' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JumpFall) == 0x000960, "Member 'UHumanAnimInstace::JumpFall' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, JumpLongFall) == 0x000968, "Member 'UHumanAnimInstace::JumpLongFall' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, FirstPersonWeapon) == 0x000970, "Member 'UHumanAnimInstace::FirstPersonWeapon' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, StartSequence) == 0x000978, "Member 'UHumanAnimInstace::StartSequence' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, StopSequence) == 0x000980, "Member 'UHumanAnimInstace::StopSequence' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionStart) == 0x000990, "Member 'UHumanAnimInstace::InteractionStart' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionEnd) == 0x000998, "Member 'UHumanAnimInstace::InteractionEnd' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionLoop) == 0x0009A0, "Member 'UHumanAnimInstace::InteractionLoop' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionAction) == 0x0009A8, "Member 'UHumanAnimInstace::InteractionAction' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, InteractionLayer) == 0x0009B0, "Member 'UHumanAnimInstace::InteractionLayer' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, HandOverride) == 0x0009B8, "Member 'UHumanAnimInstace::HandOverride' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, TurnInPlace) == 0x0009C0, "Member 'UHumanAnimInstace::TurnInPlace' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, TurnInPlaceBlendSpace) == 0x0009C8, "Member 'UHumanAnimInstace::TurnInPlaceBlendSpace' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderClimbUpLoop_Straight) == 0x0009D0, "Member 'UHumanAnimInstace::LadderClimbUpLoop_Straight' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderClimbUpLoop_Incline) == 0x0009D8, "Member 'UHumanAnimInstace::LadderClimbUpLoop_Incline' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderClimbDownLoop_Straight) == 0x0009E0, "Member 'UHumanAnimInstace::LadderClimbDownLoop_Straight' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderClimbDownLoop_Incline) == 0x0009E8, "Member 'UHumanAnimInstace::LadderClimbDownLoop_Incline' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderSlide_Straight) == 0x0009F0, "Member 'UHumanAnimInstace::LadderSlide_Straight' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, LadderSlide_Incline) == 0x0009F8, "Member 'UHumanAnimInstace::LadderSlide_Incline' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterIdle) == 0x000A00, "Member 'UHumanAnimInstace::WaterIdle' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterForward) == 0x000A08, "Member 'UHumanAnimInstace::WaterForward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterRightForward) == 0x000A10, "Member 'UHumanAnimInstace::WaterRightForward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterRightBackward) == 0x000A18, "Member 'UHumanAnimInstace::WaterRightBackward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterLeftForward) == 0x000A20, "Member 'UHumanAnimInstace::WaterLeftForward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterLeftBackward) == 0x000A28, "Member 'UHumanAnimInstace::WaterLeftBackward' has a wrong offset!");
static_assert(offsetof(UHumanAnimInstace, WaterBack) == 0x000A30, "Member 'UHumanAnimInstace::WaterBack' has a wrong offset!");

// Class Flame.LeaderboardReadBoardBaseDev
// 0x0038 (0x00D8 - 0x00A0)
class ULeaderboardReadBoardBaseDev : public ULeaderboardReadBoardBase
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardBaseDev">();
	}
	static class ULeaderboardReadBoardBaseDev* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardBaseDev>();
	}
};
static_assert(alignof(ULeaderboardReadBoardBaseDev) == 0x000008, "Wrong alignment on ULeaderboardReadBoardBaseDev");
static_assert(sizeof(ULeaderboardReadBoardBaseDev) == 0x0000D8, "Wrong size on ULeaderboardReadBoardBaseDev");

// Class Flame.LeaderboardReadBoardAroundUserDev
// 0x0000 (0x00D8 - 0x00D8)
class ULeaderboardReadBoardAroundUserDev final : public ULeaderboardReadBoardBaseDev
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundUserDev">();
	}
	static class ULeaderboardReadBoardAroundUserDev* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundUserDev>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundUserDev) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundUserDev");
static_assert(sizeof(ULeaderboardReadBoardAroundUserDev) == 0x0000D8, "Wrong size on ULeaderboardReadBoardAroundUserDev");

// Class Flame.HumanCommon
// 0x0000 (0x0028 - 0x0028)
class UHumanCommon final : public UBlueprintFunctionLibrary
{
public:
	static void Dbg_CycleCameraShoulder();
	static void Dbg_ToggleForceUnarmedAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanCommon">();
	}
	static class UHumanCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanCommon>();
	}
};
static_assert(alignof(UHumanCommon) == 0x000008, "Wrong alignment on UHumanCommon");
static_assert(sizeof(UHumanCommon) == 0x000028, "Wrong size on UHumanCommon");

// Class Flame.StopMeleeMovement
// 0x0000 (0x0038 - 0x0038)
class UStopMeleeMovement final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StopMeleeMovement">();
	}
	static class UStopMeleeMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStopMeleeMovement>();
	}
};
static_assert(alignof(UStopMeleeMovement) == 0x000008, "Wrong alignment on UStopMeleeMovement");
static_assert(sizeof(UStopMeleeMovement) == 0x000038, "Wrong size on UStopMeleeMovement");

// Class Flame.HumanCharacterFunctions
// 0x0000 (0x0028 - 0x0028)
class UHumanCharacterFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplyCharacterDescriptor(class AHumanCharacter* TargetCharacter, const struct FHumanCharacterInfo& SourceDescriptor);
	static bool ApplyLoadoutInfo(class AHumanCharacter* TargetCharacter, const struct FLoadoutInfo& SourceDescriptor);
	static struct FLoadoutDiff ComputeLoadoutsDiff(const struct FLoadoutInfo& ReceivedLoadout, const struct FLoadoutInfo& CurrentLoadout);
	static bool CreateCharacterDescriptor(const class AHumanCharacter* FromCharacter, struct FHumanCharacterInfo* TargetDescriptor);
	static class FString GetCurrentWeaponStatus(class AHumanCharacter* TargetCharacter);
	static EMachineStatus GetMachineStatusForUpperBody(class AHumanCharacter* TargetCharacter);
	static bool LoadAllWeaponsFromBag(class AHumanCharacter* TargetCharacter);
	static bool RemoveMagazinesFromAllWeapons(class AHumanCharacter* TargetCharacter);
	static bool UnloadAllWeaponsToBag(class AHumanCharacter* TargetCharacter);
	static struct FLoadoutInfo WhatIsMissingInLoadout(const struct FLoadoutInfo& RequestedLoadout, const struct FLoadoutInfo& CurrentLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanCharacterFunctions">();
	}
	static class UHumanCharacterFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanCharacterFunctions>();
	}
};
static_assert(alignof(UHumanCharacterFunctions) == 0x000008, "Wrong alignment on UHumanCharacterFunctions");
static_assert(sizeof(UHumanCharacterFunctions) == 0x000028, "Wrong size on UHumanCharacterFunctions");

// Class Flame.ClimbingAnimMetaData
// 0x0018 (0x0040 - 0x0028)
class UClimbingAnimMetaData final : public UAnimMetaData
{
public:
	float                                         TargetOffsetFromEdge;                              // 0x0028(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionToCoreMinTime;                           // 0x002C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionToCoreTargetInAnimation;                 // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTresholdFromCore;                               // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStableTime;                                // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTransitionTime;                                 // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClimbingAnimMetaData">();
	}
	static class UClimbingAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClimbingAnimMetaData>();
	}
};
static_assert(alignof(UClimbingAnimMetaData) == 0x000008, "Wrong alignment on UClimbingAnimMetaData");
static_assert(sizeof(UClimbingAnimMetaData) == 0x000040, "Wrong size on UClimbingAnimMetaData");
static_assert(offsetof(UClimbingAnimMetaData, TargetOffsetFromEdge) == 0x000028, "Member 'UClimbingAnimMetaData::TargetOffsetFromEdge' has a wrong offset!");
static_assert(offsetof(UClimbingAnimMetaData, TransitionToCoreMinTime) == 0x00002C, "Member 'UClimbingAnimMetaData::TransitionToCoreMinTime' has a wrong offset!");
static_assert(offsetof(UClimbingAnimMetaData, TransitionToCoreTargetInAnimation) == 0x000030, "Member 'UClimbingAnimMetaData::TransitionToCoreTargetInAnimation' has a wrong offset!");
static_assert(offsetof(UClimbingAnimMetaData, MaxTresholdFromCore) == 0x000034, "Member 'UClimbingAnimMetaData::MaxTresholdFromCore' has a wrong offset!");
static_assert(offsetof(UClimbingAnimMetaData, ClimbingStableTime) == 0x000038, "Member 'UClimbingAnimMetaData::ClimbingStableTime' has a wrong offset!");
static_assert(offsetof(UClimbingAnimMetaData, EndTransitionTime) == 0x00003C, "Member 'UClimbingAnimMetaData::EndTransitionTime' has a wrong offset!");

// Class Flame.NotificationSystem
// 0x0028 (0x0050 - 0x0028)
class UNotificationSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNotificationBase*>              PendingNotifications;                              // 0x0040(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddNotification(class UNotificationBase* InNotification);
	void OnPreLoadMap(const class FString& InMapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationSystem">();
	}
	static class UNotificationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationSystem>();
	}
};
static_assert(alignof(UNotificationSystem) == 0x000008, "Wrong alignment on UNotificationSystem");
static_assert(sizeof(UNotificationSystem) == 0x000050, "Wrong size on UNotificationSystem");
static_assert(offsetof(UNotificationSystem, PendingNotifications) == 0x000040, "Member 'UNotificationSystem::PendingNotifications' has a wrong offset!");

// Class Flame.SavedMoveBoxComponent
// 0x0010 (0x0490 - 0x0480)
class USavedMoveBoxComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SavedMoveBoxComponent">();
	}
	static class USavedMoveBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USavedMoveBoxComponent>();
	}
};
static_assert(alignof(USavedMoveBoxComponent) == 0x000010, "Wrong alignment on USavedMoveBoxComponent");
static_assert(sizeof(USavedMoveBoxComponent) == 0x000490, "Wrong size on USavedMoveBoxComponent");

// Class Flame.LeaderboardSystemSettings
// 0x0030 (0x0068 - 0x0038)
class ULeaderboardSystemSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UDataTable>              UserStatsTranslationTable;                         // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              PlatformRequestTimeOut;                            // 0x0060(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardSystemSettings">();
	}
	static class ULeaderboardSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardSystemSettings>();
	}
};
static_assert(alignof(ULeaderboardSystemSettings) == 0x000008, "Wrong alignment on ULeaderboardSystemSettings");
static_assert(sizeof(ULeaderboardSystemSettings) == 0x000068, "Wrong size on ULeaderboardSystemSettings");
static_assert(offsetof(ULeaderboardSystemSettings, UserStatsTranslationTable) == 0x000038, "Member 'ULeaderboardSystemSettings::UserStatsTranslationTable' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystemSettings, PlatformRequestTimeOut) == 0x000060, "Member 'ULeaderboardSystemSettings::PlatformRequestTimeOut' has a wrong offset!");

// Class Flame.HumanMovementComponent
// 0x03A0 (0x0EA0 - 0x0B00)
class UHumanMovementComponent final : public UCharacterMovementComponent
{
public:
	class AHumanCharacter*                        HumanCharacter;                                    // 0x0B00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B08[0x8];                                      // 0x0B08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         SimCompressedFlags;                                // 0x0B10(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B11[0x67];                                     // 0x0B11(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCannotEnterProne;                                // 0x0B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         StanceChangeMargin;                                // 0x0B88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleStandHalfHeight;                            // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleCrouchHalfHeight;                           // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B94[0x1C];                                     // 0x0B94(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMovementConfig>            MovementConfig;                                    // 0x0BB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneSphereForwardDist;                            // 0x0BB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneSphereBackwardDist;                           // 0x0BBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC0[0x40];                                     // 0x0BC0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         SimProneYaw;                                       // 0x0C00(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C01[0x3];                                      // 0x0C01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneStandIgnorePushTime;                          // 0x0C04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x20];                                     // 0x0C08(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStanceChangeEffect>            StanceChangeEffects;                               // 0x0C28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C38[0x50];                                     // 0x0C38(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbAndVaultCooldownTime;                         // 0x0C88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClimbAndVaultMinVelocity;                          // 0x0C8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraManagerComponent*                CameraManager;                                     // 0x0C90(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          DisplacementAnimationSequence;                     // 0x0C98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAnimSequence*>                  DisplacementAnimationSequenceQueue;                // 0x0CA0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CB0[0x160];                                    // 0x0CB0(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          SimLadderMount_bExitMount;                         // 0x0E10(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E11[0x3];                                      // 0x0E11(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimLadderClimb                        SimLadderClimb;                                    // 0x0E14(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E20[0x8];                                      // 0x0E20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LadderClimbSpeed;                                  // 0x0E28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderClimbSprintSpeed;                            // 0x0E2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderClimbSlideSpeed;                             // 0x0E30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderAcceleration;                                // 0x0E34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderDecelerate;                                  // 0x0E38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LadderSlowdown;                                    // 0x0E3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWorldLadder*                           LastLadder;                                        // 0x0E40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                CurrentLadderAnim;                                 // 0x0E48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E50[0x50];                                     // 0x0E50(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheatResetProneSphere();
	void ClientSetIsStaggered(bool Staggered);
	void DoCurveDisplacement(const class UAnimSequence* Sequence, float WorldYaw);
	bool DoStagger(int32 StaggerSeverity, float WorldYaw);
	void LagSwitch_RevertToServerLocation(const struct FVector& ServerLocation, const struct FRotator& ServerRotation);
	void MulticastStartClimbOrVault(const struct FVector& PreppedLoc, const struct FVector& PreppedVel);
	void OnRep_SimLadderClimb();
	void OnRep_SimLadderMount_bExitMount();
	void RequestStanceChange(EStance NewStance);

	EStance GetStance() const;
	bool IsStaggered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanMovementComponent">();
	}
	static class UHumanMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanMovementComponent>();
	}
};
static_assert(alignof(UHumanMovementComponent) == 0x000010, "Wrong alignment on UHumanMovementComponent");
static_assert(sizeof(UHumanMovementComponent) == 0x000EA0, "Wrong size on UHumanMovementComponent");
static_assert(offsetof(UHumanMovementComponent, HumanCharacter) == 0x000B00, "Member 'UHumanMovementComponent::HumanCharacter' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, SimCompressedFlags) == 0x000B10, "Member 'UHumanMovementComponent::SimCompressedFlags' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, OnCannotEnterProne) == 0x000B78, "Member 'UHumanMovementComponent::OnCannotEnterProne' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, StanceChangeMargin) == 0x000B88, "Member 'UHumanMovementComponent::StanceChangeMargin' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, CapsuleStandHalfHeight) == 0x000B8C, "Member 'UHumanMovementComponent::CapsuleStandHalfHeight' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, CapsuleCrouchHalfHeight) == 0x000B90, "Member 'UHumanMovementComponent::CapsuleCrouchHalfHeight' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, MovementConfig) == 0x000BB0, "Member 'UHumanMovementComponent::MovementConfig' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, ProneSphereForwardDist) == 0x000BB8, "Member 'UHumanMovementComponent::ProneSphereForwardDist' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, ProneSphereBackwardDist) == 0x000BBC, "Member 'UHumanMovementComponent::ProneSphereBackwardDist' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, SimProneYaw) == 0x000C00, "Member 'UHumanMovementComponent::SimProneYaw' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, ProneStandIgnorePushTime) == 0x000C04, "Member 'UHumanMovementComponent::ProneStandIgnorePushTime' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, StanceChangeEffects) == 0x000C28, "Member 'UHumanMovementComponent::StanceChangeEffects' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, ClimbAndVaultCooldownTime) == 0x000C88, "Member 'UHumanMovementComponent::ClimbAndVaultCooldownTime' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, ClimbAndVaultMinVelocity) == 0x000C8C, "Member 'UHumanMovementComponent::ClimbAndVaultMinVelocity' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, CameraManager) == 0x000C90, "Member 'UHumanMovementComponent::CameraManager' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, DisplacementAnimationSequence) == 0x000C98, "Member 'UHumanMovementComponent::DisplacementAnimationSequence' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, DisplacementAnimationSequenceQueue) == 0x000CA0, "Member 'UHumanMovementComponent::DisplacementAnimationSequenceQueue' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, SimLadderMount_bExitMount) == 0x000E10, "Member 'UHumanMovementComponent::SimLadderMount_bExitMount' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, SimLadderClimb) == 0x000E14, "Member 'UHumanMovementComponent::SimLadderClimb' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderClimbSpeed) == 0x000E28, "Member 'UHumanMovementComponent::LadderClimbSpeed' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderClimbSprintSpeed) == 0x000E2C, "Member 'UHumanMovementComponent::LadderClimbSprintSpeed' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderClimbSlideSpeed) == 0x000E30, "Member 'UHumanMovementComponent::LadderClimbSlideSpeed' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderAcceleration) == 0x000E34, "Member 'UHumanMovementComponent::LadderAcceleration' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderDecelerate) == 0x000E38, "Member 'UHumanMovementComponent::LadderDecelerate' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LadderSlowdown) == 0x000E3C, "Member 'UHumanMovementComponent::LadderSlowdown' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, LastLadder) == 0x000E40, "Member 'UHumanMovementComponent::LastLadder' has a wrong offset!");
static_assert(offsetof(UHumanMovementComponent, CurrentLadderAnim) == 0x000E48, "Member 'UHumanMovementComponent::CurrentLadderAnim' has a wrong offset!");

// Class Flame.HumanPlayerController
// 0x0450 (0x09D0 - 0x0580)
class AHumanPlayerController : public APlayerController
{
public:
	struct FInputActionMapper                     InputActionMapper;                                 // 0x0580(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x88];                                     // 0x0590(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	ECloudInitMode                                CloudInitMode;                                     // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoadoutLoaded;                                  // 0x0619(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61A[0x6];                                      // 0x061A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadoutInfo                           LastKnownLoadout;                                  // 0x0620(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	bool                                          bIsClothesLoaded;                                  // 0x0648(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_649[0x57];                                     // 0x0649(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOwnedSkinsLoaded;                               // 0x06A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAssignedSkinsLoaded;                            // 0x06A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A2[0x6];                                      // 0x06A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnResponseFromCloud;                               // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnReceivedShelterCloudEvent;                       // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACraftingTimerManager>      CraftingTimerManagerClass;                         // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACraftingTimerManager*                  CraftingTimerManager;                              // 0x06D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AShelterTimerManager>       ShelterTimerManagerClass;                          // 0x06D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AShelterTimerManager*                   ShelterTimerManager;                               // 0x06E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StackedActionAfterLastOne;                         // 0x06E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEarlyClientTravel;                               // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsCollectingHeartBeatData;                         // 0x0708(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_709[0x7];                                      // 0x0709(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ReportPlayerReceived;                              // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_720[0x8];                                      // 0x0720(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCloudUserIdSet;                                  // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginPlayingState;                               // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEndPlayingState;                                 // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         HoldRecognitionTime;                               // 0x0758(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFlameSpectator*                        FlameSpectator;                                    // 0x0760(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerLobby*                           LobbyInUse;                                        // 0x0768(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_770[0x40];                                     // 0x0770(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AHumanPlayerCharacter*                  HumanCharacter;                                    // 0x07B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSpectating;                                     // 0x07B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AlreadyInteracted;                                 // 0x07B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7BA[0x6];                                      // 0x07BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UControllerInputAnalyzer*               ControllerInputAnalyzer;                           // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x140];                                    // 0x07C8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBuildingEnter;                                   // 0x0908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBuildingLeave;                                   // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBuildingTypeEntered;                             // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBuildingTypeLeave;                               // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0x28];                                     // 0x0948(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerStateFirstSync;                            // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          UseReloadSingleTap;                                // 0x0980(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseReloadDoubleTap;                                // 0x0981(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_982[0x2];                                      // 0x0982(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadTriggerTapTime;                              // 0x0984(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FClientHeartBeatInfo                   HearbeatInfo;                                      // 0x0988(0x0020)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A8[0xC];                                      // 0x09A8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkClockUpdateFrequency;                       // 0x09B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B8[0x18];                                     // 0x09B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ADS();
	void Chamber();
	void ChangeFireMode();
	void ChangeWeaponSkin(class AWeapon* TargetWeapon, TSubclassOf<class AItemSkin> NewSkin);
	void CheatAddConsumable(TSubclassOf<class AConsumableItem> ConsumableClass);
	void CheatAddWeapon(TSubclassOf<class AWeapon> OneWeaponClass);
	void CheatServer(const class FString& Command);
	void CheatServerRunCommand(const class FString& Command);
	void ClientCreateSessionForRandom(const class FString& GroupId);
	void ClientJoinSessionForRandom(const class FString& GroupSessionId);
	void ClientSetSpawnRotation(const struct FRotator& Rotation);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientSetUserIdToken(const class FString& IdToken);
	void ClientUpdateWorldTime(float ClientTimestamp, float ServerTimestamp);
	void CloudUserIdSetDelegate__DelegateSignature(const class FString& Userid);
	bool CollectCraftedItems(int32 QueueId);
	void ConsumableMenu();
	void CreateGlint(class USceneComponent* AttachComponent, float Size);
	void Crouch();
	void DebugTestShelterFunc(TSubclassOf<class AShelterSlot> Slot);
	void EquipLastConsumable();
	void EquipLastWeapon();
	void EquipMap();
	void Fire();
	void Gesture();
	void GestureMenu();
	bool GetAssignedSkinsFromCloud();
	bool GetCurrentLoadout(struct FLoadoutInfo* OutLoadout);
	bool GetLastLoadout(struct FLoadoutInfo* OutLoadout);
	class UPlayerGroupInfo* GetPlayerGroup();
	void HoldBreath();
	void Holster();
	void Interact();
	void InteractAction();
	void Jump();
	void Menu();
	void MenuAction();
	void MoveCharacterToCurrentPosition();
	void MoveCharacterToCurrentPositionAction();
	void OnEnterBuildingVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEnterBuildingVolumeByActor(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnGameStorePurchaseCompleted(EGameStorePurchaseType PurchaseType, const struct FUniqueNetIdRepl& Userid, const int32 PurchaseRequestId, const struct FGameStoreProductId& RequestedProductId, const struct FCloudRequestResult& Result, const struct FGameStorePurchaseResult& PurchaseResult, const bool PurchaseListRefreshed);
	void OnInputActionProcessed(const class FString& ActionName);
	void OnLeaveBuildingVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLeaveBuildingVolumeByActor(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOpenShelterUIAction();
	void OnPlayerMenuAction();
	void OnPlayerStateFirstSync__DelegateSignature(class AHumanPlayerController* HumanController, class AHumanPlayerState* HumanPlayerState);
	void OnRep_ClothesLoaded(bool OldValue);
	void OnRep_InventoryLoaded(bool OldValue);
	void OnSpawnBPActorFromConsole(const class FString& ObjectName, const class UClass* ObjectClass);
	void OnSpawnSMActorFromConsole(const class FString& ObjectName, const class UStaticMesh* StaticMeshObject);
	void OpenDevMenu();
	void OpenGameMenu();
	void OpenGameMenuAction();
	void OpenShelterUI();
	void OpenShelterUIAction();
	void PhysxShowCollisions(float Range);
	void Ping();
	void PlayerMenu();
	void PlayerMenuAction();
	void ProcessInputAction(const class FString& InputActionName, class AItem* Parameter);
	void Prone();
	void PushActionToStack(const class FString& ActionName);
	void QueryLoadoutAndClothes();
	void QueryStash();
	void QuickMelee();
	void ReceivedShelterCloudEvent__DelegateSignature(const struct FCloudShelterEventList& Events);
	void ReleaseFireTrigger();
	void Reload();
	class FString RemoveActionFromStack();
	bool ReportPlayer(const class FString& ReportedUserId, const class FString& Reason);
	void ReportPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	void ResetCamera();
	void ResetCloudState();
	void ResponseFromCloud__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	void ScripterSpecialHold();
	void ScripterSpecialPress();
	void ScripterSpecialRelease();
	void SelectConsumableClass(TSubclassOf<class AConsumableItem> StoredConsumable);
	void SelectValidWeapon(EWeaponSlotType Slot);
	void SelectWeapon(EWeaponSlotType Slot);
	void SendToServerCollectedHeartbeatData(const struct FClientHeartBeatInfo& Data);
	void ServerAskQueryLoadoutAndClothes();
	void ServerAskQueryStash();
	void ServerChangeWeaponSkin(class AWeapon* TargetWeapon, TSubclassOf<class AItemSkin> NewSkin);
	void ServerCheatAddConsumable(TSubclassOf<class AConsumableItem> ConsumableClass);
	void ServerCheatAddWeapon(TSubclassOf<class AWeapon> OneWeaponClass);
	void ServerClientIsReadyForGroupCheck();
	void ServerInteract();
	void ServerMoveCharacterToCurrentPosition(const struct FVector& Location);
	void ServerNetStatsRecording();
	void ServerRepossesPawn();
	void ServerRequestWorldTime(float ClientTimestamp);
	void ServerReturnSessionForRandom(const class FString& GroupSessionId);
	void ServerSetAimAssistSettings(const struct FAimAssistSettings& Settings);
	void ServerSetMachineMode(EMachineMode NewMode);
	void ServerSetMiscInputSettings(const struct FMiscInputSettings& Settings);
	void ServerSetTriggerDown(bool bValue);
	void ServerStopInteract();
	void ServerToggleSpectator();
	void SetAimingDebug(bool bEnable);
	void SetControlSettingsFromSaveGame(const class UOptionsSaveGame* OptionsSaveGame);
	void SetCurrentViewForControlRotation(bool CurrentViewForControlRotation);
	bool SetLoadoutPresetToCloud(const struct FLoadoutInfo& Loadout);
	void SetSkinsForSever(const struct FCloudUserWeaponSkinsInfo& Skins);
	void SetSpawnRotation(const struct FRotator& Rotation);
	void SetUSeSameCloudData(bool UseSame);
	void ShowGlint(class UGlintComponent* AttachComponent, uint8 Intensity);
	void SpawnBPActorFromConsole(const class FString& ObjectName);
	void SpawnSMActorFromConsole(const class FString& ObjectName);
	bool SpectateNextPlayerAction();
	void SpectatePreviousPlayer();
	void SpectatePreviousPlayerAction();
	bool SpectateStartMovingUpAction();
	bool SpectateStopMovingUpAction();
	bool SpectateToggleAfterBurnerAction();
	void SpectatorMoveUp(float Value);
	void Sprint();
	void Stand();
	void StopADS();
	void StopChamber();
	void StopFire();
	void StopGesture();
	void StopInteract();
	void StopInteractAction();
	void StopJump();
	void StopReload();
	void StopSprint();
	void StopThrowableAiming();
	void StopUse();
	void SwapPerspective();
	void SwapShoulder();
	void Switch(class AItem* StoredItem);
	void ThrowableAiming();
	void ToggleCrouch();
	void ToggleMachineMode();
	void ToggleNetStatsRecording();
	void ToggleProne();
	void ToggleSpectate();
	void ToggleSpectateAction();
	void ToggleSpectatorCollisions();
	void ToggleSpectatorCollisionsAction();
	void ToolMenu();
	void Use();
	void WeaponMenu();

	bool CanAcceptOperations() const;
	const bool CanBoostShelterImprovemement() const;
	TArray<class UFlameWidget*> GetAllOpenedWidgets(TSubclassOf<class UFlameWidget> InWidgetClass) const;
	class FString GetAnalyticsUserId() const;
	const struct FVector2D GetCachedAimInput() const;
	struct FVector2D GetCachedAimInputMultiplier() const;
	const struct FVector2D GetCachedMovementInput() const;
	class FString GetCloudUserId() const;
	class ACraftingTimerManager* GetCraftingTimerManager() const;
	float GetCurrentLookUpInputValue() const;
	float GetCurrentMoveForwardInputValue() const;
	float GetCurrentMoveRightInputValue() const;
	float GetCurrentTurnInputValue() const;
	EGameScenario GetGameScenario() const;
	bool GetHubGateState() const;
	class AHumanPlayerCharacter* GetHumanCharacter() const;
	const struct FMiscInputSettings GetMiscInputSettings() const;
	float GetNetworkLastReceive() const;
	float GetServerWorldTime() const;
	float GetServerWorldTimeDelta() const;
	class UShelterCraftingList* GetShelterBuilder() const;
	class AShelterTimerManager* GetShelterTimerManager() const;
	class AStash* GetStash() const;
	class FString GetTokenString() const;
	class UWidget* GetWidgetUnderMouse() const;
	bool IsAnyMenuOpen() const;
	bool IsCloudInventoryAndStuffInitialized() const;
	bool IsCloudUserIdSet() const;
	bool IsInsideBuilding() const;
	bool IsInteractInProgress() const;
	bool IsMenuInProgress() const;
	const bool IsUserCloudInfoUpToDate() const;
	void SetHubGateState(bool GateState) const;
	bool ShouldIgnoreInputAxis(class FName InAxisName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanPlayerController">();
	}
	static class AHumanPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanPlayerController>();
	}
};
static_assert(alignof(AHumanPlayerController) == 0x000008, "Wrong alignment on AHumanPlayerController");
static_assert(sizeof(AHumanPlayerController) == 0x0009D0, "Wrong size on AHumanPlayerController");
static_assert(offsetof(AHumanPlayerController, InputActionMapper) == 0x000580, "Member 'AHumanPlayerController::InputActionMapper' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, CloudInitMode) == 0x000618, "Member 'AHumanPlayerController::CloudInitMode' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, bIsLoadoutLoaded) == 0x000619, "Member 'AHumanPlayerController::bIsLoadoutLoaded' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, LastKnownLoadout) == 0x000620, "Member 'AHumanPlayerController::LastKnownLoadout' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, bIsClothesLoaded) == 0x000648, "Member 'AHumanPlayerController::bIsClothesLoaded' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, bIsOwnedSkinsLoaded) == 0x0006A0, "Member 'AHumanPlayerController::bIsOwnedSkinsLoaded' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, bIsAssignedSkinsLoaded) == 0x0006A1, "Member 'AHumanPlayerController::bIsAssignedSkinsLoaded' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnResponseFromCloud) == 0x0006A8, "Member 'AHumanPlayerController::OnResponseFromCloud' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnReceivedShelterCloudEvent) == 0x0006B8, "Member 'AHumanPlayerController::OnReceivedShelterCloudEvent' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, CraftingTimerManagerClass) == 0x0006C8, "Member 'AHumanPlayerController::CraftingTimerManagerClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, CraftingTimerManager) == 0x0006D0, "Member 'AHumanPlayerController::CraftingTimerManager' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, ShelterTimerManagerClass) == 0x0006D8, "Member 'AHumanPlayerController::ShelterTimerManagerClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, ShelterTimerManager) == 0x0006E0, "Member 'AHumanPlayerController::ShelterTimerManager' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, StackedActionAfterLastOne) == 0x0006E8, "Member 'AHumanPlayerController::StackedActionAfterLastOne' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnEarlyClientTravel) == 0x0006F8, "Member 'AHumanPlayerController::OnEarlyClientTravel' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, IsCollectingHeartBeatData) == 0x000708, "Member 'AHumanPlayerController::IsCollectingHeartBeatData' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, ReportPlayerReceived) == 0x000710, "Member 'AHumanPlayerController::ReportPlayerReceived' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnCloudUserIdSet) == 0x000728, "Member 'AHumanPlayerController::OnCloudUserIdSet' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnBeginPlayingState) == 0x000738, "Member 'AHumanPlayerController::OnBeginPlayingState' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnEndPlayingState) == 0x000748, "Member 'AHumanPlayerController::OnEndPlayingState' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, HoldRecognitionTime) == 0x000758, "Member 'AHumanPlayerController::HoldRecognitionTime' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, FlameSpectator) == 0x000760, "Member 'AHumanPlayerController::FlameSpectator' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, LobbyInUse) == 0x000768, "Member 'AHumanPlayerController::LobbyInUse' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, HumanCharacter) == 0x0007B0, "Member 'AHumanPlayerController::HumanCharacter' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, bIsSpectating) == 0x0007B8, "Member 'AHumanPlayerController::bIsSpectating' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, AlreadyInteracted) == 0x0007B9, "Member 'AHumanPlayerController::AlreadyInteracted' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, ControllerInputAnalyzer) == 0x0007C0, "Member 'AHumanPlayerController::ControllerInputAnalyzer' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnBuildingEnter) == 0x000908, "Member 'AHumanPlayerController::OnBuildingEnter' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnBuildingLeave) == 0x000918, "Member 'AHumanPlayerController::OnBuildingLeave' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnBuildingTypeEntered) == 0x000928, "Member 'AHumanPlayerController::OnBuildingTypeEntered' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnBuildingTypeLeave) == 0x000938, "Member 'AHumanPlayerController::OnBuildingTypeLeave' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, OnPlayerStateFirstSync) == 0x000970, "Member 'AHumanPlayerController::OnPlayerStateFirstSync' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, UseReloadSingleTap) == 0x000980, "Member 'AHumanPlayerController::UseReloadSingleTap' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, UseReloadDoubleTap) == 0x000981, "Member 'AHumanPlayerController::UseReloadDoubleTap' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, ReloadTriggerTapTime) == 0x000984, "Member 'AHumanPlayerController::ReloadTriggerTapTime' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, HearbeatInfo) == 0x000988, "Member 'AHumanPlayerController::HearbeatInfo' has a wrong offset!");
static_assert(offsetof(AHumanPlayerController, NetworkClockUpdateFrequency) == 0x0009B4, "Member 'AHumanPlayerController::NetworkClockUpdateFrequency' has a wrong offset!");

// Class Flame.HumanPlayerControllerFunctionsFunctions
// 0x0000 (0x0028 - 0x0028)
class UHumanPlayerControllerFunctionsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool CanProcessInputAction(const class AHumanPlayerController* OneController, class FName ActionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanPlayerControllerFunctionsFunctions">();
	}
	static class UHumanPlayerControllerFunctionsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanPlayerControllerFunctionsFunctions>();
	}
};
static_assert(alignof(UHumanPlayerControllerFunctionsFunctions) == 0x000008, "Wrong alignment on UHumanPlayerControllerFunctionsFunctions");
static_assert(sizeof(UHumanPlayerControllerFunctionsFunctions) == 0x000028, "Wrong size on UHumanPlayerControllerFunctionsFunctions");

// Class Flame.LeaderboardReadBoardBasePlatform
// 0x0058 (0x00F8 - 0x00A0)
class ULeaderboardReadBoardBasePlatform : public ULeaderboardReadBoardBase
{
public:
	uint8                                         Pad_A0[0x58];                                      // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardBasePlatform">();
	}
	static class ULeaderboardReadBoardBasePlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardBasePlatform>();
	}
};
static_assert(alignof(ULeaderboardReadBoardBasePlatform) == 0x000008, "Wrong alignment on ULeaderboardReadBoardBasePlatform");
static_assert(sizeof(ULeaderboardReadBoardBasePlatform) == 0x0000F8, "Wrong size on ULeaderboardReadBoardBasePlatform");

// Class Flame.HumanPlayerCharacter
// 0x01A0 (0x0DA0 - 0x0C00)
class AHumanPlayerCharacter : public AHumanCharacter
{
public:
	uint8                                         Pad_C00[0x34];                                     // 0x0C00(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputDelay;                                        // 0x0C34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C38[0x9];                                      // 0x0C38(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsFireAfterCurrentState;                       // 0x0C41(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWantsFireAfterClimbOrVault;                       // 0x0C42(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C43[0x1D];                                     // 0x0C43(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x0C60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMotionAimComponent*                    MotionAimComponent;                                // 0x0C68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USelectionWheelComponent>   SelectionWheelClass;                               // 0x0C70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USelectionWheelComponent*               SelectionWheel;                                    // 0x0C78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMapTool>                   MapToolClass;                                      // 0x0C80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMapTool*                               MapTool;                                           // 0x0C88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterWeaponSway                   CharacterWeaponSway;                               // 0x0C90(0x00A0)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FlashbangEffectStrength;                           // 0x0D30(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashbangEffectTime;                               // 0x0D34(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConcussionEffectStrength;                          // 0x0D38(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConcussionEffectTime;                              // 0x0D3C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D40[0x8];                                      // 0x0D40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCheckFiringPipeline;                              // 0x0D48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D49[0x3];                                      // 0x0D49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionalAirControl;                             // 0x0D4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimAssistComponent*                    AimAssistComponent;                                // 0x0D50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CameraAttachmentPoint;                             // 0x0D58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlameSpringArmComponent*               TwoArmCameraSetupRight;                            // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlameSpringArmComponent*               TwoArmCameraSetupBack;                             // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraPositionOffsetRightShoulder;                 // 0x0D70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraPositionOffsetLeftShoulder;                  // 0x0D7C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlashbangDotMultiplier;                            // 0x0D88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashbangDecayRate;                                // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcussionDecayRate;                               // 0x0D94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D98[0x8];                                      // 0x0D98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPostProcessingEffect(class UMaterialInterface* PostProcessMaterial);
	void ConsumableMenuAction();
	class UMaterialInstanceDynamic* CreateOrGetPostProcessingEffect(class UMaterialInterface* PostProcessMaterial);
	void EquipLastConsumableAction();
	void EquipMapAction();
	void GestureAction();
	void GestureMenuAction();
	void HoldBreathAction();
	void InitiateTinnitusEffect(float EffectStrength);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void OnPingPressed();
	void OpenDevMenuAction();
	void OpenSelectionWheel(const ESelectionWheelType& WheelType);
	void PingAction();
	void ResetCameraAction();
	void SelectLastWheelItem(const ESelectionWheelType& WheelType);
	void ShowGrenadeIndicator(class AGrenade* Grenade);
	void SwapPerspectiveAction();
	void SwapShoulderAction();
	void TickConcussionEffect();
	void TickFlashbangEffect();
	void UpdateConcussionEffect(float Strength, float Time);
	void UpdateFlashbangEffect(float Strength, float Time);
	void WeaponMenuAction();

	float GetLookUpValue() const;
	class AMapTool* GetMapTool() const;
	TSubclassOf<class AMapTool> GetMapToolClass() const;
	float GetMoveForwardValue() const;
	float GetMoveRightValue() const;
	class USelectionWheelComponent* GetSelectionWheelComponent() const;
	float GetTurnValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanPlayerCharacter">();
	}
	static class AHumanPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanPlayerCharacter>();
	}
};
static_assert(alignof(AHumanPlayerCharacter) == 0x000010, "Wrong alignment on AHumanPlayerCharacter");
static_assert(sizeof(AHumanPlayerCharacter) == 0x000DA0, "Wrong size on AHumanPlayerCharacter");
static_assert(offsetof(AHumanPlayerCharacter, InputDelay) == 0x000C34, "Member 'AHumanPlayerCharacter::InputDelay' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, bWantsFireAfterCurrentState) == 0x000C41, "Member 'AHumanPlayerCharacter::bWantsFireAfterCurrentState' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, bWantsFireAfterClimbOrVault) == 0x000C42, "Member 'AHumanPlayerCharacter::bWantsFireAfterClimbOrVault' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, Camera) == 0x000C60, "Member 'AHumanPlayerCharacter::Camera' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, MotionAimComponent) == 0x000C68, "Member 'AHumanPlayerCharacter::MotionAimComponent' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, SelectionWheelClass) == 0x000C70, "Member 'AHumanPlayerCharacter::SelectionWheelClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, SelectionWheel) == 0x000C78, "Member 'AHumanPlayerCharacter::SelectionWheel' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, MapToolClass) == 0x000C80, "Member 'AHumanPlayerCharacter::MapToolClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, MapTool) == 0x000C88, "Member 'AHumanPlayerCharacter::MapTool' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, CharacterWeaponSway) == 0x000C90, "Member 'AHumanPlayerCharacter::CharacterWeaponSway' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, FlashbangEffectStrength) == 0x000D30, "Member 'AHumanPlayerCharacter::FlashbangEffectStrength' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, FlashbangEffectTime) == 0x000D34, "Member 'AHumanPlayerCharacter::FlashbangEffectTime' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, ConcussionEffectStrength) == 0x000D38, "Member 'AHumanPlayerCharacter::ConcussionEffectStrength' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, ConcussionEffectTime) == 0x000D3C, "Member 'AHumanPlayerCharacter::ConcussionEffectTime' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, bCheckFiringPipeline) == 0x000D48, "Member 'AHumanPlayerCharacter::bCheckFiringPipeline' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, DirectionalAirControl) == 0x000D4C, "Member 'AHumanPlayerCharacter::DirectionalAirControl' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, AimAssistComponent) == 0x000D50, "Member 'AHumanPlayerCharacter::AimAssistComponent' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, CameraAttachmentPoint) == 0x000D58, "Member 'AHumanPlayerCharacter::CameraAttachmentPoint' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, TwoArmCameraSetupRight) == 0x000D60, "Member 'AHumanPlayerCharacter::TwoArmCameraSetupRight' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, TwoArmCameraSetupBack) == 0x000D68, "Member 'AHumanPlayerCharacter::TwoArmCameraSetupBack' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, CameraPositionOffsetRightShoulder) == 0x000D70, "Member 'AHumanPlayerCharacter::CameraPositionOffsetRightShoulder' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, CameraPositionOffsetLeftShoulder) == 0x000D7C, "Member 'AHumanPlayerCharacter::CameraPositionOffsetLeftShoulder' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, FlashbangDotMultiplier) == 0x000D88, "Member 'AHumanPlayerCharacter::FlashbangDotMultiplier' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, FlashbangDecayRate) == 0x000D90, "Member 'AHumanPlayerCharacter::FlashbangDecayRate' has a wrong offset!");
static_assert(offsetof(AHumanPlayerCharacter, ConcussionDecayRate) == 0x000D94, "Member 'AHumanPlayerCharacter::ConcussionDecayRate' has a wrong offset!");

// Class Flame.HumanPlayerState
// 0x0220 (0x0540 - 0x0320)
class AHumanPlayerState : public APlayerState
{
public:
	FMulticastInlineDelegateProperty_             LobbyLoadedClient;                                 // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FInputActionMachine                    InputActionMachine;                                // 0x0330(0x0178)(NativeAccessSpecifierPrivate)
	EFlamePlatform                                PlayerPlatform;                                    // 0x04A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsReadyInLobby;                                    // 0x04A9(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTutorialDone;                                     // 0x04AA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AB[0x1];                                      // 0x04AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WinStreak;                                         // 0x04AC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerGroupId;                                     // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerInLobby                         LobbyLoadout;                                      // 0x04D0(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLobbyStateChanged;                               // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	TSubclassOf<class AShelterSlot>               CraftingTableSlotClass;                            // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AStash>                     StashClass;                                        // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AStash*                                 Stash;                                             // 0x0518(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShelterCustomizationComponent*         Customizations;                                    // 0x0520(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UShelterCustomizationComponent> CustomizationClass;                                // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABulletDecalManager>        BulletDecalManagerClass;                           // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABulletDecalManager*                    BulletDecalManager;                                // 0x0538(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MulticastReceivedActionsOnClients(const struct FInputActionMachineState& Desc);
	void OnRep_IsReadyInLobby();
	void OnRep_PlayerPlatform();
	void OnRep_PostChangeLobbyLoadout();
	void OnRep_PostChangeStash(class AStash* OldStash);
	void ServerProcessAction(const struct FInputActionMachineState& Desc);

	EFlamePlatform GetPlayerPlatform() const;
	struct FUniqueNetIdRepl GetPlayerUniqueId() const;
	class AStash* GetStash() const;
	class UShelterCustomizationComponent* GetWardrobe() const;
	bool HasBoosterCrate() const;
	bool HasBoosterInsurance() const;
	bool HasBoosterLoot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanPlayerState">();
	}
	static class AHumanPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanPlayerState>();
	}
};
static_assert(alignof(AHumanPlayerState) == 0x000008, "Wrong alignment on AHumanPlayerState");
static_assert(sizeof(AHumanPlayerState) == 0x000540, "Wrong size on AHumanPlayerState");
static_assert(offsetof(AHumanPlayerState, LobbyLoadedClient) == 0x000320, "Member 'AHumanPlayerState::LobbyLoadedClient' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, InputActionMachine) == 0x000330, "Member 'AHumanPlayerState::InputActionMachine' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, PlayerPlatform) == 0x0004A8, "Member 'AHumanPlayerState::PlayerPlatform' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, IsReadyInLobby) == 0x0004A9, "Member 'AHumanPlayerState::IsReadyInLobby' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, bTutorialDone) == 0x0004AA, "Member 'AHumanPlayerState::bTutorialDone' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, WinStreak) == 0x0004AC, "Member 'AHumanPlayerState::WinStreak' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, PlayerGroupId) == 0x0004C0, "Member 'AHumanPlayerState::PlayerGroupId' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, LobbyLoadout) == 0x0004D0, "Member 'AHumanPlayerState::LobbyLoadout' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, OnLobbyStateChanged) == 0x0004F8, "Member 'AHumanPlayerState::OnLobbyStateChanged' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, CraftingTableSlotClass) == 0x000508, "Member 'AHumanPlayerState::CraftingTableSlotClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, StashClass) == 0x000510, "Member 'AHumanPlayerState::StashClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, Stash) == 0x000518, "Member 'AHumanPlayerState::Stash' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, Customizations) == 0x000520, "Member 'AHumanPlayerState::Customizations' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, CustomizationClass) == 0x000528, "Member 'AHumanPlayerState::CustomizationClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, BulletDecalManagerClass) == 0x000530, "Member 'AHumanPlayerState::BulletDecalManagerClass' has a wrong offset!");
static_assert(offsetof(AHumanPlayerState, BulletDecalManager) == 0x000538, "Member 'AHumanPlayerState::BulletDecalManager' has a wrong offset!");

// Class Flame.ChallengeCondition
// 0x0000 (0x0220 - 0x0220)
class AChallengeCondition : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeCondition">();
	}
	static class AChallengeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallengeCondition>();
	}
};
static_assert(alignof(AChallengeCondition) == 0x000008, "Wrong alignment on AChallengeCondition");
static_assert(sizeof(AChallengeCondition) == 0x000220, "Wrong size on AChallengeCondition");

// Class Flame.MaterialListActor
// 0x0000 (0x0220 - 0x0220)
class AMaterialListActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialListActor">();
	}
	static class AMaterialListActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaterialListActor>();
	}
};
static_assert(alignof(AMaterialListActor) == 0x000008, "Wrong alignment on AMaterialListActor");
static_assert(sizeof(AMaterialListActor) == 0x000220, "Wrong size on AMaterialListActor");

// Class Flame.StaminaComponent
// 0x0128 (0x01D8 - 0x00B0)
class UStaminaComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x14];                                      // 0x00B0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaMultiplier;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdrenalineStaminaMultiplier;                       // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FStaminaUsageData> ItemStaminaConsumptionMap;                         // 0x00D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsUnderQuarterStamina;                            // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CountOfBearTrapsDamagedBy;                         // 0x0121(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PermanentDamageToMaxStamina;                       // 0x0124(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DelegateOnDepleteStamina;                          // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x4];                                      // 0x0140(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stamina;                                           // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintingThreshold;                                // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdrenalineBreakpointThreshold;                     // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintingRestartTime;                              // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldBreathThreshold;                               // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldBreathRestartTime;                             // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepletionSprinting;                                // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepletionRunning;                                  // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepletionWalking;                                  // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepletionStanding;                                 // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepletionHoldingBreath;                            // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FStaminaEffect>                 StaminaEffects;                                    // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveStamina*                          WeightCurve;                                       // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveStamina*                          AdrenalineWeightCurve;                             // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveStaminaMultiplier*                StaminaMultiplierCurve;                            // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AHumanCharacter*                        HumanCharacter;                                    // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHumanMovementComponent*                MovementComp;                                      // 0x01C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldBreathOverrideThreshold;                       // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldBreathOverrideDuration;                        // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HoldBreathOverrideLevel;                           // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddConsumptionForCurrentItem(EConsumptionSource Source, float Consumption);
	void AddPermanentDamageToStamina(float PercentageOfMaxStaminaToRemove);
	bool AddToConsumptionSources(const class FString& Item, EConsumptionSource Source, float Consumption);
	bool AdrenalineBoostActive();
	bool AdrenalineDeprivationActive();
	void ClearStaminaConsumptionMap();
	void ClientAddStaminaEffect(int32 Idx);
	void ClientRemoveStaminaEffectsOfIndex(int32 Idx);
	void ClientResetComponent();
	void ConsumePercentageOfStamina(float Percentage, EConsumptionSource Source);
	void ConsumeStamina(float Amount, EConsumptionSource Source);
	bool GetConsumptionByItemAndSource(const class FString& Item, EConsumptionSource Source, float* OutConsumption);
	void OnDamageByBearTrap(float PercentageOfMaxStaminaToRemove);
	void OnDeath();
	void OnDepleteStamina();
	void OnEffectRemoved(class FName EffectName);
	void OnStaminaStartedRegenerating();
	bool PlayStaminaEffect(class FName Name_0);
	void RemoveAllEfectsOfName(class FName Name_0);
	void ResetComponent();
	void SetCheatInfiniteSprint(bool bInfinite);
	void StartHoldBreath();
	void StopHoldBreath();
	void StopHoldBreathForced(float Duration);

	bool CanStartHoldBreath() const;
	bool CanStartSprinting() const;
	float GetMaximumStaminaValue() const;
	float GetSprintingThreshold() const;
	float GetStaminaValue() const;
	bool IsExhausted() const;
	bool IsHoldBreathOverriden(int32* OutBreathLevel) const;
	bool IsHoldingBreath() const;
	bool IsStaminaEffectPlaying(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaminaComponent">();
	}
	static class UStaminaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaminaComponent>();
	}
};
static_assert(alignof(UStaminaComponent) == 0x000008, "Wrong alignment on UStaminaComponent");
static_assert(sizeof(UStaminaComponent) == 0x0001D8, "Wrong size on UStaminaComponent");
static_assert(offsetof(UStaminaComponent, StaminaMultiplier) == 0x0000C4, "Member 'UStaminaComponent::StaminaMultiplier' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, AdrenalineStaminaMultiplier) == 0x0000C8, "Member 'UStaminaComponent::AdrenalineStaminaMultiplier' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, ItemStaminaConsumptionMap) == 0x0000D0, "Member 'UStaminaComponent::ItemStaminaConsumptionMap' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, bIsUnderQuarterStamina) == 0x000120, "Member 'UStaminaComponent::bIsUnderQuarterStamina' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, CountOfBearTrapsDamagedBy) == 0x000121, "Member 'UStaminaComponent::CountOfBearTrapsDamagedBy' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, PermanentDamageToMaxStamina) == 0x000124, "Member 'UStaminaComponent::PermanentDamageToMaxStamina' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DelegateOnDepleteStamina) == 0x000130, "Member 'UStaminaComponent::DelegateOnDepleteStamina' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, Stamina) == 0x000144, "Member 'UStaminaComponent::Stamina' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, SprintingThreshold) == 0x000148, "Member 'UStaminaComponent::SprintingThreshold' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, AdrenalineBreakpointThreshold) == 0x00014C, "Member 'UStaminaComponent::AdrenalineBreakpointThreshold' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, SprintingRestartTime) == 0x000150, "Member 'UStaminaComponent::SprintingRestartTime' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HoldBreathThreshold) == 0x000154, "Member 'UStaminaComponent::HoldBreathThreshold' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HoldBreathRestartTime) == 0x000158, "Member 'UStaminaComponent::HoldBreathRestartTime' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DepletionSprinting) == 0x00015C, "Member 'UStaminaComponent::DepletionSprinting' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DepletionRunning) == 0x000160, "Member 'UStaminaComponent::DepletionRunning' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DepletionWalking) == 0x000164, "Member 'UStaminaComponent::DepletionWalking' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DepletionStanding) == 0x000168, "Member 'UStaminaComponent::DepletionStanding' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, DepletionHoldingBreath) == 0x00016C, "Member 'UStaminaComponent::DepletionHoldingBreath' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, StaminaEffects) == 0x000170, "Member 'UStaminaComponent::StaminaEffects' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, WeightCurve) == 0x000190, "Member 'UStaminaComponent::WeightCurve' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, AdrenalineWeightCurve) == 0x000198, "Member 'UStaminaComponent::AdrenalineWeightCurve' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, StaminaMultiplierCurve) == 0x0001A0, "Member 'UStaminaComponent::StaminaMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HumanCharacter) == 0x0001B8, "Member 'UStaminaComponent::HumanCharacter' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, MovementComp) == 0x0001C0, "Member 'UStaminaComponent::MovementComp' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HoldBreathOverrideThreshold) == 0x0001C8, "Member 'UStaminaComponent::HoldBreathOverrideThreshold' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HoldBreathOverrideDuration) == 0x0001CC, "Member 'UStaminaComponent::HoldBreathOverrideDuration' has a wrong offset!");
static_assert(offsetof(UStaminaComponent, HoldBreathOverrideLevel) == 0x0001D0, "Member 'UStaminaComponent::HoldBreathOverrideLevel' has a wrong offset!");

// Class Flame.StaminaBreathingComponent
// 0x0030 (0x0208 - 0x01D8)
class UStaminaBreathingComponent : public UStaminaComponent
{
public:
	TWeakObjectPtr<class AHumanCharacter>         CharacterOwner;                                    // 0x01D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         BreathAudioComponent;                              // 0x01E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x20];                                     // 0x01E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoCoughBreath(float CoughingTime);
	void OnBreathCallback();
	void OnBreatheCough(const struct FBreathProperties& BreathProperties);
	void OnBreatheIn(const struct FBreathProperties& BreathProperties);
	void OnBreatheOut(const struct FBreathProperties& BreathProperties);
	void OnHoldBreathEnd(const struct FBreathProperties& BreathProperties, bool bForced);
	void OnHoldBreathStart(const struct FBreathProperties& BreathProperties);
	void PlayBreathSound(class USoundBase* Sound);
	void StartBreath();
	void StopBreath();

	struct FBreathProperties GetBreathProperties(float DeltaTime, EBreathType NewBreathType, EBreathType PreviousBreathType, const struct FBreathProperties& PreviousBreathProperties) const;
	float GetBreathSoundVolume(EBreathType BreathType, const struct FBreathProperties& BreathProperties, bool Is1PersonView) const;
	EBreathType GetBreathType(EBreathType PreviousBreathType, const struct FBreathProperties& PreviousBreathProperties) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaminaBreathingComponent">();
	}
	static class UStaminaBreathingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaminaBreathingComponent>();
	}
};
static_assert(alignof(UStaminaBreathingComponent) == 0x000008, "Wrong alignment on UStaminaBreathingComponent");
static_assert(sizeof(UStaminaBreathingComponent) == 0x000208, "Wrong size on UStaminaBreathingComponent");
static_assert(offsetof(UStaminaBreathingComponent, CharacterOwner) == 0x0001D8, "Member 'UStaminaBreathingComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UStaminaBreathingComponent, BreathAudioComponent) == 0x0001E0, "Member 'UStaminaBreathingComponent::BreathAudioComponent' has a wrong offset!");

// Class Flame.ChallengeManager
// 0x0020 (0x0240 - 0x0220)
class AChallengeManager : public AInfo
{
public:
	TSubclassOf<class AChallengeSlot>             ChallengeSlotClass;                                // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AChallengeSlot*>                 ChallengeSlots;                                    // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeManager">();
	}
	static class AChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallengeManager>();
	}
};
static_assert(alignof(AChallengeManager) == 0x000008, "Wrong alignment on AChallengeManager");
static_assert(sizeof(AChallengeManager) == 0x000240, "Wrong size on AChallengeManager");
static_assert(offsetof(AChallengeManager, ChallengeSlotClass) == 0x000220, "Member 'AChallengeManager::ChallengeSlotClass' has a wrong offset!");
static_assert(offsetof(AChallengeManager, ChallengeSlots) == 0x000228, "Member 'AChallengeManager::ChallengeSlots' has a wrong offset!");

// Class Flame.ChallengePrerequisite
// 0x0000 (0x0220 - 0x0220)
class AChallengePrerequisite final : public AInfo
{
public:
	bool IsPrerequisiteMet(TSubclassOf<class AItem> ItemType, int32 Number, EItemCategory ItemCategory, class FName ChallengeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengePrerequisite">();
	}
	static class AChallengePrerequisite* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallengePrerequisite>();
	}
};
static_assert(alignof(AChallengePrerequisite) == 0x000008, "Wrong alignment on AChallengePrerequisite");
static_assert(sizeof(AChallengePrerequisite) == 0x000220, "Wrong size on AChallengePrerequisite");

// Class Flame.ChallengeSlot
// 0x0000 (0x0220 - 0x0220)
class AChallengeSlot : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeSlot">();
	}
	static class AChallengeSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallengeSlot>();
	}
};
static_assert(alignof(AChallengeSlot) == 0x000008, "Wrong alignment on AChallengeSlot");
static_assert(sizeof(AChallengeSlot) == 0x000220, "Wrong size on AChallengeSlot");

// Class Flame.CharacterHitZoneComponent
// 0x0020 (0x00D0 - 0x00B0)
class UCharacterHitZoneComponent final : public UActorComponent
{
public:
	TArray<class FName>                           HitZoneComponents;                                 // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ECharacterHitZone>                     HitZones;                                          // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddHitZoneComponent(ECharacterHitZone Zone, class FName BoneName);

	ECharacterHitZone GetComponentZone(class FName BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHitZoneComponent">();
	}
	static class UCharacterHitZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHitZoneComponent>();
	}
};
static_assert(alignof(UCharacterHitZoneComponent) == 0x000008, "Wrong alignment on UCharacterHitZoneComponent");
static_assert(sizeof(UCharacterHitZoneComponent) == 0x0000D0, "Wrong size on UCharacterHitZoneComponent");
static_assert(offsetof(UCharacterHitZoneComponent, HitZoneComponents) == 0x0000B0, "Member 'UCharacterHitZoneComponent::HitZoneComponents' has a wrong offset!");
static_assert(offsetof(UCharacterHitZoneComponent, HitZones) == 0x0000C0, "Member 'UCharacterHitZoneComponent::HitZones' has a wrong offset!");

// Class Flame.LeaderboardWriteBoardPlatform
// 0x0038 (0x00C0 - 0x0088)
class ULeaderboardWriteBoardPlatform : public ULeaderboardWriteBoardBase
{
public:
	uint8                                         Pad_88[0x38];                                      // 0x0088(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardPlatform">();
	}
	static class ULeaderboardWriteBoardPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardPlatform>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardPlatform) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardPlatform");
static_assert(sizeof(ULeaderboardWriteBoardPlatform) == 0x0000C0, "Wrong size on ULeaderboardWriteBoardPlatform");

// Class Flame.DummyPoint
// 0x0000 (0x0480 - 0x0480)
class UDummyPoint final : public UBillboardComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DummyPoint">();
	}
	static class UDummyPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDummyPoint>();
	}
};
static_assert(alignof(UDummyPoint) == 0x000010, "Wrong alignment on UDummyPoint");
static_assert(sizeof(UDummyPoint) == 0x000480, "Wrong size on UDummyPoint");

// Class Flame.CharacterOutline
// 0x0048 (0x0268 - 0x0220)
class ACharacterOutline : public AActor
{
public:
	class UCapsuleComponent*                      StandCaps;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CrouchCaps;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      ProneCaps;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            NormalCamera;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            UnarmedCamera;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            NormalCameraCrouch;                                // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            UnarmedCameraCrouch;                               // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            NormalCameraProne;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDummyPoint*                            UnarmedCameraProne;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOutline">();
	}
	static class ACharacterOutline* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterOutline>();
	}
};
static_assert(alignof(ACharacterOutline) == 0x000008, "Wrong alignment on ACharacterOutline");
static_assert(sizeof(ACharacterOutline) == 0x000268, "Wrong size on ACharacterOutline");
static_assert(offsetof(ACharacterOutline, StandCaps) == 0x000220, "Member 'ACharacterOutline::StandCaps' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, CrouchCaps) == 0x000228, "Member 'ACharacterOutline::CrouchCaps' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, ProneCaps) == 0x000230, "Member 'ACharacterOutline::ProneCaps' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, NormalCamera) == 0x000238, "Member 'ACharacterOutline::NormalCamera' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, UnarmedCamera) == 0x000240, "Member 'ACharacterOutline::UnarmedCamera' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, NormalCameraCrouch) == 0x000248, "Member 'ACharacterOutline::NormalCameraCrouch' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, UnarmedCameraCrouch) == 0x000250, "Member 'ACharacterOutline::UnarmedCameraCrouch' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, NormalCameraProne) == 0x000258, "Member 'ACharacterOutline::NormalCameraProne' has a wrong offset!");
static_assert(offsetof(ACharacterOutline, UnarmedCameraProne) == 0x000260, "Member 'ACharacterOutline::UnarmedCameraProne' has a wrong offset!");

// Class Flame.CharacterSubActorVisibilityComponent
// 0x0010 (0x00C0 - 0x00B0)
class UCharacterSubActorVisibilityComponent final : public UActorComponent
{
public:
	TArray<class UPrimitiveComponent*>            PrimitiveComponents;                               // 0x00B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSubActorVisibilityComponent">();
	}
	static class UCharacterSubActorVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSubActorVisibilityComponent>();
	}
};
static_assert(alignof(UCharacterSubActorVisibilityComponent) == 0x000008, "Wrong alignment on UCharacterSubActorVisibilityComponent");
static_assert(sizeof(UCharacterSubActorVisibilityComponent) == 0x0000C0, "Wrong size on UCharacterSubActorVisibilityComponent");
static_assert(offsetof(UCharacterSubActorVisibilityComponent, PrimitiveComponents) == 0x0000B0, "Member 'UCharacterSubActorVisibilityComponent::PrimitiveComponents' has a wrong offset!");

// Class Flame.MovementConfig
// 0x0168 (0x0190 - 0x0028)
class UMovementConfig : public UObject
{
public:
	bool                                          bIsNewAnimSystem;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWalkSpeed;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdrenalineSpeedModifier;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmedSpeedModifier;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickInputToRun;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StaggerSlowdownCurve;                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneDepthThreshold;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchDepthThreshold;                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintDepthThreshold;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDepthThreshold;                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDepthExponent;                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDepthIgnore;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathDepthThreshold;                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterMinSpeedModifier;                             // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BackpackWeightCurve;                               // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AdrenalineBackpackWeightCurve;                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveSlopeSpeed*                       CurveSlopeSpeed;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ForcedPhysicsAsset;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeed_AI;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSMovementSpeed_AI;                               // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EMovementSpeedType, float>               StandMovementSpeeds;                               // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EMovementSpeedType, float>               CrouchMovementSpeeds;                              // 0x00E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EMovementSpeedType, float>               ProneMovementSpeeds;                               // 0x0130(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAccelerationDef                       DefaultAcceleration;                               // 0x0180(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementConfig">();
	}
	static class UMovementConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementConfig>();
	}
};
static_assert(alignof(UMovementConfig) == 0x000008, "Wrong alignment on UMovementConfig");
static_assert(sizeof(UMovementConfig) == 0x000190, "Wrong size on UMovementConfig");
static_assert(offsetof(UMovementConfig, bIsNewAnimSystem) == 0x000028, "Member 'UMovementConfig::bIsNewAnimSystem' has a wrong offset!");
static_assert(offsetof(UMovementConfig, MaxWalkSpeed) == 0x00002C, "Member 'UMovementConfig::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMovementConfig, AdrenalineSpeedModifier) == 0x000030, "Member 'UMovementConfig::AdrenalineSpeedModifier' has a wrong offset!");
static_assert(offsetof(UMovementConfig, ArmedSpeedModifier) == 0x000034, "Member 'UMovementConfig::ArmedSpeedModifier' has a wrong offset!");
static_assert(offsetof(UMovementConfig, StickInputToRun) == 0x000038, "Member 'UMovementConfig::StickInputToRun' has a wrong offset!");
static_assert(offsetof(UMovementConfig, StaggerSlowdownCurve) == 0x000040, "Member 'UMovementConfig::StaggerSlowdownCurve' has a wrong offset!");
static_assert(offsetof(UMovementConfig, ProneDepthThreshold) == 0x000048, "Member 'UMovementConfig::ProneDepthThreshold' has a wrong offset!");
static_assert(offsetof(UMovementConfig, CrouchDepthThreshold) == 0x00004C, "Member 'UMovementConfig::CrouchDepthThreshold' has a wrong offset!");
static_assert(offsetof(UMovementConfig, SprintDepthThreshold) == 0x000050, "Member 'UMovementConfig::SprintDepthThreshold' has a wrong offset!");
static_assert(offsetof(UMovementConfig, MovementDepthThreshold) == 0x000054, "Member 'UMovementConfig::MovementDepthThreshold' has a wrong offset!");
static_assert(offsetof(UMovementConfig, MovementDepthExponent) == 0x000058, "Member 'UMovementConfig::MovementDepthExponent' has a wrong offset!");
static_assert(offsetof(UMovementConfig, MovementDepthIgnore) == 0x00005C, "Member 'UMovementConfig::MovementDepthIgnore' has a wrong offset!");
static_assert(offsetof(UMovementConfig, DeathDepthThreshold) == 0x000060, "Member 'UMovementConfig::DeathDepthThreshold' has a wrong offset!");
static_assert(offsetof(UMovementConfig, WaterMinSpeedModifier) == 0x000064, "Member 'UMovementConfig::WaterMinSpeedModifier' has a wrong offset!");
static_assert(offsetof(UMovementConfig, BackpackWeightCurve) == 0x000068, "Member 'UMovementConfig::BackpackWeightCurve' has a wrong offset!");
static_assert(offsetof(UMovementConfig, AdrenalineBackpackWeightCurve) == 0x000070, "Member 'UMovementConfig::AdrenalineBackpackWeightCurve' has a wrong offset!");
static_assert(offsetof(UMovementConfig, CurveSlopeSpeed) == 0x000078, "Member 'UMovementConfig::CurveSlopeSpeed' has a wrong offset!");
static_assert(offsetof(UMovementConfig, ForcedPhysicsAsset) == 0x000080, "Member 'UMovementConfig::ForcedPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UMovementConfig, MaxWalkSpeed_AI) == 0x000088, "Member 'UMovementConfig::MaxWalkSpeed_AI' has a wrong offset!");
static_assert(offsetof(UMovementConfig, ADSMovementSpeed_AI) == 0x00008C, "Member 'UMovementConfig::ADSMovementSpeed_AI' has a wrong offset!");
static_assert(offsetof(UMovementConfig, StandMovementSpeeds) == 0x000090, "Member 'UMovementConfig::StandMovementSpeeds' has a wrong offset!");
static_assert(offsetof(UMovementConfig, CrouchMovementSpeeds) == 0x0000E0, "Member 'UMovementConfig::CrouchMovementSpeeds' has a wrong offset!");
static_assert(offsetof(UMovementConfig, ProneMovementSpeeds) == 0x000130, "Member 'UMovementConfig::ProneMovementSpeeds' has a wrong offset!");
static_assert(offsetof(UMovementConfig, DefaultAcceleration) == 0x000180, "Member 'UMovementConfig::DefaultAcceleration' has a wrong offset!");

// Class Flame.StateMachineDebugComponent
// 0x0000 (0x04B0 - 0x04B0)
class UStateMachineDebugComponent : public UTextRenderComponent
{
public:
	bool                                          bDrawOnAutonomous;                                 // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawOnSimulated;                                  // 0x04A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInfoFromServer;                               // 0x04AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInfoFromLocal;                                // 0x04AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetCurrentItemStateInfo() const;
	class FString GetCurrentStateOnServerInfo() const;
	class FString GetStatesHistoryLocal() const;
	class FString GetStatesHistoryOnServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachineDebugComponent">();
	}
	static class UStateMachineDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachineDebugComponent>();
	}
};
static_assert(alignof(UStateMachineDebugComponent) == 0x000010, "Wrong alignment on UStateMachineDebugComponent");
static_assert(sizeof(UStateMachineDebugComponent) == 0x0004B0, "Wrong size on UStateMachineDebugComponent");
static_assert(offsetof(UStateMachineDebugComponent, bDrawOnAutonomous) == 0x0004A8, "Member 'UStateMachineDebugComponent::bDrawOnAutonomous' has a wrong offset!");
static_assert(offsetof(UStateMachineDebugComponent, bDrawOnSimulated) == 0x0004A9, "Member 'UStateMachineDebugComponent::bDrawOnSimulated' has a wrong offset!");
static_assert(offsetof(UStateMachineDebugComponent, bShowInfoFromServer) == 0x0004AA, "Member 'UStateMachineDebugComponent::bShowInfoFromServer' has a wrong offset!");
static_assert(offsetof(UStateMachineDebugComponent, bShowInfoFromLocal) == 0x0004AB, "Member 'UStateMachineDebugComponent::bShowInfoFromLocal' has a wrong offset!");

// Class Flame.CharacterWeaponAnimData
// 0x0010 (0x0038 - 0x0028)
class UCharacterWeaponAnimData : public UObject
{
public:
	class UAnimMontage*                           Vault;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Climb;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterWeaponAnimData">();
	}
	static class UCharacterWeaponAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterWeaponAnimData>();
	}
};
static_assert(alignof(UCharacterWeaponAnimData) == 0x000008, "Wrong alignment on UCharacterWeaponAnimData");
static_assert(sizeof(UCharacterWeaponAnimData) == 0x000038, "Wrong size on UCharacterWeaponAnimData");
static_assert(offsetof(UCharacterWeaponAnimData, Vault) == 0x000028, "Member 'UCharacterWeaponAnimData::Vault' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimData, Climb) == 0x000030, "Member 'UCharacterWeaponAnimData::Climb' has a wrong offset!");

// Class Flame.LobbyBaseMenuWidget
// 0x0000 (0x02D8 - 0x02D8)
class ULobbyBaseMenuWidget : public UMenuWidget
{
public:
	int32 GetActivatedAmountCPP(EBoosterTypes Booster);
	void LeaveLobby();
	void LockLobby();
	void RefreshReadyUI(const TArray<int32>& ReadyIDs);
	void SetBoosterState(EBoosterTypes Booster, int32 OrderedCount, int32 TotalActiveCount, int32 MaxCount, int32 TicketsUsed);
	void SetRemainingTime(int32 Seconds);
	void SetRemainingTimeEncounter(int32 Seconds);
	void UpdateHCs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyBaseMenuWidget">();
	}
	static class ULobbyBaseMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyBaseMenuWidget>();
	}
};
static_assert(alignof(ULobbyBaseMenuWidget) == 0x000008, "Wrong alignment on ULobbyBaseMenuWidget");
static_assert(sizeof(ULobbyBaseMenuWidget) == 0x0002D8, "Wrong size on ULobbyBaseMenuWidget");

// Class Flame.CheatFunctions
// 0x0000 (0x0028 - 0x0028)
class UCheatFunctions final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> CollectActionsInProgress(const class AHumanCharacter* Character);
	static class UStateMachineComponent* GetStateMachine(const class AHumanCharacter* Character);
	static bool GetTransformFromClipboard(struct FTransform* Transform);
	static void InterruptAllStates(const class AHumanCharacter* Character);
	static void PlayerTransformToClipboard(class UObject* WorldContextObject);
	static void SetPlayerTransformFromClipboard(class UObject* WorldContextObject);
	static void SetTransformToClipboard(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatFunctions">();
	}
	static class UCheatFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatFunctions>();
	}
};
static_assert(alignof(UCheatFunctions) == 0x000008, "Wrong alignment on UCheatFunctions");
static_assert(sizeof(UCheatFunctions) == 0x000028, "Wrong size on UCheatFunctions");

// Class Flame.ChildActorWithBoundsComponent
// 0x0000 (0x0230 - 0x0230)
class UChildActorWithBoundsComponent final : public UChildActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildActorWithBoundsComponent">();
	}
	static class UChildActorWithBoundsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildActorWithBoundsComponent>();
	}
};
static_assert(alignof(UChildActorWithBoundsComponent) == 0x000010, "Wrong alignment on UChildActorWithBoundsComponent");
static_assert(sizeof(UChildActorWithBoundsComponent) == 0x000230, "Wrong size on UChildActorWithBoundsComponent");

// Class Flame.IKRightfNotify
// 0x0008 (0x0040 - 0x0038)
class UIKRightfNotify final : public UAnimNotify
{
public:
	bool                                          bIsOn;                                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimationNotifyIKViewType                    AnimationNotifyIKViewType;                         // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRightfNotify">();
	}
	static class UIKRightfNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRightfNotify>();
	}
};
static_assert(alignof(UIKRightfNotify) == 0x000008, "Wrong alignment on UIKRightfNotify");
static_assert(sizeof(UIKRightfNotify) == 0x000040, "Wrong size on UIKRightfNotify");
static_assert(offsetof(UIKRightfNotify, bIsOn) == 0x000038, "Member 'UIKRightfNotify::bIsOn' has a wrong offset!");
static_assert(offsetof(UIKRightfNotify, AnimationNotifyIKViewType) == 0x000039, "Member 'UIKRightfNotify::AnimationNotifyIKViewType' has a wrong offset!");

// Class Flame.ListButtonWidget
// 0x00E0 (0x0398 - 0x02B8)
class UListButtonWidget : public UFlameWidget
{
public:
	struct FLinearColor                           BackgroundNormalColour;                            // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundFocusColour;                             // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundNormalTint;                              // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundHoverTint;                               // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseNativeFocusImplementation;                      // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameButton*                           Button;                                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ButtonText;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECursorMode                                   HoverState;                                        // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECursorMode                                   DisabledState;                                     // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReleased;                                        // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFocused;                                         // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnfocused;                                       // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHovered;                                         // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnhovered;                                       // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsFocusBlocked;                                    // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanFocusBlock;                                     // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClicked(class UButton* Sender);
	void OnButtonFocused(class UButton* Sender);
	void OnButtonHovered();
	void OnButtonPressed(class UButton* Sender);
	void OnButtonReleased(class UButton* Sender);
	void OnButtonUnfocused(class UButton* Sender);
	void OnButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListButtonWidget">();
	}
	static class UListButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UListButtonWidget>();
	}
};
static_assert(alignof(UListButtonWidget) == 0x000008, "Wrong alignment on UListButtonWidget");
static_assert(sizeof(UListButtonWidget) == 0x000398, "Wrong size on UListButtonWidget");
static_assert(offsetof(UListButtonWidget, BackgroundNormalColour) == 0x0002B8, "Member 'UListButtonWidget::BackgroundNormalColour' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, BackgroundFocusColour) == 0x0002C8, "Member 'UListButtonWidget::BackgroundFocusColour' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, BackgroundNormalTint) == 0x0002D8, "Member 'UListButtonWidget::BackgroundNormalTint' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, BackgroundHoverTint) == 0x0002E8, "Member 'UListButtonWidget::BackgroundHoverTint' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, UseNativeFocusImplementation) == 0x0002F8, "Member 'UListButtonWidget::UseNativeFocusImplementation' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, Button) == 0x000300, "Member 'UListButtonWidget::Button' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, BackgroundImage) == 0x000308, "Member 'UListButtonWidget::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, ButtonText) == 0x000310, "Member 'UListButtonWidget::ButtonText' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, HoverState) == 0x000318, "Member 'UListButtonWidget::HoverState' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, DisabledState) == 0x000319, "Member 'UListButtonWidget::DisabledState' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnClicked) == 0x000320, "Member 'UListButtonWidget::OnClicked' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnPressed) == 0x000330, "Member 'UListButtonWidget::OnPressed' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnReleased) == 0x000340, "Member 'UListButtonWidget::OnReleased' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnFocused) == 0x000350, "Member 'UListButtonWidget::OnFocused' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnUnfocused) == 0x000360, "Member 'UListButtonWidget::OnUnfocused' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnHovered) == 0x000370, "Member 'UListButtonWidget::OnHovered' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, OnUnhovered) == 0x000380, "Member 'UListButtonWidget::OnUnhovered' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, IsFocusBlocked) == 0x000390, "Member 'UListButtonWidget::IsFocusBlocked' has a wrong offset!");
static_assert(offsetof(UListButtonWidget, CanFocusBlock) == 0x000391, "Member 'UListButtonWidget::CanFocusBlock' has a wrong offset!");

// Class Flame.IKLeftfNotify
// 0x0008 (0x0040 - 0x0038)
class UIKLeftfNotify final : public UAnimNotify
{
public:
	bool                                          bIsOn;                                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimationNotifyIKViewType                    AnimationNotifyIKViewType;                         // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKLeftfNotify">();
	}
	static class UIKLeftfNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKLeftfNotify>();
	}
};
static_assert(alignof(UIKLeftfNotify) == 0x000008, "Wrong alignment on UIKLeftfNotify");
static_assert(sizeof(UIKLeftfNotify) == 0x000040, "Wrong size on UIKLeftfNotify");
static_assert(offsetof(UIKLeftfNotify, bIsOn) == 0x000038, "Member 'UIKLeftfNotify::bIsOn' has a wrong offset!");
static_assert(offsetof(UIKLeftfNotify, AnimationNotifyIKViewType) == 0x000039, "Member 'UIKLeftfNotify::AnimationNotifyIKViewType' has a wrong offset!");

// Class Flame.IKArmsNotify
// 0x0008 (0x0040 - 0x0038)
class UIKArmsNotify final : public UAnimNotify
{
public:
	bool                                          bIsOn;                                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKArmsNotify">();
	}
	static class UIKArmsNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKArmsNotify>();
	}
};
static_assert(alignof(UIKArmsNotify) == 0x000008, "Wrong alignment on UIKArmsNotify");
static_assert(sizeof(UIKArmsNotify) == 0x000040, "Wrong size on UIKArmsNotify");
static_assert(offsetof(UIKArmsNotify, bIsOn) == 0x000038, "Member 'UIKArmsNotify::bIsOn' has a wrong offset!");

// Class Flame.AimActiveNotify
// 0x0008 (0x0040 - 0x0038)
class UAimActiveNotify final : public UAnimNotify
{
public:
	bool                                          bDisableAiming;                                    // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimActiveNotify">();
	}
	static class UAimActiveNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimActiveNotify>();
	}
};
static_assert(alignof(UAimActiveNotify) == 0x000008, "Wrong alignment on UAimActiveNotify");
static_assert(sizeof(UAimActiveNotify) == 0x000040, "Wrong size on UAimActiveNotify");
static_assert(offsetof(UAimActiveNotify, bDisableAiming) == 0x000038, "Member 'UAimActiveNotify::bDisableAiming' has a wrong offset!");

// Class Flame.InGameNewsSystem
// 0x0130 (0x01E0 - 0x00B0)
class UInGameNewsSystem : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInGameNewsSystemReady;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ImageCacheSizeInKB;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FNewsDto>          LoadedNews;                                        // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UTexture2DDynamic*> Loaded2DDynamicImages;                             // 0x0118(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x78];                                     // 0x0168(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetNews(TArray<struct FNewsUIData>* OutNews);
	bool NeedsToBeDisplayed(const struct FNewsDto& News);
	void RemoveNotFoundNewsFromSaveFile(const TArray<struct FNewsDto>& News);

	bool IsInGameNewsSystemReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameNewsSystem">();
	}
	static class UInGameNewsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameNewsSystem>();
	}
};
static_assert(alignof(UInGameNewsSystem) == 0x000008, "Wrong alignment on UInGameNewsSystem");
static_assert(sizeof(UInGameNewsSystem) == 0x0001E0, "Wrong size on UInGameNewsSystem");
static_assert(offsetof(UInGameNewsSystem, OnInGameNewsSystemReady) == 0x0000B0, "Member 'UInGameNewsSystem::OnInGameNewsSystemReady' has a wrong offset!");
static_assert(offsetof(UInGameNewsSystem, ImageCacheSizeInKB) == 0x0000C0, "Member 'UInGameNewsSystem::ImageCacheSizeInKB' has a wrong offset!");
static_assert(offsetof(UInGameNewsSystem, LoadedNews) == 0x0000C8, "Member 'UInGameNewsSystem::LoadedNews' has a wrong offset!");
static_assert(offsetof(UInGameNewsSystem, Loaded2DDynamicImages) == 0x000118, "Member 'UInGameNewsSystem::Loaded2DDynamicImages' has a wrong offset!");

// Class Flame.MarkerForDebugComponent
// 0x0000 (0x00B0 - 0x00B0)
class UMarkerForDebugComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarkerForDebugComponent">();
	}
	static class UMarkerForDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarkerForDebugComponent>();
	}
};
static_assert(alignof(UMarkerForDebugComponent) == 0x000008, "Wrong alignment on UMarkerForDebugComponent");
static_assert(sizeof(UMarkerForDebugComponent) == 0x0000B0, "Wrong size on UMarkerForDebugComponent");

// Class Flame.InitialPlayerController
// 0x0000 (0x0580 - 0x0580)
class AInitialPlayerController final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitialPlayerController">();
	}
	static class AInitialPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInitialPlayerController>();
	}
};
static_assert(alignof(AInitialPlayerController) == 0x000008, "Wrong alignment on AInitialPlayerController");
static_assert(sizeof(AInitialPlayerController) == 0x000580, "Wrong size on AInitialPlayerController");

// Class Flame.InputActionDecorator
// 0x0000 (0x0028 - 0x0028)
class UInputActionDecorator final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionDecorator">();
	}
	static class UInputActionDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionDecorator>();
	}
};
static_assert(alignof(UInputActionDecorator) == 0x000008, "Wrong alignment on UInputActionDecorator");
static_assert(sizeof(UInputActionDecorator) == 0x000028, "Wrong size on UInputActionDecorator");

// Class Flame.InputActionHintWidget
// 0x0010 (0x02C8 - 0x02B8)
class UInputActionHintWidget : public UFlameWidget
{
public:
	class URichTextBlock*                         RichTextHint;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetContent(const class FText& InMessage, const TArray<EInputIcon>& InIcons);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionHintWidget">();
	}
	static class UInputActionHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionHintWidget>();
	}
};
static_assert(alignof(UInputActionHintWidget) == 0x000008, "Wrong alignment on UInputActionHintWidget");
static_assert(sizeof(UInputActionHintWidget) == 0x0002C8, "Wrong size on UInputActionHintWidget");
static_assert(offsetof(UInputActionHintWidget, RichTextHint) == 0x0002B8, "Member 'UInputActionHintWidget::RichTextHint' has a wrong offset!");

// Class Flame.InputActionWidget
// 0x0178 (0x0430 - 0x02B8)
class UInputActionWidget : public UFlameWidget
{
public:
	bool                                          IsHoverByCode;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SkipListenerRebind;                                // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNamePlatformSpecific;                           // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionName;                                        // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EFlamePlatform, class FText>             PlatformActionNames;                               // 0x02D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EInputIcon                                    InputIcon;                                         // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputIcon                                    InputIconWindows;                                  // 0x0329(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClickable;                                      // 0x032A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoldable;                                       // 0x032B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoverable;                                      // 0x032C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWideImage;                                     // 0x032D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECursorMode                                   HoverState;                                        // 0x032E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECursorMode                                   DisabledState;                                     // 0x032F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldTime;                                          // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayAsUpperCase;                               // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FontSize;                                          // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconSize;                                          // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                ContentPadding;                                    // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColour;                                      // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HoverColour;                                       // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsumeActions;                                   // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundOnPress;                                      // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundOnHold;                                       // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundOnRelease;                                    // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x20];                                     // 0x0390(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHold;                                            // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReleased;                                        // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEnabled;                                         // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDisabled;                                        // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInputIconChanged;                                // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UInputIconImage*                        InputIconImage;                                    // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformTextBlock*                     ActionNameTextBlock;                               // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ExternalStartHoldTimer();
	void ExternalStopHoldTimer();
	bool HasActionName();
	void NativeOnActionHold();
	void NativeOnActionPressed();
	void NativeOnActionReleased();
	void NativeOnDisabled();
	void NativeOnEnabled();
	void OnActionHold();
	void OnActionHoldEvent__DelegateSignature();
	void OnActionPressed();
	void OnActionPressedEvent__DelegateSignature();
	void OnActionReleased();
	void OnActionReleasedEvent__DelegateSignature();
	void OnClickedEvent__DelegateSignature();
	void OnDisabledEvent__DelegateSignature();
	void OnEnabledEvent__DelegateSignature();
	void OnInputIconChangedEvent__DelegateSignature();
	void OnMouseClicked();
	void SetActionName(const class FText& InText);
	void SetConsumeActions(const bool InValue);
	void SetHoldTime(float TimeInSeconds);
	void SetInputIcon(const EInputIcon InIcon, const bool bInIsHoldable);
	void SetSoundOnHold(class USoundBase* InSoundOnHold);
	void SetSoundOnPress(class USoundBase* InSoundOnPress);
	void SetSoundOnRelease(class USoundBase* InSoundOnRelease);
	void SetWindowsInputIcon(const EInputIcon InIcon, const bool bInIsWideImage);
	void TriggerButtonPress();
	void UpdateProgress();
	void WindowsInputTypeChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionWidget">();
	}
	static class UInputActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionWidget>();
	}
};
static_assert(alignof(UInputActionWidget) == 0x000008, "Wrong alignment on UInputActionWidget");
static_assert(sizeof(UInputActionWidget) == 0x000430, "Wrong size on UInputActionWidget");
static_assert(offsetof(UInputActionWidget, IsHoverByCode) == 0x0002B8, "Member 'UInputActionWidget::IsHoverByCode' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, SkipListenerRebind) == 0x0002B9, "Member 'UInputActionWidget::SkipListenerRebind' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bIsNamePlatformSpecific) == 0x0002BA, "Member 'UInputActionWidget::bIsNamePlatformSpecific' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, ActionName) == 0x0002C0, "Member 'UInputActionWidget::ActionName' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, PlatformActionNames) == 0x0002D8, "Member 'UInputActionWidget::PlatformActionNames' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, InputIcon) == 0x000328, "Member 'UInputActionWidget::InputIcon' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, InputIconWindows) == 0x000329, "Member 'UInputActionWidget::InputIconWindows' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bIsClickable) == 0x00032A, "Member 'UInputActionWidget::bIsClickable' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bIsHoldable) == 0x00032B, "Member 'UInputActionWidget::bIsHoldable' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bIsHoverable) == 0x00032C, "Member 'UInputActionWidget::bIsHoverable' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bUseWideImage) == 0x00032D, "Member 'UInputActionWidget::bUseWideImage' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, HoverState) == 0x00032E, "Member 'UInputActionWidget::HoverState' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, DisabledState) == 0x00032F, "Member 'UInputActionWidget::DisabledState' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, HoldTime) == 0x000330, "Member 'UInputActionWidget::HoldTime' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bDisplayAsUpperCase) == 0x000334, "Member 'UInputActionWidget::bDisplayAsUpperCase' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, FontSize) == 0x000338, "Member 'UInputActionWidget::FontSize' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, IconSize) == 0x00033C, "Member 'UInputActionWidget::IconSize' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, ContentPadding) == 0x000340, "Member 'UInputActionWidget::ContentPadding' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, NormalColour) == 0x000350, "Member 'UInputActionWidget::NormalColour' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, HoverColour) == 0x000360, "Member 'UInputActionWidget::HoverColour' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, bConsumeActions) == 0x000370, "Member 'UInputActionWidget::bConsumeActions' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, SoundOnPress) == 0x000378, "Member 'UInputActionWidget::SoundOnPress' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, SoundOnHold) == 0x000380, "Member 'UInputActionWidget::SoundOnHold' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, SoundOnRelease) == 0x000388, "Member 'UInputActionWidget::SoundOnRelease' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnPressed) == 0x0003B0, "Member 'UInputActionWidget::OnPressed' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnHold) == 0x0003C0, "Member 'UInputActionWidget::OnHold' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnReleased) == 0x0003D0, "Member 'UInputActionWidget::OnReleased' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnClicked) == 0x0003E0, "Member 'UInputActionWidget::OnClicked' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnEnabled) == 0x0003F0, "Member 'UInputActionWidget::OnEnabled' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnDisabled) == 0x000400, "Member 'UInputActionWidget::OnDisabled' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, OnInputIconChanged) == 0x000410, "Member 'UInputActionWidget::OnInputIconChanged' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, InputIconImage) == 0x000420, "Member 'UInputActionWidget::InputIconImage' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, ActionNameTextBlock) == 0x000428, "Member 'UInputActionWidget::ActionNameTextBlock' has a wrong offset!");

// Class Flame.PingManager
// 0x0090 (0x00B8 - 0x0028)
class UPingManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnPingResponsesReady;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x80];                                      // 0x0038(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPingManager* GetPingManager(const class UObject* WorldContextObject);

	bool IsPingOfServersComputed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingManager">();
	}
	static class UPingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingManager>();
	}
};
static_assert(alignof(UPingManager) == 0x000008, "Wrong alignment on UPingManager");
static_assert(sizeof(UPingManager) == 0x0000B8, "Wrong size on UPingManager");
static_assert(offsetof(UPingManager, OnPingResponsesReady) == 0x000028, "Member 'UPingManager::OnPingResponsesReady' has a wrong offset!");

// Class Flame.InputActionWidgetExtended
// 0x0028 (0x0458 - 0x0430)
class UInputActionWidgetExtended : public UInputActionWidget
{
public:
	class UPlatformTextBlock*                     ActionInfoTextBlock;                               // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ActionInfo;                                        // 0x0438(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisplayInfoAsUpperCase;                           // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InfoFontSize;                                      // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool HasActionInfo();
	void SetActionInfo(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionWidgetExtended">();
	}
	static class UInputActionWidgetExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionWidgetExtended>();
	}
};
static_assert(alignof(UInputActionWidgetExtended) == 0x000008, "Wrong alignment on UInputActionWidgetExtended");
static_assert(sizeof(UInputActionWidgetExtended) == 0x000458, "Wrong size on UInputActionWidgetExtended");
static_assert(offsetof(UInputActionWidgetExtended, ActionInfoTextBlock) == 0x000430, "Member 'UInputActionWidgetExtended::ActionInfoTextBlock' has a wrong offset!");
static_assert(offsetof(UInputActionWidgetExtended, ActionInfo) == 0x000438, "Member 'UInputActionWidgetExtended::ActionInfo' has a wrong offset!");
static_assert(offsetof(UInputActionWidgetExtended, bDisplayInfoAsUpperCase) == 0x000450, "Member 'UInputActionWidgetExtended::bDisplayInfoAsUpperCase' has a wrong offset!");
static_assert(offsetof(UInputActionWidgetExtended, InfoFontSize) == 0x000454, "Member 'UInputActionWidgetExtended::InfoFontSize' has a wrong offset!");

// Class Flame.InputChoiceWidget
// 0x0030 (0x0460 - 0x0430)
class UInputChoiceWidget : public UInputActionWidget
{
public:
	class FString                                 Separator;                                         // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColor;                                       // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectedColor;                                     // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetSelectedIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputChoiceWidget">();
	}
	static class UInputChoiceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputChoiceWidget>();
	}
};
static_assert(alignof(UInputChoiceWidget) == 0x000008, "Wrong alignment on UInputChoiceWidget");
static_assert(sizeof(UInputChoiceWidget) == 0x000460, "Wrong size on UInputChoiceWidget");
static_assert(offsetof(UInputChoiceWidget, Separator) == 0x000430, "Member 'UInputChoiceWidget::Separator' has a wrong offset!");
static_assert(offsetof(UInputChoiceWidget, NormalColor) == 0x000440, "Member 'UInputChoiceWidget::NormalColor' has a wrong offset!");
static_assert(offsetof(UInputChoiceWidget, SelectedColor) == 0x000450, "Member 'UInputChoiceWidget::SelectedColor' has a wrong offset!");

// Class Flame.InputAction
// 0x0048 (0x0070 - 0x0028)
class UInputAction final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AHumanPlayerController*                 Controller;                                        // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KeyHold();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputAction">();
	}
	static class UInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputAction>();
	}
};
static_assert(alignof(UInputAction) == 0x000008, "Wrong alignment on UInputAction");
static_assert(sizeof(UInputAction) == 0x000070, "Wrong size on UInputAction");
static_assert(offsetof(UInputAction, Controller) == 0x000058, "Member 'UInputAction::Controller' has a wrong offset!");

// Class Flame.LeaderboardReadBoardAroundUserPlatform
// 0x0000 (0x00F8 - 0x00F8)
class ULeaderboardReadBoardAroundUserPlatform final : public ULeaderboardReadBoardBasePlatform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundUserPlatform">();
	}
	static class ULeaderboardReadBoardAroundUserPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundUserPlatform>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundUserPlatform) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundUserPlatform");
static_assert(sizeof(ULeaderboardReadBoardAroundUserPlatform) == 0x0000F8, "Wrong size on ULeaderboardReadBoardAroundUserPlatform");

// Class Flame.InteractionActorComponent
// 0x0088 (0x0138 - 0x00B0)
class UInteractionActorComponent : public UActorComponent
{
public:
	bool                                          bIsEnabled;                                        // 0x00B0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisibleMarkers;                                   // 0x00B1(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarkersRadius;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MarkersConeAngle;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InteractionDistance;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InteractionConeAngle;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x74];                                      // 0x00C4(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyInteractionEnd(class UInteractionItemComponent* InteractingItem);
	void ClientNotifyInteractionStart(class UInteractionItemComponent* InteractingItem);
	void ClientNotifyPreInteractionEnd(class UInteractionItemComponent* InteractingItem, bool bPreInteracitonCanceled);
	void ClientNotifyPreInteractionStart(class UInteractionItemComponent* InteractingItem, float PreInteractionPhaseLen);
	void MulticastNotifyInteractionEnd(class UInteractionItemComponent* InteractingItem);
	void MulticastNotifyInteractionStart(class UInteractionItemComponent* InteractingItem);
	void MulticastNotifyPreInteractionEnd(class UInteractionItemComponent* InteractingItem, bool bPreInteracitonCanceled);
	void MulticastNotifyPreInteractionStart(class UInteractionItemComponent* InteractingItem, float PreInteractionPhaseLen);
	void OnHideMarker(class UInteractionActorComponent* Sender);
	void OnShowMarker(class UInteractionActorComponent* Sender, class UInteractionItemComponent* InteractionItem, const struct FVector& MarkerPosition, bool InteractionAllowed);
	void OnUpdateMarker(class UInteractionActorComponent* Sender, const struct FVector& MarkerPosition);
	void ResetComponent();
	void SetEnabled(bool Enabled);
	void SetMarkersVisibility(bool Visibility);
	void SetMarkersVisibilityByOptions(bool Visibility);

	class UInteractionItemComponent* GetInteractingItemComponent() const;
	class UInteractionItemComponent* GetLastInteractingItemComponent() const;
	float GetMarkersRadius() const;
	bool GetMarkersVisibility() const;
	bool GetMarkersVisibilityByOptions() const;
	float GetPreInteractiveTimerProgress() const;
	bool IsEnabled() const;
	bool IsPlayerInteracting() const;
	bool IsPreInteractiveTimerActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionActorComponent">();
	}
	static class UInteractionActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionActorComponent>();
	}
};
static_assert(alignof(UInteractionActorComponent) == 0x000008, "Wrong alignment on UInteractionActorComponent");
static_assert(sizeof(UInteractionActorComponent) == 0x000138, "Wrong size on UInteractionActorComponent");
static_assert(offsetof(UInteractionActorComponent, bIsEnabled) == 0x0000B0, "Member 'UInteractionActorComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UInteractionActorComponent, bVisibleMarkers) == 0x0000B1, "Member 'UInteractionActorComponent::bVisibleMarkers' has a wrong offset!");
static_assert(offsetof(UInteractionActorComponent, MarkersRadius) == 0x0000B4, "Member 'UInteractionActorComponent::MarkersRadius' has a wrong offset!");
static_assert(offsetof(UInteractionActorComponent, MarkersConeAngle) == 0x0000B8, "Member 'UInteractionActorComponent::MarkersConeAngle' has a wrong offset!");
static_assert(offsetof(UInteractionActorComponent, InteractionDistance) == 0x0000BC, "Member 'UInteractionActorComponent::InteractionDistance' has a wrong offset!");
static_assert(offsetof(UInteractionActorComponent, InteractionConeAngle) == 0x0000C0, "Member 'UInteractionActorComponent::InteractionConeAngle' has a wrong offset!");

// Class Flame.Tool
// 0x0008 (0x03A0 - 0x0398)
class ATool : public AItem
{
public:
	class AHumanCharacter*                        HumanOwner;                                        // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EquipToolInternal();
	void HandleInput(const struct FKey& Key, EInputEvent Event, float Force);
	void HandleInputInternal(const struct FKey& Key, EInputEvent Event, float Force);
	void RemoveFromHands(ENetRole NetRole);
	void RemoveFromHandsInternal(uint8 NetRole);
	void SetHumanOwner(const class AHumanCharacter* NewOwner);
	void TakeIntoHands(ENetRole NetRole);
	void TakeIntoHandsInternal(uint8 NetRole);
	void UnequipToolInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tool">();
	}
	static class ATool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATool>();
	}
};
static_assert(alignof(ATool) == 0x000008, "Wrong alignment on ATool");
static_assert(sizeof(ATool) == 0x0003A0, "Wrong size on ATool");
static_assert(offsetof(ATool, HumanOwner) == 0x000398, "Member 'ATool::HumanOwner' has a wrong offset!");

// Class Flame.Interior
// 0x0008 (0x0030 - 0x0028)
class UInterior final : public UObject
{
public:
	float                                         MaxRenderDistance;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRenderDistanceSwitch;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interior">();
	}
	static class UInterior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterior>();
	}
};
static_assert(alignof(UInterior) == 0x000008, "Wrong alignment on UInterior");
static_assert(sizeof(UInterior) == 0x000030, "Wrong size on UInterior");
static_assert(offsetof(UInterior, MaxRenderDistance) == 0x000028, "Member 'UInterior::MaxRenderDistance' has a wrong offset!");
static_assert(offsetof(UInterior, MaxRenderDistanceSwitch) == 0x00002C, "Member 'UInterior::MaxRenderDistanceSwitch' has a wrong offset!");

// Class Flame.InventoryComponent
// 0x0130 (0x0330 - 0x0200)
class UInventoryComponent final : public UEquipmentStorageComponent
{
public:
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PresetFromCloudLoadedAuthority;                    // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedAuthority;                              // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedClient;                                 // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnLootTaken;                                       // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnPersistentsChangedClient;                        // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnItemChanged;                                     // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInventoryOperationsComponent> InventoryOperationsClass;                          // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AThrowable>                 ThrowableClass;                                    // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0xC];                                      // 0x0278(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AItem>                   CurrentItem;                                       // 0x0284(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AItem>                   CurrentItemServer;                                 // 0x028C(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AItem>                   LastValidItem;                                     // 0x0294(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AWeapon>                 CurrentWeapon;                                     // 0x029C(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AWeapon>                 LastWeapon;                                        // 0x02A4(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AConsumableItem*>                CachedConsumablesPool;                             // 0x02B0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class APersistentItem*>                Persistents;                                       // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         LastOperationId;                                   // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, TSubclassOf<class APersistentItem>> OldPersistentsMap;                                 // 0x02D8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientSetCurrentWeaponDirectly(class AItem* Item);
	void OnRep_PostChangeCurrentWeapon();
	void OnRep_PostChangeItem();
	void OnRep_PostChangeItemServer();
	void OnRep_PostChangeLastOperationId();
	void OnRep_PostChangeLastValidItem();
	void OnRep_PostChangeLastWeapon();
	void OnRep_PostChangePersistents();
	void ServerUseItem(class AItem* OneConsumable, class AActor* Target);
	void SetFirstValidWeaponOrHolster();
	void SetLastKnownItemPtr(class AItem* Item);
	void SetWeightModifier(const float NewWeightModifier);
	class APersistentItem* SpawnAndAttachPersistent(TSubclassOf<class APersistentItem> PersistentClass);

	bool DoesSomethingModifyDamage(const struct FHitResultSimplified& HitOptimised, EDamageType DamageType, TArray<TSubclassOf<class AItem>>* ItemsWhichAffectedDamage) const;
	bool DoesSomethingModifyDamageBone(class FName Bone, EDamageType DamageType, TArray<TSubclassOf<class AItem>>* ItemsWhichAffectedDamage) const;
	class APersistentItem* FindFirstPersistentByClass(TSubclassOf<class APersistentItem> PersistentClass) const;
	int32 GetAmmoCountForWeapon(const class AWeapon* Weapon) const;
	class UItemsGrid* GetBackpack() const;
	int32 GetBackpackColsCount() const;
	struct FResourceGrid GetBackpackDescriptor() const;
	int32 GetBackpackRowsCount() const;
	class AItem* GetCurrentItem() const;
	float GetInventoryWeight() const;
	class AItem* GetLastKnownItemFromServer() const;
	class ULinkedWeapons* GetWeapons() const;
	bool IsPersistentPresent(TSubclassOf<class APersistentItem> PersistentClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000330, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, PresetFromCloudLoadedAuthority) == 0x000208, "Member 'UInventoryComponent::PresetFromCloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CloudLoadedAuthority) == 0x000218, "Member 'UInventoryComponent::CloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CloudLoadedClient) == 0x000228, "Member 'UInventoryComponent::CloudLoadedClient' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnLootTaken) == 0x000238, "Member 'UInventoryComponent::OnLootTaken' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnPersistentsChangedClient) == 0x000248, "Member 'UInventoryComponent::OnPersistentsChangedClient' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemChanged) == 0x000258, "Member 'UInventoryComponent::OnItemChanged' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryOperationsClass) == 0x000268, "Member 'UInventoryComponent::InventoryOperationsClass' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ThrowableClass) == 0x000270, "Member 'UInventoryComponent::ThrowableClass' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CurrentItem) == 0x000284, "Member 'UInventoryComponent::CurrentItem' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CurrentItemServer) == 0x00028C, "Member 'UInventoryComponent::CurrentItemServer' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastValidItem) == 0x000294, "Member 'UInventoryComponent::LastValidItem' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CurrentWeapon) == 0x00029C, "Member 'UInventoryComponent::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastWeapon) == 0x0002A4, "Member 'UInventoryComponent::LastWeapon' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, CachedConsumablesPool) == 0x0002B0, "Member 'UInventoryComponent::CachedConsumablesPool' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, Persistents) == 0x0002C0, "Member 'UInventoryComponent::Persistents' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastOperationId) == 0x0002D0, "Member 'UInventoryComponent::LastOperationId' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OldPersistentsMap) == 0x0002D8, "Member 'UInventoryComponent::OldPersistentsMap' has a wrong offset!");

// Class Flame.LootableCorpse
// 0x0040 (0x0288 - 0x0248)
class ALootableCorpse : public APhysicsLootableActor
{
public:
	class FString                                 DeadPlayerName;                                    // 0x0248(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFlamePlatform                                DeadPlayerPlatform;                                // 0x0258(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       DeadPlayerUniqueId;                                // 0x0260(0x0028)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GetDeadPlayerName() const;
	EFlamePlatform GetDeadPlayerPlatform() const;
	struct FUniqueNetIdRepl GetDeadPlayerUniqueId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootableCorpse">();
	}
	static class ALootableCorpse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootableCorpse>();
	}
};
static_assert(alignof(ALootableCorpse) == 0x000008, "Wrong alignment on ALootableCorpse");
static_assert(sizeof(ALootableCorpse) == 0x000288, "Wrong size on ALootableCorpse");
static_assert(offsetof(ALootableCorpse, DeadPlayerName) == 0x000248, "Member 'ALootableCorpse::DeadPlayerName' has a wrong offset!");
static_assert(offsetof(ALootableCorpse, DeadPlayerPlatform) == 0x000258, "Member 'ALootableCorpse::DeadPlayerPlatform' has a wrong offset!");
static_assert(offsetof(ALootableCorpse, DeadPlayerUniqueId) == 0x000260, "Member 'ALootableCorpse::DeadPlayerUniqueId' has a wrong offset!");

// Class Flame.InventoryFunctions
// 0x0000 (0x0028 - 0x0028)
class UInventoryFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void AddItemsFromInventoryToUI(const class UInventoryComponent* Inventory, class UDynamicContainerWidget* UIContainer);
	static struct FCanStoreResult CanStoreToInventory(const class UInventoryComponent* Inventory, TSubclassOf<class AItemForBackpack> Resource);
	static void ClearGrid(class UItemsList* TargetGrid);
	static int32 ConsumeResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count);
	static int32 CountOfCurrency(const class UStashComponent* TargetStash, TSubclassOf<class ACurrency> CurrencyClass);
	static int32 CountOfResource(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource);
	static int32 CountOfWeapons(const class UWeaponsStorage* WeaponsList, TSubclassOf<class AWeapon> WeaponClass);
	static int32 CountToFullStack(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource);
	static TArray<struct FEquipItemsInfo> CreateOperationsForItemDistributionFromToBag(const class UInventoryComponent* TargetInventory, TSubclassOf<class AItemForBackpack> Resource, int32 Count);
	static int32 FindFirstEmptySlotIndex(const class UItemsList* TargetGrid);
	static TArray<TSubclassOf<class AConsumableItem>> GetAllConsumablesClasses(const class UItemsList* TargetGrid);
	static TArray<struct FBackpackItemSlot> GetAllConsumablesSlots(const class UItemsList* TargetGrid);
	static struct FResourceGrid GetBackpackDescriptor(const class UInventoryComponent* SourceInventory);
	static const TArray<class AWeapon*> GetInventoryWeapons(const class APawn* PlayerPawn);
	static class FText GetItemCategoryName(EItemCategory Category);
	static int32 HowManyCanBeStored(const class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource);
	static int32 HowManyCanBeStoredInOneSlot(const class UInventoryComponent* Inventory, TSubclassOf<class AItemForBackpack> Resource);
	static int32 HowManyCanBeTakenFromSlot(const class UItemsList* TargetGrid, const class AItemForBackpack* Resource);
	static void InitBackpackFromDescriptor(class UInventoryComponent* TargetInventory, const struct FResourceGrid& SourceGrid);
	static bool IsAmmoCompatibleWithLoadout(const class APawn* PlayerPawn, TSubclassOf<class AAmmoItem> AmmoClass);
	static bool IsGridEmpty(const class UItemsList* TargetGrid);
	static void MergeGrids(class UItemsGrid* TargetGrid, class UItemsGrid* SourceGrid);
	static int32 StoreResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count);
	static bool UpdateResource(class UItemsList* TargetGrid, TSubclassOf<class AItemForBackpack> Resource, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFunctions">();
	}
	static class UInventoryFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryFunctions>();
	}
};
static_assert(alignof(UInventoryFunctions) == 0x000008, "Wrong alignment on UInventoryFunctions");
static_assert(sizeof(UInventoryFunctions) == 0x000028, "Wrong size on UInventoryFunctions");

// Class Flame.InventoryActionMapping
// 0x0050 (0x0078 - 0x0028)
class UInventoryActionMapping : public UObject
{
public:
	TMap<EInputIcon, EInventoryOperationMode>     ActionMapping;                                     // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryActionMapping">();
	}
	static class UInventoryActionMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryActionMapping>();
	}
};
static_assert(alignof(UInventoryActionMapping) == 0x000008, "Wrong alignment on UInventoryActionMapping");
static_assert(sizeof(UInventoryActionMapping) == 0x000078, "Wrong size on UInventoryActionMapping");
static_assert(offsetof(UInventoryActionMapping, ActionMapping) == 0x000028, "Member 'UInventoryActionMapping::ActionMapping' has a wrong offset!");

// Class Flame.ItemClassHelpers
// 0x0000 (0x0028 - 0x0028)
class UItemClassHelpers final : public UObject
{
public:
	static void GetItemRowFromDataTable(class UDataTable* DataTable, class FName RowName, bool* Success, struct FItemClassTableRow* RowData);
	static void GetTableRowFromItemClass(TSubclassOf<class AItem> ItemClass, bool* Success, struct FDataTableRowHandle* TableHandle, const class UObject* WorldContextObject);
	static void GetTableRowFromItemName(const class FString& ItemName, bool* Success, struct FDataTableRowHandle* TableHandle, const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemClassHelpers">();
	}
	static class UItemClassHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemClassHelpers>();
	}
};
static_assert(alignof(UItemClassHelpers) == 0x000008, "Wrong alignment on UItemClassHelpers");
static_assert(sizeof(UItemClassHelpers) == 0x000028, "Wrong size on UItemClassHelpers");

// Class Flame.OnlineStatusComponent
// 0x0020 (0x00D0 - 0x00B0)
class UOnlineStatusComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetStatusFinished;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetOverviewFinished;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetOverview(class AHumanPlayerController* Player);
	void GetOverviewDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudOverviewResponse& Data);
	int32 GetStatus(class AHumanPlayerController* Player);
	void GetStatusDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudStatusResponse& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineStatusComponent">();
	}
	static class UOnlineStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineStatusComponent>();
	}
};
static_assert(alignof(UOnlineStatusComponent) == 0x000008, "Wrong alignment on UOnlineStatusComponent");
static_assert(sizeof(UOnlineStatusComponent) == 0x0000D0, "Wrong size on UOnlineStatusComponent");
static_assert(offsetof(UOnlineStatusComponent, GetStatusFinished) == 0x0000B0, "Member 'UOnlineStatusComponent::GetStatusFinished' has a wrong offset!");
static_assert(offsetof(UOnlineStatusComponent, GetOverviewFinished) == 0x0000C0, "Member 'UOnlineStatusComponent::GetOverviewFinished' has a wrong offset!");

// Class Flame.CurrencyHard
// 0x0000 (0x0398 - 0x0398)
class ACurrencyHard : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyHard">();
	}
	static class ACurrencyHard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyHard>();
	}
};
static_assert(alignof(ACurrencyHard) == 0x000008, "Wrong alignment on ACurrencyHard");
static_assert(sizeof(ACurrencyHard) == 0x000398, "Wrong size on ACurrencyHard");

// Class Flame.CurrencyMaterial
// 0x0000 (0x0398 - 0x0398)
class ACurrencyMaterial : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyMaterial">();
	}
	static class ACurrencyMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyMaterial>();
	}
};
static_assert(alignof(ACurrencyMaterial) == 0x000008, "Wrong alignment on ACurrencyMaterial");
static_assert(sizeof(ACurrencyMaterial) == 0x000398, "Wrong size on ACurrencyMaterial");

// Class Flame.PlatformStoreOffersManager
// 0x0058 (0x0080 - 0x0028)
class UPlatformStoreOffersManager : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlatformStoreOfferInfo*>        PlatformOffers;                                    // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOfferesManagerStateChanged;                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPlatformStoreOfferInfo* FindPlatformOfferByGameStoreId(const struct FGameStoreProductId& GameStoreProductId);
	class UPlatformStoreOfferInfo* FindPlatformOfferByPlatfromId(const class FString& PlatformId);
	void PlatformStoreOffersStateChanged__DelegateSignature(EPlatformStoreOffersState OldState, EPlatformStoreOffersState NewState);
	bool RefreshPlatformStoreOffers(EPlatformStoreOffersRefreshMode RefreshMode);

	EPlatformStoreOffersState GetOffersManagerState() const;
	const TArray<class UPlatformStoreOfferInfo*> GetPlatformOffers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManager">();
	}
	static class UPlatformStoreOffersManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManager>();
	}
};
static_assert(alignof(UPlatformStoreOffersManager) == 0x000008, "Wrong alignment on UPlatformStoreOffersManager");
static_assert(sizeof(UPlatformStoreOffersManager) == 0x000080, "Wrong size on UPlatformStoreOffersManager");
static_assert(offsetof(UPlatformStoreOffersManager, PlatformOffers) == 0x000058, "Member 'UPlatformStoreOffersManager::PlatformOffers' has a wrong offset!");
static_assert(offsetof(UPlatformStoreOffersManager, OnOfferesManagerStateChanged) == 0x000068, "Member 'UPlatformStoreOffersManager::OnOfferesManagerStateChanged' has a wrong offset!");

// Class Flame.PlatformStoreOffersManagerNull
// 0x0008 (0x0088 - 0x0080)
class UPlatformStoreOffersManagerNull final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerNull">();
	}
	static class UPlatformStoreOffersManagerNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerNull>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerNull) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerNull");
static_assert(sizeof(UPlatformStoreOffersManagerNull) == 0x000088, "Wrong size on UPlatformStoreOffersManagerNull");

// Class Flame.CurrencyBattlePassXPBooster
// 0x0000 (0x0398 - 0x0398)
class ACurrencyBattlePassXPBooster : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBattlePassXPBooster">();
	}
	static class ACurrencyBattlePassXPBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBattlePassXPBooster>();
	}
};
static_assert(alignof(ACurrencyBattlePassXPBooster) == 0x000008, "Wrong alignment on ACurrencyBattlePassXPBooster");
static_assert(sizeof(ACurrencyBattlePassXPBooster) == 0x000398, "Wrong size on ACurrencyBattlePassXPBooster");

// Class Flame.CurrencyBattlePassLevel
// 0x0000 (0x0398 - 0x0398)
class ACurrencyBattlePassLevel : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBattlePassLevel">();
	}
	static class ACurrencyBattlePassLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBattlePassLevel>();
	}
};
static_assert(alignof(ACurrencyBattlePassLevel) == 0x000008, "Wrong alignment on ACurrencyBattlePassLevel");
static_assert(sizeof(ACurrencyBattlePassLevel) == 0x000398, "Wrong size on ACurrencyBattlePassLevel");

// Class Flame.CurrencyBattlePassXP
// 0x0000 (0x0398 - 0x0398)
class ACurrencyBattlePassXP : public ACurrency
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBattlePassXP">();
	}
	static class ACurrencyBattlePassXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBattlePassXP>();
	}
};
static_assert(alignof(ACurrencyBattlePassXP) == 0x000008, "Wrong alignment on ACurrencyBattlePassXP");
static_assert(sizeof(ACurrencyBattlePassXP) == 0x000398, "Wrong size on ACurrencyBattlePassXP");

// Class Flame.PartItem
// 0x0000 (0x03B0 - 0x03B0)
class APartItem : public AItemForBackpack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartItem">();
	}
	static class APartItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APartItem>();
	}
};
static_assert(alignof(APartItem) == 0x000008, "Wrong alignment on APartItem");
static_assert(sizeof(APartItem) == 0x0003B0, "Wrong size on APartItem");

// Class Flame.NetworkStatsWidget
// 0x0010 (0x02C8 - 0x02B8)
class UNetworkStatsWidget : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTexts(const class FText& LagText, const class FText& BandwidthInText, const class FText& BandwidthOutText, const class FText& LossInText, const class FText& LossOutText);
	void UpdateVisibilityFromGameSettings(const struct FGameSaveSettings& GameSettings);

	bool IsActivatedOnOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkStatsWidget">();
	}
	static class UNetworkStatsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkStatsWidget>();
	}
};
static_assert(alignof(UNetworkStatsWidget) == 0x000008, "Wrong alignment on UNetworkStatsWidget");
static_assert(sizeof(UNetworkStatsWidget) == 0x0002C8, "Wrong size on UNetworkStatsWidget");

// Class Flame.CurrencyBoosterTicketDoubleXP
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketDoubleXP : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketDoubleXP">();
	}
	static class ACurrencyBoosterTicketDoubleXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketDoubleXP>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketDoubleXP) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketDoubleXP");
static_assert(sizeof(ACurrencyBoosterTicketDoubleXP) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketDoubleXP");

// Class Flame.CurrencyBoosterTicketDoubleParts
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketDoubleParts : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketDoubleParts">();
	}
	static class ACurrencyBoosterTicketDoubleParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketDoubleParts>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketDoubleParts) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketDoubleParts");
static_assert(sizeof(ACurrencyBoosterTicketDoubleParts) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketDoubleParts");

// Class Flame.PlatformStorePurchaseHandlerPlaystation
// 0x0000 (0x0078 - 0x0078)
class UPlatformStorePurchaseHandlerPlaystation final : public UPlatformStorePurchaseHandlerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStorePurchaseHandlerPlaystation">();
	}
	static class UPlatformStorePurchaseHandlerPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStorePurchaseHandlerPlaystation>();
	}
};
static_assert(alignof(UPlatformStorePurchaseHandlerPlaystation) == 0x000008, "Wrong alignment on UPlatformStorePurchaseHandlerPlaystation");
static_assert(sizeof(UPlatformStorePurchaseHandlerPlaystation) == 0x000078, "Wrong size on UPlatformStorePurchaseHandlerPlaystation");

// Class Flame.CurrencyBoosterTicketDoubleResources
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketDoubleResources : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketDoubleResources">();
	}
	static class ACurrencyBoosterTicketDoubleResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketDoubleResources>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketDoubleResources) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketDoubleResources");
static_assert(sizeof(ACurrencyBoosterTicketDoubleResources) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketDoubleResources");

// Class Flame.CurrencyBoosterTicketLootBox
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketLootBox : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketLootBox">();
	}
	static class ACurrencyBoosterTicketLootBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketLootBox>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketLootBox) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketLootBox");
static_assert(sizeof(ACurrencyBoosterTicketLootBox) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketLootBox");

// Class Flame.CurrencyBoosterTicketLoot
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketLoot : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketLoot">();
	}
	static class ACurrencyBoosterTicketLoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketLoot>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketLoot) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketLoot");
static_assert(sizeof(ACurrencyBoosterTicketLoot) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketLoot");

// Class Flame.CurrencyBoosterTicketBreakLock
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketBreakLock : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketBreakLock">();
	}
	static class ACurrencyBoosterTicketBreakLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketBreakLock>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketBreakLock) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketBreakLock");
static_assert(sizeof(ACurrencyBoosterTicketBreakLock) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketBreakLock");

// Class Flame.QuaternionsBPFunctions
// 0x0000 (0x0028 - 0x0028)
class UQuaternionsBPFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FQuat ComposeQuaternions(const struct FQuat& A, const struct FQuat& B);
	static struct FQuat InverseTransformRotationQuat(const struct FTransform& T, const struct FQuat& Rotation);
	static struct FQuat NormalizeQuaternion(const struct FQuat& Quaternion);
	static struct FRotator QuaternionToRotator(const struct FQuat& Quaternion);
	static struct FTransform RotateTransformQuat(const struct FTransform& T, const struct FQuat& Rotation);
	static struct FQuat RotatorToQuaternion(const struct FRotator& Rotation);
	static void SetRelativeRotationQuat(class USceneComponent* SceneComponent, const struct FQuat& NewRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuaternionsBPFunctions">();
	}
	static class UQuaternionsBPFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuaternionsBPFunctions>();
	}
};
static_assert(alignof(UQuaternionsBPFunctions) == 0x000008, "Wrong alignment on UQuaternionsBPFunctions");
static_assert(sizeof(UQuaternionsBPFunctions) == 0x000028, "Wrong size on UQuaternionsBPFunctions");

// Class Flame.CurrencyBoosterTicketDeathmatch
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketDeathmatch : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketDeathmatch">();
	}
	static class ACurrencyBoosterTicketDeathmatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketDeathmatch>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketDeathmatch) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketDeathmatch");
static_assert(sizeof(ACurrencyBoosterTicketDeathmatch) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketDeathmatch");

// Class Flame.OnlineBoostersComponent
// 0x0010 (0x00C0 - 0x00B0)
class UOnlineBoostersComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             ActivateBoosterTicketsFinished;                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 ActivateBoosterTickets(class AHumanPlayerController* Player, const class FString& BoosterTicketSku, const int32 Count);
	void ActivateBoosterTicketsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FBoosterDetails& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineBoostersComponent">();
	}
	static class UOnlineBoostersComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineBoostersComponent>();
	}
};
static_assert(alignof(UOnlineBoostersComponent) == 0x000008, "Wrong alignment on UOnlineBoostersComponent");
static_assert(sizeof(UOnlineBoostersComponent) == 0x0000C0, "Wrong size on UOnlineBoostersComponent");
static_assert(offsetof(UOnlineBoostersComponent, ActivateBoosterTicketsFinished) == 0x0000B0, "Member 'UOnlineBoostersComponent::ActivateBoosterTicketsFinished' has a wrong offset!");

// Class Flame.CurrencyBoosterTicketInsurance
// 0x0000 (0x03A8 - 0x03A8)
class ACurrencyBoosterTicketInsurance : public ACurrencyBoosterTicket
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyBoosterTicketInsurance">();
	}
	static class ACurrencyBoosterTicketInsurance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyBoosterTicketInsurance>();
	}
};
static_assert(alignof(ACurrencyBoosterTicketInsurance) == 0x000008, "Wrong alignment on ACurrencyBoosterTicketInsurance");
static_assert(sizeof(ACurrencyBoosterTicketInsurance) == 0x0003A8, "Wrong size on ACurrencyBoosterTicketInsurance");

// Class Flame.PlatformStoreUnexpectedPurchaseWatcherBase
// 0x0050 (0x0078 - 0x0028)
class UPlatformStoreUnexpectedPurchaseWatcherBase : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreUnexpectedPurchaseWatcherBase">();
	}
	static class UPlatformStoreUnexpectedPurchaseWatcherBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreUnexpectedPurchaseWatcherBase>();
	}
};
static_assert(alignof(UPlatformStoreUnexpectedPurchaseWatcherBase) == 0x000008, "Wrong alignment on UPlatformStoreUnexpectedPurchaseWatcherBase");
static_assert(sizeof(UPlatformStoreUnexpectedPurchaseWatcherBase) == 0x000078, "Wrong size on UPlatformStoreUnexpectedPurchaseWatcherBase");

// Class Flame.ShotgunAmmoItem
// 0x0000 (0x03B0 - 0x03B0)
class AShotgunAmmoItem : public AAmmoItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunAmmoItem">();
	}
	static class AShotgunAmmoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotgunAmmoItem>();
	}
};
static_assert(alignof(AShotgunAmmoItem) == 0x000008, "Wrong alignment on AShotgunAmmoItem");
static_assert(sizeof(AShotgunAmmoItem) == 0x0003B0, "Wrong size on AShotgunAmmoItem");

// Class Flame.RiverCollision
// 0x0018 (0x0238 - 0x0220)
class ARiverCollision final : public AActor
{
public:
	class UProceduralMeshComponent*               Mesh;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 RiverOwner;                                        // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    CollisionHeightPoint;                              // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GenerateCollisionMesh(const TArray<struct FVector>& Vertices, const TArray<int32>& Indices);
	void SetCollisionPointHeight(const float& NewHeight);
	void SetRiverOwner(class AActor* NewOwner);

	float GetCollisionPointHeight() const;
	class AActor* GetRiverOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiverCollision">();
	}
	static class ARiverCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARiverCollision>();
	}
};
static_assert(alignof(ARiverCollision) == 0x000008, "Wrong alignment on ARiverCollision");
static_assert(sizeof(ARiverCollision) == 0x000238, "Wrong size on ARiverCollision");
static_assert(offsetof(ARiverCollision, Mesh) == 0x000220, "Member 'ARiverCollision::Mesh' has a wrong offset!");
static_assert(offsetof(ARiverCollision, RiverOwner) == 0x000228, "Member 'ARiverCollision::RiverOwner' has a wrong offset!");
static_assert(offsetof(ARiverCollision, CollisionHeightPoint) == 0x000230, "Member 'ARiverCollision::CollisionHeightPoint' has a wrong offset!");

// Class Flame.OnlineSettings
// 0x0020 (0x0058 - 0x0038)
class UOnlineSettings final : public UDeveloperSettings
{
public:
	class FString                                 MatchmakingClientGroup;                            // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingServerGroup;                            // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSettings">();
	}
	static class UOnlineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSettings>();
	}
};
static_assert(alignof(UOnlineSettings) == 0x000008, "Wrong alignment on UOnlineSettings");
static_assert(sizeof(UOnlineSettings) == 0x000058, "Wrong size on UOnlineSettings");
static_assert(offsetof(UOnlineSettings, MatchmakingClientGroup) == 0x000038, "Member 'UOnlineSettings::MatchmakingClientGroup' has a wrong offset!");
static_assert(offsetof(UOnlineSettings, MatchmakingServerGroup) == 0x000048, "Member 'UOnlineSettings::MatchmakingServerGroup' has a wrong offset!");

// Class Flame.Chemicals
// 0x0000 (0x03B0 - 0x03B0)
class AChemicals : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chemicals">();
	}
	static class AChemicals* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChemicals>();
	}
};
static_assert(alignof(AChemicals) == 0x000008, "Wrong alignment on AChemicals");
static_assert(sizeof(AChemicals) == 0x0003B0, "Wrong size on AChemicals");

// Class Flame.Fertilizer
// 0x0000 (0x03B0 - 0x03B0)
class AFertilizer : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fertilizer">();
	}
	static class AFertilizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFertilizer>();
	}
};
static_assert(alignof(AFertilizer) == 0x000008, "Wrong alignment on AFertilizer");
static_assert(sizeof(AFertilizer) == 0x0003B0, "Wrong size on AFertilizer");

// Class Flame.ObstacleComponent
// 0x0020 (0x00D0 - 0x00B0)
class UObstacleComponent final : public UActorComponent
{
public:
	class UObstacleAsset*                         ObstacleAsset;                                     // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FObstacleEdge>                  Edges;                                             // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bObstacleEnabled;                                  // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEdge(const struct FObstacleEdge& Edge);
	void AddSplineTransformedEdges(const class UObstacleAsset* Obstacle, const class USplineMeshComponent* SplineMeshComponent);
	void AddTransformedEdges(const class UObstacleAsset* Obstacle, const struct FTransform& Transform);
	void SetObstacleAsset(class UObstacleAsset* Asset);
	void SetObstacleEnabled(const bool bEnabled);

	TArray<struct FObstacleEdge> GetTransformedEdges(const class USplineMeshComponent* SplineMesh) const;
	bool HasEdges() const;
	bool IsObstacleEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObstacleComponent">();
	}
	static class UObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObstacleComponent>();
	}
};
static_assert(alignof(UObstacleComponent) == 0x000008, "Wrong alignment on UObstacleComponent");
static_assert(sizeof(UObstacleComponent) == 0x0000D0, "Wrong size on UObstacleComponent");
static_assert(offsetof(UObstacleComponent, ObstacleAsset) == 0x0000B0, "Member 'UObstacleComponent::ObstacleAsset' has a wrong offset!");
static_assert(offsetof(UObstacleComponent, Edges) == 0x0000B8, "Member 'UObstacleComponent::Edges' has a wrong offset!");
static_assert(offsetof(UObstacleComponent, bObstacleEnabled) == 0x0000C8, "Member 'UObstacleComponent::bObstacleEnabled' has a wrong offset!");

// Class Flame.OnlineCharityBoxComponent
// 0x0040 (0x00F0 - 0x00B0)
class UOnlineCharityBoxComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetCharityBoxStateFinished;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AddToCharityBoxFinished;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetCharityBoxSeasonsInfoFinished;                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClaimCharityBoxRewardsFinished;                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 AddToCharityBox(class AHumanPlayerController* Player, const struct FCloudCharityBoxAddInfo& Info);
	void AddToCharityBoxDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxState& Data);
	int32 ClaimCharityBoxRewards(class AHumanPlayerController* Player, const class FString& SeasonName);
	void ClaimCharityBoxRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxClaimInfo& Data);
	int32 GetCharityBoxSeasonsInfo(class AHumanPlayerController* Player);
	void GetCharityBoxSeasonsInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxSeasonsInfo& Data);
	int32 GetCharityBoxState(class AHumanPlayerController* Player);
	void GetCharityBoxStateDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudCharityBoxState& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineCharityBoxComponent">();
	}
	static class UOnlineCharityBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineCharityBoxComponent>();
	}
};
static_assert(alignof(UOnlineCharityBoxComponent) == 0x000008, "Wrong alignment on UOnlineCharityBoxComponent");
static_assert(sizeof(UOnlineCharityBoxComponent) == 0x0000F0, "Wrong size on UOnlineCharityBoxComponent");
static_assert(offsetof(UOnlineCharityBoxComponent, GetCharityBoxStateFinished) == 0x0000B0, "Member 'UOnlineCharityBoxComponent::GetCharityBoxStateFinished' has a wrong offset!");
static_assert(offsetof(UOnlineCharityBoxComponent, AddToCharityBoxFinished) == 0x0000C0, "Member 'UOnlineCharityBoxComponent::AddToCharityBoxFinished' has a wrong offset!");
static_assert(offsetof(UOnlineCharityBoxComponent, GetCharityBoxSeasonsInfoFinished) == 0x0000D0, "Member 'UOnlineCharityBoxComponent::GetCharityBoxSeasonsInfoFinished' has a wrong offset!");
static_assert(offsetof(UOnlineCharityBoxComponent, ClaimCharityBoxRewardsFinished) == 0x0000E0, "Member 'UOnlineCharityBoxComponent::ClaimCharityBoxRewardsFinished' has a wrong offset!");

// Class Flame.Glass
// 0x0000 (0x03B0 - 0x03B0)
class AGlass : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Glass">();
	}
	static class AGlass* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlass>();
	}
};
static_assert(alignof(AGlass) == 0x000008, "Wrong alignment on AGlass");
static_assert(sizeof(AGlass) == 0x0003B0, "Wrong size on AGlass");

// Class Flame.MetalParts
// 0x0000 (0x03B0 - 0x03B0)
class AMetalParts : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetalParts">();
	}
	static class AMetalParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMetalParts>();
	}
};
static_assert(alignof(AMetalParts) == 0x000008, "Wrong alignment on AMetalParts");
static_assert(sizeof(AMetalParts) == 0x0003B0, "Wrong size on AMetalParts");

// Class Flame.Nails
// 0x0000 (0x03B0 - 0x03B0)
class ANails : public AShelterResourceItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Nails">();
	}
	static class ANails* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANails>();
	}
};
static_assert(alignof(ANails) == 0x000008, "Wrong alignment on ANails");
static_assert(sizeof(ANails) == 0x0003B0, "Wrong size on ANails");

// Class Flame.PlatformStoreOffersManagerWindows
// 0x0008 (0x0088 - 0x0080)
class UPlatformStoreOffersManagerWindows final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerWindows">();
	}
	static class UPlatformStoreOffersManagerWindows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerWindows>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerWindows) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerWindows");
static_assert(sizeof(UPlatformStoreOffersManagerWindows) == 0x000088, "Wrong size on UPlatformStoreOffersManagerWindows");

// Class Flame.LethalItemComponent
// 0x0008 (0x00B8 - 0x00B0)
class ULethalItemComponent final : public UActorComponent
{
public:
	int32                                         InstigatorID;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LethalItemComponent">();
	}
	static class ULethalItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULethalItemComponent>();
	}
};
static_assert(alignof(ULethalItemComponent) == 0x000008, "Wrong alignment on ULethalItemComponent");
static_assert(sizeof(ULethalItemComponent) == 0x0000B8, "Wrong size on ULethalItemComponent");
static_assert(offsetof(ULethalItemComponent, InstigatorID) == 0x0000B0, "Member 'ULethalItemComponent::InstigatorID' has a wrong offset!");

// Class Flame.CollectibleItem
// 0x0000 (0x03B0 - 0x03B0)
class ACollectibleItem : public AItemForBackpack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectibleItem">();
	}
	static class ACollectibleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectibleItem>();
	}
};
static_assert(alignof(ACollectibleItem) == 0x000008, "Wrong alignment on ACollectibleItem");
static_assert(sizeof(ACollectibleItem) == 0x0003B0, "Wrong size on ACollectibleItem");

// Class Flame.ItemInfoWidget
// 0x0008 (0x02C0 - 0x02B8)
class UItemInfoWidget : public UFlameWidget
{
public:
	class AItem*                                  Item;                                              // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnItemChanged();
	void SetItem(class AItem* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInfoWidget">();
	}
	static class UItemInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInfoWidget>();
	}
};
static_assert(alignof(UItemInfoWidget) == 0x000008, "Wrong alignment on UItemInfoWidget");
static_assert(sizeof(UItemInfoWidget) == 0x0002C0, "Wrong size on UItemInfoWidget");
static_assert(offsetof(UItemInfoWidget, Item) == 0x0002B8, "Member 'UItemInfoWidget::Item' has a wrong offset!");

// Class Flame.LeaderboardSystem
// 0x0050 (0x0078 - 0x0028)
class ULeaderboardSystem : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULeaderboardHandlersManager*            LeaderboardHandlersManager;                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardDataCache*                  LeaderboardDataCache;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULeaderboardSystemMonitor*              LeaderboardMonitor;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULeaderboardSystemMonitor>  LeaderboardMonitorClass;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLeaderboardReadBoardFinished;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeaderboardWriteBoardDataFinished;               // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static int32 InvalidLeaderboardRequest();

	bool ClearAllCachedLeaderboardData();
	bool ClearCachedLeaderboardData(class FName StatName);
	bool ClearCachedLeaderboardRequest(const struct FLeaderboardReadContext& BoardContext);
	void DeInitLeaderboardSystem();
	class ULeaderboardSystemMonitor* GetLeaderboardSystemMonitor();
	void InitLeaderboardSystem();
	void OnLeaderboardReadBoardFinished__DelegateSignature(bool Succeeded, int32 RequestId, const struct FLeaderboardReadContext& BoardContext, const struct FLeaderboardData& LeaderboardData);
	void OnLeaderboardWriteBoardDataFinished__DelegateSignature(bool Succeeded, int32 RequestId);
	void OnTick();
	int32 ReadLeaderboardData(const class AHumanPlayerController* Controller, const struct FLeaderboardReadContext& BoardContext, bool CheckCachedData, const struct FTimespan& UseCacheIfNotOlderThan);
	bool SetupLocalLeaderboardData(const class FString& CsvFileName);
	int32 WriteLeaderboardData(const class AHumanPlayerController* Controller, class FName BoardName, int32 PlayerValue);

	bool IsLocalLeaderboardEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardSystem">();
	}
	static class ULeaderboardSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardSystem>();
	}
};
static_assert(alignof(ULeaderboardSystem) == 0x000008, "Wrong alignment on ULeaderboardSystem");
static_assert(sizeof(ULeaderboardSystem) == 0x000078, "Wrong size on ULeaderboardSystem");
static_assert(offsetof(ULeaderboardSystem, LeaderboardHandlersManager) == 0x000038, "Member 'ULeaderboardSystem::LeaderboardHandlersManager' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystem, LeaderboardDataCache) == 0x000040, "Member 'ULeaderboardSystem::LeaderboardDataCache' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystem, LeaderboardMonitor) == 0x000048, "Member 'ULeaderboardSystem::LeaderboardMonitor' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystem, LeaderboardMonitorClass) == 0x000050, "Member 'ULeaderboardSystem::LeaderboardMonitorClass' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystem, OnLeaderboardReadBoardFinished) == 0x000058, "Member 'ULeaderboardSystem::OnLeaderboardReadBoardFinished' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystem, OnLeaderboardWriteBoardDataFinished) == 0x000068, "Member 'ULeaderboardSystem::OnLeaderboardWriteBoardDataFinished' has a wrong offset!");

// Class Flame.ConsumablePlan
// 0x0000 (0x03D8 - 0x03D8)
class AConsumablePlan : public APlan
{
public:
	TSubclassOf<class AConsumableItem> GetConsumableClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumablePlan">();
	}
	static class AConsumablePlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConsumablePlan>();
	}
};
static_assert(alignof(AConsumablePlan) == 0x000008, "Wrong alignment on AConsumablePlan");
static_assert(sizeof(AConsumablePlan) == 0x0003D8, "Wrong size on AConsumablePlan");

// Class Flame.OnlineUserStatsComponent
// 0x0010 (0x00C0 - 0x00B0)
class UOnlineUserStatsComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetUserStatisticsFinished;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetUserStatistics(class AHumanPlayerController* Player);
	void GetUserStatisticsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserProfileStatistics& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineUserStatsComponent">();
	}
	static class UOnlineUserStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineUserStatsComponent>();
	}
};
static_assert(alignof(UOnlineUserStatsComponent) == 0x000008, "Wrong alignment on UOnlineUserStatsComponent");
static_assert(sizeof(UOnlineUserStatsComponent) == 0x0000C0, "Wrong size on UOnlineUserStatsComponent");
static_assert(offsetof(UOnlineUserStatsComponent, GetUserStatisticsFinished) == 0x0000B0, "Member 'UOnlineUserStatsComponent::GetUserStatisticsFinished' has a wrong offset!");

// Class Flame.WeaponPlan
// 0x0010 (0x03E8 - 0x03D8)
class AWeaponPlan : public APlan
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class AWeapon> GetWeaponClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponPlan">();
	}
	static class AWeaponPlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponPlan>();
	}
};
static_assert(alignof(AWeaponPlan) == 0x000008, "Wrong alignment on AWeaponPlan");
static_assert(sizeof(AWeaponPlan) == 0x0003E8, "Wrong size on AWeaponPlan");

// Class Flame.PlatformStoreRefreshPurchasesHandlerBase
// 0x0050 (0x0078 - 0x0028)
class UPlatformStoreRefreshPurchasesHandlerBase : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreRefreshPurchasesHandlerBase">();
	}
	static class UPlatformStoreRefreshPurchasesHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreRefreshPurchasesHandlerBase>();
	}
};
static_assert(alignof(UPlatformStoreRefreshPurchasesHandlerBase) == 0x000008, "Wrong alignment on UPlatformStoreRefreshPurchasesHandlerBase");
static_assert(sizeof(UPlatformStoreRefreshPurchasesHandlerBase) == 0x000078, "Wrong size on UPlatformStoreRefreshPurchasesHandlerBase");

// Class Flame.PlatformStoreRefreshPurchasesHandlerGeneric
// 0x0000 (0x0078 - 0x0078)
class UPlatformStoreRefreshPurchasesHandlerGeneric final : public UPlatformStoreRefreshPurchasesHandlerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreRefreshPurchasesHandlerGeneric">();
	}
	static class UPlatformStoreRefreshPurchasesHandlerGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreRefreshPurchasesHandlerGeneric>();
	}
};
static_assert(alignof(UPlatformStoreRefreshPurchasesHandlerGeneric) == 0x000008, "Wrong alignment on UPlatformStoreRefreshPurchasesHandlerGeneric");
static_assert(sizeof(UPlatformStoreRefreshPurchasesHandlerGeneric) == 0x000078, "Wrong size on UPlatformStoreRefreshPurchasesHandlerGeneric");

// Class Flame.ItemRarities
// 0x0010 (0x0038 - 0x0028)
class UItemRarities : public UObject
{
public:
	TArray<struct FItemRarity>                    ItemRarities;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<struct FItemRarity> GetItemRarities() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRarities">();
	}
	static class UItemRarities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRarities>();
	}
};
static_assert(alignof(UItemRarities) == 0x000008, "Wrong alignment on UItemRarities");
static_assert(sizeof(UItemRarities) == 0x000038, "Wrong size on UItemRarities");
static_assert(offsetof(UItemRarities, ItemRarities) == 0x000028, "Member 'UItemRarities::ItemRarities' has a wrong offset!");

// Class Flame.ItemsGrid
// 0x0010 (0x00C8 - 0x00B8)
class UItemsGrid : public UItemsList
{
public:
	int32                                         RowsCount;                                         // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColsCount;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsGrid">();
	}
	static class UItemsGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsGrid>();
	}
};
static_assert(alignof(UItemsGrid) == 0x000008, "Wrong alignment on UItemsGrid");
static_assert(sizeof(UItemsGrid) == 0x0000C8, "Wrong size on UItemsGrid");
static_assert(offsetof(UItemsGrid, RowsCount) == 0x0000B8, "Member 'UItemsGrid::RowsCount' has a wrong offset!");
static_assert(offsetof(UItemsGrid, ColsCount) == 0x0000BC, "Member 'UItemsGrid::ColsCount' has a wrong offset!");

// Class Flame.PerformanceTests
// 0x00F8 (0x0318 - 0x0220)
class APerformanceTests final : public AActor
{
public:
	uint8                                         Pad_220[0xF8];                                     // 0x0220(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DealayedCommand1(const class FString& Command, ECommandType CommandType);
	void DealayedCommand2(const class FString& Command, ECommandType CommandType);
	void DelayedWrite(const class FString& Filename);
	void PerformanceTestsTriggered(int32 Mode);
	void PerformanceTestsTriggeredTicks();
	void PerformanceTestsTriggeredTicksManual();
	void PerformanceTestsTriggeredTicksManualDisable();
	void PerformanceTestsTriggeredTicksManualEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceTests">();
	}
	static class APerformanceTests* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerformanceTests>();
	}
};
static_assert(alignof(APerformanceTests) == 0x000008, "Wrong alignment on APerformanceTests");
static_assert(sizeof(APerformanceTests) == 0x000318, "Wrong size on APerformanceTests");

// Class Flame.Backpack
// 0x0008 (0x00D0 - 0x00C8)
class UBackpack final : public UItemsGrid
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Backpack">();
	}
	static class UBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackpack>();
	}
};
static_assert(alignof(UBackpack) == 0x000008, "Wrong alignment on UBackpack");
static_assert(sizeof(UBackpack) == 0x0000D0, "Wrong size on UBackpack");

// Class Flame.ItemStateBringDown
// 0x0018 (0x0090 - 0x0078)
class UItemStateBringDown final : public UItemState
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStateBringDown">();
	}
	static class UItemStateBringDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStateBringDown>();
	}
};
static_assert(alignof(UItemStateBringDown) == 0x000008, "Wrong alignment on UItemStateBringDown");
static_assert(sizeof(UItemStateBringDown) == 0x000090, "Wrong size on UItemStateBringDown");

// Class Flame.LeaderboardWriteBoardPlatformSwitch
// 0x0008 (0x00C8 - 0x00C0)
class ULeaderboardWriteBoardPlatformSwitch final : public ULeaderboardWriteBoardPlatform
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardPlatformSwitch">();
	}
	static class ULeaderboardWriteBoardPlatformSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardPlatformSwitch>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardPlatformSwitch) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardPlatformSwitch");
static_assert(sizeof(ULeaderboardWriteBoardPlatformSwitch) == 0x0000C8, "Wrong size on ULeaderboardWriteBoardPlatformSwitch");

// Class Flame.ConsumablePart
// 0x0000 (0x03B0 - 0x03B0)
class AConsumablePart : public APartItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumablePart">();
	}
	static class AConsumablePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConsumablePart>();
	}
};
static_assert(alignof(AConsumablePart) == 0x000008, "Wrong alignment on AConsumablePart");
static_assert(sizeof(AConsumablePart) == 0x0003B0, "Wrong size on AConsumablePart");

// Class Flame.PremiumBattlePassToken
// 0x0000 (0x0398 - 0x0398)
class APremiumBattlePassToken : public AToken
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremiumBattlePassToken">();
	}
	static class APremiumBattlePassToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<APremiumBattlePassToken>();
	}
};
static_assert(alignof(APremiumBattlePassToken) == 0x000008, "Wrong alignment on APremiumBattlePassToken");
static_assert(sizeof(APremiumBattlePassToken) == 0x000398, "Wrong size on APremiumBattlePassToken");

// Class Flame.NotificationListBase
// 0x0018 (0x02D0 - 0x02B8)
class UNotificationListBase : public UFlameWidget
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Channels;                                          // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNotificationCount;                              // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGridPanel*                             NotificationList;                                  // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddNotification(class UNotificationBase* InNotification);
	void OnAddNotification(class UNotificationBase* InNotification);
	void OnMenuClosed(class UMenuWidget* MenuWidget);
	void OnMenuOpened(class UMenuWidget* MenuWidget);
	void RefreshRowIndices();

	class UNotificationBase* FindNotificationToRemove() const;
	int32 GetChannels() const;
	int32 GetMinPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationListBase">();
	}
	static class UNotificationListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationListBase>();
	}
};
static_assert(alignof(UNotificationListBase) == 0x000008, "Wrong alignment on UNotificationListBase");
static_assert(sizeof(UNotificationListBase) == 0x0002D0, "Wrong size on UNotificationListBase");
static_assert(offsetof(UNotificationListBase, Channels) == 0x0002C0, "Member 'UNotificationListBase::Channels' has a wrong offset!");
static_assert(offsetof(UNotificationListBase, MaxNotificationCount) == 0x0002C4, "Member 'UNotificationListBase::MaxNotificationCount' has a wrong offset!");
static_assert(offsetof(UNotificationListBase, NotificationList) == 0x0002C8, "Member 'UNotificationListBase::NotificationList' has a wrong offset!");

// Class Flame.PlatformStoreOfferInfoPlaystation
// 0x0058 (0x0080 - 0x0028)
class UPlatformStoreOfferInfoPlaystation final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoPlaystation">();
	}
	static class UPlatformStoreOfferInfoPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoPlaystation>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoPlaystation) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoPlaystation");
static_assert(sizeof(UPlatformStoreOfferInfoPlaystation) == 0x000080, "Wrong size on UPlatformStoreOfferInfoPlaystation");

// Class Flame.ItemTransferWidget
// 0x00A0 (0x03B8 - 0x0318)
class UItemTransferWidget : public UUpdateableWidget
{
public:
	class UFlameSlot*                             FocusedSlot;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USwapWeaponsWidget>         SwapWeaponsWidgetClass;                            // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwapWeaponsWidget*                     SwapWeaponsWidget;                                 // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeapon*                                WeaponToSwap;                                      // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponContainerWidget*                 PlayerWeaponContainer;                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameGridWidget*                       PlayerItemGrid;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameListWidget*                       ContainerWeaponList;                               // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameScalableGridWidget*               ContainerItemGrid;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemInfoWidget*                        ItemInfoWidget;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        ItemLimitText;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionTakeAll;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionTake;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionDestroy;                                     // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionClose;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizableItemProvider*              PlayerItemProvider;                                // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizableItemProvider*              ContainerItemProvider;                             // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizableItemProvider*              ContainerWeaponProvider;                           // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEquipmentStorageComponent*             LootedContainer;                                   // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSwapWeaponsClosed(class UFlameWidget* FlameWidget);
	void TakeAll();
	void TakeFlameSlot(class UFlameSlot* InFlameSlot, EInputIcon InInputAction);

	bool IsDestroyAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTransferWidget">();
	}
	static class UItemTransferWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTransferWidget>();
	}
};
static_assert(alignof(UItemTransferWidget) == 0x000008, "Wrong alignment on UItemTransferWidget");
static_assert(sizeof(UItemTransferWidget) == 0x0003B8, "Wrong size on UItemTransferWidget");
static_assert(offsetof(UItemTransferWidget, FocusedSlot) == 0x000318, "Member 'UItemTransferWidget::FocusedSlot' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, SwapWeaponsWidgetClass) == 0x000320, "Member 'UItemTransferWidget::SwapWeaponsWidgetClass' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, SwapWeaponsWidget) == 0x000328, "Member 'UItemTransferWidget::SwapWeaponsWidget' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, WeaponToSwap) == 0x000330, "Member 'UItemTransferWidget::WeaponToSwap' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, PlayerWeaponContainer) == 0x000338, "Member 'UItemTransferWidget::PlayerWeaponContainer' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, PlayerItemGrid) == 0x000340, "Member 'UItemTransferWidget::PlayerItemGrid' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ContainerWeaponList) == 0x000348, "Member 'UItemTransferWidget::ContainerWeaponList' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ContainerItemGrid) == 0x000350, "Member 'UItemTransferWidget::ContainerItemGrid' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ItemInfoWidget) == 0x000358, "Member 'UItemTransferWidget::ItemInfoWidget' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ItemLimitText) == 0x000360, "Member 'UItemTransferWidget::ItemLimitText' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ActionTakeAll) == 0x000368, "Member 'UItemTransferWidget::ActionTakeAll' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ActionTake) == 0x000370, "Member 'UItemTransferWidget::ActionTake' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ActionDestroy) == 0x000378, "Member 'UItemTransferWidget::ActionDestroy' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ActionClose) == 0x000380, "Member 'UItemTransferWidget::ActionClose' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, PlayerItemProvider) == 0x000388, "Member 'UItemTransferWidget::PlayerItemProvider' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ContainerItemProvider) == 0x000390, "Member 'UItemTransferWidget::ContainerItemProvider' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, ContainerWeaponProvider) == 0x000398, "Member 'UItemTransferWidget::ContainerWeaponProvider' has a wrong offset!");
static_assert(offsetof(UItemTransferWidget, LootedContainer) == 0x0003B0, "Member 'UItemTransferWidget::LootedContainer' has a wrong offset!");

// Class Flame.ThrowThrowable
// 0x0000 (0x0038 - 0x0038)
class UThrowThrowable final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowThrowable">();
	}
	static class UThrowThrowable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowThrowable>();
	}
};
static_assert(alignof(UThrowThrowable) == 0x000008, "Wrong alignment on UThrowThrowable");
static_assert(sizeof(UThrowThrowable) == 0x000038, "Wrong size on UThrowThrowable");

// Class Flame.LoadoutVisualizationBase
// 0x0000 (0x0220 - 0x0220)
class ALoadoutVisualizationBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutVisualizationBase">();
	}
	static class ALoadoutVisualizationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadoutVisualizationBase>();
	}
};
static_assert(alignof(ALoadoutVisualizationBase) == 0x000008, "Wrong alignment on ALoadoutVisualizationBase");
static_assert(sizeof(ALoadoutVisualizationBase) == 0x000220, "Wrong size on ALoadoutVisualizationBase");

// Class Flame.JsonObject
// 0x0010 (0x0038 - 0x0028)
class UJsonObject final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJsonObject* ConstructJsonObject(class UObject* WorldContextObject);

	class FString ExportToString(bool Pretty);
	TArray<class FString> GetFieldNames();
	class UJsonObject* MergeJsonObject(class UJsonObject* InJsonObject, bool Overwrite);
	void RemoveField(const class FString& FieldName);
	void Reset();
	class UJsonObject* SetArrayField(const class FString& FieldName, const TArray<class UJsonValue*>& InArray);
	class UJsonObject* SetBoolArrayField(const class FString& FieldName, const TArray<bool>& BoolArray);
	class UJsonObject* SetBoolField(const class FString& FieldName, bool InValue);
	class UJsonObject* SetField(const class FString& FieldName, class UJsonValue* JsonValue);
	class UJsonObject* SetIntegerArrayField(const class FString& FieldName, const TArray<int32>& NumberArray);
	class UJsonObject* SetIntegerField(const class FString& FieldName, int32 Number);
	class UJsonObject* SetNumberArrayField(const class FString& FieldName, const TArray<float>& NumberArray);
	class UJsonObject* SetNumberField(const class FString& FieldName, float Number);
	class UJsonObject* SetObjectArrayField(const class FString& FieldName, const TArray<class UJsonObject*>& ObjectArray);
	class UJsonObject* SetObjectField(const class FString& FieldName, class UJsonObject* JsonObject);
	class UJsonObject* SetStringArrayField(const class FString& FieldName, const TArray<class FString>& StringArray);
	class UJsonObject* SetStringField(const class FString& FieldName, const class FString& StringValue);

	TArray<class UJsonValue*> GetArrayField(const class FString& FieldName) const;
	TArray<bool> GetBoolArrayField(const class FString& FieldName) const;
	bool GetBoolField(const class FString& FieldName) const;
	class UJsonValue* GetField(const class FString& FieldName) const;
	TArray<int32> GetIntegerArrayField(const class FString& FieldName) const;
	int32 GetIntegerField(const class FString& FieldName) const;
	TArray<float> GetNumberArrayField(const class FString& FieldName) const;
	float GetNumberField(const class FString& FieldName) const;
	TArray<class UJsonObject*> GetObjectArrayField(const class FString& FieldName) const;
	class UJsonObject* GetObjectField(const class FString& FieldName) const;
	TArray<class FString> GetStringArrayField(const class FString& FieldName) const;
	class FString GetStringField(const class FString& FieldName) const;
	bool HasField(const class FString& FieldName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JsonObject">();
	}
	static class UJsonObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJsonObject>();
	}
};
static_assert(alignof(UJsonObject) == 0x000008, "Wrong alignment on UJsonObject");
static_assert(sizeof(UJsonObject) == 0x000038, "Wrong size on UJsonObject");

// Class Flame.JsonValue
// 0x0010 (0x0038 - 0x0028)
class UJsonValue final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJsonValue* ConstructJsonValueArray(class UObject* WorldContextObject, const TArray<class UJsonValue*>& InArray);
	static class UJsonValue* ConstructJsonValueBool(class UObject* WorldContextObject, bool InValue);
	static class UJsonValue* ConstructJsonValueNumber(class UObject* WorldContextObject, float Number);
	static class UJsonValue* ConstructJsonValueObject(class UObject* WorldContextObject, class UJsonObject* JsonObject);
	static class UJsonValue* ConstructJsonValueString(class UObject* WorldContextObject, const class FString& StringValue);

	class UJsonObject* AsObject();

	TArray<class UJsonValue*> AsArray() const;
	bool AsBool() const;
	float AsNumber() const;
	class FString AsString() const;
	EJsonType GetType() const;
	class FString GetTypeString() const;
	bool IsNull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JsonValue">();
	}
	static class UJsonValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJsonValue>();
	}
};
static_assert(alignof(UJsonValue) == 0x000008, "Wrong alignment on UJsonValue");
static_assert(sizeof(UJsonValue) == 0x000038, "Wrong size on UJsonValue");

// Class Flame.LadderInteractionComponent
// 0x0000 (0x0178 - 0x0178)
class ULadderInteractionComponent final : public UInteractionItemComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderInteractionComponent">();
	}
	static class ULadderInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderInteractionComponent>();
	}
};
static_assert(alignof(ULadderInteractionComponent) == 0x000008, "Wrong alignment on ULadderInteractionComponent");
static_assert(sizeof(ULadderInteractionComponent) == 0x000178, "Wrong size on ULadderInteractionComponent");

// Class Flame.OnlineCustomizationComponent
// 0x0000 (0x00B0 - 0x00B0)
class UOnlineCustomizationComponent : public UOnlineComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineCustomizationComponent">();
	}
	static class UOnlineCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineCustomizationComponent>();
	}
};
static_assert(alignof(UOnlineCustomizationComponent) == 0x000008, "Wrong alignment on UOnlineCustomizationComponent");
static_assert(sizeof(UOnlineCustomizationComponent) == 0x0000B0, "Wrong size on UOnlineCustomizationComponent");

// Class Flame.PlatformStoreOffersManagerSteam
// 0x0038 (0x00B8 - 0x0080)
class UPlatformStoreOffersManagerSteam final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x38];                                      // 0x0080(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerSteam">();
	}
	static class UPlatformStoreOffersManagerSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerSteam>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerSteam) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerSteam");
static_assert(sizeof(UPlatformStoreOffersManagerSteam) == 0x0000B8, "Wrong size on UPlatformStoreOffersManagerSteam");

// Class Flame.LayeredSoundAudioComponent
// 0x0060 (0x0900 - 0x08A0)
class ULayeredSoundAudioComponent : public UAudioComponentExtended
{
public:
	uint8                                         Pad_8A0[0x60];                                     // 0x08A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLayerEnabled(class FName LayerName, bool bEnableLayer, float FadeTime);
	void SetLayerValue(class FName LayerName, float Value, float FadeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LayeredSoundAudioComponent">();
	}
	static class ULayeredSoundAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULayeredSoundAudioComponent>();
	}
};
static_assert(alignof(ULayeredSoundAudioComponent) == 0x000010, "Wrong alignment on ULayeredSoundAudioComponent");
static_assert(sizeof(ULayeredSoundAudioComponent) == 0x000900, "Wrong size on ULayeredSoundAudioComponent");

// Class Flame.LeaderboardReadBoardAroundRankDev
// 0x0000 (0x00D8 - 0x00D8)
class ULeaderboardReadBoardAroundRankDev final : public ULeaderboardReadBoardBaseDev
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundRankDev">();
	}
	static class ULeaderboardReadBoardAroundRankDev* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundRankDev>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundRankDev) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundRankDev");
static_assert(sizeof(ULeaderboardReadBoardAroundRankDev) == 0x0000D8, "Wrong size on ULeaderboardReadBoardAroundRankDev");

// Class Flame.LeaderboardReadBoardAroundRankLocal
// 0x0000 (0x00E0 - 0x00E0)
class ULeaderboardReadBoardAroundRankLocal final : public ULeaderboardReadBoardBaseLocal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundRankLocal">();
	}
	static class ULeaderboardReadBoardAroundRankLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundRankLocal>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundRankLocal) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundRankLocal");
static_assert(sizeof(ULeaderboardReadBoardAroundRankLocal) == 0x0000E0, "Wrong size on ULeaderboardReadBoardAroundRankLocal");

// Class Flame.LeaderboardReadBoardAroundRankPlatform
// 0x0000 (0x00F8 - 0x00F8)
class ULeaderboardReadBoardAroundRankPlatform final : public ULeaderboardReadBoardBasePlatform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundRankPlatform">();
	}
	static class ULeaderboardReadBoardAroundRankPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundRankPlatform>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundRankPlatform) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundRankPlatform");
static_assert(sizeof(ULeaderboardReadBoardAroundRankPlatform) == 0x0000F8, "Wrong size on ULeaderboardReadBoardAroundRankPlatform");

// Class Flame.LeaderboardReadBoardAroundUserLocal
// 0x0000 (0x00E0 - 0x00E0)
class ULeaderboardReadBoardAroundUserLocal final : public ULeaderboardReadBoardBaseLocal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardAroundUserLocal">();
	}
	static class ULeaderboardReadBoardAroundUserLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardAroundUserLocal>();
	}
};
static_assert(alignof(ULeaderboardReadBoardAroundUserLocal) == 0x000008, "Wrong alignment on ULeaderboardReadBoardAroundUserLocal");
static_assert(sizeof(ULeaderboardReadBoardAroundUserLocal) == 0x0000E0, "Wrong size on ULeaderboardReadBoardAroundUserLocal");

// Class Flame.LeaderboardReadBoardFriendsDev
// 0x0000 (0x00D8 - 0x00D8)
class ULeaderboardReadBoardFriendsDev final : public ULeaderboardReadBoardBaseDev
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardFriendsDev">();
	}
	static class ULeaderboardReadBoardFriendsDev* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardFriendsDev>();
	}
};
static_assert(alignof(ULeaderboardReadBoardFriendsDev) == 0x000008, "Wrong alignment on ULeaderboardReadBoardFriendsDev");
static_assert(sizeof(ULeaderboardReadBoardFriendsDev) == 0x0000D8, "Wrong size on ULeaderboardReadBoardFriendsDev");

// Class Flame.LeaderboardReadBoardFriendsLocal
// 0x0000 (0x00E0 - 0x00E0)
class ULeaderboardReadBoardFriendsLocal final : public ULeaderboardReadBoardBaseLocal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardFriendsLocal">();
	}
	static class ULeaderboardReadBoardFriendsLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardFriendsLocal>();
	}
};
static_assert(alignof(ULeaderboardReadBoardFriendsLocal) == 0x000008, "Wrong alignment on ULeaderboardReadBoardFriendsLocal");
static_assert(sizeof(ULeaderboardReadBoardFriendsLocal) == 0x0000E0, "Wrong size on ULeaderboardReadBoardFriendsLocal");

// Class Flame.LeaderboardReadBoardFriendsPlatform
// 0x0000 (0x00F8 - 0x00F8)
class ULeaderboardReadBoardFriendsPlatform final : public ULeaderboardReadBoardBasePlatform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardReadBoardFriendsPlatform">();
	}
	static class ULeaderboardReadBoardFriendsPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardReadBoardFriendsPlatform>();
	}
};
static_assert(alignof(ULeaderboardReadBoardFriendsPlatform) == 0x000008, "Wrong alignment on ULeaderboardReadBoardFriendsPlatform");
static_assert(sizeof(ULeaderboardReadBoardFriendsPlatform) == 0x0000F8, "Wrong size on ULeaderboardReadBoardFriendsPlatform");

// Class Flame.LeaderboardSystemMonitor
// 0x0020 (0x0048 - 0x0028)
class ULeaderboardSystemMonitor : public UObject
{
public:
	TArray<struct FLeaderboardMonitorReadCall>    ReadCalls;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLeaderboardMonitorWriteCall>   WriteCalls;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Init();
	void OnLeaderboardReadCall(const struct FLeaderboardReadContext& BoardContext);
	void OnLeaderboardWriteCall(class FName BoardName, int32 PlayerValue);
	void OnTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardSystemMonitor">();
	}
	static class ULeaderboardSystemMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardSystemMonitor>();
	}
};
static_assert(alignof(ULeaderboardSystemMonitor) == 0x000008, "Wrong alignment on ULeaderboardSystemMonitor");
static_assert(sizeof(ULeaderboardSystemMonitor) == 0x000048, "Wrong size on ULeaderboardSystemMonitor");
static_assert(offsetof(ULeaderboardSystemMonitor, ReadCalls) == 0x000028, "Member 'ULeaderboardSystemMonitor::ReadCalls' has a wrong offset!");
static_assert(offsetof(ULeaderboardSystemMonitor, WriteCalls) == 0x000038, "Member 'ULeaderboardSystemMonitor::WriteCalls' has a wrong offset!");

// Class Flame.LeaderboardWriteBoardLocal
// 0x0008 (0x0090 - 0x0088)
class ULeaderboardWriteBoardLocal final : public ULeaderboardWriteBoardBase
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardLocal">();
	}
	static class ULeaderboardWriteBoardLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardLocal>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardLocal) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardLocal");
static_assert(sizeof(ULeaderboardWriteBoardLocal) == 0x000090, "Wrong size on ULeaderboardWriteBoardLocal");

// Class Flame.LeaderboardWriteBoardPlatformPlaystation
// 0x0008 (0x00C8 - 0x00C0)
class ULeaderboardWriteBoardPlatformPlaystation final : public ULeaderboardWriteBoardPlatform
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardPlatformPlaystation">();
	}
	static class ULeaderboardWriteBoardPlatformPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardPlatformPlaystation>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardPlatformPlaystation) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardPlatformPlaystation");
static_assert(sizeof(ULeaderboardWriteBoardPlatformPlaystation) == 0x0000C8, "Wrong size on ULeaderboardWriteBoardPlatformPlaystation");

// Class Flame.LeaderboardWriteBoardPlatformXbox
// 0x0000 (0x00C0 - 0x00C0)
class ULeaderboardWriteBoardPlatformXbox final : public ULeaderboardWriteBoardPlatform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderboardWriteBoardPlatformXbox">();
	}
	static class ULeaderboardWriteBoardPlatformXbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderboardWriteBoardPlatformXbox>();
	}
};
static_assert(alignof(ULeaderboardWriteBoardPlatformXbox) == 0x000008, "Wrong alignment on ULeaderboardWriteBoardPlatformXbox");
static_assert(sizeof(ULeaderboardWriteBoardPlatformXbox) == 0x0000C0, "Wrong size on ULeaderboardWriteBoardPlatformXbox");

// Class Flame.LinkToStash
// 0x0000 (0x0230 - 0x0230)
class ALinkToStash : public AGameplayStorage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkToStash">();
	}
	static class ALinkToStash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALinkToStash>();
	}
};
static_assert(alignof(ALinkToStash) == 0x000008, "Wrong alignment on ALinkToStash");
static_assert(sizeof(ALinkToStash) == 0x000230, "Wrong size on ALinkToStash");

// Class Flame.Loadout
// 0x0020 (0x0048 - 0x0028)
class ULoadout final : public UObject
{
public:
	TSubclassOf<class APrimaryWeapon>             PrimaryWeaponClass;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASideArmWeapon>             SecondaryWeaponClass;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMeleeWeapon>               MeleeWeaponClass;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AThrowable>                 GrenadeWeaponClass;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout">();
	}
	static class ULoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout>();
	}
};
static_assert(alignof(ULoadout) == 0x000008, "Wrong alignment on ULoadout");
static_assert(sizeof(ULoadout) == 0x000048, "Wrong size on ULoadout");
static_assert(offsetof(ULoadout, PrimaryWeaponClass) == 0x000028, "Member 'ULoadout::PrimaryWeaponClass' has a wrong offset!");
static_assert(offsetof(ULoadout, SecondaryWeaponClass) == 0x000030, "Member 'ULoadout::SecondaryWeaponClass' has a wrong offset!");
static_assert(offsetof(ULoadout, MeleeWeaponClass) == 0x000038, "Member 'ULoadout::MeleeWeaponClass' has a wrong offset!");
static_assert(offsetof(ULoadout, GrenadeWeaponClass) == 0x000040, "Member 'ULoadout::GrenadeWeaponClass' has a wrong offset!");

// Class Flame.LoadoutWidget
// 0x0028 (0x0340 - 0x0318)
class ULoadoutWidget : public UUpdateableWidget
{
public:
	class UWeaponContainerWidget*                 WeaponWheel;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameGridWidget*                       PlayerItemGrid;                                    // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionDestroy;                                     // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionClose;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizableItemProvider*              PlayerItemProvider;                                // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDestroyHold();

	class AItem* GetFocusedItem() const;
	class UFlameSlot* GetFocusedSlot() const;
	bool IsDestroyAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutWidget">();
	}
	static class ULoadoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutWidget>();
	}
};
static_assert(alignof(ULoadoutWidget) == 0x000008, "Wrong alignment on ULoadoutWidget");
static_assert(sizeof(ULoadoutWidget) == 0x000340, "Wrong size on ULoadoutWidget");
static_assert(offsetof(ULoadoutWidget, WeaponWheel) == 0x000318, "Member 'ULoadoutWidget::WeaponWheel' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PlayerItemGrid) == 0x000320, "Member 'ULoadoutWidget::PlayerItemGrid' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, ActionDestroy) == 0x000328, "Member 'ULoadoutWidget::ActionDestroy' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, ActionClose) == 0x000330, "Member 'ULoadoutWidget::ActionClose' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PlayerItemProvider) == 0x000338, "Member 'ULoadoutWidget::PlayerItemProvider' has a wrong offset!");

// Class Flame.LootableWeapon
// 0x0030 (0x0270 - 0x0240)
class ALootableWeapon final : public ALootable
{
public:
	struct FWeaponDescriptor                      WeaponDescriptor;                                  // 0x0240(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         RespawnTime;                                       // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0xC];                                      // 0x0264(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool LootWeapon(class AHumanCharacter* TargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootableWeapon">();
	}
	static class ALootableWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootableWeapon>();
	}
};
static_assert(alignof(ALootableWeapon) == 0x000008, "Wrong alignment on ALootableWeapon");
static_assert(sizeof(ALootableWeapon) == 0x000270, "Wrong size on ALootableWeapon");
static_assert(offsetof(ALootableWeapon, WeaponDescriptor) == 0x000240, "Member 'ALootableWeapon::WeaponDescriptor' has a wrong offset!");
static_assert(offsetof(ALootableWeapon, RespawnTime) == 0x000260, "Member 'ALootableWeapon::RespawnTime' has a wrong offset!");

// Class Flame.LootBoxComponent
// 0x0038 (0x00E8 - 0x00B0)
class ULootBoxComponent final : public UOnlineComponentBase
{
public:
	TWeakObjectPtr<class AHumanPlayerController>  OpenLootboxTarget;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             LootBoxInfoReceived;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AllLootBoxesInfoReceived;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LootBoxOpened;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AllLootBoxesInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxesInfoCloud& LootBoxesInfo);
	int32 GetAllLootBoxesInfoItem(class AHumanPlayerController* Player);
	int32 GetLootBoxInfo(class AHumanPlayerController* Player, const class FString& LootBoxName);
	int32 GetLootBoxInfoItem(class AHumanPlayerController* Player, const TSubclassOf<class AItem>& LootBox);
	void LootBoxInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxInfoCloud& LootBoxInfo);
	int32 OpenLootBox(class AHumanPlayerController* Player, const class FString& LootBoxName);
	void OpenLootBoxDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FLootBoxOpenedCloudResult& LootBoxItems);
	int32 OpenLootBoxItem(class AHumanPlayerController* Player, const TSubclassOf<class AItem>& LootBox);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootBoxComponent">();
	}
	static class ULootBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootBoxComponent>();
	}
};
static_assert(alignof(ULootBoxComponent) == 0x000008, "Wrong alignment on ULootBoxComponent");
static_assert(sizeof(ULootBoxComponent) == 0x0000E8, "Wrong size on ULootBoxComponent");
static_assert(offsetof(ULootBoxComponent, OpenLootboxTarget) == 0x0000B0, "Member 'ULootBoxComponent::OpenLootboxTarget' has a wrong offset!");
static_assert(offsetof(ULootBoxComponent, LootBoxInfoReceived) == 0x0000B8, "Member 'ULootBoxComponent::LootBoxInfoReceived' has a wrong offset!");
static_assert(offsetof(ULootBoxComponent, AllLootBoxesInfoReceived) == 0x0000C8, "Member 'ULootBoxComponent::AllLootBoxesInfoReceived' has a wrong offset!");
static_assert(offsetof(ULootBoxComponent, LootBoxOpened) == 0x0000D8, "Member 'ULootBoxComponent::LootBoxOpened' has a wrong offset!");

// Class Flame.MapsManager
// 0x0018 (0x0040 - 0x0028)
class UMapsManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             GetMapsRotationFinished;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BlueprintDeInit();
	void BlueprintInit();
	class UFlameGameInstance* GetGameInstance();
	int32 GetMapsRotation(class AHumanPlayerController* Player);
	void GetMapsRotationDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudMapRotationsResponse& Data);
	void Tick(float DeltaTime);

	struct FCloudMapRotationSlot GetDefaultMapRotationSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapsManager">();
	}
	static class UMapsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapsManager>();
	}
};
static_assert(alignof(UMapsManager) == 0x000008, "Wrong alignment on UMapsManager");
static_assert(sizeof(UMapsManager) == 0x000040, "Wrong size on UMapsManager");
static_assert(offsetof(UMapsManager, GetMapsRotationFinished) == 0x000030, "Member 'UMapsManager::GetMapsRotationFinished' has a wrong offset!");

// Class Flame.MapTool
// 0x0000 (0x03A0 - 0x03A0)
class AMapTool : public ATool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTool">();
	}
	static class AMapTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapTool>();
	}
};
static_assert(alignof(AMapTool) == 0x000008, "Wrong alignment on AMapTool");
static_assert(sizeof(AMapTool) == 0x0003A0, "Wrong size on AMapTool");

// Class Flame.MatchInfoComponent
// 0x00C0 (0x0170 - 0x00B0)
class UMatchInfoComponent : public UOnlineComponentBase
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             MatchRegistered;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnregisterMatchFinished;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserRegistered;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserUnregistered;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MatchSettingsReceived;                             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MatchSettingsCommited;                             // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LootSettingsReceived;                              // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MatchResultForPlayerSet;                           // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TutorialCompletedSet;                              // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetUserMatchesStatisticFinished;                   // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetMatchLoadoutsFinished;                          // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 CommitMatchSettings(const TArray<struct FCloudUserLobbyInfo>& UserInfos);
	void CommitMatchSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchCommitInfo& CloudSettings);
	int32 GetLootSettings();
	void GetLootSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudLootSettings& LootSettings);
	int32 GetMatchLoadouts(const struct FCloudGetMatchLoadoutsRequest& RequestSettings);
	void GetMatchLoadoutsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchLoadouts& Loadouts);
	int32 GetMatchSettings();
	void GetMatchSettingsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMatchSettingsInfo& CommitSettings);
	int32 GetUserMatchesStatistic(class AHumanPlayerController* Player, ECloudUserMatchStatisticsPeriod TimePeriod);
	void GetUserMatchesStatisticDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, ECloudUserMatchStatisticsPeriod TimePeriod, const struct FCloudUserMatchesStatistic& Data);
	void MatchStartedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& MatchID);
	int32 RegisterMatch(const class FString& GameMode, const class FString& Map);
	int32 RegisterUserToMatch(class AHumanPlayerController* Player, const class FString& GroupName);
	int32 SetMatchResultForPlayer(class AHumanPlayerController* Player, const struct FUserMatchInfo& MatchInfo);
	void SetPlayerMatchDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, const struct FUserMatchReward& Reward);
	int32 SetTutorialCompleted(class AController* Player, bool TutorialCompleted);
	void SetTutorialCompletedDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	int32 UnregisterMatch(const class FString& MatchCloudId);
	void UnregisterMatchDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult);
	int32 UnregisterUserFromMatch(const class FString& Userid);
	void UserRegisteredDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player);
	void UserUnregisteredDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid);

	class FString GetMatchId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchInfoComponent">();
	}
	static class UMatchInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchInfoComponent>();
	}
};
static_assert(alignof(UMatchInfoComponent) == 0x000008, "Wrong alignment on UMatchInfoComponent");
static_assert(sizeof(UMatchInfoComponent) == 0x000170, "Wrong size on UMatchInfoComponent");
static_assert(offsetof(UMatchInfoComponent, MatchRegistered) == 0x0000C0, "Member 'UMatchInfoComponent::MatchRegistered' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, UnregisterMatchFinished) == 0x0000D0, "Member 'UMatchInfoComponent::UnregisterMatchFinished' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, UserRegistered) == 0x0000E0, "Member 'UMatchInfoComponent::UserRegistered' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, UserUnregistered) == 0x0000F0, "Member 'UMatchInfoComponent::UserUnregistered' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, MatchSettingsReceived) == 0x000100, "Member 'UMatchInfoComponent::MatchSettingsReceived' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, MatchSettingsCommited) == 0x000110, "Member 'UMatchInfoComponent::MatchSettingsCommited' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, LootSettingsReceived) == 0x000120, "Member 'UMatchInfoComponent::LootSettingsReceived' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, MatchResultForPlayerSet) == 0x000130, "Member 'UMatchInfoComponent::MatchResultForPlayerSet' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, TutorialCompletedSet) == 0x000140, "Member 'UMatchInfoComponent::TutorialCompletedSet' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, GetUserMatchesStatisticFinished) == 0x000150, "Member 'UMatchInfoComponent::GetUserMatchesStatisticFinished' has a wrong offset!");
static_assert(offsetof(UMatchInfoComponent, GetMatchLoadoutsFinished) == 0x000160, "Member 'UMatchInfoComponent::GetMatchLoadoutsFinished' has a wrong offset!");

// Class Flame.MessageBoxWidget
// 0x0030 (0x0320 - 0x02F0)
class UMessageBoxWidget : public UModalWidget
{
public:
	EMessageBoxType                               Type;                                              // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMessageBoxAction                             Result;                                            // 0x02F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0x6];                                      // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameTextBlock*                        TitleText;                                         // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        MessageText;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ActionsHBox;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActionCancelPressed();
	void OnActionConfirmPressed();
	void OnActionGotItPressed();
	void OnActionNoPressed();
	void OnActionYesPressed();
	void SetMessage(const class FText& InMessage);
	void SetTitle(const class FText& InTitle);
	void SetType(EMessageBoxType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageBoxWidget">();
	}
	static class UMessageBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageBoxWidget>();
	}
};
static_assert(alignof(UMessageBoxWidget) == 0x000008, "Wrong alignment on UMessageBoxWidget");
static_assert(sizeof(UMessageBoxWidget) == 0x000320, "Wrong size on UMessageBoxWidget");
static_assert(offsetof(UMessageBoxWidget, Type) == 0x0002F0, "Member 'UMessageBoxWidget::Type' has a wrong offset!");
static_assert(offsetof(UMessageBoxWidget, Result) == 0x0002F1, "Member 'UMessageBoxWidget::Result' has a wrong offset!");
static_assert(offsetof(UMessageBoxWidget, TitleText) == 0x0002F8, "Member 'UMessageBoxWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UMessageBoxWidget, MessageText) == 0x000300, "Member 'UMessageBoxWidget::MessageText' has a wrong offset!");
static_assert(offsetof(UMessageBoxWidget, ActionsHBox) == 0x000308, "Member 'UMessageBoxWidget::ActionsHBox' has a wrong offset!");

// Class Flame.MotionAimComponent
// 0x0070 (0x0120 - 0x00B0)
class UMotionAimComponent final : public UActorComponent
{
public:
	struct FVector                                DebugVector;                                       // 0x00B0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RealLastTilt;                                      // 0x00BC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimDebug;                                          // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimLerping;                                        // 0x00C9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x56];                                      // 0x00CA(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMotionAimEnabled(bool bEnabled, bool bAlsoSixAxisSensors, bool bAlsoAimAssist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionAimComponent">();
	}
	static class UMotionAimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionAimComponent>();
	}
};
static_assert(alignof(UMotionAimComponent) == 0x000008, "Wrong alignment on UMotionAimComponent");
static_assert(sizeof(UMotionAimComponent) == 0x000120, "Wrong size on UMotionAimComponent");
static_assert(offsetof(UMotionAimComponent, DebugVector) == 0x0000B0, "Member 'UMotionAimComponent::DebugVector' has a wrong offset!");
static_assert(offsetof(UMotionAimComponent, RealLastTilt) == 0x0000BC, "Member 'UMotionAimComponent::RealLastTilt' has a wrong offset!");
static_assert(offsetof(UMotionAimComponent, AimDebug) == 0x0000C8, "Member 'UMotionAimComponent::AimDebug' has a wrong offset!");
static_assert(offsetof(UMotionAimComponent, AimLerping) == 0x0000C9, "Member 'UMotionAimComponent::AimLerping' has a wrong offset!");

// Class Flame.NavLinkClimb
// 0x0048 (0x0268 - 0x0220)
class ANavLinkClimb final : public AActor
{
public:
	class UNavLinkClimbComponent*                 NavLinkClimbComponent;                             // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ToggleTrigger;                                     // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbStart;                                        // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbEnd;                                          // 0x023C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVaultOnLink;                                      // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x17];                                     // 0x0251(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpAfterTime(class AHumanCharacter* HumanCharacter);
	void OnActorBeginOverlapDelegate(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorEndOverlapDelegate(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnNavLinkReached(class UNavLinkCustomComponent* NavLinkComponent, class UObject* Actor, const struct FVector& Destination);
	void SetDefaultTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkClimb">();
	}
	static class ANavLinkClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkClimb>();
	}
};
static_assert(alignof(ANavLinkClimb) == 0x000008, "Wrong alignment on ANavLinkClimb");
static_assert(sizeof(ANavLinkClimb) == 0x000268, "Wrong size on ANavLinkClimb");
static_assert(offsetof(ANavLinkClimb, NavLinkClimbComponent) == 0x000220, "Member 'ANavLinkClimb::NavLinkClimbComponent' has a wrong offset!");
static_assert(offsetof(ANavLinkClimb, ToggleTrigger) == 0x000228, "Member 'ANavLinkClimb::ToggleTrigger' has a wrong offset!");
static_assert(offsetof(ANavLinkClimb, ClimbStart) == 0x000230, "Member 'ANavLinkClimb::ClimbStart' has a wrong offset!");
static_assert(offsetof(ANavLinkClimb, ClimbEnd) == 0x00023C, "Member 'ANavLinkClimb::ClimbEnd' has a wrong offset!");
static_assert(offsetof(ANavLinkClimb, SpriteComponent) == 0x000248, "Member 'ANavLinkClimb::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ANavLinkClimb, bVaultOnLink) == 0x000250, "Member 'ANavLinkClimb::bVaultOnLink' has a wrong offset!");

// Class Flame.NotificationBase
// 0x0018 (0x02D0 - 0x02B8)
class UNotificationBase : public UFlameWidget
{
public:
	struct FNotificationParams                    Parameters;                                        // 0x02B8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x02C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5[0xB];                                      // 0x02C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deactivate();
	void OnHide();
	void OnShow();

	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationBase">();
	}
	static class UNotificationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationBase>();
	}
};
static_assert(alignof(UNotificationBase) == 0x000008, "Wrong alignment on UNotificationBase");
static_assert(sizeof(UNotificationBase) == 0x0002D0, "Wrong size on UNotificationBase");
static_assert(offsetof(UNotificationBase, Parameters) == 0x0002B8, "Member 'UNotificationBase::Parameters' has a wrong offset!");
static_assert(offsetof(UNotificationBase, bIsActive) == 0x0002C4, "Member 'UNotificationBase::bIsActive' has a wrong offset!");

// Class Flame.NotificationSubscriber
// 0x0000 (0x0028 - 0x0028)
class INotificationSubscriber final : public IInterface
{
public:
	void AddNotification(class UNotificationBase* InNotification);

	int32 GetChannels() const;
	int32 GetMinPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationSubscriber">();
	}
	static class INotificationSubscriber* GetDefaultObj()
	{
		return GetDefaultObjImpl<INotificationSubscriber>();
	}
};
static_assert(alignof(INotificationSubscriber) == 0x000008, "Wrong alignment on INotificationSubscriber");
static_assert(sizeof(INotificationSubscriber) == 0x000028, "Wrong size on INotificationSubscriber");

// Class Flame.ObstacleAsset
// 0x0010 (0x0038 - 0x0028)
class UObstacleAsset final : public UObject
{
public:
	TArray<struct FObstacleEdge>                  Edges;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObstacleAsset">();
	}
	static class UObstacleAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObstacleAsset>();
	}
};
static_assert(alignof(UObstacleAsset) == 0x000008, "Wrong alignment on UObstacleAsset");
static_assert(sizeof(UObstacleAsset) == 0x000038, "Wrong size on UObstacleAsset");
static_assert(offsetof(UObstacleAsset, Edges) == 0x000028, "Member 'UObstacleAsset::Edges' has a wrong offset!");

// Class Flame.OnlineCraftingComponent
// 0x0000 (0x00B0 - 0x00B0)
class UOnlineCraftingComponent final : public UOnlineComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineCraftingComponent">();
	}
	static class UOnlineCraftingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineCraftingComponent>();
	}
};
static_assert(alignof(UOnlineCraftingComponent) == 0x000008, "Wrong alignment on UOnlineCraftingComponent");
static_assert(sizeof(UOnlineCraftingComponent) == 0x0000B0, "Wrong size on UOnlineCraftingComponent");

// Class Flame.OnlineChallengesComponent
// 0x0070 (0x0120 - 0x00B0)
class UOnlineChallengesComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             UserChallengeSlotsReceived;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReRollUserChallengeReceived;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserChallengeProgressSet;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserChallengeClaimed;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserSeasonChallengeRewardsReceived;                // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserSeasonChallengeProgressReceived;               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserSeasonChallengeClaimed;                        // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 ClaimUserChallenge(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName);
	void ClaimUserChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeClaimResult& ClaimResult);
	int32 ClaimUserSeasonChallenge(class AHumanPlayerController* Player);
	void ClaimUserSeasonChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeClaimResult& ClaimResult);
	int32 GetUserChallengeSlots(class AHumanPlayerController* Player);
	void GetUserChallengeSlotsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudGetChallengeResponse& Response);
	int32 GetUserSeasonChallengeProgress(class AHumanPlayerController* Player);
	void GetUserSeasonChallengeProgressDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeProgressResult& Response);
	int32 GetUserSeasonChallengeRewards(class AHumanPlayerController* Player);
	void GetUserSeasonChallengeRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudSeasonChallengeRewardsResult& Response);
	int32 ReRollUserChallenge(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName);
	void ReRollUserChallengeDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeClaimResult& Response);
	int32 SetUserChallengeProgress(class AHumanPlayerController* Player, const class FString& SlotCategory, int32 SlotId, const class FName& ChallengeName, int32 Progress);
	void SetUserChallengeProgressDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudChallengeSlotInfo& ProgressResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineChallengesComponent">();
	}
	static class UOnlineChallengesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineChallengesComponent>();
	}
};
static_assert(alignof(UOnlineChallengesComponent) == 0x000008, "Wrong alignment on UOnlineChallengesComponent");
static_assert(sizeof(UOnlineChallengesComponent) == 0x000120, "Wrong size on UOnlineChallengesComponent");
static_assert(offsetof(UOnlineChallengesComponent, UserChallengeSlotsReceived) == 0x0000B0, "Member 'UOnlineChallengesComponent::UserChallengeSlotsReceived' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, ReRollUserChallengeReceived) == 0x0000C0, "Member 'UOnlineChallengesComponent::ReRollUserChallengeReceived' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, UserChallengeProgressSet) == 0x0000D0, "Member 'UOnlineChallengesComponent::UserChallengeProgressSet' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, UserChallengeClaimed) == 0x0000E0, "Member 'UOnlineChallengesComponent::UserChallengeClaimed' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, UserSeasonChallengeRewardsReceived) == 0x0000F0, "Member 'UOnlineChallengesComponent::UserSeasonChallengeRewardsReceived' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, UserSeasonChallengeProgressReceived) == 0x000100, "Member 'UOnlineChallengesComponent::UserSeasonChallengeProgressReceived' has a wrong offset!");
static_assert(offsetof(UOnlineChallengesComponent, UserSeasonChallengeClaimed) == 0x000110, "Member 'UOnlineChallengesComponent::UserSeasonChallengeClaimed' has a wrong offset!");

// Class Flame.OnlineInventoryComponent
// 0x0158 (0x0208 - 0x00B0)
class UOnlineInventoryComponent : public UOnlineComponentBase
{
public:
	uint8                                         Pad_B0[0x158];                                     // 0x00B0(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineInventoryComponent">();
	}
	static class UOnlineInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineInventoryComponent>();
	}
};
static_assert(alignof(UOnlineInventoryComponent) == 0x000008, "Wrong alignment on UOnlineInventoryComponent");
static_assert(sizeof(UOnlineInventoryComponent) == 0x000208, "Wrong size on UOnlineInventoryComponent");

// Class Flame.OnlineMapRewardsComponent
// 0x0010 (0x00C0 - 0x00B0)
class UOnlineMapRewardsComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetMapRewardsFinished;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetMapRewards(class AHumanPlayerController* Player);
	void GetMapRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudMapRewardsResult& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineMapRewardsComponent">();
	}
	static class UOnlineMapRewardsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineMapRewardsComponent>();
	}
};
static_assert(alignof(UOnlineMapRewardsComponent) == 0x000008, "Wrong alignment on UOnlineMapRewardsComponent");
static_assert(sizeof(UOnlineMapRewardsComponent) == 0x0000C0, "Wrong size on UOnlineMapRewardsComponent");
static_assert(offsetof(UOnlineMapRewardsComponent, GetMapRewardsFinished) == 0x0000B0, "Member 'UOnlineMapRewardsComponent::GetMapRewardsFinished' has a wrong offset!");

// Class Flame.OnlineUserLeaderBoardsComponent
// 0x0020 (0x00D0 - 0x00B0)
class UOnlineUserLeaderBoardsComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetUserLeaderBoardDetailFinished;                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetUserLeaderBoardsFinished;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetUserLeaderBoardDetail(class AHumanPlayerController* Player, const struct FCloudUserLeaderBoardDetailRequest& Req);
	void GetUserLeaderBoardDetailDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserLeaderBoardDetailDto& Data);
	int32 GetUserLeaderBoards(class AHumanPlayerController* Player);
	void GetUserLeaderBoardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserLeaderBoards& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineUserLeaderBoardsComponent">();
	}
	static class UOnlineUserLeaderBoardsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineUserLeaderBoardsComponent>();
	}
};
static_assert(alignof(UOnlineUserLeaderBoardsComponent) == 0x000008, "Wrong alignment on UOnlineUserLeaderBoardsComponent");
static_assert(sizeof(UOnlineUserLeaderBoardsComponent) == 0x0000D0, "Wrong size on UOnlineUserLeaderBoardsComponent");
static_assert(offsetof(UOnlineUserLeaderBoardsComponent, GetUserLeaderBoardDetailFinished) == 0x0000B0, "Member 'UOnlineUserLeaderBoardsComponent::GetUserLeaderBoardDetailFinished' has a wrong offset!");
static_assert(offsetof(UOnlineUserLeaderBoardsComponent, GetUserLeaderBoardsFinished) == 0x0000C0, "Member 'UOnlineUserLeaderBoardsComponent::GetUserLeaderBoardsFinished' has a wrong offset!");

// Class Flame.OnlineWeaponCustomizationsComponent
// 0x0000 (0x00B0 - 0x00B0)
class UOnlineWeaponCustomizationsComponent : public UOnlineComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineWeaponCustomizationsComponent">();
	}
	static class UOnlineWeaponCustomizationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineWeaponCustomizationsComponent>();
	}
};
static_assert(alignof(UOnlineWeaponCustomizationsComponent) == 0x000008, "Wrong alignment on UOnlineWeaponCustomizationsComponent");
static_assert(sizeof(UOnlineWeaponCustomizationsComponent) == 0x0000B0, "Wrong size on UOnlineWeaponCustomizationsComponent");

// Class Flame.OnlineWipeRewardsComponent
// 0x0010 (0x00C0 - 0x00B0)
class UOnlineWipeRewardsComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             GetUserWipeRewardsFinished;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetUserWipeRewards(class AHumanPlayerController* Player);
	void GetUserWipeRewardsDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudUserWipeRewards& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineWipeRewardsComponent">();
	}
	static class UOnlineWipeRewardsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineWipeRewardsComponent>();
	}
};
static_assert(alignof(UOnlineWipeRewardsComponent) == 0x000008, "Wrong alignment on UOnlineWipeRewardsComponent");
static_assert(sizeof(UOnlineWipeRewardsComponent) == 0x0000C0, "Wrong size on UOnlineWipeRewardsComponent");
static_assert(offsetof(UOnlineWipeRewardsComponent, GetUserWipeRewardsFinished) == 0x0000B0, "Member 'UOnlineWipeRewardsComponent::GetUserWipeRewardsFinished' has a wrong offset!");

// Class Flame.OptionsElementSlider
// 0x0008 (0x03B0 - 0x03A8)
class UOptionsElementSlider : public UOptionsElementWidget
{
public:
	class UFlameSlider*                           Slider;                                            // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsElementSlider">();
	}
	static class UOptionsElementSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsElementSlider>();
	}
};
static_assert(alignof(UOptionsElementSlider) == 0x000008, "Wrong alignment on UOptionsElementSlider");
static_assert(sizeof(UOptionsElementSlider) == 0x0003B0, "Wrong size on UOptionsElementSlider");
static_assert(offsetof(UOptionsElementSlider, Slider) == 0x0003A8, "Member 'UOptionsElementSlider::Slider' has a wrong offset!");

// Class Flame.WeaponPart
// 0x0000 (0x03B0 - 0x03B0)
class AWeaponPart : public APartItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponPart">();
	}
	static class AWeaponPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponPart>();
	}
};
static_assert(alignof(AWeaponPart) == 0x000008, "Wrong alignment on AWeaponPart");
static_assert(sizeof(AWeaponPart) == 0x0003B0, "Wrong size on AWeaponPart");

// Class Flame.ParticleSystemComponentExtended
// 0x0000 (0x06C0 - 0x06C0)
class UParticleSystemComponentExtended : public UParticleSystemComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemComponentExtended">();
	}
	static class UParticleSystemComponentExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemComponentExtended>();
	}
};
static_assert(alignof(UParticleSystemComponentExtended) == 0x000010, "Wrong alignment on UParticleSystemComponentExtended");
static_assert(sizeof(UParticleSystemComponentExtended) == 0x0006C0, "Wrong size on UParticleSystemComponentExtended");

// Class Flame.GenPerformanceSettings
// 0x0008 (0x0030 - 0x0028)
class UGenPerformanceSettings final : public UObject
{
public:
	int32                                         EnablePerformanceMode;                             // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenPerformanceSettings">();
	}
	static class UGenPerformanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenPerformanceSettings>();
	}
};
static_assert(alignof(UGenPerformanceSettings) == 0x000008, "Wrong alignment on UGenPerformanceSettings");
static_assert(sizeof(UGenPerformanceSettings) == 0x000030, "Wrong size on UGenPerformanceSettings");
static_assert(offsetof(UGenPerformanceSettings, EnablePerformanceMode) == 0x000028, "Member 'UGenPerformanceSettings::EnablePerformanceMode' has a wrong offset!");

// Class Flame.PhysicsFunctions
// 0x0000 (0x0028 - 0x0028)
class UPhysicsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static EPhysicalSurface GetHitOptimisedSurfaceType(const struct FHitResultSimplified& HitOptimised);
	static EPhysicalSurface GetHitSurfaceType(const struct FHitResult& HitResult);
	static bool IsPointInBuilding(class UObject* WorldContextObject, const struct FVector& PointToTest);
	static bool IsPointInWater(float* Depth, struct FVector* WaterSurfaceLocation, class UObject* WorldContextObject, const struct FVector& PointToTest, float DetectionLength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsFunctions">();
	}
	static class UPhysicsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsFunctions>();
	}
};
static_assert(alignof(UPhysicsFunctions) == 0x000008, "Wrong alignment on UPhysicsFunctions");
static_assert(sizeof(UPhysicsFunctions) == 0x000028, "Wrong size on UPhysicsFunctions");

// Class Flame.PlatformStore
// 0x0000 (0x02D8 - 0x02D8)
class UPlatformStore : public UMenuWidget
{
public:
	void OnStoreEmpty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStore">();
	}
	static class UPlatformStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStore>();
	}
};
static_assert(alignof(UPlatformStore) == 0x000008, "Wrong alignment on UPlatformStore");
static_assert(sizeof(UPlatformStore) == 0x0002D8, "Wrong size on UPlatformStore");

// Class Flame.PlatformStoreOfferInfoNull
// 0x0028 (0x0050 - 0x0028)
class UPlatformStoreOfferInfoNull final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoNull">();
	}
	static class UPlatformStoreOfferInfoNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoNull>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoNull) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoNull");
static_assert(sizeof(UPlatformStoreOfferInfoNull) == 0x000050, "Wrong size on UPlatformStoreOfferInfoNull");

// Class Flame.PlatformStoreOfferInfoSteam
// 0x0168 (0x0190 - 0x0028)
class UPlatformStoreOfferInfoSteam final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x168];                                     // 0x0028(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoSteam">();
	}
	static class UPlatformStoreOfferInfoSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoSteam>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoSteam) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoSteam");
static_assert(sizeof(UPlatformStoreOfferInfoSteam) == 0x000190, "Wrong size on UPlatformStoreOfferInfoSteam");

// Class Flame.PlatformStoreOfferInfoSwitch
// 0x0050 (0x0078 - 0x0028)
class UPlatformStoreOfferInfoSwitch final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoSwitch">();
	}
	static class UPlatformStoreOfferInfoSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoSwitch>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoSwitch) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoSwitch");
static_assert(sizeof(UPlatformStoreOfferInfoSwitch) == 0x000078, "Wrong size on UPlatformStoreOfferInfoSwitch");

// Class Flame.PlatformStoreOfferInfoWindows
// 0x0040 (0x0068 - 0x0028)
class UPlatformStoreOfferInfoWindows final : public UPlatformStoreOfferInfo
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOfferInfoWindows">();
	}
	static class UPlatformStoreOfferInfoWindows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOfferInfoWindows>();
	}
};
static_assert(alignof(UPlatformStoreOfferInfoWindows) == 0x000008, "Wrong alignment on UPlatformStoreOfferInfoWindows");
static_assert(sizeof(UPlatformStoreOfferInfoWindows) == 0x000068, "Wrong size on UPlatformStoreOfferInfoWindows");

// Class Flame.PlatformStoreOffersManagerPlaystation
// 0x0008 (0x0088 - 0x0080)
class UPlatformStoreOffersManagerPlaystation final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerPlaystation">();
	}
	static class UPlatformStoreOffersManagerPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerPlaystation>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerPlaystation) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerPlaystation");
static_assert(sizeof(UPlatformStoreOffersManagerPlaystation) == 0x000088, "Wrong size on UPlatformStoreOffersManagerPlaystation");

// Class Flame.PlatformStoreOffersManagerSwitch
// 0x0008 (0x0088 - 0x0080)
class UPlatformStoreOffersManagerSwitch final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerSwitch">();
	}
	static class UPlatformStoreOffersManagerSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerSwitch>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerSwitch) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerSwitch");
static_assert(sizeof(UPlatformStoreOffersManagerSwitch) == 0x000088, "Wrong size on UPlatformStoreOffersManagerSwitch");

// Class Flame.PlatformStoreOffersManagerXbox
// 0x0008 (0x0088 - 0x0080)
class UPlatformStoreOffersManagerXbox final : public UPlatformStoreOffersManager
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreOffersManagerXbox">();
	}
	static class UPlatformStoreOffersManagerXbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreOffersManagerXbox>();
	}
};
static_assert(alignof(UPlatformStoreOffersManagerXbox) == 0x000008, "Wrong alignment on UPlatformStoreOffersManagerXbox");
static_assert(sizeof(UPlatformStoreOffersManagerXbox) == 0x000088, "Wrong size on UPlatformStoreOffersManagerXbox");

// Class Flame.PlatformStorePurchaseHandlerGeneric
// 0x0000 (0x0078 - 0x0078)
class UPlatformStorePurchaseHandlerGeneric final : public UPlatformStorePurchaseHandlerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStorePurchaseHandlerGeneric">();
	}
	static class UPlatformStorePurchaseHandlerGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStorePurchaseHandlerGeneric>();
	}
};
static_assert(alignof(UPlatformStorePurchaseHandlerGeneric) == 0x000008, "Wrong alignment on UPlatformStorePurchaseHandlerGeneric");
static_assert(sizeof(UPlatformStorePurchaseHandlerGeneric) == 0x000078, "Wrong size on UPlatformStorePurchaseHandlerGeneric");

// Class Flame.PlatformStorePurchaseHandlerSteam
// 0x0038 (0x00B0 - 0x0078)
class UPlatformStorePurchaseHandlerSteam final : public UPlatformStorePurchaseHandlerBase
{
public:
	float                                         PurchaseSignaledToCloudRetriesIntervalInSeconds;   // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfPurchaseSignaledToCloudRetries;            // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x30];                                      // 0x0080(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStorePurchaseHandlerSteam">();
	}
	static class UPlatformStorePurchaseHandlerSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStorePurchaseHandlerSteam>();
	}
};
static_assert(alignof(UPlatformStorePurchaseHandlerSteam) == 0x000008, "Wrong alignment on UPlatformStorePurchaseHandlerSteam");
static_assert(sizeof(UPlatformStorePurchaseHandlerSteam) == 0x0000B0, "Wrong size on UPlatformStorePurchaseHandlerSteam");
static_assert(offsetof(UPlatformStorePurchaseHandlerSteam, PurchaseSignaledToCloudRetriesIntervalInSeconds) == 0x000078, "Member 'UPlatformStorePurchaseHandlerSteam::PurchaseSignaledToCloudRetriesIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UPlatformStorePurchaseHandlerSteam, NumberOfPurchaseSignaledToCloudRetries) == 0x00007C, "Member 'UPlatformStorePurchaseHandlerSteam::NumberOfPurchaseSignaledToCloudRetries' has a wrong offset!");

// Class Flame.PlatformStorePurchaseHandlerSteamMicrotransaction
// 0x0058 (0x00D0 - 0x0078)
class UPlatformStorePurchaseHandlerSteamMicrotransaction final : public UPlatformStorePurchaseHandlerBase
{
public:
	uint8                                         Pad_78[0x58];                                      // 0x0078(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStorePurchaseHandlerSteamMicrotransaction">();
	}
	static class UPlatformStorePurchaseHandlerSteamMicrotransaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStorePurchaseHandlerSteamMicrotransaction>();
	}
};
static_assert(alignof(UPlatformStorePurchaseHandlerSteamMicrotransaction) == 0x000008, "Wrong alignment on UPlatformStorePurchaseHandlerSteamMicrotransaction");
static_assert(sizeof(UPlatformStorePurchaseHandlerSteamMicrotransaction) == 0x0000D0, "Wrong size on UPlatformStorePurchaseHandlerSteamMicrotransaction");

// Class Flame.PlatformStoreRefreshPurchasesHandlerPlaystation
// 0x0000 (0x0078 - 0x0078)
class UPlatformStoreRefreshPurchasesHandlerPlaystation final : public UPlatformStoreRefreshPurchasesHandlerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreRefreshPurchasesHandlerPlaystation">();
	}
	static class UPlatformStoreRefreshPurchasesHandlerPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreRefreshPurchasesHandlerPlaystation>();
	}
};
static_assert(alignof(UPlatformStoreRefreshPurchasesHandlerPlaystation) == 0x000008, "Wrong alignment on UPlatformStoreRefreshPurchasesHandlerPlaystation");
static_assert(sizeof(UPlatformStoreRefreshPurchasesHandlerPlaystation) == 0x000078, "Wrong size on UPlatformStoreRefreshPurchasesHandlerPlaystation");

// Class Flame.PlatformStoreSettings
// 0x0030 (0x0068 - 0x0038)
class UPlatformStoreSettings final : public UDeveloperSettings
{
public:
	int32                                         SCEEPlaystationServiceLabel;                       // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SCEEPlaystationTitleId;                            // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SCEAPlaystationServiceLabel;                       // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SCEAPlaystationTitleId;                            // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreSettings">();
	}
	static class UPlatformStoreSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreSettings>();
	}
};
static_assert(alignof(UPlatformStoreSettings) == 0x000008, "Wrong alignment on UPlatformStoreSettings");
static_assert(sizeof(UPlatformStoreSettings) == 0x000068, "Wrong size on UPlatformStoreSettings");
static_assert(offsetof(UPlatformStoreSettings, SCEEPlaystationServiceLabel) == 0x000038, "Member 'UPlatformStoreSettings::SCEEPlaystationServiceLabel' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSettings, SCEEPlaystationTitleId) == 0x000040, "Member 'UPlatformStoreSettings::SCEEPlaystationTitleId' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSettings, SCEAPlaystationServiceLabel) == 0x000050, "Member 'UPlatformStoreSettings::SCEAPlaystationServiceLabel' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSettings, SCEAPlaystationTitleId) == 0x000058, "Member 'UPlatformStoreSettings::SCEAPlaystationTitleId' has a wrong offset!");

// Class Flame.PlatformStoreSystem
// 0x00B0 (0x00D8 - 0x0028)
class UPlatformStoreSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformStoreOffersManager*            PlatformOffers;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformStoreUnexpectedPurchaseWatcherBase* PurchaseWatcher;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformStorePurchaseHandlerBase*      PurchaseRequest;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlatformStoreRefreshPurchasesHandlerBase* RefreshPurchasesRequest;                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SystemShopClosed;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRefreshPlatformPurchasesFinished;                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlatformStoreOffersManager* GetPlatformStoreOffersManager(const class UObject* WorldContextObject);

	bool CheckoutInSystemShop(const struct FUniqueNetIdRepl& InUserId, const class FString& ProductId);
	class UPlatformStorePurchaseHandlerBase* GetCurrentPurchaseRequest();
	void OnPurchaseFinished(const struct FCloudRequestResult& CloudRequestResult, const struct FGameStorePurchaseResult& GameStorePurchaseResult);
	void OnStoreOverlayActivated(bool bIsActive);
	bool OpenSystemShop(int32 ControllerId);
	bool OpenSystemShopItem(int32 ControllerId, const class FString& PlatformProductId);
	void RefreshPlatformPurchasesFinished__DelegateSignature(const struct FUniqueNetIdRepl& Userid, const struct FCloudRequestResult& Result);
	bool RefreshPlatformPurchasesOnCloud(const class APlayerController* Controller, struct FUniqueNetIdRepl* ControllerUserId);
	void SetPurchaseFinishedDelegate(TDelegate<void(struct FCloudRequestResult& CloudRequestResult, struct FGameStorePurchaseResult& GameStorePurchaseResult)> Callback);
	bool ShowLastPlatfromRefreshErrorMessage(const struct FUniqueNetIdRepl& InUserId, bool ClearError);
	void SystemShopClosed__DelegateSignature(bool Purchased);

	bool IsAllowedToMakePurchases(const struct FUniqueNetIdRepl& Userid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreSystem">();
	}
	static class UPlatformStoreSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreSystem>();
	}
};
static_assert(alignof(UPlatformStoreSystem) == 0x000008, "Wrong alignment on UPlatformStoreSystem");
static_assert(sizeof(UPlatformStoreSystem) == 0x0000D8, "Wrong size on UPlatformStoreSystem");
static_assert(offsetof(UPlatformStoreSystem, PlatformOffers) == 0x000060, "Member 'UPlatformStoreSystem::PlatformOffers' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSystem, PurchaseWatcher) == 0x000068, "Member 'UPlatformStoreSystem::PurchaseWatcher' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSystem, PurchaseRequest) == 0x000070, "Member 'UPlatformStoreSystem::PurchaseRequest' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSystem, RefreshPurchasesRequest) == 0x000078, "Member 'UPlatformStoreSystem::RefreshPurchasesRequest' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSystem, SystemShopClosed) == 0x000080, "Member 'UPlatformStoreSystem::SystemShopClosed' has a wrong offset!");
static_assert(offsetof(UPlatformStoreSystem, OnRefreshPlatformPurchasesFinished) == 0x0000A8, "Member 'UPlatformStoreSystem::OnRefreshPlatformPurchasesFinished' has a wrong offset!");

// Class Flame.PlatformStoreUnexpectedPurchaseWatcherGeneric
// 0x0000 (0x0078 - 0x0078)
class UPlatformStoreUnexpectedPurchaseWatcherGeneric final : public UPlatformStoreUnexpectedPurchaseWatcherBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreUnexpectedPurchaseWatcherGeneric">();
	}
	static class UPlatformStoreUnexpectedPurchaseWatcherGeneric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreUnexpectedPurchaseWatcherGeneric>();
	}
};
static_assert(alignof(UPlatformStoreUnexpectedPurchaseWatcherGeneric) == 0x000008, "Wrong alignment on UPlatformStoreUnexpectedPurchaseWatcherGeneric");
static_assert(sizeof(UPlatformStoreUnexpectedPurchaseWatcherGeneric) == 0x000078, "Wrong size on UPlatformStoreUnexpectedPurchaseWatcherGeneric");

// Class Flame.PlatformStoreUnexpectedPurchaseWatcherPlaystation
// 0x0000 (0x0078 - 0x0078)
class UPlatformStoreUnexpectedPurchaseWatcherPlaystation final : public UPlatformStoreUnexpectedPurchaseWatcherBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreUnexpectedPurchaseWatcherPlaystation">();
	}
	static class UPlatformStoreUnexpectedPurchaseWatcherPlaystation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreUnexpectedPurchaseWatcherPlaystation>();
	}
};
static_assert(alignof(UPlatformStoreUnexpectedPurchaseWatcherPlaystation) == 0x000008, "Wrong alignment on UPlatformStoreUnexpectedPurchaseWatcherPlaystation");
static_assert(sizeof(UPlatformStoreUnexpectedPurchaseWatcherPlaystation) == 0x000078, "Wrong size on UPlatformStoreUnexpectedPurchaseWatcherPlaystation");

// Class Flame.PlatformToolsSteam
// 0x0038 (0x0060 - 0x0028)
class UPlatformToolsSteam final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSteamOverlayActivated;                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMicrotransactionEnabled();
	bool IsOverlayEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformToolsSteam">();
	}
	static class UPlatformToolsSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformToolsSteam>();
	}
};
static_assert(alignof(UPlatformToolsSteam) == 0x000008, "Wrong alignment on UPlatformToolsSteam");
static_assert(sizeof(UPlatformToolsSteam) == 0x000060, "Wrong size on UPlatformToolsSteam");
static_assert(offsetof(UPlatformToolsSteam, OnSteamOverlayActivated) == 0x000040, "Member 'UPlatformToolsSteam::OnSteamOverlayActivated' has a wrong offset!");

// Class Flame.PlayerGroupInfo
// 0x0078 (0x00A0 - 0x0028)
class UPlayerGroupInfo : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupId;                                           // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckNewPlayer(class AHumanPlayerController* Controller);
	class APlayerStartFlame* FindPlayerStartForController(class AHumanPlayerController* Controller);
	TArray<class AHumanPlayerController*> GetControllers();
	class APlayerStartPrimary* GetPrimaryGroupStart();

	int32 GetPlayerCount(bool OnlyActive) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGroupInfo">();
	}
	static class UPlayerGroupInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGroupInfo>();
	}
};
static_assert(alignof(UPlayerGroupInfo) == 0x000008, "Wrong alignment on UPlayerGroupInfo");
static_assert(sizeof(UPlayerGroupInfo) == 0x0000A0, "Wrong size on UPlayerGroupInfo");
static_assert(offsetof(UPlayerGroupInfo, GroupId) == 0x000080, "Member 'UPlayerGroupInfo::GroupId' has a wrong offset!");

// Class Flame.PlayerGroupsManager
// 0x0038 (0x0060 - 0x0028)
class UPlayerGroupsManager : public UObject
{
public:
	TArray<class UPlayerGroupInfo*>               Groups;                                            // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPlayerGroupInfo*>               Solos;                                             // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPlayerGroupInfo*>               AllGroups;                                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerGroupInfo>           PlayerGroupInfoClass;                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGroupsManager">();
	}
	static class UPlayerGroupsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGroupsManager>();
	}
};
static_assert(alignof(UPlayerGroupsManager) == 0x000008, "Wrong alignment on UPlayerGroupsManager");
static_assert(sizeof(UPlayerGroupsManager) == 0x000060, "Wrong size on UPlayerGroupsManager");
static_assert(offsetof(UPlayerGroupsManager, Groups) == 0x000028, "Member 'UPlayerGroupsManager::Groups' has a wrong offset!");
static_assert(offsetof(UPlayerGroupsManager, Solos) == 0x000038, "Member 'UPlayerGroupsManager::Solos' has a wrong offset!");
static_assert(offsetof(UPlayerGroupsManager, AllGroups) == 0x000048, "Member 'UPlayerGroupsManager::AllGroups' has a wrong offset!");
static_assert(offsetof(UPlayerGroupsManager, PlayerGroupInfoClass) == 0x000058, "Member 'UPlayerGroupsManager::PlayerGroupInfoClass' has a wrong offset!");

// Class Flame.PlayerInfoWidget
// 0x0040 (0x03D8 - 0x0398)
class UPlayerInfoWidget : public UListButtonWidget
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x0398(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProfilePictureWidget*                  ProfilePicture;                                    // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerNicknameWidget*                  PlayerNickname;                                    // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerPresenceWidget*                  PlayerPresence;                                    // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerChanged();
	void SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId);

	bool IsValidPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInfoWidget">();
	}
	static class UPlayerInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInfoWidget>();
	}
};
static_assert(alignof(UPlayerInfoWidget) == 0x000008, "Wrong alignment on UPlayerInfoWidget");
static_assert(sizeof(UPlayerInfoWidget) == 0x0003D8, "Wrong size on UPlayerInfoWidget");
static_assert(offsetof(UPlayerInfoWidget, PlayerNetId) == 0x000398, "Member 'UPlayerInfoWidget::PlayerNetId' has a wrong offset!");
static_assert(offsetof(UPlayerInfoWidget, ProfilePicture) == 0x0003C0, "Member 'UPlayerInfoWidget::ProfilePicture' has a wrong offset!");
static_assert(offsetof(UPlayerInfoWidget, PlayerNickname) == 0x0003C8, "Member 'UPlayerInfoWidget::PlayerNickname' has a wrong offset!");
static_assert(offsetof(UPlayerInfoWidget, PlayerPresence) == 0x0003D0, "Member 'UPlayerInfoWidget::PlayerPresence' has a wrong offset!");

// Class Flame.PlayerLobby
// 0x0010 (0x0230 - 0x0220)
class APlayerLobby : public AActor
{
public:
	TArray<class APlayerStartLobby*>              LobbyStarts;                                       // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void PreparePlayerStarts();
	class APlayerStartFlame* SelectNextLobbyStartForPlayer(class AController* Player);
	void SetReady(class UMarketplaceComponent* TheInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLobby">();
	}
	static class APlayerLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerLobby>();
	}
};
static_assert(alignof(APlayerLobby) == 0x000008, "Wrong alignment on APlayerLobby");
static_assert(sizeof(APlayerLobby) == 0x000230, "Wrong size on APlayerLobby");
static_assert(offsetof(APlayerLobby, LobbyStarts) == 0x000220, "Member 'APlayerLobby::LobbyStarts' has a wrong offset!");

// Class Flame.PlayerNicknameWidget
// 0x0188 (0x0440 - 0x02B8)
class UPlayerNicknameWidget : public UFlameWidget
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x02B8(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         PlayerNickname;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DownloadIcon;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlatformIcon;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDownloadIcon;                                 // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseTestingName;                                    // 0x02F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TestingName;                                       // 0x0300(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfCharactersDisplayed;                    // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            CharacterLenghtfontSizeTresholds;                  // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   NoNickname;                                        // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EFlamePlatform                                DefaultPlatform;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInactivePlayerInfo                    OfflinePlayerInfo;                                 // 0x0390(0x0048)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFlamePlatform, class UTexture2D*>       PlatfromIconMap;                                   // 0x03E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             OtherPlatfromIcon;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustIconSizeToFontSize(int32 FontSize, class UImage* Icon);
	void SetDefaultNameAndPlatform(const class FString& Name_0, EFlamePlatform Platform);
	void SetMaximumCharacters(int32 Max);
	void SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId);
	void SetPlayerOfflineInfo(const struct FUniqueNetIdRepl& InPlayerNetId, const class FString& Name_0, EFlamePlatform Platform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNicknameWidget">();
	}
	static class UPlayerNicknameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNicknameWidget>();
	}
};
static_assert(alignof(UPlayerNicknameWidget) == 0x000008, "Wrong alignment on UPlayerNicknameWidget");
static_assert(sizeof(UPlayerNicknameWidget) == 0x000440, "Wrong size on UPlayerNicknameWidget");
static_assert(offsetof(UPlayerNicknameWidget, PlayerNetId) == 0x0002B8, "Member 'UPlayerNicknameWidget::PlayerNetId' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, PlayerNickname) == 0x0002E0, "Member 'UPlayerNicknameWidget::PlayerNickname' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, DownloadIcon) == 0x0002E8, "Member 'UPlayerNicknameWidget::DownloadIcon' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, PlatformIcon) == 0x0002F0, "Member 'UPlayerNicknameWidget::PlatformIcon' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, bShowDownloadIcon) == 0x0002F8, "Member 'UPlayerNicknameWidget::bShowDownloadIcon' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, UseTestingName) == 0x0002F9, "Member 'UPlayerNicknameWidget::UseTestingName' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, TestingName) == 0x000300, "Member 'UPlayerNicknameWidget::TestingName' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, MaxNumberOfCharactersDisplayed) == 0x000318, "Member 'UPlayerNicknameWidget::MaxNumberOfCharactersDisplayed' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, CharacterLenghtfontSizeTresholds) == 0x000320, "Member 'UPlayerNicknameWidget::CharacterLenghtfontSizeTresholds' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, NoNickname) == 0x000370, "Member 'UPlayerNicknameWidget::NoNickname' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, DefaultPlatform) == 0x000388, "Member 'UPlayerNicknameWidget::DefaultPlatform' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, OfflinePlayerInfo) == 0x000390, "Member 'UPlayerNicknameWidget::OfflinePlayerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, PlatfromIconMap) == 0x0003E0, "Member 'UPlayerNicknameWidget::PlatfromIconMap' has a wrong offset!");
static_assert(offsetof(UPlayerNicknameWidget, OtherPlatfromIcon) == 0x000430, "Member 'UPlayerNicknameWidget::OtherPlatfromIcon' has a wrong offset!");

// Class Flame.PlayerNotification
// 0x0028 (0x02F8 - 0x02D0)
class UPlayerNotification : public UNotificationBase
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x02D0(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerChanged();
	void SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNotification">();
	}
	static class UPlayerNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNotification>();
	}
};
static_assert(alignof(UPlayerNotification) == 0x000008, "Wrong alignment on UPlayerNotification");
static_assert(sizeof(UPlayerNotification) == 0x0002F8, "Wrong size on UPlayerNotification");
static_assert(offsetof(UPlayerNotification, PlayerNetId) == 0x0002D0, "Member 'UPlayerNotification::PlayerNetId' has a wrong offset!");

// Class Flame.PlayerPresenceWidget
// 0x0038 (0x02F0 - 0x02B8)
class UPlayerPresenceWidget : public UFlameWidget
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x02B8(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PresenceIcon;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        PresenceText;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPresenceUpdated(EPlayerPresence InPresence);
	void SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPresenceWidget">();
	}
	static class UPlayerPresenceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPresenceWidget>();
	}
};
static_assert(alignof(UPlayerPresenceWidget) == 0x000008, "Wrong alignment on UPlayerPresenceWidget");
static_assert(sizeof(UPlayerPresenceWidget) == 0x0002F0, "Wrong size on UPlayerPresenceWidget");
static_assert(offsetof(UPlayerPresenceWidget, PlayerNetId) == 0x0002B8, "Member 'UPlayerPresenceWidget::PlayerNetId' has a wrong offset!");
static_assert(offsetof(UPlayerPresenceWidget, PresenceIcon) == 0x0002E0, "Member 'UPlayerPresenceWidget::PresenceIcon' has a wrong offset!");
static_assert(offsetof(UPlayerPresenceWidget, PresenceText) == 0x0002E8, "Member 'UPlayerPresenceWidget::PresenceText' has a wrong offset!");

// Class Flame.PlayersFunctions
// 0x0000 (0x0028 - 0x0028)
class UPlayersFunctions final : public UBlueprintFunctionLibrary
{
public:
	static TArray<TSubclassOf<class AAmmoItem>> GetAvailableAmmo(const class APlayerController* Controller);
	static TArray<TSubclassOf<class AConsumableItem>> GetAvailableConsumables(const class APlayerController* Controller);
	static TArray<TSubclassOf<class AWeapon>> GetAvailableWeapons(const class APlayerController* Controller);
	static float GetAverageDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static float GetAverageSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static float GetMaxDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static float GetMaxSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static float GetMinDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static float GetMinSquaredDistToPlayers(class UObject* WorldContextObject, const struct FVector& WorldPos);
	static TArray<class APlayerController*> GetPlayerControllers(class UObject* WorldContextObject, bool IgnoreWithoutPawn);
	static int32 GetPlayersCount(class UObject* WorldContextObject, bool IgnoreWithoutPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersFunctions">();
	}
	static class UPlayersFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersFunctions>();
	}
};
static_assert(alignof(UPlayersFunctions) == 0x000008, "Wrong alignment on UPlayersFunctions");
static_assert(sizeof(UPlayersFunctions) == 0x000028, "Wrong size on UPlayersFunctions");

// Class Flame.PlayerStartLobby
// 0x0008 (0x0290 - 0x0288)
class APlayerStartLobby final : public APlayerStartFlame
{
public:
	int32                                         StartIndex;                                        // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartLobby">();
	}
	static class APlayerStartLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartLobby>();
	}
};
static_assert(alignof(APlayerStartLobby) == 0x000008, "Wrong alignment on APlayerStartLobby");
static_assert(sizeof(APlayerStartLobby) == 0x000290, "Wrong size on APlayerStartLobby");
static_assert(offsetof(APlayerStartLobby, StartIndex) == 0x000288, "Member 'APlayerStartLobby::StartIndex' has a wrong offset!");

// Class Flame.PlayerStartPrimary
// 0x0010 (0x0298 - 0x0288)
class APlayerStartPrimary : public APlayerStartFlame
{
public:
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APlayerStartFlame* FindStartForPlayer(class AHumanPlayerController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartPrimary">();
	}
	static class APlayerStartPrimary* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartPrimary>();
	}
};
static_assert(alignof(APlayerStartPrimary) == 0x000008, "Wrong alignment on APlayerStartPrimary");
static_assert(sizeof(APlayerStartPrimary) == 0x000298, "Wrong size on APlayerStartPrimary");

// Class Flame.PlayerStartSecondary
// 0x0008 (0x0290 - 0x0288)
class APlayerStartSecondary : public APlayerStartFlame
{
public:
	int32                                         StartIndex;                                        // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartSecondary">();
	}
	static class APlayerStartSecondary* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartSecondary>();
	}
};
static_assert(alignof(APlayerStartSecondary) == 0x000008, "Wrong alignment on APlayerStartSecondary");
static_assert(sizeof(APlayerStartSecondary) == 0x000290, "Wrong size on APlayerStartSecondary");
static_assert(offsetof(APlayerStartSecondary, StartIndex) == 0x000288, "Member 'APlayerStartSecondary::StartIndex' has a wrong offset!");

// Class Flame.PlayReloadSoundNotify
// 0x0008 (0x0040 - 0x0038)
class UPlayReloadSoundNotify final : public UAnimNotify
{
public:
	class USoundBase*                             Sound;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayReloadSoundNotify">();
	}
	static class UPlayReloadSoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayReloadSoundNotify>();
	}
};
static_assert(alignof(UPlayReloadSoundNotify) == 0x000008, "Wrong alignment on UPlayReloadSoundNotify");
static_assert(sizeof(UPlayReloadSoundNotify) == 0x000040, "Wrong size on UPlayReloadSoundNotify");
static_assert(offsetof(UPlayReloadSoundNotify, Sound) == 0x000038, "Member 'UPlayReloadSoundNotify::Sound' has a wrong offset!");

// Class Flame.PlaySoundExtendedNotify
// 0x0000 (0x0058 - 0x0058)
class UPlaySoundExtendedNotify final : public UAnimNotify_PlaySound
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaySoundExtendedNotify">();
	}
	static class UPlaySoundExtendedNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaySoundExtendedNotify>();
	}
};
static_assert(alignof(UPlaySoundExtendedNotify) == 0x000008, "Wrong alignment on UPlaySoundExtendedNotify");
static_assert(sizeof(UPlaySoundExtendedNotify) == 0x000058, "Wrong size on UPlaySoundExtendedNotify");

// Class Flame.PoiseComponent
// 0x0020 (0x00D0 - 0x00B0)
class UPoiseComponent : public UActorComponent
{
public:
	struct FPoisebar                              BarStunStagger;                                    // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             WeaponTypeStaggerConfiguration;                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FPoiseInfo Inflict(float Damage, const class AWeapon* Weapon, EDamageType DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoiseComponent">();
	}
	static class UPoiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoiseComponent>();
	}
};
static_assert(alignof(UPoiseComponent) == 0x000008, "Wrong alignment on UPoiseComponent");
static_assert(sizeof(UPoiseComponent) == 0x0000D0, "Wrong size on UPoiseComponent");
static_assert(offsetof(UPoiseComponent, BarStunStagger) == 0x0000B0, "Member 'UPoiseComponent::BarStunStagger' has a wrong offset!");
static_assert(offsetof(UPoiseComponent, WeaponTypeStaggerConfiguration) == 0x0000C8, "Member 'UPoiseComponent::WeaponTypeStaggerConfiguration' has a wrong offset!");

// Class Flame.ProjectileWeapon
// 0x0160 (0x0D00 - 0x0BA0)
class AProjectileWeapon : public AWeapon
{
public:
	class FName                                   MuzzleSocketName;                                  // 0x0BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnCasingsAndBeltParticlesManually;              // 0x0BA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA9[0x7];                                      // 0x0BA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponCollisionData>       WeaponCollisionClass;                              // 0x0BB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AWeaponMagazine>            MagazineClass;                                     // 0x0BB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               FireMuzzleParticleSystem;                          // 0x0BC0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               BulletCasingParticleSystem;                        // 0x0BC8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BulletCasingSocket;                                // 0x0BD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               BeltParticleSystem;                                // 0x0BD8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BeltSocket;                                        // 0x0BE0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BE8[0xB8];                                     // 0x0BE8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletManager*                         _BulletManager;                                    // 0x0CA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA8[0x20];                                     // 0x0CA8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponMagazine*                        CurrentLoadedMagazine;                             // 0x0CC8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ChamberLoadedAmmo;                                 // 0x0CD0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD4[0x4];                                      // 0x0CD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAmmoCount;                                  // 0x0CD8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CDC[0x4];                                      // 0x0CDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagazineSize;                                      // 0x0CE0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ChamberSize;                                       // 0x0CE4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE8[0x18];                                     // 0x0CE8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifySpreadAboutFire();
	void MulticastFireBullet(const struct FVector_NetQuantize& Location, const TArray<struct FVector_NetQuantizeNormal>& Directions, bool bShouldSpawnTracer);
	void OnRep_AmmoCount(int32 PreviousCount);
	void OnRep_ChamberLoadedAmmoCount(int32 PreviousCount);
	void ServerSendShot_Anticheat();

	int32 GetChamberLoadedAmmo() const;
	int32 GetCurrentAmmoCount() const;
	float GetCurrentAmmoRatio() const;
	int32 GetCurrentChamberCount() const;
	float GetCurrentModifiedDispersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileWeapon">();
	}
	static class AProjectileWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileWeapon>();
	}
};
static_assert(alignof(AProjectileWeapon) == 0x000010, "Wrong alignment on AProjectileWeapon");
static_assert(sizeof(AProjectileWeapon) == 0x000D00, "Wrong size on AProjectileWeapon");
static_assert(offsetof(AProjectileWeapon, MuzzleSocketName) == 0x000BA0, "Member 'AProjectileWeapon::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, SpawnCasingsAndBeltParticlesManually) == 0x000BA8, "Member 'AProjectileWeapon::SpawnCasingsAndBeltParticlesManually' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, WeaponCollisionClass) == 0x000BB0, "Member 'AProjectileWeapon::WeaponCollisionClass' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MagazineClass) == 0x000BB8, "Member 'AProjectileWeapon::MagazineClass' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, FireMuzzleParticleSystem) == 0x000BC0, "Member 'AProjectileWeapon::FireMuzzleParticleSystem' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, BulletCasingParticleSystem) == 0x000BC8, "Member 'AProjectileWeapon::BulletCasingParticleSystem' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, BulletCasingSocket) == 0x000BD0, "Member 'AProjectileWeapon::BulletCasingSocket' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, BeltParticleSystem) == 0x000BD8, "Member 'AProjectileWeapon::BeltParticleSystem' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, BeltSocket) == 0x000BE0, "Member 'AProjectileWeapon::BeltSocket' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, _BulletManager) == 0x000CA0, "Member 'AProjectileWeapon::_BulletManager' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, CurrentLoadedMagazine) == 0x000CC8, "Member 'AProjectileWeapon::CurrentLoadedMagazine' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ChamberLoadedAmmo) == 0x000CD0, "Member 'AProjectileWeapon::ChamberLoadedAmmo' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, CurrentAmmoCount) == 0x000CD8, "Member 'AProjectileWeapon::CurrentAmmoCount' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MagazineSize) == 0x000CE0, "Member 'AProjectileWeapon::MagazineSize' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ChamberSize) == 0x000CE4, "Member 'AProjectileWeapon::ChamberSize' has a wrong offset!");

// Class Flame.PrimaryWeapon
// 0x0000 (0x0D00 - 0x0D00)
class APrimaryWeapon : public AProjectileWeapon
{
public:
	void OnEnter1PV();
	void OnExit1PV();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryWeapon">();
	}
	static class APrimaryWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrimaryWeapon>();
	}
};
static_assert(alignof(APrimaryWeapon) == 0x000010, "Wrong alignment on APrimaryWeapon");
static_assert(sizeof(APrimaryWeapon) == 0x000D00, "Wrong size on APrimaryWeapon");

// Class Flame.ProfilePictureQuery
// 0x0048 (0x0070 - 0x0028)
class UProfilePictureQuery final : public UObject
{
public:
	struct FUniqueNetIdRepl                       NetId;                                             // 0x0028(0x0028)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAsyncTaskDownloadImage*                AsyncDownloadTask;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDownloadImageFailed(class UTexture2DDynamic* Texture);
	void OnDownloadImageSucceeded(class UTexture2DDynamic* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfilePictureQuery">();
	}
	static class UProfilePictureQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfilePictureQuery>();
	}
};
static_assert(alignof(UProfilePictureQuery) == 0x000008, "Wrong alignment on UProfilePictureQuery");
static_assert(sizeof(UProfilePictureQuery) == 0x000070, "Wrong size on UProfilePictureQuery");
static_assert(offsetof(UProfilePictureQuery, NetId) == 0x000028, "Member 'UProfilePictureQuery::NetId' has a wrong offset!");
static_assert(offsetof(UProfilePictureQuery, AsyncDownloadTask) == 0x000050, "Member 'UProfilePictureQuery::AsyncDownloadTask' has a wrong offset!");

// Class Flame.ProfilePictureWidget
// 0x0050 (0x0308 - 0x02B8)
class UProfilePictureWidget : public UFlameWidget
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x02B8(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProfilePicture;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DownloadIcon;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             NoPictureIcon;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             NoPlayerIcon;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoPlayerIconOpacity;                               // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDownloadIcon;                                 // 0x0304(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDownloadCompleted(const struct FUniqueNetIdRepl& InPlayerNetId, class UTexture2DDynamic* InTexture);
	void OnDownloadStarted(const struct FUniqueNetIdRepl& InPlayerNetId);
	void SetPlayerNetId(const struct FUniqueNetIdRepl& InPlayerNetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfilePictureWidget">();
	}
	static class UProfilePictureWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfilePictureWidget>();
	}
};
static_assert(alignof(UProfilePictureWidget) == 0x000008, "Wrong alignment on UProfilePictureWidget");
static_assert(sizeof(UProfilePictureWidget) == 0x000308, "Wrong size on UProfilePictureWidget");
static_assert(offsetof(UProfilePictureWidget, PlayerNetId) == 0x0002B8, "Member 'UProfilePictureWidget::PlayerNetId' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, ProfilePicture) == 0x0002E0, "Member 'UProfilePictureWidget::ProfilePicture' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, DownloadIcon) == 0x0002E8, "Member 'UProfilePictureWidget::DownloadIcon' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, NoPictureIcon) == 0x0002F0, "Member 'UProfilePictureWidget::NoPictureIcon' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, NoPlayerIcon) == 0x0002F8, "Member 'UProfilePictureWidget::NoPlayerIcon' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, NoPlayerIconOpacity) == 0x000300, "Member 'UProfilePictureWidget::NoPlayerIconOpacity' has a wrong offset!");
static_assert(offsetof(UProfilePictureWidget, bShowDownloadIcon) == 0x000304, "Member 'UProfilePictureWidget::bShowDownloadIcon' has a wrong offset!");

// Class Flame.Projectile
// 0x0008 (0x0228 - 0x0220)
class AProjectile final : public AActor
{
public:
	class UProjectileComponent*                   ProjectileComponent;                               // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile">();
	}
	static class AProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile>();
	}
};
static_assert(alignof(AProjectile) == 0x000008, "Wrong alignment on AProjectile");
static_assert(sizeof(AProjectile) == 0x000228, "Wrong size on AProjectile");
static_assert(offsetof(AProjectile, ProjectileComponent) == 0x000220, "Member 'AProjectile::ProjectileComponent' has a wrong offset!");

// Class Flame.BulletManager
// 0x1090A8 (0x1092C8 - 0x0220)
class ABulletManager : public AInfo
{
public:
	FMulticastInlineDelegateProperty_             OnBulletHit;                                       // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(struct FHitResultSimplified& HitResultOptimised, struct FAmmoTypeConfiguration& BulletTypeConfig, class AHumanCharacter* OwnerCharacter, bool bIsPenetrating, bool bIsDeformed)> OnBulletHitOwningClient;                           // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnBulletHitAllClients;                             // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         SonicCrackRadius;                                  // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletWhizzRadius;                                 // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowWhizzRadius;                                  // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileFlyByRadius;                             // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletWhizzMinimalSpeed;                           // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletFlybySoundTravelDistance;                    // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletFlybySoundTravelTime;                        // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowWhizzMinimalSpeed;                            // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileDeformationSpeedFactor;                  // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SonicCrackAudioTravelDistance;                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SonicCrackAudioTravelTime;                         // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SonicCrackRelativeTravelCenter;                    // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletWhizzAudioTravelDistance;                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletWhizzAudioTravelTime;                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletWhizzRelativeTravelCenter;                   // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFlamePlatform, uint8>                   PlatformMaxTracerActorNum;                         // 0x0290(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         MaxNumOfTracersActor;                              // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWholeBodyHitZoneMultiplayers          ShotgunHitZone;                                    // 0x02E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWholeBodyHitZoneMultiplayers          CrossbowHitZone;                                   // 0x0338(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FWholeBodyHitZoneMultiplayers          DefaultHitZone;                                    // 0x0388(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EFlamePlatform, int32>                   PlatformMaxImpactEmittersPerSurface;               // 0x03D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EFlamePlatform, float>                   PlatformMinTimeBetweenEmitterUpdates;              // 0x0428(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bEmitterImpactOptimizationsActive;                 // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MaterialDamageParameterConfig;                     // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x108BD8];                                 // 0x0488(0x108BD8)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 _World;                                            // 0x109060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AItem>, struct FAmmoTypeConfiguration> BulletTypeMap;                                     // 0x109068(0x0050)(NativeAccessSpecifierPrivate)
	struct FAmmoTypeConfiguration                 DummyConfiguration;                                // 0x1090B8(0x0148)(NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AItem>>              _ProjectileItems;                                  // 0x109200(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109210[0xB0];                                  // 0x109210(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletDecalManager*                    BulletDecalManager;                                // 0x1092C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddBulletImpactEmitter(class AHumanCharacter* OwnerHuman, EPhysicalSurface Surface, class UParticleSystemComponent* ParticleSystem);
	void AddTracerActor(class AActor* TracerActor);
	void CreateTrace(const TSubclassOf<class AItem>& ProjectileClass, const struct FVector& Location, const struct FVector& Direction, class AProjectileTracer* Projectile, class AHumanCharacter* ProjectileOwner, class AWeapon* OwningWeapon, const struct FVector& FirePositionRaw, const struct FVector& FireDirectionRaw);
	void OnHit(TSubclassOf<class AItem> BulletType, const struct FHitResultSimplified& HitResultOptimised, const class AHumanCharacter* OwnerCharacter, bool bIsPenetrating, bool bIsDeformed);
	void OnHitRelativePosition(TSubclassOf<class AItem> BulletType, const struct FHitResultSimplified& HitResultOptimised, const class AHumanCharacter* OwnerCharacter, bool bIsPenetrating, bool bIsDeformed, const struct FVector& RelativeHitPosition);
	void OnProjectileFlyby(EProjectileType ProjectileType, const struct FVector& ProjectileOriginLocation, const struct FVector& ProjectileRectangularLocation, const class AHumanCharacter* PlayerVictim, const class AHumanCharacter* PlayerInstigator, bool bPlayerIsBeingHit);
	void OnProjectileFlybyGeneric(EProjectileType ProjectileType, const struct FVector& ProjectileOriginLocation, const class AHumanCharacter* PlayerVictim, const class AHumanCharacter* PlayerInstigator, bool bPlayerIsBeingHit, const struct FHitResultSimplified& HitOptimised);
	class UAudioComponent* PlayArrowWhizz(const struct FVector& WhizzLocation, float ArrowSpeed);
	class UAudioComponent* PlayBulletSonicCrack(const struct FVector& SonicCrackLocation, const struct FVector& BulletOrigin, float BulletSpeed, const class AHumanCharacter* PlayerVictim, bool bPlayerIsBeingHit, bool bIsProjectileDeformed);
	class UAudioComponent* PlayBulletWhizz(const struct FVector& WhizzLocation, const struct FVector& BulletOrigin, float BulletSpeed, const class AHumanCharacter* PlayerVictim, bool bPlayerIsBeingHit, bool bIsProjectileDeformed);
	void RemoveTracerActor(class AActor* TracerActor);
	void StopArrowWhizz(class UAudioComponent* WhizzSound);
	bool TryMovingBulletImpactEmitter(class AHumanCharacter* OwnerHuman, EPhysicalSurface Surface, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletManager">();
	}
	static class ABulletManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletManager>();
	}
};
static_assert(alignof(ABulletManager) == 0x000008, "Wrong alignment on ABulletManager");
static_assert(sizeof(ABulletManager) == 0x1092C8, "Wrong size on ABulletManager");
static_assert(offsetof(ABulletManager, OnBulletHit) == 0x000220, "Member 'ABulletManager::OnBulletHit' has a wrong offset!");
static_assert(offsetof(ABulletManager, OnBulletHitOwningClient) == 0x000230, "Member 'ABulletManager::OnBulletHitOwningClient' has a wrong offset!");
static_assert(offsetof(ABulletManager, OnBulletHitAllClients) == 0x000240, "Member 'ABulletManager::OnBulletHitAllClients' has a wrong offset!");
static_assert(offsetof(ABulletManager, SonicCrackRadius) == 0x000250, "Member 'ABulletManager::SonicCrackRadius' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletWhizzRadius) == 0x000254, "Member 'ABulletManager::BulletWhizzRadius' has a wrong offset!");
static_assert(offsetof(ABulletManager, ArrowWhizzRadius) == 0x000258, "Member 'ABulletManager::ArrowWhizzRadius' has a wrong offset!");
static_assert(offsetof(ABulletManager, ProjectileFlyByRadius) == 0x00025C, "Member 'ABulletManager::ProjectileFlyByRadius' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletWhizzMinimalSpeed) == 0x000260, "Member 'ABulletManager::BulletWhizzMinimalSpeed' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletFlybySoundTravelDistance) == 0x000264, "Member 'ABulletManager::BulletFlybySoundTravelDistance' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletFlybySoundTravelTime) == 0x000268, "Member 'ABulletManager::BulletFlybySoundTravelTime' has a wrong offset!");
static_assert(offsetof(ABulletManager, ArrowWhizzMinimalSpeed) == 0x00026C, "Member 'ABulletManager::ArrowWhizzMinimalSpeed' has a wrong offset!");
static_assert(offsetof(ABulletManager, ProjectileDeformationSpeedFactor) == 0x000270, "Member 'ABulletManager::ProjectileDeformationSpeedFactor' has a wrong offset!");
static_assert(offsetof(ABulletManager, SonicCrackAudioTravelDistance) == 0x000274, "Member 'ABulletManager::SonicCrackAudioTravelDistance' has a wrong offset!");
static_assert(offsetof(ABulletManager, SonicCrackAudioTravelTime) == 0x000278, "Member 'ABulletManager::SonicCrackAudioTravelTime' has a wrong offset!");
static_assert(offsetof(ABulletManager, SonicCrackRelativeTravelCenter) == 0x00027C, "Member 'ABulletManager::SonicCrackRelativeTravelCenter' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletWhizzAudioTravelDistance) == 0x000280, "Member 'ABulletManager::BulletWhizzAudioTravelDistance' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletWhizzAudioTravelTime) == 0x000284, "Member 'ABulletManager::BulletWhizzAudioTravelTime' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletWhizzRelativeTravelCenter) == 0x000288, "Member 'ABulletManager::BulletWhizzRelativeTravelCenter' has a wrong offset!");
static_assert(offsetof(ABulletManager, PlatformMaxTracerActorNum) == 0x000290, "Member 'ABulletManager::PlatformMaxTracerActorNum' has a wrong offset!");
static_assert(offsetof(ABulletManager, MaxNumOfTracersActor) == 0x0002E0, "Member 'ABulletManager::MaxNumOfTracersActor' has a wrong offset!");
static_assert(offsetof(ABulletManager, ShotgunHitZone) == 0x0002E8, "Member 'ABulletManager::ShotgunHitZone' has a wrong offset!");
static_assert(offsetof(ABulletManager, CrossbowHitZone) == 0x000338, "Member 'ABulletManager::CrossbowHitZone' has a wrong offset!");
static_assert(offsetof(ABulletManager, DefaultHitZone) == 0x000388, "Member 'ABulletManager::DefaultHitZone' has a wrong offset!");
static_assert(offsetof(ABulletManager, PlatformMaxImpactEmittersPerSurface) == 0x0003D8, "Member 'ABulletManager::PlatformMaxImpactEmittersPerSurface' has a wrong offset!");
static_assert(offsetof(ABulletManager, PlatformMinTimeBetweenEmitterUpdates) == 0x000428, "Member 'ABulletManager::PlatformMinTimeBetweenEmitterUpdates' has a wrong offset!");
static_assert(offsetof(ABulletManager, bEmitterImpactOptimizationsActive) == 0x000478, "Member 'ABulletManager::bEmitterImpactOptimizationsActive' has a wrong offset!");
static_assert(offsetof(ABulletManager, MaterialDamageParameterConfig) == 0x000480, "Member 'ABulletManager::MaterialDamageParameterConfig' has a wrong offset!");
static_assert(offsetof(ABulletManager, _World) == 0x109060, "Member 'ABulletManager::_World' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletTypeMap) == 0x109068, "Member 'ABulletManager::BulletTypeMap' has a wrong offset!");
static_assert(offsetof(ABulletManager, DummyConfiguration) == 0x1090B8, "Member 'ABulletManager::DummyConfiguration' has a wrong offset!");
static_assert(offsetof(ABulletManager, _ProjectileItems) == 0x109200, "Member 'ABulletManager::_ProjectileItems' has a wrong offset!");
static_assert(offsetof(ABulletManager, BulletDecalManager) == 0x1092C0, "Member 'ABulletManager::BulletDecalManager' has a wrong offset!");

// Class Flame.ProjectileBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectileBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static ECollisionChannel GetBulletTraceChannel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileBlueprintLibrary">();
	}
	static class UProjectileBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileBlueprintLibrary>();
	}
};
static_assert(alignof(UProjectileBlueprintLibrary) == 0x000008, "Wrong alignment on UProjectileBlueprintLibrary");
static_assert(sizeof(UProjectileBlueprintLibrary) == 0x000028, "Wrong size on UProjectileBlueprintLibrary");

// Class Flame.ProjectileTracer
// 0x0020 (0x0240 - 0x0220)
class AProjectileTracer : public AActor
{
public:
	float                                         AutoDestroyTime;                                   // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0xC];                                      // 0x0224(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               TrailParticles;                                    // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BulletMesh;                                        // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileTracer">();
	}
	static class AProjectileTracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileTracer>();
	}
};
static_assert(alignof(AProjectileTracer) == 0x000008, "Wrong alignment on AProjectileTracer");
static_assert(sizeof(AProjectileTracer) == 0x000240, "Wrong size on AProjectileTracer");
static_assert(offsetof(AProjectileTracer, AutoDestroyTime) == 0x000220, "Member 'AProjectileTracer::AutoDestroyTime' has a wrong offset!");
static_assert(offsetof(AProjectileTracer, TrailParticles) == 0x000230, "Member 'AProjectileTracer::TrailParticles' has a wrong offset!");
static_assert(offsetof(AProjectileTracer, BulletMesh) == 0x000238, "Member 'AProjectileTracer::BulletMesh' has a wrong offset!");

// Class Flame.QueryNetDriver
// 0x0000 (0x07D0 - 0x07D0)
class UQueryNetDriver final : public UIpNetDriver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QueryNetDriver">();
	}
	static class UQueryNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQueryNetDriver>();
	}
};
static_assert(alignof(UQueryNetDriver) == 0x000008, "Wrong alignment on UQueryNetDriver");
static_assert(sizeof(UQueryNetDriver) == 0x0007D0, "Wrong size on UQueryNetDriver");

// Class Flame.RadiationShieldingComponent
// 0x0030 (0x00E0 - 0x00B0)
class URadiationShieldingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             RadiationShieldChangedDelegate;                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	ERadiationShieldingLevel                      CurrentRadiationShield;                            // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x1F];                                      // 0x00C1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddShielding(ERadiationShieldingLevel Level);
	void OnBuildingEnter(class AActor* Building);
	void OnBuildingLeave(class AActor* Building);
	void RemoveShielding(ERadiationShieldingLevel Level);
	void RequestAcquireController();

	ERadiationShieldingLevel GetCurrentRadiationShieldingLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadiationShieldingComponent">();
	}
	static class URadiationShieldingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadiationShieldingComponent>();
	}
};
static_assert(alignof(URadiationShieldingComponent) == 0x000008, "Wrong alignment on URadiationShieldingComponent");
static_assert(sizeof(URadiationShieldingComponent) == 0x0000E0, "Wrong size on URadiationShieldingComponent");
static_assert(offsetof(URadiationShieldingComponent, RadiationShieldChangedDelegate) == 0x0000B0, "Member 'URadiationShieldingComponent::RadiationShieldChangedDelegate' has a wrong offset!");
static_assert(offsetof(URadiationShieldingComponent, CurrentRadiationShield) == 0x0000C0, "Member 'URadiationShieldingComponent::CurrentRadiationShield' has a wrong offset!");

// Class Flame.RawItemProvider
// 0x0000 (0x0058 - 0x0058)
class URawItemProvider final : public UInventoryItemProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RawItemProvider">();
	}
	static class URawItemProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<URawItemProvider>();
	}
};
static_assert(alignof(URawItemProvider) == 0x000008, "Wrong alignment on URawItemProvider");
static_assert(sizeof(URawItemProvider) == 0x000058, "Wrong size on URawItemProvider");

// Class Flame.Reset
// 0x0000 (0x0028 - 0x0028)
class IReset final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Reset">();
	}
	static class IReset* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReset>();
	}
};
static_assert(alignof(IReset) == 0x000008, "Wrong alignment on IReset");
static_assert(sizeof(IReset) == 0x000028, "Wrong size on IReset");

// Class Flame.ReverbEffectExtended
// 0x0008 (0x0068 - 0x0060)
class UReverbEffectExtended final : public UReverbEffect
{
public:
	float                                         InteriorModifier;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorModifierFadeTime;                          // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverbEffectExtended">();
	}
	static class UReverbEffectExtended* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverbEffectExtended>();
	}
};
static_assert(alignof(UReverbEffectExtended) == 0x000008, "Wrong alignment on UReverbEffectExtended");
static_assert(sizeof(UReverbEffectExtended) == 0x000068, "Wrong size on UReverbEffectExtended");
static_assert(offsetof(UReverbEffectExtended, InteriorModifier) == 0x000060, "Member 'UReverbEffectExtended::InteriorModifier' has a wrong offset!");
static_assert(offsetof(UReverbEffectExtended, InteriorModifierFadeTime) == 0x000064, "Member 'UReverbEffectExtended::InteriorModifierFadeTime' has a wrong offset!");

// Class Flame.RichPresence
// 0x0028 (0x0050 - 0x0028)
class URichPresence final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRichPresence(const class FString& MapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichPresence">();
	}
	static class URichPresence* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichPresence>();
	}
};
static_assert(alignof(URichPresence) == 0x000008, "Wrong alignment on URichPresence");
static_assert(sizeof(URichPresence) == 0x000050, "Wrong size on URichPresence");

// Class Flame.RiverSplineComponent
// 0x0010 (0x0560 - 0x0550)
class URiverSplineComponent final : public USplineComponent
{
public:
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              CollisionMaterial;                                 // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DeleteColliders();
	void GenerateColliders(const float HeightAddition, const float DistanceStep, const float WidthStep, const TArray<struct FRiverSplinePointDimensions>& PointDimensions);
	void SetScaleAtRiverSplinePoint(const int32 PointIdx, const struct FVector& Scale);
	void UpdateMaxFordingDepth(const float& NewMaxFordingDepth);

	int32 GetSplinePointAtDistanceAlongSpline(const float Distance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiverSplineComponent">();
	}
	static class URiverSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URiverSplineComponent>();
	}
};
static_assert(alignof(URiverSplineComponent) == 0x000010, "Wrong alignment on URiverSplineComponent");
static_assert(sizeof(URiverSplineComponent) == 0x000560, "Wrong size on URiverSplineComponent");
static_assert(offsetof(URiverSplineComponent, CollisionMaterial) == 0x000558, "Member 'URiverSplineComponent::CollisionMaterial' has a wrong offset!");

// Class Flame.RiverVertexBakingSettings
// 0x00B8 (0x02D8 - 0x0220)
class ARiverVertexBakingSettings : public AActor
{
public:
	ERiverFlowDirection                           FlowDirection;                                     // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugVectors;                                 // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         RiverActors;                                       // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             RiverMaterials;                                    // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FoamMaxDistance;                                   // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    FoamIgnoreMeshes;                                  // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             FoamIgnoreMaterials;                               // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bFoamIgnoreLandscape;                              // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightOffsetMaxDistance;                           // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    HeightOffsetIgnoreMeshes;                          // 0x0278(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             HeightOffsetIgnoreMaterials;                       // 0x0288(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHeightOffsetIgnoreLandscape;                      // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VertexOffsetMaxDistance;                           // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    VertexOffsetIgnoreMeshes;                          // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             VertexOffsetIgnoreMaterials;                       // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bVertexOffsetIgnoreLandscape;                      // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComplexCollision;                                 // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x2];                                      // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfLineTraces;                                // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothRadius;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothOffsetStrength;                              // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothHeightStrength;                              // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiverVertexBakingSettings">();
	}
	static class ARiverVertexBakingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARiverVertexBakingSettings>();
	}
};
static_assert(alignof(ARiverVertexBakingSettings) == 0x000008, "Wrong alignment on ARiverVertexBakingSettings");
static_assert(sizeof(ARiverVertexBakingSettings) == 0x0002D8, "Wrong size on ARiverVertexBakingSettings");
static_assert(offsetof(ARiverVertexBakingSettings, FlowDirection) == 0x000220, "Member 'ARiverVertexBakingSettings::FlowDirection' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, bDrawDebugVectors) == 0x000221, "Member 'ARiverVertexBakingSettings::bDrawDebugVectors' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, RiverActors) == 0x000228, "Member 'ARiverVertexBakingSettings::RiverActors' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, RiverMaterials) == 0x000238, "Member 'ARiverVertexBakingSettings::RiverMaterials' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, FoamMaxDistance) == 0x000248, "Member 'ARiverVertexBakingSettings::FoamMaxDistance' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, FoamIgnoreMeshes) == 0x000250, "Member 'ARiverVertexBakingSettings::FoamIgnoreMeshes' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, FoamIgnoreMaterials) == 0x000260, "Member 'ARiverVertexBakingSettings::FoamIgnoreMaterials' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, bFoamIgnoreLandscape) == 0x000270, "Member 'ARiverVertexBakingSettings::bFoamIgnoreLandscape' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, HeightOffsetMaxDistance) == 0x000274, "Member 'ARiverVertexBakingSettings::HeightOffsetMaxDistance' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, HeightOffsetIgnoreMeshes) == 0x000278, "Member 'ARiverVertexBakingSettings::HeightOffsetIgnoreMeshes' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, HeightOffsetIgnoreMaterials) == 0x000288, "Member 'ARiverVertexBakingSettings::HeightOffsetIgnoreMaterials' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, bHeightOffsetIgnoreLandscape) == 0x000298, "Member 'ARiverVertexBakingSettings::bHeightOffsetIgnoreLandscape' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, VertexOffsetMaxDistance) == 0x00029C, "Member 'ARiverVertexBakingSettings::VertexOffsetMaxDistance' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, VertexOffsetIgnoreMeshes) == 0x0002A0, "Member 'ARiverVertexBakingSettings::VertexOffsetIgnoreMeshes' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, VertexOffsetIgnoreMaterials) == 0x0002B0, "Member 'ARiverVertexBakingSettings::VertexOffsetIgnoreMaterials' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, bVertexOffsetIgnoreLandscape) == 0x0002C0, "Member 'ARiverVertexBakingSettings::bVertexOffsetIgnoreLandscape' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, bComplexCollision) == 0x0002C1, "Member 'ARiverVertexBakingSettings::bComplexCollision' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, NumberOfLineTraces) == 0x0002C4, "Member 'ARiverVertexBakingSettings::NumberOfLineTraces' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, SmoothRadius) == 0x0002C8, "Member 'ARiverVertexBakingSettings::SmoothRadius' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, SmoothOffsetStrength) == 0x0002CC, "Member 'ARiverVertexBakingSettings::SmoothOffsetStrength' has a wrong offset!");
static_assert(offsetof(ARiverVertexBakingSettings, SmoothHeightStrength) == 0x0002D0, "Member 'ARiverVertexBakingSettings::SmoothHeightStrength' has a wrong offset!");

// Class Flame.ScalableGridRowWidget
// 0x0028 (0x02E0 - 0x02B8)
class UScalableGridRowWidget : public UFlameWidget
{
public:
	class UHorizontalBox*                         SlotRow;                                           // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviewSlotCount;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Width;                                             // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFlameSlot>                 SlotClass;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                SlotPadding;                                       // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableGridRowWidget">();
	}
	static class UScalableGridRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableGridRowWidget>();
	}
};
static_assert(alignof(UScalableGridRowWidget) == 0x000008, "Wrong alignment on UScalableGridRowWidget");
static_assert(sizeof(UScalableGridRowWidget) == 0x0002E0, "Wrong size on UScalableGridRowWidget");
static_assert(offsetof(UScalableGridRowWidget, SlotRow) == 0x0002B8, "Member 'UScalableGridRowWidget::SlotRow' has a wrong offset!");
static_assert(offsetof(UScalableGridRowWidget, PreviewSlotCount) == 0x0002C0, "Member 'UScalableGridRowWidget::PreviewSlotCount' has a wrong offset!");
static_assert(offsetof(UScalableGridRowWidget, Width) == 0x0002C4, "Member 'UScalableGridRowWidget::Width' has a wrong offset!");
static_assert(offsetof(UScalableGridRowWidget, SlotClass) == 0x0002C8, "Member 'UScalableGridRowWidget::SlotClass' has a wrong offset!");
static_assert(offsetof(UScalableGridRowWidget, SlotPadding) == 0x0002D0, "Member 'UScalableGridRowWidget::SlotPadding' has a wrong offset!");

// Class Flame.ScarecrowActor
// 0x0010 (0x0230 - 0x0220)
class AScarecrowActor : public AGameplay
{
public:
	class UCharacterHitZoneComponent*             HitZoneManager;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHealthComponentSimple*                 HealthComponentSimple;                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MulticastOnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, class AHumanCharacter* InstigatingCharacter);
	void OnPlayerDied(float DamageAmount, const struct FHitResult& HitResult, class AHumanCharacter* InstigatingCharacter);
	void TakeDamageBlueprint(float DamageAmount, class AHumanCharacter* InstigatingCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScarecrowActor">();
	}
	static class AScarecrowActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScarecrowActor>();
	}
};
static_assert(alignof(AScarecrowActor) == 0x000008, "Wrong alignment on AScarecrowActor");
static_assert(sizeof(AScarecrowActor) == 0x000230, "Wrong size on AScarecrowActor");
static_assert(offsetof(AScarecrowActor, HitZoneManager) == 0x000220, "Member 'AScarecrowActor::HitZoneManager' has a wrong offset!");
static_assert(offsetof(AScarecrowActor, HealthComponentSimple) == 0x000228, "Member 'AScarecrowActor::HealthComponentSimple' has a wrong offset!");

// Class Flame.SceneComponentSmoothing
// 0x0040 (0x0240 - 0x0200)
class USceneComponentSmoothing final : public USceneComponent
{
public:
	class USceneComponent*                        SourceComponent;                                   // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FixedDeltaTime;                                    // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Acceleration;                                      // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Lerp;                                              // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Decay;                                             // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxTickCount;                                      // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MarginUp;                                          // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MarginDown;                                        // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Bias;                                              // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MultiplierUp;                                      // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MultiplierDown;                                    // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSourceComponent(class USceneComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentSmoothing">();
	}
	static class USceneComponentSmoothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentSmoothing>();
	}
};
static_assert(alignof(USceneComponentSmoothing) == 0x000010, "Wrong alignment on USceneComponentSmoothing");
static_assert(sizeof(USceneComponentSmoothing) == 0x000240, "Wrong size on USceneComponentSmoothing");
static_assert(offsetof(USceneComponentSmoothing, SourceComponent) == 0x0001F8, "Member 'USceneComponentSmoothing::SourceComponent' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, FixedDeltaTime) == 0x000200, "Member 'USceneComponentSmoothing::FixedDeltaTime' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, Acceleration) == 0x000204, "Member 'USceneComponentSmoothing::Acceleration' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, Lerp) == 0x000208, "Member 'USceneComponentSmoothing::Lerp' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, Decay) == 0x00020C, "Member 'USceneComponentSmoothing::Decay' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, MaxTickCount) == 0x000210, "Member 'USceneComponentSmoothing::MaxTickCount' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, MarginUp) == 0x000214, "Member 'USceneComponentSmoothing::MarginUp' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, MarginDown) == 0x000218, "Member 'USceneComponentSmoothing::MarginDown' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, Bias) == 0x00021C, "Member 'USceneComponentSmoothing::Bias' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, MultiplierUp) == 0x000220, "Member 'USceneComponentSmoothing::MultiplierUp' has a wrong offset!");
static_assert(offsetof(USceneComponentSmoothing, MultiplierDown) == 0x000224, "Member 'USceneComponentSmoothing::MultiplierDown' has a wrong offset!");

// Class Flame.SectionHeaderWidget
// 0x0028 (0x02E0 - 0x02B8)
class USectionHeaderWidget : public UFlameWidget
{
public:
	class UFlameTextBlock*                        SectionLabel;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   SectionDisplayName;                                // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EStashSection                                 SectionType;                                       // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSectionNameAndType(const class FText& InText, EStashSection Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectionHeaderWidget">();
	}
	static class USectionHeaderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USectionHeaderWidget>();
	}
};
static_assert(alignof(USectionHeaderWidget) == 0x000008, "Wrong alignment on USectionHeaderWidget");
static_assert(sizeof(USectionHeaderWidget) == 0x0002E0, "Wrong size on USectionHeaderWidget");
static_assert(offsetof(USectionHeaderWidget, SectionLabel) == 0x0002B8, "Member 'USectionHeaderWidget::SectionLabel' has a wrong offset!");
static_assert(offsetof(USectionHeaderWidget, SectionDisplayName) == 0x0002C0, "Member 'USectionHeaderWidget::SectionDisplayName' has a wrong offset!");
static_assert(offsetof(USectionHeaderWidget, SectionType) == 0x0002D8, "Member 'USectionHeaderWidget::SectionType' has a wrong offset!");

// Class Flame.SelectionWheelComponent
// 0x0048 (0x00F8 - 0x00B0)
class USelectionWheelComponent : public UActorComponent
{
public:
	TSubclassOf<class USelectionWheel>            SelectionWheelClass;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USelectionWheel*                        SelectionWheel;                                    // 0x00B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 WeaponIndices;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           ConsumableClasses;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACustomizationSlotGesture>> GestureSlots;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         LastWeaponWheelIndex;                              // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWheel();
	void OpenWheel(const ESelectionWheelType& WheelType);
	void SelectLastItem(const ESelectionWheelType& WheelType);
	void SetWeaponWheelIndex(int32 Index_0);

	bool CanWheelOpen(const ESelectionWheelType& WheelType) const;
	const TArray<int32> GetWeaponIndices() const;
	bool IsWheelOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionWheelComponent">();
	}
	static class USelectionWheelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectionWheelComponent>();
	}
};
static_assert(alignof(USelectionWheelComponent) == 0x000008, "Wrong alignment on USelectionWheelComponent");
static_assert(sizeof(USelectionWheelComponent) == 0x0000F8, "Wrong size on USelectionWheelComponent");
static_assert(offsetof(USelectionWheelComponent, SelectionWheelClass) == 0x0000B0, "Member 'USelectionWheelComponent::SelectionWheelClass' has a wrong offset!");
static_assert(offsetof(USelectionWheelComponent, SelectionWheel) == 0x0000B8, "Member 'USelectionWheelComponent::SelectionWheel' has a wrong offset!");
static_assert(offsetof(USelectionWheelComponent, WeaponIndices) == 0x0000C0, "Member 'USelectionWheelComponent::WeaponIndices' has a wrong offset!");
static_assert(offsetof(USelectionWheelComponent, ConsumableClasses) == 0x0000D0, "Member 'USelectionWheelComponent::ConsumableClasses' has a wrong offset!");
static_assert(offsetof(USelectionWheelComponent, GestureSlots) == 0x0000E0, "Member 'USelectionWheelComponent::GestureSlots' has a wrong offset!");
static_assert(offsetof(USelectionWheelComponent, LastWeaponWheelIndex) == 0x0000F0, "Member 'USelectionWheelComponent::LastWeaponWheelIndex' has a wrong offset!");

// Class Flame.SelectionWheelWeaponSlot
// 0x0030 (0x0398 - 0x0368)
class USelectionWheelWeaponSlot : public UEquipmentSlot
{
public:
	float                                         AmmoAngle;                                         // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              AmmoCountOffsetPrimary;                            // 0x036C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              AmmoCountOffsetSecondary;                          // 0x0374(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              AmmoVisualOffset;                                  // 0x037C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           AmmoCountPanel;                                    // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlotVisual*                            AmmoVisual;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAmmoAngle(float InAngle);
	void UpdateAmmoCountPosition();
	void UpdateAmmoVisualPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionWheelWeaponSlot">();
	}
	static class USelectionWheelWeaponSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectionWheelWeaponSlot>();
	}
};
static_assert(alignof(USelectionWheelWeaponSlot) == 0x000008, "Wrong alignment on USelectionWheelWeaponSlot");
static_assert(sizeof(USelectionWheelWeaponSlot) == 0x000398, "Wrong size on USelectionWheelWeaponSlot");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoAngle) == 0x000368, "Member 'USelectionWheelWeaponSlot::AmmoAngle' has a wrong offset!");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoCountOffsetPrimary) == 0x00036C, "Member 'USelectionWheelWeaponSlot::AmmoCountOffsetPrimary' has a wrong offset!");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoCountOffsetSecondary) == 0x000374, "Member 'USelectionWheelWeaponSlot::AmmoCountOffsetSecondary' has a wrong offset!");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoVisualOffset) == 0x00037C, "Member 'USelectionWheelWeaponSlot::AmmoVisualOffset' has a wrong offset!");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoCountPanel) == 0x000388, "Member 'USelectionWheelWeaponSlot::AmmoCountPanel' has a wrong offset!");
static_assert(offsetof(USelectionWheelWeaponSlot, AmmoVisual) == 0x000390, "Member 'USelectionWheelWeaponSlot::AmmoVisual' has a wrong offset!");

// Class Flame.ServerAuthorityConfig
// 0x0000 (0x0028 - 0x0028)
class UServerAuthorityConfig final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerAuthorityConfig">();
	}
	static class UServerAuthorityConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerAuthorityConfig>();
	}
};
static_assert(alignof(UServerAuthorityConfig) == 0x000008, "Wrong alignment on UServerAuthorityConfig");
static_assert(sizeof(UServerAuthorityConfig) == 0x000028, "Wrong size on UServerAuthorityConfig");

// Class Flame.ServerJoinHandler
// 0x0030 (0x0058 - 0x0028)
class UServerJoinHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerJoinHandler">();
	}
	static class UServerJoinHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerJoinHandler>();
	}
};
static_assert(alignof(UServerJoinHandler) == 0x000008, "Wrong alignment on UServerJoinHandler");
static_assert(sizeof(UServerJoinHandler) == 0x000058, "Wrong size on UServerJoinHandler");

// Class Flame.ServerQueryBeaconHost
// 0x0000 (0x0308 - 0x0308)
class AServerQueryBeaconHost final : public AOnlineBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerQueryBeaconHost">();
	}
	static class AServerQueryBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerQueryBeaconHost>();
	}
};
static_assert(alignof(AServerQueryBeaconHost) == 0x000008, "Wrong alignment on AServerQueryBeaconHost");
static_assert(sizeof(AServerQueryBeaconHost) == 0x000308, "Wrong size on AServerQueryBeaconHost");

// Class Flame.ShelterCraftingList
// 0x0058 (0x0128 - 0x00D0)
class UShelterCraftingList final : public UCraftingList
{
public:
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimalTimeBetweenCollectInSeconds;                // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DEBUG_SetInstantCollecting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterCraftingList">();
	}
	static class UShelterCraftingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterCraftingList>();
	}
};
static_assert(alignof(UShelterCraftingList) == 0x000008, "Wrong alignment on UShelterCraftingList");
static_assert(sizeof(UShelterCraftingList) == 0x000128, "Wrong size on UShelterCraftingList");
static_assert(offsetof(UShelterCraftingList, MinimalTimeBetweenCollectInSeconds) == 0x000120, "Member 'UShelterCraftingList::MinimalTimeBetweenCollectInSeconds' has a wrong offset!");

// Class Flame.ShelterCustomizationComponent
// 0x01E0 (0x0290 - 0x00B0)
class UShelterCustomizationComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             CloudLoadedAuthority;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedAssiknedSkinsAuthority;                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             CloudLoadedOwnedSkinsAuthority;                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             ItemSkinChanged;                                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class FName                                   ArchetypesTableName;                               // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CustomizationTableName;                            // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CustomizationVariantsTableName;                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SkinsTableName;                                    // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x40];                                     // 0x0110(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACustomizationVariant>> OwnedCustomizationsVariant;                        // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ACustomizationVariant>> HighlightedCustomizationsVariant;                  // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x50];                                     // 0x0170(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACustomizationVariantBundle>> OwnedBundles;                                      // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AItemSkin>>          OwnedSkins;                                        // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FSkinPair>                      AssignedSkins;                                     // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0xA0];                                     // 0x01F0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRepAssignedSkins();
	void OnRepHighlightedVariants();
	void OnRepOwnedBundles();
	void OnRepOwnedSkins();
	void OnRepOwnedVariants();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterCustomizationComponent">();
	}
	static class UShelterCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterCustomizationComponent>();
	}
};
static_assert(alignof(UShelterCustomizationComponent) == 0x000008, "Wrong alignment on UShelterCustomizationComponent");
static_assert(sizeof(UShelterCustomizationComponent) == 0x000290, "Wrong size on UShelterCustomizationComponent");
static_assert(offsetof(UShelterCustomizationComponent, CloudLoadedAuthority) == 0x0000B0, "Member 'UShelterCustomizationComponent::CloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, CloudLoadedAssiknedSkinsAuthority) == 0x0000C0, "Member 'UShelterCustomizationComponent::CloudLoadedAssiknedSkinsAuthority' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, CloudLoadedOwnedSkinsAuthority) == 0x0000D0, "Member 'UShelterCustomizationComponent::CloudLoadedOwnedSkinsAuthority' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, ItemSkinChanged) == 0x0000E0, "Member 'UShelterCustomizationComponent::ItemSkinChanged' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, ArchetypesTableName) == 0x0000F0, "Member 'UShelterCustomizationComponent::ArchetypesTableName' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, CustomizationTableName) == 0x0000F8, "Member 'UShelterCustomizationComponent::CustomizationTableName' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, CustomizationVariantsTableName) == 0x000100, "Member 'UShelterCustomizationComponent::CustomizationVariantsTableName' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, SkinsTableName) == 0x000108, "Member 'UShelterCustomizationComponent::SkinsTableName' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, OwnedCustomizationsVariant) == 0x000150, "Member 'UShelterCustomizationComponent::OwnedCustomizationsVariant' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, HighlightedCustomizationsVariant) == 0x000160, "Member 'UShelterCustomizationComponent::HighlightedCustomizationsVariant' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, OwnedBundles) == 0x0001C0, "Member 'UShelterCustomizationComponent::OwnedBundles' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, OwnedSkins) == 0x0001D0, "Member 'UShelterCustomizationComponent::OwnedSkins' has a wrong offset!");
static_assert(offsetof(UShelterCustomizationComponent, AssignedSkins) == 0x0001E0, "Member 'UShelterCustomizationComponent::AssignedSkins' has a wrong offset!");

// Class Flame.ShelterFunctions
// 0x0000 (0x0028 - 0x0028)
class UShelterFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FCloudRequest BoostImprovementUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static bool CanBoostImprovementUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static bool CanBuildSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static bool CanCollectFromImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static bool CanUpgradeLevel(const class AStash* OneStash);
	static struct FCloudRequest CollectFromShelterImprovementSlot(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash);
	static struct FCloudRequest DeconstructSpecialResource(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, int32 Count, const class AStash* OneStash, TDelegate<void()> UICallback);
	static TArray<struct FCloudImprovementInfo> GetAllImprovements(const class AStash* OneStash);
	static TArray<TSubclassOf<class AShelterRepair>> GetAllRepairs(const class AStash* OneStash);
	static int32 GetBoosterTicket(const class AStash* OneStash, const class FString& TypeKey);
	static bool GetBoosterTicketDetails(const class AStash* OneStash, const class FString& Type, int32* Index_0, struct FBoosterDetails* BoosterDetails);
	static int32 GetBoostImprovementUpgradePrice(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetCountOfChemicals(const class AStash* OneStash);
	static int32 GetCountOfElectronics(const class AStash* OneStash);
	static int32 GetCountOfFertilizer(const class AStash* OneStash);
	static int32 GetCountOfFuel(const class AStash* OneStash);
	static int32 GetCountOfGlass(const class AStash* OneStash);
	static int32 GetCountOfImprovementsInProgress(const class AStash* OneStash);
	static int32 GetCountOfLootForCollectFromImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static float GetCountOfLootForCollectFromImprovementWithPrecision(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetCountOfMetalParts(const class AStash* OneStash);
	static int32 GetCountOfNails(const class AStash* OneStash);
	static int32 GetCountOfShelterResource(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, const class AStash* OneStash);
	static int32 GetCountOfWire(const class AStash* OneStash);
	static int32 GetCraftingTableLevel(const class AStash* Stash);
	static float GetCurrentGeneratorRateMultiplier(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetCurrentImprovementLevel(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetFoodCurrency(const class AStash* OneStash);
	static int32 GetFoodCurrencyCap(const class AStash* OneStash);
	static float GetGeneratorRate(TSubclassOf<class AShelterSlot> Slot, int32 Level, const class AStash* OneStash, EBonusMode Mode);
	static int32 GetHardCurrency(const class AStash* OneStash);
	static int32 GetHardCurrencyCap(const class AStash* OneStash);
	static int32 GetImprovementsCount(const class AStash* OneStash);
	static struct FShelterSlotInfo GetImprovementSlotState(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static struct FCloudImprovementInfo GetImprovementStatus(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash);
	static struct FImprovementTextDescription GetImprovementTextDescriptionForLevel(TSubclassOf<class AShelterImprovement> Improvement, TSubclassOf<class AShelterSlot> Slot, int32 Level, EShelterImprovementDescription Mode, const class AStash* OneStash);
	static struct FShelterImprovementInfo GetInfoAboutImprovementInSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetInstantPriceToUpgradeImprovementForCertainLevel(TSubclassOf<class AShelterSlot> SlotClass, int32 Level, const class AStash* Stash);
	static struct FCloudDataShelterLevel GetLevelDescriptor(int32 NeededLevel, const class AStash* OneStash);
	static int32 GetMaterialCostForNextLevel(const class AStash* OneStash);
	static int32 GetMaterialCurrency(const class AStash* OneStash);
	static int32 GetMaterialCurrencyCap(const class AStash* OneStash);
	static int32 GetMaxImprovementLevel(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetMaxImprovementsInProgress(const class AStash* OneStash);
	static int32 GetNeededImprovementsCountForNextLevel(const class AStash* OneStash);
	static int32 GetNeededLevelForImprovement(TSubclassOf<class AShelterImprovement> ImprovementClass, const class AStash* Stash);
	static int32 GetNeededLevelForSlot(TSubclassOf<class AShelterSlot> Slot, const class AStash* Stash);
	static struct FTimespan GetRemainingImprovementBuildingTime(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* OneStash);
	static int32 GetRepairLevel(const class AStash* OneStash);
	static int32 GetRepairLevelCap(const class AStash* OneStash);
	static TArray<struct FShelterResourceInfo> GetRequirementsForUpgrade(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetShelterResourceMaterialCost(TSubclassOf<class AShelterResourceItem> ShelterResourceClass, const class AStash* OneStash);
	static int32 GetSlotLootCapacity(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static int32 GetTimeToUpgradeImprovementForCertainLevel(TSubclassOf<class AShelterSlot> SlotClass, int32 Level, const class AStash* Stash, EBonusMode Mode);
	static int32 GetTimeToUpgradeImprovementForNextLevel(TSubclassOf<class AShelterSlot> SlotClass, const class AStash* Stash, EBonusMode Mode);
	static bool HasLevelForBuildImprovement(TSubclassOf<class AShelterImprovement> ImprovementClass, class AStash* Stash);
	static bool HasLevelForBuildSlot(TSubclassOf<class AShelterSlot> Slot, class AStash* Stash);
	static bool HasToken(TSubclassOf<class AToken> TokenClass, const class AStash* OneStash);
	static bool IsMatchmakingAllowed(const class UObject* WorldContextObject);
	static bool IsSlotFullOfLoot(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);
	static struct FCloudRequest RepairLevelUp(const class AStash* OneStash);
	static struct FCloudRequest UpgradeImprovement(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash);

	bool IsShelterLevelLowerThanCap(const class AStash* OneStash) const;
	bool IsSlotLevelLowerThanCap(TSubclassOf<class AShelterSlot> Slot, const class AStash* OneStash) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterFunctions">();
	}
	static class UShelterFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterFunctions>();
	}
};
static_assert(alignof(UShelterFunctions) == 0x000008, "Wrong alignment on UShelterFunctions");
static_assert(sizeof(UShelterFunctions) == 0x000028, "Wrong size on UShelterFunctions");

// Class Flame.ShelterImprovement
// 0x0078 (0x0410 - 0x0398)
class AShelterImprovement : public AItem
{
public:
	uint8                                         Pad_398[0x58];                                     // 0x0398(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImprovementTextDescription            DefaultLevelDescription;                           // 0x03F0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         CustomTimeMultiplierForGenerator;                  // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetParentShelterSlot(TSubclassOf<class AShelterSlot> OwnerSlot);

	TSubclassOf<class AShelterSlot> GetParentSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterImprovement">();
	}
	static class AShelterImprovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterImprovement>();
	}
};
static_assert(alignof(AShelterImprovement) == 0x000008, "Wrong alignment on AShelterImprovement");
static_assert(sizeof(AShelterImprovement) == 0x000410, "Wrong size on AShelterImprovement");
static_assert(offsetof(AShelterImprovement, DefaultLevelDescription) == 0x0003F0, "Member 'AShelterImprovement::DefaultLevelDescription' has a wrong offset!");
static_assert(offsetof(AShelterImprovement, CustomTimeMultiplierForGenerator) == 0x000408, "Member 'AShelterImprovement::CustomTimeMultiplierForGenerator' has a wrong offset!");

// Class Flame.TabControlWidget
// 0x0040 (0x0318 - 0x02D8)
class UTabControlWidget : public UMenuWidget
{
public:
	class UHorizontalBox*                         TabContainer;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        TabContentSwitcher;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     InputActionNext;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     InputActionPrevious;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETabControlType                               TabControlType;                                    // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCycled;                                         // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocked;                                         // 0x02FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FB[0x5];                                      // 0x02FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTabWidget*>                     Tabs;                                              // 0x0300(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         InitialTabIndex;                                   // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedTabIndex;                                  // 0x0314(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Lock(bool bApplyToParents);
	void OnLock();
	void OnSelectionChanged(int32 NewIndex, int32 OldIndex);
	void OnUnlock();
	void ReselectTab(int32 TabIndex);
	void SelectNextTab();
	void SelectPreviousTab();
	void SelectTab(int32 TabIndex);
	void SetInitialTabIndex(int32 InIndex);
	void Unlock(bool bApplyToParents);

	TArray<class UTabWidget*> CreateTabs() const;
	class UTabWidget* GetSelectedTab() const;
	int32 GetTabCount() const;
	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabControlWidget">();
	}
	static class UTabControlWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabControlWidget>();
	}
};
static_assert(alignof(UTabControlWidget) == 0x000008, "Wrong alignment on UTabControlWidget");
static_assert(sizeof(UTabControlWidget) == 0x000318, "Wrong size on UTabControlWidget");
static_assert(offsetof(UTabControlWidget, TabContainer) == 0x0002D8, "Member 'UTabControlWidget::TabContainer' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, TabContentSwitcher) == 0x0002E0, "Member 'UTabControlWidget::TabContentSwitcher' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, InputActionNext) == 0x0002E8, "Member 'UTabControlWidget::InputActionNext' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, InputActionPrevious) == 0x0002F0, "Member 'UTabControlWidget::InputActionPrevious' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, TabControlType) == 0x0002F8, "Member 'UTabControlWidget::TabControlType' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, bIsCycled) == 0x0002F9, "Member 'UTabControlWidget::bIsCycled' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, bIsLocked) == 0x0002FA, "Member 'UTabControlWidget::bIsLocked' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, Tabs) == 0x000300, "Member 'UTabControlWidget::Tabs' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, InitialTabIndex) == 0x000310, "Member 'UTabControlWidget::InitialTabIndex' has a wrong offset!");
static_assert(offsetof(UTabControlWidget, SelectedTabIndex) == 0x000314, "Member 'UTabControlWidget::SelectedTabIndex' has a wrong offset!");

// Class Flame.ShelterMainTabControl
// 0x0000 (0x0318 - 0x0318)
class UShelterMainTabControl : public UTabControlWidget
{
public:
	void SelectMainTab(EShelterMainTab Tab);
	void SetInitialMainTab(EShelterMainTab Tab);

	int32 GetTabIndex(EShelterMainTab InTab) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterMainTabControl">();
	}
	static class UShelterMainTabControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterMainTabControl>();
	}
};
static_assert(alignof(UShelterMainTabControl) == 0x000008, "Wrong alignment on UShelterMainTabControl");
static_assert(sizeof(UShelterMainTabControl) == 0x000318, "Wrong size on UShelterMainTabControl");

// Class Flame.ShelterMapTile
// 0x0268 (0x0520 - 0x02B8)
class UShelterMapTile : public UFlameWidget
{
public:
	ECursorMode                                   HoverState;                                        // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HoverByCode;                                       // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECursorMode                                   DisabledState;                                     // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TileIsHovered;                                     // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMapTileFocused;                                  // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   LevelClassName;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOnlineGameMode                               OnlineGameMode;                                    // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LabelName;                                         // 0x02DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              EndTime;                                           // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MapImageColorNormal;                               // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MapImageColorUnavailable;                          // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventOverlayOpacityNormal;                         // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventOverlayOpacityUnavailable;                    // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             LevelDescriptionsTable;                            // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             OnlineGameModeDescriptionsTable;                   // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             LabelsTable;                                       // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLevelDescriptionTableRow              QuickPlayDescription;                              // 0x0330(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundOnFocus;                                      // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLevelDescriptionTableRow              LevelDescription;                                  // 0x0388(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FOnlineGameModeDescriptionTableRow     OnlineGameModeDescription;                         // 0x03D8(0x0078)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCloudMapRotationSlot                  CloudMapRotationSlot;                              // 0x0450(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 MapImage;                                          // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FocusFlare;                                        // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               EventOverlay;                                      // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 EventBackgroundImage;                              // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        EventName;                                         // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        GameModeName;                                      // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        LevelName;                                         // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        RemainingTimeText;                                 // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftArrow;                                         // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightArrow;                                        // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               TeamTooBigOverlay;                                 // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        TeamTooBigText;                                    // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               CrossPlayOffOverlay;                               // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionMoreInfo;                                    // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeOnCrossPlayCheckFinished(bool bCanUserCrossPlay);
	void NativeOnPlayerJoinedGroup(const struct FUniqueNetIdRepl& InUserId, const class FString& InGroupId);
	void NativeOnPlayerLeftGroup(const struct FUniqueNetIdRepl& InUserId, const class FString& InGroupId);
	void OnMapTileFocused__DelegateSignature(const class UShelterMapTile* InMapTile);
	void OnTileInitialized();
	void SetCloudMapRotationSlot(const struct FCloudMapRotationSlot& InCloudMapRotationSlot);
	void UpdateMapRotationSlot();
	void UpdateRemainingTime();
	void UpdateVisualState();

	class FName GetGameModeAlias() const;
	bool IsAllowed() const;
	bool IsMapRotationSlotCurrentlyValid(const struct FMapRotationSlotEntry& InMapRotationSlot) const;
	struct FDateTime ToClientDateTime(const struct FDateTime& InCloudTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterMapTile">();
	}
	static class UShelterMapTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterMapTile>();
	}
};
static_assert(alignof(UShelterMapTile) == 0x000008, "Wrong alignment on UShelterMapTile");
static_assert(sizeof(UShelterMapTile) == 0x000520, "Wrong size on UShelterMapTile");
static_assert(offsetof(UShelterMapTile, HoverState) == 0x0002B8, "Member 'UShelterMapTile::HoverState' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, HoverByCode) == 0x0002B9, "Member 'UShelterMapTile::HoverByCode' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, DisabledState) == 0x0002BA, "Member 'UShelterMapTile::DisabledState' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, TileIsHovered) == 0x0002BB, "Member 'UShelterMapTile::TileIsHovered' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, OnMapTileFocused) == 0x0002C0, "Member 'UShelterMapTile::OnMapTileFocused' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LevelClassName) == 0x0002D0, "Member 'UShelterMapTile::LevelClassName' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, OnlineGameMode) == 0x0002D8, "Member 'UShelterMapTile::OnlineGameMode' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LabelName) == 0x0002DC, "Member 'UShelterMapTile::LabelName' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EndTime) == 0x0002E8, "Member 'UShelterMapTile::EndTime' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, MapImageColorNormal) == 0x0002F0, "Member 'UShelterMapTile::MapImageColorNormal' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, MapImageColorUnavailable) == 0x000300, "Member 'UShelterMapTile::MapImageColorUnavailable' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EventOverlayOpacityNormal) == 0x000310, "Member 'UShelterMapTile::EventOverlayOpacityNormal' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EventOverlayOpacityUnavailable) == 0x000314, "Member 'UShelterMapTile::EventOverlayOpacityUnavailable' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LevelDescriptionsTable) == 0x000318, "Member 'UShelterMapTile::LevelDescriptionsTable' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, OnlineGameModeDescriptionsTable) == 0x000320, "Member 'UShelterMapTile::OnlineGameModeDescriptionsTable' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LabelsTable) == 0x000328, "Member 'UShelterMapTile::LabelsTable' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, QuickPlayDescription) == 0x000330, "Member 'UShelterMapTile::QuickPlayDescription' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, SoundOnFocus) == 0x000380, "Member 'UShelterMapTile::SoundOnFocus' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LevelDescription) == 0x000388, "Member 'UShelterMapTile::LevelDescription' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, OnlineGameModeDescription) == 0x0003D8, "Member 'UShelterMapTile::OnlineGameModeDescription' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, CloudMapRotationSlot) == 0x000450, "Member 'UShelterMapTile::CloudMapRotationSlot' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, MapImage) == 0x0004A0, "Member 'UShelterMapTile::MapImage' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, FocusFlare) == 0x0004A8, "Member 'UShelterMapTile::FocusFlare' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EventOverlay) == 0x0004B0, "Member 'UShelterMapTile::EventOverlay' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EventBackgroundImage) == 0x0004B8, "Member 'UShelterMapTile::EventBackgroundImage' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, EventName) == 0x0004C0, "Member 'UShelterMapTile::EventName' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, GameModeName) == 0x0004C8, "Member 'UShelterMapTile::GameModeName' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LevelName) == 0x0004D0, "Member 'UShelterMapTile::LevelName' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, RemainingTimeText) == 0x0004D8, "Member 'UShelterMapTile::RemainingTimeText' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, LeftArrow) == 0x0004E0, "Member 'UShelterMapTile::LeftArrow' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, RightArrow) == 0x0004E8, "Member 'UShelterMapTile::RightArrow' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, TeamTooBigOverlay) == 0x0004F0, "Member 'UShelterMapTile::TeamTooBigOverlay' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, TeamTooBigText) == 0x0004F8, "Member 'UShelterMapTile::TeamTooBigText' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, CrossPlayOffOverlay) == 0x000500, "Member 'UShelterMapTile::CrossPlayOffOverlay' has a wrong offset!");
static_assert(offsetof(UShelterMapTile, ActionMoreInfo) == 0x000508, "Member 'UShelterMapTile::ActionMoreInfo' has a wrong offset!");

// Class Flame.ShelterRepair
// 0x0000 (0x0398 - 0x0398)
class AShelterRepair final : public AItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterRepair">();
	}
	static class AShelterRepair* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterRepair>();
	}
};
static_assert(alignof(AShelterRepair) == 0x000008, "Wrong alignment on AShelterRepair");
static_assert(sizeof(AShelterRepair) == 0x000398, "Wrong size on AShelterRepair");

// Class Flame.ShelterSlot
// 0x0020 (0x03B8 - 0x0398)
class AShelterSlot : public AItem
{
public:
	uint8                                         Pad_398[0x20];                                     // 0x0398(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterSlot">();
	}
	static class AShelterSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterSlot>();
	}
};
static_assert(alignof(AShelterSlot) == 0x000008, "Wrong alignment on AShelterSlot");
static_assert(sizeof(AShelterSlot) == 0x0003B8, "Wrong size on AShelterSlot");

// Class Flame.ShelterStashItemProvider
// 0x0028 (0x0080 - 0x0058)
class UShelterStashItemProvider final : public UInventoryItemProvider
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIncludeUnownedItems;                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AAmmoItem>>          UnlockedAmmoTypes;                                 // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void SetCurrentPlayerPawn(class APawn* InPawn);
	void SetCurrentSection(EStashSection InSection);
	void SetCurrentView(EInventoryView InCurrentTab);
	void UpdateUnlockedAmmoTypes();

	const TArray<TSubclassOf<class AAmmoItem>> GetUnlockedAmmoTypes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterStashItemProvider">();
	}
	static class UShelterStashItemProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShelterStashItemProvider>();
	}
};
static_assert(alignof(UShelterStashItemProvider) == 0x000008, "Wrong alignment on UShelterStashItemProvider");
static_assert(sizeof(UShelterStashItemProvider) == 0x000080, "Wrong size on UShelterStashItemProvider");
static_assert(offsetof(UShelterStashItemProvider, bIncludeUnownedItems) == 0x000068, "Member 'UShelterStashItemProvider::bIncludeUnownedItems' has a wrong offset!");
static_assert(offsetof(UShelterStashItemProvider, UnlockedAmmoTypes) == 0x000070, "Member 'UShelterStashItemProvider::UnlockedAmmoTypes' has a wrong offset!");

// Class Flame.ShelterTimerManager
// 0x0070 (0x0290 - 0x0220)
class AShelterTimerManager final : public AInfo
{
public:
	int32                                         UpdateTimeInSeconds;                               // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x6C];                                     // 0x0224(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckCraftingState();

	struct FDateTime GetLastUpdateTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterTimerManager">();
	}
	static class AShelterTimerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterTimerManager>();
	}
};
static_assert(alignof(AShelterTimerManager) == 0x000008, "Wrong alignment on AShelterTimerManager");
static_assert(sizeof(AShelterTimerManager) == 0x000290, "Wrong size on AShelterTimerManager");
static_assert(offsetof(AShelterTimerManager, UpdateTimeInSeconds) == 0x000220, "Member 'AShelterTimerManager::UpdateTimeInSeconds' has a wrong offset!");

// Class Flame.ShelterUIBase
// 0x0000 (0x0220 - 0x0220)
class AShelterUIBase : public AActor
{
public:
	class AMannequin* GetItemPreviews();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShelterUIBase">();
	}
	static class AShelterUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShelterUIBase>();
	}
};
static_assert(alignof(AShelterUIBase) == 0x000008, "Wrong alignment on AShelterUIBase");
static_assert(sizeof(AShelterUIBase) == 0x000220, "Wrong size on AShelterUIBase");

// Class Flame.SideArmWeapon
// 0x0000 (0x0D00 - 0x0D00)
class ASideArmWeapon : public AProjectileWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SideArmWeapon">();
	}
	static class ASideArmWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASideArmWeapon>();
	}
};
static_assert(alignof(ASideArmWeapon) == 0x000010, "Wrong alignment on ASideArmWeapon");
static_assert(sizeof(ASideArmWeapon) == 0x000D00, "Wrong size on ASideArmWeapon");

// Class Flame.OnlineSimpleRequestComponent
// 0x0010 (0x00C0 - 0x00B0)
class UOnlineSimpleRequestComponent final : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             SendSimpleNoAuthGetRequestJsonFinished;            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 SendSimpleNoAuthGetRequestJson(const class FString& APIName);
	void SendSimpleNoAuthGetRequestJsonDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& APIName, const class UJsonValue* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSimpleRequestComponent">();
	}
	static class UOnlineSimpleRequestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSimpleRequestComponent>();
	}
};
static_assert(alignof(UOnlineSimpleRequestComponent) == 0x000008, "Wrong alignment on UOnlineSimpleRequestComponent");
static_assert(sizeof(UOnlineSimpleRequestComponent) == 0x0000C0, "Wrong size on UOnlineSimpleRequestComponent");
static_assert(offsetof(UOnlineSimpleRequestComponent, SendSimpleNoAuthGetRequestJsonFinished) == 0x0000B0, "Member 'UOnlineSimpleRequestComponent::SendSimpleNoAuthGetRequestJsonFinished' has a wrong offset!");

// Class Flame.SkinFunctions
// 0x0000 (0x0028 - 0x0028)
class USkinFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplySkinExtraGeometry(const class AItemSkin* Skin, class USkeletalMeshComponent* ExtraGeometryMesh);
	static bool ApplyWeaponSkinVisual(TSubclassOf<class AItemSkin> SkinClass, class AWeapon* Weapon, class UMeshComponent* Mesh);
	static void ClearExtraSkinGeometryVisuals(class UMeshComponent* MainWeaponMesh);
	static void ClearSkinFromWeapon(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon);
	static bool ClearWeaponSkinVisual(class UMeshComponent* PrimaryMesh, class AWeapon* Weapon);
	static TArray<TSubclassOf<class AItemSkin>> GetAllAvailableItemSkins(class AHumanPlayerController* Player, TSubclassOf<class AItem> Item);
	static TArray<TSubclassOf<class AWeaponSkin>> GetAllAvailableWeaponSkins(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon);
	static TArray<TSubclassOf<class AItemSkin>> GetAllOwnedSkins(class AHumanPlayerController* Player);
	static TArray<TSubclassOf<class AWeaponSkin>> GetAllOwnedWeaponSkins(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon);
	static TArray<class FName> GetBasicSkinSlotNames();
	static TArray<class FName> GetExtraSkinSlotNames();
	static TSubclassOf<class AWeapon> GetWeaponFromSkin(class AHumanPlayerController* Player, TSubclassOf<class AWeaponSkin> Skin);
	static TSubclassOf<class AWeaponSkin> GetWeaponSkin(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon);
	static class UMaterialInstance* LoadSkinMaterialSynchronous(TSoftObjectPtr<class UMaterialInstance> MaterialLink);
	static bool SetDefaultWeaponSkinVisual(class UMeshComponent* PrimaryMesh, class AWeapon* Weapon);
	static void SetSkinToWeapon(class AHumanPlayerController* Player, TSubclassOf<class AWeapon> Weapon, TSubclassOf<class AWeaponSkin> Skin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinFunctions">();
	}
	static class USkinFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinFunctions>();
	}
};
static_assert(alignof(USkinFunctions) == 0x000008, "Wrong alignment on USkinFunctions");
static_assert(sizeof(USkinFunctions) == 0x000028, "Wrong size on USkinFunctions");

// Class Flame.SlotVisual
// 0x0110 (0x03C8 - 0x02B8)
class USlotVisual : public UFlameWidget
{
public:
	EIconSize                                     IconSize;                                          // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESlotVisualBackground, class UTexture2D*> SlotBackgroundMap;                                 // 0x02C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             UnknownItemIcon;                                   // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             NoItemIcon;                                        // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInsuranceIcon;                                // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowEffect;                                       // 0x0321(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlotVisualBackground                         CurrentSlotBackground;                             // 0x0322(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayAmmoMode;                                  // 0x0323(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESlotVisualBackground, struct FSlotVisualBackgroundOpacityStruct> SlotBackgroundOpacityMap;                          // 0x0328(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 SlotAmmoBackgroundColor;                           // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotAmmoBackgroundBase;                            // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotAmmoOutline;                                   // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotEffect;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotBackground;                                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotInsuranceIcon;                                 // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotIcon;                                          // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotFocus;                                         // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SlotCount;                                         // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowsFocus;                                       // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBackground(ESlotVisualBackground InBackground);
	void SetCount(int32 InCount);
	void SetNoItemIcon(class UTexture2D* InIcon);
	void SetSlotColor(const struct FLinearColor& InColor);
	void SetSlotOpacity(float InOpacity);
	void ShowEffect(bool Value);
	void ShowFocus(bool Value);
	void ShowInsuranceIcon(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlotVisual">();
	}
	static class USlotVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlotVisual>();
	}
};
static_assert(alignof(USlotVisual) == 0x000008, "Wrong alignment on USlotVisual");
static_assert(sizeof(USlotVisual) == 0x0003C8, "Wrong size on USlotVisual");
static_assert(offsetof(USlotVisual, IconSize) == 0x0002B8, "Member 'USlotVisual::IconSize' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotBackgroundMap) == 0x0002C0, "Member 'USlotVisual::SlotBackgroundMap' has a wrong offset!");
static_assert(offsetof(USlotVisual, UnknownItemIcon) == 0x000310, "Member 'USlotVisual::UnknownItemIcon' has a wrong offset!");
static_assert(offsetof(USlotVisual, NoItemIcon) == 0x000318, "Member 'USlotVisual::NoItemIcon' has a wrong offset!");
static_assert(offsetof(USlotVisual, bShowInsuranceIcon) == 0x000320, "Member 'USlotVisual::bShowInsuranceIcon' has a wrong offset!");
static_assert(offsetof(USlotVisual, bShowEffect) == 0x000321, "Member 'USlotVisual::bShowEffect' has a wrong offset!");
static_assert(offsetof(USlotVisual, CurrentSlotBackground) == 0x000322, "Member 'USlotVisual::CurrentSlotBackground' has a wrong offset!");
static_assert(offsetof(USlotVisual, bDisplayAmmoMode) == 0x000323, "Member 'USlotVisual::bDisplayAmmoMode' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotBackgroundOpacityMap) == 0x000328, "Member 'USlotVisual::SlotBackgroundOpacityMap' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotAmmoBackgroundColor) == 0x000378, "Member 'USlotVisual::SlotAmmoBackgroundColor' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotAmmoBackgroundBase) == 0x000380, "Member 'USlotVisual::SlotAmmoBackgroundBase' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotAmmoOutline) == 0x000388, "Member 'USlotVisual::SlotAmmoOutline' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotEffect) == 0x000390, "Member 'USlotVisual::SlotEffect' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotBackground) == 0x000398, "Member 'USlotVisual::SlotBackground' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotInsuranceIcon) == 0x0003A0, "Member 'USlotVisual::SlotInsuranceIcon' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotIcon) == 0x0003A8, "Member 'USlotVisual::SlotIcon' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotFocus) == 0x0003B0, "Member 'USlotVisual::SlotFocus' has a wrong offset!");
static_assert(offsetof(USlotVisual, SlotCount) == 0x0003B8, "Member 'USlotVisual::SlotCount' has a wrong offset!");
static_assert(offsetof(USlotVisual, bShowsFocus) == 0x0003C0, "Member 'USlotVisual::bShowsFocus' has a wrong offset!");

// Class Flame.SpawnPersistentConsumable
// 0x0008 (0x0420 - 0x0418)
class ASpawnPersistentConsumable : public AConsumableItem
{
public:
	TSubclassOf<class APersistentItem>            PersistentClass;                                   // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPersistentConsumable">();
	}
	static class ASpawnPersistentConsumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnPersistentConsumable>();
	}
};
static_assert(alignof(ASpawnPersistentConsumable) == 0x000008, "Wrong alignment on ASpawnPersistentConsumable");
static_assert(sizeof(ASpawnPersistentConsumable) == 0x000420, "Wrong size on ASpawnPersistentConsumable");
static_assert(offsetof(ASpawnPersistentConsumable, PersistentClass) == 0x000418, "Member 'ASpawnPersistentConsumable::PersistentClass' has a wrong offset!");

// Class Flame.SpectatorSpringArmComponent
// 0x0050 (0x0250 - 0x0200)
class USpectatorSpringArmComponent final : public USceneComponent
{
public:
	struct FVector                                Offset;                                            // 0x01F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZOffset;                                           // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetProbe;                                       // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoomProbe;                                         // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtendSpeed;                                       // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtendSpeedConstant;                               // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             ProbeChannel;                                      // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x1F];                                     // 0x0219(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0238(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoredActor(const class AActor* Actor);
	void ClearIgnoredActors();
	void RemoveIgnoredActor(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorSpringArmComponent">();
	}
	static class USpectatorSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorSpringArmComponent>();
	}
};
static_assert(alignof(USpectatorSpringArmComponent) == 0x000010, "Wrong alignment on USpectatorSpringArmComponent");
static_assert(sizeof(USpectatorSpringArmComponent) == 0x000250, "Wrong size on USpectatorSpringArmComponent");
static_assert(offsetof(USpectatorSpringArmComponent, Offset) == 0x0001F8, "Member 'USpectatorSpringArmComponent::Offset' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, ZOffset) == 0x000204, "Member 'USpectatorSpringArmComponent::ZOffset' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, TargetProbe) == 0x000208, "Member 'USpectatorSpringArmComponent::TargetProbe' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, BoomProbe) == 0x00020C, "Member 'USpectatorSpringArmComponent::BoomProbe' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, ExtendSpeed) == 0x000210, "Member 'USpectatorSpringArmComponent::ExtendSpeed' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, ExtendSpeedConstant) == 0x000214, "Member 'USpectatorSpringArmComponent::ExtendSpeedConstant' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, ProbeChannel) == 0x000218, "Member 'USpectatorSpringArmComponent::ProbeChannel' has a wrong offset!");
static_assert(offsetof(USpectatorSpringArmComponent, IgnoredActors) == 0x000238, "Member 'USpectatorSpringArmComponent::IgnoredActors' has a wrong offset!");

// Class Flame.SpeedModifierComponent
// 0x00A0 (0x0150 - 0x00B0)
class USpeedModifierComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xA0];                                      // 0x00B0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSpeedModifierData(TArray<struct FContextSpeedModifier>* OutContext, TArray<struct FActiveEventSpeedModifierCurve>* OutCurve, TArray<struct FActiveEventSpeedModifierConstant>* OutConstant) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeedModifierComponent">();
	}
	static class USpeedModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeedModifierComponent>();
	}
};
static_assert(alignof(USpeedModifierComponent) == 0x000008, "Wrong alignment on USpeedModifierComponent");
static_assert(sizeof(USpeedModifierComponent) == 0x000150, "Wrong size on USpeedModifierComponent");

// Class Flame.CurveStamina
// 0x0180 (0x01B0 - 0x0030)
class UCurveStamina final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector GetValues(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveStamina">();
	}
	static class UCurveStamina* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveStamina>();
	}
};
static_assert(alignof(UCurveStamina) == 0x000008, "Wrong alignment on UCurveStamina");
static_assert(sizeof(UCurveStamina) == 0x0001B0, "Wrong size on UCurveStamina");
static_assert(offsetof(UCurveStamina, FloatCurves) == 0x000030, "Member 'UCurveStamina::FloatCurves' has a wrong offset!");

// Class Flame.CurveStaminaMultiplier
// 0x0180 (0x01B0 - 0x0030)
class UCurveStaminaMultiplier final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0030(0x0080)(NativeAccessSpecifierPublic)

public:
	struct FVector GetValues(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveStaminaMultiplier">();
	}
	static class UCurveStaminaMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveStaminaMultiplier>();
	}
};
static_assert(alignof(UCurveStaminaMultiplier) == 0x000008, "Wrong alignment on UCurveStaminaMultiplier");
static_assert(sizeof(UCurveStaminaMultiplier) == 0x0001B0, "Wrong size on UCurveStaminaMultiplier");
static_assert(offsetof(UCurveStaminaMultiplier, FloatCurves) == 0x000030, "Member 'UCurveStaminaMultiplier::FloatCurves' has a wrong offset!");

// Class Flame.StartScreen
// 0x0048 (0x0300 - 0x02B8)
class UStartScreen final : public UFlameWidget
{
public:
	TSubclassOf<class UFirstTimeOptions>          FirstTimeOptionsClass;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        WelcomeMessage;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameTextBlock*                        ErrorMessage;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ErrorOverlay;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionStartGame;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionSwitchProfile;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeOnUserLoginChanged(bool bLogin, int32 UserIndex);
	void OnFirstTimeOptionsClosed(class UFlameWidget* InOptionsWidget);
	void OnRefreshUI();
	void OnStartGameRequested();
	void OnSwitchProfileRequested();
	void StartGame();
	void StartGameClicked();
	void WindowsInputTypeChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartScreen">();
	}
	static class UStartScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartScreen>();
	}
};
static_assert(alignof(UStartScreen) == 0x000008, "Wrong alignment on UStartScreen");
static_assert(sizeof(UStartScreen) == 0x000300, "Wrong size on UStartScreen");
static_assert(offsetof(UStartScreen, FirstTimeOptionsClass) == 0x0002B8, "Member 'UStartScreen::FirstTimeOptionsClass' has a wrong offset!");
static_assert(offsetof(UStartScreen, WelcomeMessage) == 0x0002C0, "Member 'UStartScreen::WelcomeMessage' has a wrong offset!");
static_assert(offsetof(UStartScreen, ErrorMessage) == 0x0002C8, "Member 'UStartScreen::ErrorMessage' has a wrong offset!");
static_assert(offsetof(UStartScreen, ErrorOverlay) == 0x0002D0, "Member 'UStartScreen::ErrorOverlay' has a wrong offset!");
static_assert(offsetof(UStartScreen, ActionStartGame) == 0x0002D8, "Member 'UStartScreen::ActionStartGame' has a wrong offset!");
static_assert(offsetof(UStartScreen, ActionSwitchProfile) == 0x0002E0, "Member 'UStartScreen::ActionSwitchProfile' has a wrong offset!");

// Class Flame.StashComponent
// 0x0300 (0x0500 - 0x0200)
class UStashComponent final : public ULootOnGroundComponent
{
public:
	FMulticastInlineDelegateProperty_             CloudLoadedAuthority;                              // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             MaterialUpdated;                                   // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             BoosterTicketUpdated;                              // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x280];                                    // 0x0230(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AShelterSlot>               CraftingTableSlotClass;                            // 0x04B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWeaponsCraftingList>       WeaponsCraftingClass;                              // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UConsumablesCraftingList>   ConsumablesCraftingClass;                          // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAmmoCraftingList>          AmmoCraftingClass;                                 // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UShelterCraftingList>       ShelterCraftingClass;                              // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponsCraftingList*                   CraftedWeapons;                                    // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsumablesCraftingList*               CraftedConsumables;                                // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAmmoCraftingList*                      CraftedAmmo;                                       // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShelterCraftingList*                   CraftedShelter;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTokensList*                            TokensList;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PostChangeCraftingAmmo(class UAmmoCraftingList* OldContainer);
	void OnRep_PostChangeCraftingConsumables(class UConsumablesCraftingList* OldContainer);
	void OnRep_PostChangeCraftingShelter(class UShelterCraftingList* OldContainer);
	void OnRep_PostChangeCraftingWeapons(class UWeaponsCraftingList* OldContainer);
	void OnRep_PostChangeTokens(class UTokensList* OldContainer);

	int32 GetBoosterTicketCount(const class FString& TypeKey) const;
	bool GetBoosterTicketDetails(const class FString& Type, int32* Index_0, struct FBoosterDetails* BoosterDetails) const;
	class UAmmoCraftingList* GetCraftingAmmo() const;
	class UConsumablesCraftingList* GetCraftingConsumables() const;
	class UShelterCraftingList* GetCraftingShelter() const;
	class UWeaponsCraftingList* GetCraftingWeapons() const;
	int32 GetCurrencyCount() const;
	int32 GetFoodCapacity() const;
	int32 GetFoodCount() const;
	int32 GetMaterialCapacity() const;
	int32 GetMaterialCount() const;
	int32 GetShelterLevel() const;
	bool IsInitiliazed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StashComponent">();
	}
	static class UStashComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStashComponent>();
	}
};
static_assert(alignof(UStashComponent) == 0x000008, "Wrong alignment on UStashComponent");
static_assert(sizeof(UStashComponent) == 0x000500, "Wrong size on UStashComponent");
static_assert(offsetof(UStashComponent, CloudLoadedAuthority) == 0x000200, "Member 'UStashComponent::CloudLoadedAuthority' has a wrong offset!");
static_assert(offsetof(UStashComponent, MaterialUpdated) == 0x000210, "Member 'UStashComponent::MaterialUpdated' has a wrong offset!");
static_assert(offsetof(UStashComponent, BoosterTicketUpdated) == 0x000220, "Member 'UStashComponent::BoosterTicketUpdated' has a wrong offset!");
static_assert(offsetof(UStashComponent, CraftingTableSlotClass) == 0x0004B0, "Member 'UStashComponent::CraftingTableSlotClass' has a wrong offset!");
static_assert(offsetof(UStashComponent, WeaponsCraftingClass) == 0x0004B8, "Member 'UStashComponent::WeaponsCraftingClass' has a wrong offset!");
static_assert(offsetof(UStashComponent, ConsumablesCraftingClass) == 0x0004C0, "Member 'UStashComponent::ConsumablesCraftingClass' has a wrong offset!");
static_assert(offsetof(UStashComponent, AmmoCraftingClass) == 0x0004C8, "Member 'UStashComponent::AmmoCraftingClass' has a wrong offset!");
static_assert(offsetof(UStashComponent, ShelterCraftingClass) == 0x0004D0, "Member 'UStashComponent::ShelterCraftingClass' has a wrong offset!");
static_assert(offsetof(UStashComponent, CraftedWeapons) == 0x0004D8, "Member 'UStashComponent::CraftedWeapons' has a wrong offset!");
static_assert(offsetof(UStashComponent, CraftedConsumables) == 0x0004E0, "Member 'UStashComponent::CraftedConsumables' has a wrong offset!");
static_assert(offsetof(UStashComponent, CraftedAmmo) == 0x0004E8, "Member 'UStashComponent::CraftedAmmo' has a wrong offset!");
static_assert(offsetof(UStashComponent, CraftedShelter) == 0x0004F0, "Member 'UStashComponent::CraftedShelter' has a wrong offset!");
static_assert(offsetof(UStashComponent, TokensList) == 0x0004F8, "Member 'UStashComponent::TokensList' has a wrong offset!");

// Class Flame.StateMachineComponent
// 0x00D8 (0x0188 - 0x00B0)
class UStateMachineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HistoryDepth;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMachineMode                                  LastKnownMachineMode;                              // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StatesStartedCount;                                // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StatesPassedCount;                                 // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StatesPassedCountServer;                           // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemStateHistoryInfo>          StatesHistory;                                     // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemStateHistoryInfo>          StatesHistoryServer;                               // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FItemStatePair>                 StatesQueue;                                       // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemStatePair>                 StatesQueueServerReplicated;                       // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FServerStateInfoLocal>          StatesServerRpc;                                   // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x48];                                     // 0x0120(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateFinishedScriptDelegate;                     // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnLastStateFinishedScriptDelegate;                 // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void MulticastReceivedStateEndFromServer(const struct FServerStateInfo& Info);
	void MulticastReceivedStateStartFromServer(const struct FServerStateInfo& Info);
	void OnRepHistory(const TArray<struct FItemStateHistoryInfo>& OldArray);
	void OnRepStates(const TArray<struct FItemStatePair>& OldArray);

	class FString GetCurrentStateInfo() const;
	class FString GetCurrentStateInfoServer() const;
	class UItemState* GetCurrentStateInMachine() const;
	bool IsMachineEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachineComponent">();
	}
	static class UStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachineComponent>();
	}
};
static_assert(alignof(UStateMachineComponent) == 0x000008, "Wrong alignment on UStateMachineComponent");
static_assert(sizeof(UStateMachineComponent) == 0x000188, "Wrong size on UStateMachineComponent");
static_assert(offsetof(UStateMachineComponent, HistoryDepth) == 0x0000B8, "Member 'UStateMachineComponent::HistoryDepth' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, LastKnownMachineMode) == 0x0000BC, "Member 'UStateMachineComponent::LastKnownMachineMode' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesStartedCount) == 0x0000C0, "Member 'UStateMachineComponent::StatesStartedCount' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesPassedCount) == 0x0000C4, "Member 'UStateMachineComponent::StatesPassedCount' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesPassedCountServer) == 0x0000C8, "Member 'UStateMachineComponent::StatesPassedCountServer' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesHistory) == 0x0000D0, "Member 'UStateMachineComponent::StatesHistory' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesHistoryServer) == 0x0000E0, "Member 'UStateMachineComponent::StatesHistoryServer' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesQueue) == 0x0000F0, "Member 'UStateMachineComponent::StatesQueue' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesQueueServerReplicated) == 0x000100, "Member 'UStateMachineComponent::StatesQueueServerReplicated' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, StatesServerRpc) == 0x000110, "Member 'UStateMachineComponent::StatesServerRpc' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, OnStateFinishedScriptDelegate) == 0x000168, "Member 'UStateMachineComponent::OnStateFinishedScriptDelegate' has a wrong offset!");
static_assert(offsetof(UStateMachineComponent, OnLastStateFinishedScriptDelegate) == 0x000178, "Member 'UStateMachineComponent::OnLastStateFinishedScriptDelegate' has a wrong offset!");

// Class Flame.SteamGameStorePurchaseHandler
// 0x0020 (0x00A0 - 0x0080)
class USteamGameStorePurchaseHandler final : public UGameStorePurchaseHandler
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntervalInSeconds;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformStoreOffersManagerSteam*       StoredSteamOffersManager;                          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetSimulateOverlaySteam(bool bEnable);

	void CheckStorePurchaseCompleted();
	void StartPollingStore();
	void StopPollingStore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamGameStorePurchaseHandler">();
	}
	static class USteamGameStorePurchaseHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamGameStorePurchaseHandler>();
	}
};
static_assert(alignof(USteamGameStorePurchaseHandler) == 0x000008, "Wrong alignment on USteamGameStorePurchaseHandler");
static_assert(sizeof(USteamGameStorePurchaseHandler) == 0x0000A0, "Wrong size on USteamGameStorePurchaseHandler");
static_assert(offsetof(USteamGameStorePurchaseHandler, IntervalInSeconds) == 0x000088, "Member 'USteamGameStorePurchaseHandler::IntervalInSeconds' has a wrong offset!");
static_assert(offsetof(USteamGameStorePurchaseHandler, StoredSteamOffersManager) == 0x000090, "Member 'USteamGameStorePurchaseHandler::StoredSteamOffersManager' has a wrong offset!");

// Class Flame.SteamMicrotransactionGameStorePurchaseHandler
// 0x0020 (0x00A0 - 0x0080)
class USteamMicrotransactionGameStorePurchaseHandler final : public UGameStorePurchaseHandler
{
public:
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlatformStoreOffersManagerSteam*       StoredSteamOffersManager;                          // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void SetSimulateOverlaySteam(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamMicrotransactionGameStorePurchaseHandler">();
	}
	static class USteamMicrotransactionGameStorePurchaseHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamMicrotransactionGameStorePurchaseHandler>();
	}
};
static_assert(alignof(USteamMicrotransactionGameStorePurchaseHandler) == 0x000008, "Wrong alignment on USteamMicrotransactionGameStorePurchaseHandler");
static_assert(sizeof(USteamMicrotransactionGameStorePurchaseHandler) == 0x0000A0, "Wrong size on USteamMicrotransactionGameStorePurchaseHandler");
static_assert(offsetof(USteamMicrotransactionGameStorePurchaseHandler, StoredSteamOffersManager) == 0x000098, "Member 'USteamMicrotransactionGameStorePurchaseHandler::StoredSteamOffersManager' has a wrong offset!");

// Class Flame.SubtitleWidget
// 0x0008 (0x02C0 - 0x02B8)
class USubtitleWidget : public UFlameWidget
{
public:
	class UFlameTextBlock*                        SubtitleText;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSetSubtitleText(const class FText& InSubtitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleWidget">();
	}
	static class USubtitleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleWidget>();
	}
};
static_assert(alignof(USubtitleWidget) == 0x000008, "Wrong alignment on USubtitleWidget");
static_assert(sizeof(USubtitleWidget) == 0x0002C0, "Wrong size on USubtitleWidget");
static_assert(offsetof(USubtitleWidget, SubtitleText) == 0x0002B8, "Member 'USubtitleWidget::SubtitleText' has a wrong offset!");

// Class Flame.SwapWeaponsWidget
// 0x0028 (0x0318 - 0x02F0)
class USwapWeaponsWidget : public UModalWidget
{
public:
	class UFlameSlot*                             WeaponSlotNew;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             WeaponSlotA;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             WeaponSlotB;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputActionWidget*                     ActionClose;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeapon*                                SelectedWeapon;                                    // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClosed();
	void OnSelectedWeaponA(class UButton* Sender);
	void OnSelectedWeaponB(class UButton* Sender);
	void SelectWeaponOnMouseClick(class UFlameSlot* WeaponSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwapWeaponsWidget">();
	}
	static class USwapWeaponsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwapWeaponsWidget>();
	}
};
static_assert(alignof(USwapWeaponsWidget) == 0x000008, "Wrong alignment on USwapWeaponsWidget");
static_assert(sizeof(USwapWeaponsWidget) == 0x000318, "Wrong size on USwapWeaponsWidget");
static_assert(offsetof(USwapWeaponsWidget, WeaponSlotNew) == 0x0002F0, "Member 'USwapWeaponsWidget::WeaponSlotNew' has a wrong offset!");
static_assert(offsetof(USwapWeaponsWidget, WeaponSlotA) == 0x0002F8, "Member 'USwapWeaponsWidget::WeaponSlotA' has a wrong offset!");
static_assert(offsetof(USwapWeaponsWidget, WeaponSlotB) == 0x000300, "Member 'USwapWeaponsWidget::WeaponSlotB' has a wrong offset!");
static_assert(offsetof(USwapWeaponsWidget, ActionClose) == 0x000308, "Member 'USwapWeaponsWidget::ActionClose' has a wrong offset!");
static_assert(offsetof(USwapWeaponsWidget, SelectedWeapon) == 0x000310, "Member 'USwapWeaponsWidget::SelectedWeapon' has a wrong offset!");

// Class Flame.TabWidget
// 0x0050 (0x0308 - 0x02B8)
class UTabWidget : public UFlameWidget
{
public:
	struct FLinearColor                           BackgroundNormalTintSelected;                      // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundNormalTintDeselected;                    // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundHoverTint;                               // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECursorMode                                   HoverState;                                        // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECursorMode                                   DisabledState;                                     // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsLocked;                                          // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TabText;                                           // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelected;                                       // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeselect();
	void OnSelect();
	void OnTabHovered();
	void OnTabUnhovered();

	class UUserWidget* GetTabContent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabWidget">();
	}
	static class UTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabWidget>();
	}
};
static_assert(alignof(UTabWidget) == 0x000008, "Wrong alignment on UTabWidget");
static_assert(sizeof(UTabWidget) == 0x000308, "Wrong size on UTabWidget");
static_assert(offsetof(UTabWidget, BackgroundNormalTintSelected) == 0x0002B8, "Member 'UTabWidget::BackgroundNormalTintSelected' has a wrong offset!");
static_assert(offsetof(UTabWidget, BackgroundNormalTintDeselected) == 0x0002C8, "Member 'UTabWidget::BackgroundNormalTintDeselected' has a wrong offset!");
static_assert(offsetof(UTabWidget, BackgroundHoverTint) == 0x0002D8, "Member 'UTabWidget::BackgroundHoverTint' has a wrong offset!");
static_assert(offsetof(UTabWidget, HoverState) == 0x0002E8, "Member 'UTabWidget::HoverState' has a wrong offset!");
static_assert(offsetof(UTabWidget, DisabledState) == 0x0002E9, "Member 'UTabWidget::DisabledState' has a wrong offset!");
static_assert(offsetof(UTabWidget, IsLocked) == 0x0002F0, "Member 'UTabWidget::IsLocked' has a wrong offset!");
static_assert(offsetof(UTabWidget, TabText) == 0x0002F8, "Member 'UTabWidget::TabText' has a wrong offset!");
static_assert(offsetof(UTabWidget, bIsSelected) == 0x000300, "Member 'UTabWidget::bIsSelected' has a wrong offset!");

// Class Flame.Task
// 0x0080 (0x00A8 - 0x0028)
class UTask final : public UObject
{
public:
	int32                                         TaskID;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskCategory                                 TaskCategory;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskState                                    TaskState;                                         // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TaskName;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TaskObjective;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TaskJournalEntryReceived;                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TaskJournalEntryCompleted;                         // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrentCompletion;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalCompletion;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCondition>>         Conditions;                                        // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AdvanceTaskCompletion();
	void BindTaskDelegates();
	void ChangeTaskState(ETaskState NewState);
	void CompleteTask();
	void GetFormattedTaskText();
	void StartTask();
	void UnBindTaskDelegates();
	void UpdateTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Task">();
	}
	static class UTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTask>();
	}
};
static_assert(alignof(UTask) == 0x000008, "Wrong alignment on UTask");
static_assert(sizeof(UTask) == 0x0000A8, "Wrong size on UTask");
static_assert(offsetof(UTask, TaskID) == 0x000028, "Member 'UTask::TaskID' has a wrong offset!");
static_assert(offsetof(UTask, TaskCategory) == 0x00002C, "Member 'UTask::TaskCategory' has a wrong offset!");
static_assert(offsetof(UTask, TaskState) == 0x00002D, "Member 'UTask::TaskState' has a wrong offset!");
static_assert(offsetof(UTask, TaskName) == 0x000030, "Member 'UTask::TaskName' has a wrong offset!");
static_assert(offsetof(UTask, TaskObjective) == 0x000048, "Member 'UTask::TaskObjective' has a wrong offset!");
static_assert(offsetof(UTask, TaskJournalEntryReceived) == 0x000060, "Member 'UTask::TaskJournalEntryReceived' has a wrong offset!");
static_assert(offsetof(UTask, TaskJournalEntryCompleted) == 0x000078, "Member 'UTask::TaskJournalEntryCompleted' has a wrong offset!");
static_assert(offsetof(UTask, CurrentCompletion) == 0x000090, "Member 'UTask::CurrentCompletion' has a wrong offset!");
static_assert(offsetof(UTask, TotalCompletion) == 0x000094, "Member 'UTask::TotalCompletion' has a wrong offset!");
static_assert(offsetof(UTask, Conditions) == 0x000098, "Member 'UTask::Conditions' has a wrong offset!");

// Class Flame.TaskSystemComponent
// 0x0010 (0x00C0 - 0x00B0)
class UTaskSystemComponent final : public UActorComponent
{
public:
	TArray<class UTask*>                          ActiveTasks;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddTask(TSubclassOf<class UTask> TaskToAdd);
	void CompleteTask(int32 TaskID);
	TArray<TSubclassOf<class UTask>> GetReadyTasks();
	class UTask* GetTask(int32 TaskID);
	ETaskState GetTaskState(int32 TaskID);
	bool HasTask(int32 TaskID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskSystemComponent">();
	}
	static class UTaskSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskSystemComponent>();
	}
};
static_assert(alignof(UTaskSystemComponent) == 0x000008, "Wrong alignment on UTaskSystemComponent");
static_assert(sizeof(UTaskSystemComponent) == 0x0000C0, "Wrong size on UTaskSystemComponent");
static_assert(offsetof(UTaskSystemComponent, ActiveTasks) == 0x0000B0, "Member 'UTaskSystemComponent::ActiveTasks' has a wrong offset!");

// Class Flame.TextNotification
// 0x0010 (0x02E0 - 0x02D0)
class UTextNotification : public UNotificationBase
{
public:
	ETextNotificationType                         Type;                                              // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlameTextBlock*                        Message;                                           // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnContentChanged();
	void SetMessage(const class FText& InText);
	void SetType(ETextNotificationType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextNotification">();
	}
	static class UTextNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextNotification>();
	}
};
static_assert(alignof(UTextNotification) == 0x000008, "Wrong alignment on UTextNotification");
static_assert(sizeof(UTextNotification) == 0x0002E0, "Wrong size on UTextNotification");
static_assert(offsetof(UTextNotification, Type) == 0x0002D0, "Member 'UTextNotification::Type' has a wrong offset!");
static_assert(offsetof(UTextNotification, Message) == 0x0002D8, "Member 'UTextNotification::Message' has a wrong offset!");

// Class Flame.Throwable
// 0x0000 (0x0D00 - 0x0D00)
class AThrowable final : public AProjectileWeapon
{
public:
	void ReceiveOnThrow(class AThrowableConsumable* ProjectileFired);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Throwable">();
	}
	static class AThrowable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowable>();
	}
};
static_assert(alignof(AThrowable) == 0x000010, "Wrong alignment on AThrowable");
static_assert(sizeof(AThrowable) == 0x000D00, "Wrong size on AThrowable");

// Class Flame.AimingArcSpline
// 0x0160 (0x06B0 - 0x0550)
class UAimingArcSpline final : public USplineComponent
{
public:
	struct FPredictProjectilePathResult           Result;                                            // 0x0550(0x00B8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ArcMaterial;                                       // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ImpactPointMaterial;                               // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ArcMeshPath;                                       // 0x0618(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        ImpactPoint;                                       // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshes;                                      // 0x0638(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MaxMeshes;                                         // 0x0648(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x64];                                     // 0x064C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimingArcSpline">();
	}
	static class UAimingArcSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimingArcSpline>();
	}
};
static_assert(alignof(UAimingArcSpline) == 0x000010, "Wrong alignment on UAimingArcSpline");
static_assert(sizeof(UAimingArcSpline) == 0x0006B0, "Wrong size on UAimingArcSpline");
static_assert(offsetof(UAimingArcSpline, Result) == 0x000550, "Member 'UAimingArcSpline::Result' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, ArcMaterial) == 0x000608, "Member 'UAimingArcSpline::ArcMaterial' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, ImpactPointMaterial) == 0x000610, "Member 'UAimingArcSpline::ImpactPointMaterial' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, ArcMeshPath) == 0x000618, "Member 'UAimingArcSpline::ArcMeshPath' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, ImpactPoint) == 0x000630, "Member 'UAimingArcSpline::ImpactPoint' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, SplineMeshes) == 0x000638, "Member 'UAimingArcSpline::SplineMeshes' has a wrong offset!");
static_assert(offsetof(UAimingArcSpline, MaxMeshes) == 0x000648, "Member 'UAimingArcSpline::MaxMeshes' has a wrong offset!");

// Class Flame.ThrowableHelpers
// 0x0000 (0x0028 - 0x0028)
class UThrowableHelpers final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowableHelpers">();
	}
	static class UThrowableHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowableHelpers>();
	}
};
static_assert(alignof(UThrowableHelpers) == 0x000008, "Wrong alignment on UThrowableHelpers");
static_assert(sizeof(UThrowableHelpers) == 0x000028, "Wrong size on UThrowableHelpers");

// Class Flame.TokensList
// 0x0010 (0x00C8 - 0x00B8)
class UTokensList final : public UItemsList
{
public:
	TArray<TSubclassOf<class AToken>>             AvailableTokens;                                   // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokensList">();
	}
	static class UTokensList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTokensList>();
	}
};
static_assert(alignof(UTokensList) == 0x000008, "Wrong alignment on UTokensList");
static_assert(sizeof(UTokensList) == 0x0000C8, "Wrong size on UTokensList");
static_assert(offsetof(UTokensList, AvailableTokens) == 0x0000B8, "Member 'UTokensList::AvailableTokens' has a wrong offset!");

// Class Flame.TutorialAIDataProvider
// 0x0030 (0x0250 - 0x0220)
class ATutorialAIDataProvider final : public AActor
{
public:
	struct FTutorialAIInitializationData          InitializationData;                                // 0x0220(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAIDataProvider">();
	}
	static class ATutorialAIDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialAIDataProvider>();
	}
};
static_assert(alignof(ATutorialAIDataProvider) == 0x000008, "Wrong alignment on ATutorialAIDataProvider");
static_assert(sizeof(ATutorialAIDataProvider) == 0x000250, "Wrong size on ATutorialAIDataProvider");
static_assert(offsetof(ATutorialAIDataProvider, InitializationData) == 0x000220, "Member 'ATutorialAIDataProvider::InitializationData' has a wrong offset!");

// Class Flame.UICoreObject
// 0x0068 (0x0090 - 0x0028)
class UUICoreObject final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UModalWidget*                           ModalWidget;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LevelDescriptionsTable;                            // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const struct FItemRarity GetItemRarity(int32 InIndex) const;
	struct FLevelDescriptionTableRow GetLevelDescription(class FName InLevelName) const;
	class UModalWidget* GetModalWidget() const;
	int32 GetZOrder(EUILayer InLayer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoreObject">();
	}
	static class UUICoreObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoreObject>();
	}
};
static_assert(alignof(UUICoreObject) == 0x000008, "Wrong alignment on UUICoreObject");
static_assert(sizeof(UUICoreObject) == 0x000090, "Wrong size on UUICoreObject");
static_assert(offsetof(UUICoreObject, ModalWidget) == 0x000078, "Member 'UUICoreObject::ModalWidget' has a wrong offset!");
static_assert(offsetof(UUICoreObject, LevelDescriptionsTable) == 0x000088, "Member 'UUICoreObject::LevelDescriptionsTable' has a wrong offset!");

// Class Flame.UserInterfaceFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserInterfaceFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CloseGameMenu(const class APlayerController* InPlayerController);
	static void CloseModalWidget(const class APlayerController* InOwningPlayer);
	static void CloseShelterUI(const class APlayerController* InPlayerController);
	static class FString Conv_NetIdToString(const struct FUniqueNetIdRepl& InNetId);
	static bool EqualEqual_NetIdNetId(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B);
	static bool ExistsModalWidget(const class APlayerController* InOwningPlayer);
	static class UWidget* FindFocusedWidget(const class AHumanPlayerController* HumanController);
	static class UMenuWidget* GetActiveMenuWidget(const class AHumanPlayerController* HumanController);
	static TArray<class UUserWidget*> GetAllNestedUserWidgets(const class UUserWidget* InUserWidget);
	static void GetAllOpenedWidgets(const class APlayerController* InPlayerController, TArray<class UFlameWidget*>* OutWidgets, TSubclassOf<class UFlameWidget> InWidgetClass);
	static class UMenuWidget* GetGameMenu(const class APlayerController* InPlayerController);
	static class UUserWidget* GetGrandParentUserWidget(const class UWidget* InWidget, int32 InNumOfGenerations);
	static int32 GetHighestInputPriority(TArray<class UUserWidget*>* InUserWidgets);
	static TArray<class FText> GetInputsFromText(const class FText& Text);
	static const struct FItemRarity GetItemRarity(class UObject* WorldContextObject, class AItem* InItem);
	static struct FLevelDescriptionTableRow GetLevelDescription(class UObject* WorldContextObject, class FName InLevelName);
	static struct FLinearColor GetMapMarkerColor(class UObject* WorldContextObject, EMapMarkerType InMarkerType);
	static class UNotificationSystem* GetNotificationSystem(const class UObject* WorldContextObject);
	static class UUserWidget* GetParentUserWidget(const class UWidget* InWidget);
	static class FString GetPlatformGroup();
	static class UProfilePictureCache* GetProfilePictureCache(const class UObject* WorldContextObject);
	static class FText GetRichPlayerNickname(const class FText& InPlayerNickname, EFlamePlatform InPlayerPlatform);
	static class FText GetRichPlayerNicknameWidget();
	static class UShelterMainTabControl* GetShelterUI(const class APlayerController* InPlayerController);
	static class UUICoreObject* GetUICoreObject(const class UObject* WorldContextObject);
	static int32 GetZOrder(const class UObject* WorldContextObject, EUILayer Layer);
	static bool HasFocus(const class UWidget* InWidget);
	static bool IsAnyMenuOpen(const class APlayerController* InPlayerController);
	static bool IsExhibitionPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId);
	static bool IsLocalPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId);
	static bool IsPlatformGroupConsole();
	static bool IsPlatformGroupDesktop();
	static bool IsPlatformGroupMobile();
	static bool IsReallyVisible(const class UWidget* InWidget);
	static bool IsValidPlayer(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueNetId);
	static void KeepCurrentFocus(class APlayerController* InPlayerController);
	static struct FLinearColor LinearColorFromHexString(const class FString& InHexString);
	static bool NotEqual_NetIdNetId(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B);
	static void OpenGameMenu(const class APlayerController* InPlayerController);
	static class UModalWidget* OpenIdleWidget(class APlayerController* InOwningPlayer);
	static class UModalWidget* OpenModalWidget(class APlayerController* InOwningPlayer, TSubclassOf<class UModalWidget> InWidgetClass);
	static void OpenShelterUI(const class APlayerController* InPlayerController, EShelterMainTab InTab);
	static class FText ReplaceTextWithControls(const class FText& Text, const TArray<class FText>& Inputs);
	static void ReportEnterInGameStoreUI();
	static void ReportExitInGameStoreUI();
	static class FString SetDefaultLanguage();
	static bool SetLanguage(const class FString& InCultureName);
	static class UMessageBoxWidget* ShowMessageBox(class UObject* WorldContextObject, const class FText& InTitle, const class FText& InMessage, EMessageBoxType InType, const TDelegate<void(EMessageBoxAction Result)>& OnMessageBoxClosed);
	static void ShowTextNotification(class UObject* WorldContextObject, ETextNotificationType InType, float InDuration, const class FText& InMessage, const struct FNotificationParams& InParameters);
	static bool StringIsEmpty(const class FString& String);
	static bool StringNotEmpty(const class FString& String);
	static void TimerWithString(const TDelegate<void(const class FString& Value)>& Event, float Time, const class FString& Value);

	void TimerDynamicDelegateS__DelegateSignature(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInterfaceFunctionLibrary">();
	}
	static class UUserInterfaceFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInterfaceFunctionLibrary>();
	}
};
static_assert(alignof(UUserInterfaceFunctionLibrary) == 0x000008, "Wrong alignment on UUserInterfaceFunctionLibrary");
static_assert(sizeof(UUserInterfaceFunctionLibrary) == 0x000028, "Wrong size on UUserInterfaceFunctionLibrary");

// Class Flame.UniformComponent
// 0x0000 (0x0EF0 - 0x0EF0)
class UUniformComponent : public UClothesMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniformComponent">();
	}
	static class UUniformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniformComponent>();
	}
};
static_assert(alignof(UUniformComponent) == 0x000010, "Wrong alignment on UUniformComponent");
static_assert(sizeof(UUniformComponent) == 0x000EF0, "Wrong size on UUniformComponent");

// Class Flame.UsableComponent
// 0x0038 (0x00E8 - 0x00B0)
class UUsableComponent final : public UActorComponent
{
public:
	float                                         Time;                                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             UsedAuthority;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UsedClient;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UsedProxy;                                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool CanBeUsed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableComponent">();
	}
	static class UUsableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableComponent>();
	}
};
static_assert(alignof(UUsableComponent) == 0x000008, "Wrong alignment on UUsableComponent");
static_assert(sizeof(UUsableComponent) == 0x0000E8, "Wrong size on UUsableComponent");
static_assert(offsetof(UUsableComponent, Time) == 0x0000B0, "Member 'UUsableComponent::Time' has a wrong offset!");
static_assert(offsetof(UUsableComponent, UsedAuthority) == 0x0000B8, "Member 'UUsableComponent::UsedAuthority' has a wrong offset!");
static_assert(offsetof(UUsableComponent, UsedClient) == 0x0000C8, "Member 'UUsableComponent::UsedClient' has a wrong offset!");
static_assert(offsetof(UUsableComponent, UsedProxy) == 0x0000D8, "Member 'UUsableComponent::UsedProxy' has a wrong offset!");

// Class Flame.OnlineUserCountersComponent
// 0x0020 (0x00D0 - 0x00B0)
class UOnlineUserCountersComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             UserCounterReceived;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserCounterUpdated;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetUserCounter(class AHumanPlayerController* Player, class FName CounterName);
	void GetUserCounterDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, const struct FCloudUserCounterValue& CounterValue);
	int32 UpdateUserCounter(class AHumanPlayerController* Player, class FName CounterName, const struct FCloudUserCounterUpdate& UpdateData);
	void UpdateUserCounterDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, class AHumanPlayerController* Player, ECloudUserCounterOperation Operation, const struct FCloudUserCounterValue& CounterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineUserCountersComponent">();
	}
	static class UOnlineUserCountersComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineUserCountersComponent>();
	}
};
static_assert(alignof(UOnlineUserCountersComponent) == 0x000008, "Wrong alignment on UOnlineUserCountersComponent");
static_assert(sizeof(UOnlineUserCountersComponent) == 0x0000D0, "Wrong size on UOnlineUserCountersComponent");
static_assert(offsetof(UOnlineUserCountersComponent, UserCounterReceived) == 0x0000B0, "Member 'UOnlineUserCountersComponent::UserCounterReceived' has a wrong offset!");
static_assert(offsetof(UOnlineUserCountersComponent, UserCounterUpdated) == 0x0000C0, "Member 'UOnlineUserCountersComponent::UserCounterUpdated' has a wrong offset!");

// Class Flame.UserInfoComponent
// 0x00F0 (0x01A0 - 0x00B0)
class UUserInfoComponent : public UOnlineComponentBase
{
public:
	FMulticastInlineDelegateProperty_             MatchInfoReceived;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserCloudInfoReceived;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetUserMatchesStatisticFinished;                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetPlayerBansReceived;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BanPlayerReceived;                                 // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnbanPlayerReceived;                               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastMatchID;                                       // 0x0118(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastMatchResultsLoaded;                            // 0x0128(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FUserMatchResult>  MatchResults;                                      // 0x0130(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x20];                                     // 0x0180(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 BanPlayer(class AHumanPlayerController* Player, const class FString& PlayerCloudId);
	void BanPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudBannedPlayersResult& Result);
	int32 GetMatchInfo(const class FString& MatchCloudId);
	int32 GetPlayerBans(class AHumanPlayerController* Player);
	void GetPlayerBansDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FCloudBannedPlayersResult& Result);
	int32 GetUserCloudInfo(const bool bForceUpdate);
	int32 GetUserCloudInfoForController(class AHumanPlayerController* Player);
	int32 GetUserMatchesStatistic(class AHumanPlayerController* Player, ECloudUserMatchStatisticsPeriod TimePeriod);
	void GetUserMatchesStatisticDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, ECloudUserMatchStatisticsPeriod TimePeriod, const struct FCloudUserMatchesStatistic& Data);
	void MatchInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& MatchCloudId, const struct FUserMatchResult& MatchResult);
	void RequestUserCloudInfo(const bool bForceUpdate);
	int32 UnbanPlayer(class AHumanPlayerController* Player, const class FString& PlayerCloudId);
	void UnbanPlayerDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const class FString& Userid, const struct FCloudBannedPlayersResult& Result);
	void UserCloudInfoDelegate__DelegateSignature(const struct FCloudRequestResult& RequestResult, const struct FUserCloudInfo& UserInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInfoComponent">();
	}
	static class UUserInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInfoComponent>();
	}
};
static_assert(alignof(UUserInfoComponent) == 0x000008, "Wrong alignment on UUserInfoComponent");
static_assert(sizeof(UUserInfoComponent) == 0x0001A0, "Wrong size on UUserInfoComponent");
static_assert(offsetof(UUserInfoComponent, MatchInfoReceived) == 0x0000B0, "Member 'UUserInfoComponent::MatchInfoReceived' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, UserCloudInfoReceived) == 0x0000C0, "Member 'UUserInfoComponent::UserCloudInfoReceived' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, GetUserMatchesStatisticFinished) == 0x0000D0, "Member 'UUserInfoComponent::GetUserMatchesStatisticFinished' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, GetPlayerBansReceived) == 0x0000E0, "Member 'UUserInfoComponent::GetPlayerBansReceived' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, BanPlayerReceived) == 0x0000F0, "Member 'UUserInfoComponent::BanPlayerReceived' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, UnbanPlayerReceived) == 0x000100, "Member 'UUserInfoComponent::UnbanPlayerReceived' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, LastMatchID) == 0x000118, "Member 'UUserInfoComponent::LastMatchID' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, LastMatchResultsLoaded) == 0x000128, "Member 'UUserInfoComponent::LastMatchResultsLoaded' has a wrong offset!");
static_assert(offsetof(UUserInfoComponent, MatchResults) == 0x000130, "Member 'UUserInfoComponent::MatchResults' has a wrong offset!");

// Class Flame.VegetationComponent
// 0x0000 (0x0200 - 0x0200)
class UVegetationComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VegetationComponent">();
	}
	static class UVegetationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVegetationComponent>();
	}
};
static_assert(alignof(UVegetationComponent) == 0x000010, "Wrong alignment on UVegetationComponent");
static_assert(sizeof(UVegetationComponent) == 0x000200, "Wrong size on UVegetationComponent");

// Class Flame.VerticalAnimConfig
// 0x0090 (0x00B8 - 0x0028)
class UVerticalAnimConfig final : public UObject
{
public:
	struct FFourAxisJumping                       Jumping;                                           // 0x0028(0x0078)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbingAnims                         Climbing;                                          // 0x00A0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerticalAnimConfig">();
	}
	static class UVerticalAnimConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerticalAnimConfig>();
	}
};
static_assert(alignof(UVerticalAnimConfig) == 0x000008, "Wrong alignment on UVerticalAnimConfig");
static_assert(sizeof(UVerticalAnimConfig) == 0x0000B8, "Wrong size on UVerticalAnimConfig");
static_assert(offsetof(UVerticalAnimConfig, Jumping) == 0x000028, "Member 'UVerticalAnimConfig::Jumping' has a wrong offset!");
static_assert(offsetof(UVerticalAnimConfig, Climbing) == 0x0000A0, "Member 'UVerticalAnimConfig::Climbing' has a wrong offset!");

// Class Flame.WaterActor
// 0x0038 (0x0258 - 0x0220)
class AWaterActor : public AActor
{
public:
	class UStaticMesh*                            WaterSurfaceMesh;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WaterCollisionMesh;                                // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWaterComponent*                        WaterComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              WaterMaterial;                                     // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      WaterMaterialInstance;                             // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              DepthVisualizationMaterial;                        // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAddition;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterActor">();
	}
	static class AWaterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterActor>();
	}
};
static_assert(alignof(AWaterActor) == 0x000008, "Wrong alignment on AWaterActor");
static_assert(sizeof(AWaterActor) == 0x000258, "Wrong size on AWaterActor");
static_assert(offsetof(AWaterActor, WaterSurfaceMesh) == 0x000220, "Member 'AWaterActor::WaterSurfaceMesh' has a wrong offset!");
static_assert(offsetof(AWaterActor, WaterCollisionMesh) == 0x000228, "Member 'AWaterActor::WaterCollisionMesh' has a wrong offset!");
static_assert(offsetof(AWaterActor, WaterComponent) == 0x000230, "Member 'AWaterActor::WaterComponent' has a wrong offset!");
static_assert(offsetof(AWaterActor, WaterMaterial) == 0x000238, "Member 'AWaterActor::WaterMaterial' has a wrong offset!");
static_assert(offsetof(AWaterActor, WaterMaterialInstance) == 0x000240, "Member 'AWaterActor::WaterMaterialInstance' has a wrong offset!");
static_assert(offsetof(AWaterActor, DepthVisualizationMaterial) == 0x000248, "Member 'AWaterActor::DepthVisualizationMaterial' has a wrong offset!");
static_assert(offsetof(AWaterActor, HeightAddition) == 0x000250, "Member 'AWaterActor::HeightAddition' has a wrong offset!");

// Class Flame.WaterBody
// 0x0028 (0x0280 - 0x0258)
class AWaterBody final : public AWaterActor
{
public:
	float                                         CollisionDepth;                                    // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDepthVisualization;                            // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowWaterSurface;                                  // 0x025D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E[0x2];                                      // 0x025E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   WaterSurfaceComp;                                  // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          WaterCollisionComp;                                // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   DepthVisualization;                                // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterBody">();
	}
	static class AWaterBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterBody>();
	}
};
static_assert(alignof(AWaterBody) == 0x000008, "Wrong alignment on AWaterBody");
static_assert(sizeof(AWaterBody) == 0x000280, "Wrong size on AWaterBody");
static_assert(offsetof(AWaterBody, CollisionDepth) == 0x000258, "Member 'AWaterBody::CollisionDepth' has a wrong offset!");
static_assert(offsetof(AWaterBody, ShowDepthVisualization) == 0x00025C, "Member 'AWaterBody::ShowDepthVisualization' has a wrong offset!");
static_assert(offsetof(AWaterBody, ShowWaterSurface) == 0x00025D, "Member 'AWaterBody::ShowWaterSurface' has a wrong offset!");
static_assert(offsetof(AWaterBody, WaterSurfaceComp) == 0x000260, "Member 'AWaterBody::WaterSurfaceComp' has a wrong offset!");
static_assert(offsetof(AWaterBody, WaterCollisionComp) == 0x000268, "Member 'AWaterBody::WaterCollisionComp' has a wrong offset!");
static_assert(offsetof(AWaterBody, DepthVisualization) == 0x000270, "Member 'AWaterBody::DepthVisualization' has a wrong offset!");

// Class Flame.WaterVolume
// 0x0008 (0x0260 - 0x0258)
class AWaterVolume final : public AVolume
{
public:
	class UWaterComponent*                        WaterComp;                                         // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void SetupWaterBrushCollision(class UPrimitiveComponent* PrimitiveComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVolume">();
	}
	static class AWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVolume>();
	}
};
static_assert(alignof(AWaterVolume) == 0x000008, "Wrong alignment on AWaterVolume");
static_assert(sizeof(AWaterVolume) == 0x000260, "Wrong size on AWaterVolume");
static_assert(offsetof(AWaterVolume, WaterComp) == 0x000258, "Member 'AWaterVolume::WaterComp' has a wrong offset!");

// Class Flame.AimPointComponent
// 0x0010 (0x0810 - 0x0800)
class UAimPointComponent final : public UCameraComponent
{
public:
	struct FVector                                AnimatedOffset;                                    // 0x0800(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80C[0x4];                                      // 0x080C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustAimpointToSocket();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointComponent">();
	}
	static class UAimPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointComponent>();
	}
};
static_assert(alignof(UAimPointComponent) == 0x000010, "Wrong alignment on UAimPointComponent");
static_assert(sizeof(UAimPointComponent) == 0x000810, "Wrong size on UAimPointComponent");
static_assert(offsetof(UAimPointComponent, AnimatedOffset) == 0x000800, "Member 'UAimPointComponent::AnimatedOffset' has a wrong offset!");

// Class Flame.WeaponConfigManager
// 0x0468 (0x0688 - 0x0220)
class AWeaponConfigManager final : public AInfo
{
public:
	TMap<TSubclassOf<class AWeapon>, struct FFirearmWeaponConfiguration> WeaponTypeMap;                                     // 0x0220(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x418];                                    // 0x0270(0x0418)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponConfigManager">();
	}
	static class AWeaponConfigManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponConfigManager>();
	}
};
static_assert(alignof(AWeaponConfigManager) == 0x000008, "Wrong alignment on AWeaponConfigManager");
static_assert(sizeof(AWeaponConfigManager) == 0x000688, "Wrong size on AWeaponConfigManager");
static_assert(offsetof(AWeaponConfigManager, WeaponTypeMap) == 0x000220, "Member 'AWeaponConfigManager::WeaponTypeMap' has a wrong offset!");

// Class Flame.WeaponContainerWidget
// 0x0020 (0x02E8 - 0x02C8)
class UWeaponContainerWidget : public UContainerWidget
{
public:
	class UFlameSlot*                             PrimaryWeaponSlotA;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             PrimaryWeaponSlotB;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             SecondaryWeaponSlotA;                              // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlameSlot*                             SecondaryWeaponSlotB;                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FillSlots(const class ULinkedWeapons* WeaponsComponent);

	class AWeapon* GetWeapon(const EWeaponSlotType SlotType) const;
	class UFlameSlot* GetWeaponSlot(const EWeaponSlotType SlotType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponContainerWidget">();
	}
	static class UWeaponContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponContainerWidget>();
	}
};
static_assert(alignof(UWeaponContainerWidget) == 0x000008, "Wrong alignment on UWeaponContainerWidget");
static_assert(sizeof(UWeaponContainerWidget) == 0x0002E8, "Wrong size on UWeaponContainerWidget");
static_assert(offsetof(UWeaponContainerWidget, PrimaryWeaponSlotA) == 0x0002C8, "Member 'UWeaponContainerWidget::PrimaryWeaponSlotA' has a wrong offset!");
static_assert(offsetof(UWeaponContainerWidget, PrimaryWeaponSlotB) == 0x0002D0, "Member 'UWeaponContainerWidget::PrimaryWeaponSlotB' has a wrong offset!");
static_assert(offsetof(UWeaponContainerWidget, SecondaryWeaponSlotA) == 0x0002D8, "Member 'UWeaponContainerWidget::SecondaryWeaponSlotA' has a wrong offset!");
static_assert(offsetof(UWeaponContainerWidget, SecondaryWeaponSlotB) == 0x0002E0, "Member 'UWeaponContainerWidget::SecondaryWeaponSlotB' has a wrong offset!");

// Class Flame.WeaponMagazine
// 0x0020 (0x0240 - 0x0220)
class AWeaponMagazine : public AActor
{
public:
	class FName                                   ReloadHandAttachSocketName;                        // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            EmptyMesh;                                         // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            NonEmptyMesh;                                      // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponMagazine">();
	}
	static class AWeaponMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponMagazine>();
	}
};
static_assert(alignof(AWeaponMagazine) == 0x000008, "Wrong alignment on AWeaponMagazine");
static_assert(sizeof(AWeaponMagazine) == 0x000240, "Wrong size on AWeaponMagazine");
static_assert(offsetof(AWeaponMagazine, ReloadHandAttachSocketName) == 0x000220, "Member 'AWeaponMagazine::ReloadHandAttachSocketName' has a wrong offset!");
static_assert(offsetof(AWeaponMagazine, EmptyMesh) == 0x000228, "Member 'AWeaponMagazine::EmptyMesh' has a wrong offset!");
static_assert(offsetof(AWeaponMagazine, NonEmptyMesh) == 0x000230, "Member 'AWeaponMagazine::NonEmptyMesh' has a wrong offset!");
static_assert(offsetof(AWeaponMagazine, MeshComponent) == 0x000238, "Member 'AWeaponMagazine::MeshComponent' has a wrong offset!");

// Class Flame.Muzzle
// 0x0000 (0x0028 - 0x0028)
class UMuzzle : public UObject
{
public:
	class AWeapon* GetOuterAWeapon();

	EMuzzleType GetMuzzleType() const;
	const struct FFirearmWeaponConfiguration GetWeaponData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Muzzle">();
	}
	static class UMuzzle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMuzzle>();
	}
};
static_assert(alignof(UMuzzle) == 0x000008, "Wrong alignment on UMuzzle");
static_assert(sizeof(UMuzzle) == 0x000028, "Wrong size on UMuzzle");

// Class Flame.WeaponMuzzle
// 0x0028 (0x0050 - 0x0028)
class UWeaponMuzzle final : public UMuzzle
{
public:
	class AWeaponMagazine*                        CurrentLoadedMagazine;                             // 0x0028(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ChamberLoadedAmmo;                                 // 0x0030(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAmmoCount;                                  // 0x0038(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagazineSize;                                      // 0x0040(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ChamberSize;                                       // 0x0044(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AmmoCount(int32 PreviousCount);
	void OnRep_ChamberLoadedAmmoCount(int32 PreviousCount);

	int32 GetChamberLoadedAmmo() const;
	int32 GetCurrentAmmoCount() const;
	float GetCurrentAmmoRatio() const;
	int32 GetCurrentChamberCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponMuzzle">();
	}
	static class UWeaponMuzzle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponMuzzle>();
	}
};
static_assert(alignof(UWeaponMuzzle) == 0x000008, "Wrong alignment on UWeaponMuzzle");
static_assert(sizeof(UWeaponMuzzle) == 0x000050, "Wrong size on UWeaponMuzzle");
static_assert(offsetof(UWeaponMuzzle, CurrentLoadedMagazine) == 0x000028, "Member 'UWeaponMuzzle::CurrentLoadedMagazine' has a wrong offset!");
static_assert(offsetof(UWeaponMuzzle, ChamberLoadedAmmo) == 0x000030, "Member 'UWeaponMuzzle::ChamberLoadedAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponMuzzle, CurrentAmmoCount) == 0x000038, "Member 'UWeaponMuzzle::CurrentAmmoCount' has a wrong offset!");
static_assert(offsetof(UWeaponMuzzle, MagazineSize) == 0x000040, "Member 'UWeaponMuzzle::MagazineSize' has a wrong offset!");
static_assert(offsetof(UWeaponMuzzle, ChamberSize) == 0x000044, "Member 'UWeaponMuzzle::ChamberSize' has a wrong offset!");

// Class Flame.WeaponsCraftingList
// 0x0000 (0x00D0 - 0x00D0)
class UWeaponsCraftingList final : public UCraftingList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponsCraftingList">();
	}
	static class UWeaponsCraftingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponsCraftingList>();
	}
};
static_assert(alignof(UWeaponsCraftingList) == 0x000008, "Wrong alignment on UWeaponsCraftingList");
static_assert(sizeof(UWeaponsCraftingList) == 0x0000D0, "Wrong size on UWeaponsCraftingList");

// Class Flame.WeaponSegment
// 0x0018 (0x02F0 - 0x02D8)
class UWeaponSegment : public UWheelSegment
{
public:
	int32                                         WeaponIndex;                                       // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                Weapon;                                            // 0x02E0(0x0008)(ZeroConstructor, Transient, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USelectionWheelWeaponSlot*              WeaponSlot;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetWeapon(class AWeapon* InWeapon);
	void SetWeaponIndex(int32 InWeaponIndex);

	class AWeapon* GetWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSegment">();
	}
	static class UWeaponSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSegment>();
	}
};
static_assert(alignof(UWeaponSegment) == 0x000008, "Wrong alignment on UWeaponSegment");
static_assert(sizeof(UWeaponSegment) == 0x0002F0, "Wrong size on UWeaponSegment");
static_assert(offsetof(UWeaponSegment, WeaponIndex) == 0x0002D8, "Member 'UWeaponSegment::WeaponIndex' has a wrong offset!");
static_assert(offsetof(UWeaponSegment, Weapon) == 0x0002E0, "Member 'UWeaponSegment::Weapon' has a wrong offset!");
static_assert(offsetof(UWeaponSegment, WeaponSlot) == 0x0002E8, "Member 'UWeaponSegment::WeaponSlot' has a wrong offset!");

// Class Flame.WeaponsFunctions
// 0x0000 (0x0028 - 0x0028)
class UWeaponsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool AreWeaponAndAmmoCompatible(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass, TSubclassOf<class AAmmoItem> AmmoClass);
	static EWeaponSlotType ConvertIndexToSlot(int32 Index_0);
	static int32 ConvertSlotToIndex(EWeaponSlotType Slot);
	static struct FWeaponDescriptor CreateWeaponDescriptor(const class AWeapon* Weapon);
	static class AWeapon* CreateWeaponFromDescriptor(const class UObject* WorldContextObject, const struct FWeaponDescriptor& Info, class AHumanCharacter* Owner);
	static TArray<TSubclassOf<class AAmmoItem>> GetCompatibleAmmoTypes(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass);
	static int32 GetCountOfAvailableAmmoInBagForWeapon(TSubclassOf<class AWeapon> WeaponClass, const class AHumanCharacter* Owner);
	static int32 GetCurrentAmmoCount(const class AWeapon* Weapon);
	static int32 GetWeaponCapacity(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass);
	static bool GetWeaponMagazineAndChamberCapacities(const class UObject* WorldContextObject, TSubclassOf<class AWeapon> WeaponClass, int32* MagazineCount, int32* ChamberCount);
	static bool IsSecondaryWeapon(const class AWeapon* Weapon);
	static bool IsShotgun(const class AWeapon* Weapon);
	static bool IsValidWeaponDescriptor(const struct FWeaponDescriptor& Info);
	static bool UnloadWeaponToInventory(class AWeapon* Weapon, class AHumanCharacter* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponsFunctions">();
	}
	static class UWeaponsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponsFunctions>();
	}
};
static_assert(alignof(UWeaponsFunctions) == 0x000008, "Wrong alignment on UWeaponsFunctions");
static_assert(sizeof(UWeaponsFunctions) == 0x000028, "Wrong size on UWeaponsFunctions");

// Class Flame.ItemSkin
// 0x0138 (0x04D0 - 0x0398)
class AItemSkin : public AItem
{
public:
	TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> Materials;                                         // 0x0398(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> ExtraGeometryMaterials;                            // 0x03E8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              SkinTexture;                                       // 0x0448(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CamoOffset;                                        // 0x0470(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CamoRotation;                                      // 0x047C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CamoScale;                                         // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           ExtraGeometryMeshLink;                             // 0x0490(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRenderExtraGeometryStatic;                      // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ParticleDefinitions;                               // 0x04C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool GetCanRenderExtraGeometryStatic() const;
	const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> GetExtraGeometryMaterials() const;
	TSubclassOf<class AItem> GetItemClass() const;
	const TMap<class FName, TSoftObjectPtr<class UMaterialInstance>> GetMaterials() const;
	struct FDataTableRowHandle GetSkinParticleConfigHandle() const;
	class UTexture2D* GetTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSkin">();
	}
	static class AItemSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSkin>();
	}
};
static_assert(alignof(AItemSkin) == 0x000008, "Wrong alignment on AItemSkin");
static_assert(sizeof(AItemSkin) == 0x0004D0, "Wrong size on AItemSkin");
static_assert(offsetof(AItemSkin, Materials) == 0x000398, "Member 'AItemSkin::Materials' has a wrong offset!");
static_assert(offsetof(AItemSkin, ExtraGeometryMaterials) == 0x0003E8, "Member 'AItemSkin::ExtraGeometryMaterials' has a wrong offset!");
static_assert(offsetof(AItemSkin, SkinTexture) == 0x000448, "Member 'AItemSkin::SkinTexture' has a wrong offset!");
static_assert(offsetof(AItemSkin, CamoOffset) == 0x000470, "Member 'AItemSkin::CamoOffset' has a wrong offset!");
static_assert(offsetof(AItemSkin, CamoRotation) == 0x00047C, "Member 'AItemSkin::CamoRotation' has a wrong offset!");
static_assert(offsetof(AItemSkin, CamoScale) == 0x000488, "Member 'AItemSkin::CamoScale' has a wrong offset!");
static_assert(offsetof(AItemSkin, ExtraGeometryMeshLink) == 0x000490, "Member 'AItemSkin::ExtraGeometryMeshLink' has a wrong offset!");
static_assert(offsetof(AItemSkin, CanRenderExtraGeometryStatic) == 0x0004B8, "Member 'AItemSkin::CanRenderExtraGeometryStatic' has a wrong offset!");
static_assert(offsetof(AItemSkin, ParticleDefinitions) == 0x0004C0, "Member 'AItemSkin::ParticleDefinitions' has a wrong offset!");

// Class Flame.WeaponSkin
// 0x0000 (0x04D0 - 0x04D0)
class AWeaponSkin : public AItemSkin
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSkin">();
	}
	static class AWeaponSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponSkin>();
	}
};
static_assert(alignof(AWeaponSkin) == 0x000008, "Wrong alignment on AWeaponSkin");
static_assert(sizeof(AWeaponSkin) == 0x0004D0, "Wrong size on AWeaponSkin");

// Class Flame.WeaponStateFireBurst
// 0x0000 (0x0098 - 0x0098)
class UWeaponStateFireBurst final : public UWeaponStateFiringWithWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateFireBurst">();
	}
	static class UWeaponStateFireBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateFireBurst>();
	}
};
static_assert(alignof(UWeaponStateFireBurst) == 0x000008, "Wrong alignment on UWeaponStateFireBurst");
static_assert(sizeof(UWeaponStateFireBurst) == 0x000098, "Wrong size on UWeaponStateFireBurst");

// Class Flame.WeaponStateFiringFullAuto
// 0x0000 (0x0098 - 0x0098)
class UWeaponStateFiringFullAuto final : public UWeaponStateFiringWithWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateFiringFullAuto">();
	}
	static class UWeaponStateFiringFullAuto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateFiringFullAuto>();
	}
};
static_assert(alignof(UWeaponStateFiringFullAuto) == 0x000008, "Wrong alignment on UWeaponStateFiringFullAuto");
static_assert(sizeof(UWeaponStateFiringFullAuto) == 0x000098, "Wrong size on UWeaponStateFiringFullAuto");

// Class Flame.WeaponStateChamberRound
// 0x0008 (0x0080 - 0x0078)
class UWeaponStateChamberRound final : public UItemState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateChamberRound">();
	}
	static class UWeaponStateChamberRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateChamberRound>();
	}
};
static_assert(alignof(UWeaponStateChamberRound) == 0x000008, "Wrong alignment on UWeaponStateChamberRound");
static_assert(sizeof(UWeaponStateChamberRound) == 0x000080, "Wrong size on UWeaponStateChamberRound");

// Class Flame.WeaponStateMeleeAttack
// 0x0020 (0x0098 - 0x0078)
class UWeaponStateMeleeAttack final : public UWeaponStateFiring
{
public:
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateMeleeAttack">();
	}
	static class UWeaponStateMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateMeleeAttack>();
	}
};
static_assert(alignof(UWeaponStateMeleeAttack) == 0x000008, "Wrong alignment on UWeaponStateMeleeAttack");
static_assert(sizeof(UWeaponStateMeleeAttack) == 0x000098, "Wrong size on UWeaponStateMeleeAttack");

// Class Flame.WeaponStateReload
// 0x0020 (0x0098 - 0x0078)
class UWeaponStateReload final : public UItemState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EReloadStateMode                              Mode;                                              // 0x0080(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECancelReloadState                            CancelState;                                       // 0x0081(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82[0xA];                                       // 0x0082(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RoundLoadEventName;                                // 0x008C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RoundLoaded(class USkeletalMeshComponent* Skeleton, class UAnimSequenceBase* Animation, bool bAuthority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStateReload">();
	}
	static class UWeaponStateReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStateReload>();
	}
};
static_assert(alignof(UWeaponStateReload) == 0x000008, "Wrong alignment on UWeaponStateReload");
static_assert(sizeof(UWeaponStateReload) == 0x000098, "Wrong size on UWeaponStateReload");
static_assert(offsetof(UWeaponStateReload, Mode) == 0x000080, "Member 'UWeaponStateReload::Mode' has a wrong offset!");
static_assert(offsetof(UWeaponStateReload, CancelState) == 0x000081, "Member 'UWeaponStateReload::CancelState' has a wrong offset!");
static_assert(offsetof(UWeaponStateReload, RoundLoadEventName) == 0x00008C, "Member 'UWeaponStateReload::RoundLoadEventName' has a wrong offset!");

// Class Flame.WidgetDecorator
// 0x00A8 (0x00D0 - 0x0028)
class UWidgetDecorator : public URichTextBlockDecorator
{
public:
	TSubclassOf<class UUserWidget>                DefaultWidgetClass;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UUserWidget*>       CreatedWidgetsDictionary;                          // 0x0030(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FString, TSubclassOf<class UUserWidget>> WidgetDictionary;                                  // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	class UUserWidget* GetUserWidgetByName(const class FString& InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetDecorator">();
	}
	static class UWidgetDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetDecorator>();
	}
};
static_assert(alignof(UWidgetDecorator) == 0x000008, "Wrong alignment on UWidgetDecorator");
static_assert(sizeof(UWidgetDecorator) == 0x0000D0, "Wrong size on UWidgetDecorator");
static_assert(offsetof(UWidgetDecorator, DefaultWidgetClass) == 0x000028, "Member 'UWidgetDecorator::DefaultWidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetDecorator, CreatedWidgetsDictionary) == 0x000030, "Member 'UWidgetDecorator::CreatedWidgetsDictionary' has a wrong offset!");
static_assert(offsetof(UWidgetDecorator, WidgetDictionary) == 0x000080, "Member 'UWidgetDecorator::WidgetDictionary' has a wrong offset!");

// Class Flame.Window
// 0x00D0 (0x02F0 - 0x0220)
class AWindow : public AActor
{
public:
	EBuildingOverrideBehavior                     OverrideBehavior;                                  // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWindowData>                    WindowData;                                        // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            BoardedMesh;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            FrameMesh;                                         // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FrameTransform;                                    // 0x0250(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Frame;                                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   Board;                                             // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AWindowSashSet*>                 GeneratedSets;                                     // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         MaterialIndex;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             FrameMaterials;                                    // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   FrameMaterialSlot;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             BoardMaterials;                                    // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   BoardMaterialSlot;                                 // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuilding*                              ParentBuilding;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightmapGenerationOverride                   LightmapOverride;                                  // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0xF];                                      // 0x02E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockWindow();
	void LockWindow();
	void TriggerOpen(bool bOpen, bool bInstant);

	class AWindowSashSet* GetSashSet(const int32 Idx) const;
	bool GetSashSetIndex(class AWindowSashSet* SashSet, int32* ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Window">();
	}
	static class AWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindow>();
	}
};
static_assert(alignof(AWindow) == 0x000010, "Wrong alignment on AWindow");
static_assert(sizeof(AWindow) == 0x0002F0, "Wrong size on AWindow");
static_assert(offsetof(AWindow, OverrideBehavior) == 0x000220, "Member 'AWindow::OverrideBehavior' has a wrong offset!");
static_assert(offsetof(AWindow, WindowData) == 0x000228, "Member 'AWindow::WindowData' has a wrong offset!");
static_assert(offsetof(AWindow, BoardedMesh) == 0x000238, "Member 'AWindow::BoardedMesh' has a wrong offset!");
static_assert(offsetof(AWindow, FrameMesh) == 0x000240, "Member 'AWindow::FrameMesh' has a wrong offset!");
static_assert(offsetof(AWindow, FrameTransform) == 0x000250, "Member 'AWindow::FrameTransform' has a wrong offset!");
static_assert(offsetof(AWindow, Frame) == 0x000280, "Member 'AWindow::Frame' has a wrong offset!");
static_assert(offsetof(AWindow, Board) == 0x000288, "Member 'AWindow::Board' has a wrong offset!");
static_assert(offsetof(AWindow, GeneratedSets) == 0x000290, "Member 'AWindow::GeneratedSets' has a wrong offset!");
static_assert(offsetof(AWindow, MaterialIndex) == 0x0002A0, "Member 'AWindow::MaterialIndex' has a wrong offset!");
static_assert(offsetof(AWindow, FrameMaterials) == 0x0002A8, "Member 'AWindow::FrameMaterials' has a wrong offset!");
static_assert(offsetof(AWindow, FrameMaterialSlot) == 0x0002B8, "Member 'AWindow::FrameMaterialSlot' has a wrong offset!");
static_assert(offsetof(AWindow, BoardMaterials) == 0x0002C0, "Member 'AWindow::BoardMaterials' has a wrong offset!");
static_assert(offsetof(AWindow, BoardMaterialSlot) == 0x0002D0, "Member 'AWindow::BoardMaterialSlot' has a wrong offset!");
static_assert(offsetof(AWindow, ParentBuilding) == 0x0002D8, "Member 'AWindow::ParentBuilding' has a wrong offset!");
static_assert(offsetof(AWindow, LightmapOverride) == 0x0002E0, "Member 'AWindow::LightmapOverride' has a wrong offset!");

// Class Flame.WindowSashSet
// 0x0070 (0x0290 - 0x0220)
class AWindowSashSet : public AActor
{
public:
	bool                                          RemovePaneUponDamage;                              // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDirectionRestrictedInteractionComponent* DirectionRestrictedInteractionComponent;           // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionRestrictedInteractionComponent* DirectionRestrictedOutsideInteractionComponent;    // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObstacleComponent*                     ObstacleComponent;                                 // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTimelineComponent*                     TimelineComponent;                                 // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AnimationCurve;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceObstacleEnabled;                             // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          InteractionBlockComponent;                         // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           Panes;                                             // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bIsBoardedUp;                                      // 0x0270(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractDot;                                       // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FWindowSashRuntime>             SashComponents;                                    // 0x0278(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bIsOpen;                                           // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const bool ShouldSpawnBoarded(const EWindowBoardBehavior BoardBehavior);

	void EndAnimationUpdate();
	void LockWindow();
	void MulticastOnPaneShot(const int32 Idx, const struct FVector& HitLocation);
	void MulticastPlayOpenAnimation(bool bOpen);
	void OnDamage(class AActor* SomeActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCounter);
	void OnInteract(class UInteractionItemComponent* Sender, class AActor* InteractingActor);
	void OnPaneShot(const struct FVector& HitLocation, const struct FTransform& PaneTransform, class UStaticMesh* PaneMesh);
	void OnPlayOpenAnimation(bool bOpen, bool bInstant);
	void OnWindowClose();
	void OnWindowOpen();
	void OpenAnimationUpdate(float T);
	void RegisterPane(class UStaticMeshComponent* PaneComponent);
	bool UnlockWindow();

	class UStaticMeshComponent* GetPaneByIdx(const int32 Idx) const;
	bool IsWindowOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowSashSet">();
	}
	static class AWindowSashSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindowSashSet>();
	}
};
static_assert(alignof(AWindowSashSet) == 0x000008, "Wrong alignment on AWindowSashSet");
static_assert(sizeof(AWindowSashSet) == 0x000290, "Wrong size on AWindowSashSet");
static_assert(offsetof(AWindowSashSet, RemovePaneUponDamage) == 0x000220, "Member 'AWindowSashSet::RemovePaneUponDamage' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, DirectionRestrictedInteractionComponent) == 0x000228, "Member 'AWindowSashSet::DirectionRestrictedInteractionComponent' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, DirectionRestrictedOutsideInteractionComponent) == 0x000230, "Member 'AWindowSashSet::DirectionRestrictedOutsideInteractionComponent' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, ObstacleComponent) == 0x000238, "Member 'AWindowSashSet::ObstacleComponent' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, TimelineComponent) == 0x000240, "Member 'AWindowSashSet::TimelineComponent' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, AnimationCurve) == 0x000248, "Member 'AWindowSashSet::AnimationCurve' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, bForceObstacleEnabled) == 0x000250, "Member 'AWindowSashSet::bForceObstacleEnabled' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, InteractionBlockComponent) == 0x000258, "Member 'AWindowSashSet::InteractionBlockComponent' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, Panes) == 0x000260, "Member 'AWindowSashSet::Panes' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, bIsBoardedUp) == 0x000270, "Member 'AWindowSashSet::bIsBoardedUp' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, InteractDot) == 0x000274, "Member 'AWindowSashSet::InteractDot' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, SashComponents) == 0x000278, "Member 'AWindowSashSet::SashComponents' has a wrong offset!");
static_assert(offsetof(AWindowSashSet, bIsOpen) == 0x000288, "Member 'AWindowSashSet::bIsOpen' has a wrong offset!");

// Class Flame.WoundsManagerComponent
// 0x0040 (0x00F0 - 0x00B0)
class UWoundsManagerComponent final : public UActorComponent
{
public:
	EWoundsManagerAddMode                         AddMode;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWounds;                                         // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMesh(class UMeshComponent* Component);
	void AddWound(const struct FVector& HitWorldPosition, class UPrimitiveComponent* HitComponent, class FName HitBoneName, float Radius);
	void Init(const class AActor* Actor);
	void Reset();
	void SetMaterialParameterNames(const TArray<class FName>& Names);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WoundsManagerComponent">();
	}
	static class UWoundsManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWoundsManagerComponent>();
	}
};
static_assert(alignof(UWoundsManagerComponent) == 0x000008, "Wrong alignment on UWoundsManagerComponent");
static_assert(sizeof(UWoundsManagerComponent) == 0x0000F0, "Wrong size on UWoundsManagerComponent");
static_assert(offsetof(UWoundsManagerComponent, AddMode) == 0x0000B0, "Member 'UWoundsManagerComponent::AddMode' has a wrong offset!");
static_assert(offsetof(UWoundsManagerComponent, MaxWounds) == 0x0000B4, "Member 'UWoundsManagerComponent::MaxWounds' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Character_Script

#include "Basic.hpp"

#include "BP_Character_Script_classes.hpp"
#include "BP_Character_Script_parameters.hpp"


namespace SDK
{

// Function BP_Character_Script.BP_Character_Script_C.Player Scored a Kill__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PlayerController_Script_C*    Killer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerController_Script_C*    Victim                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Player_Scored_a_Kill__DelegateSignature(class ABP_PlayerController_Script_C* Killer, class ABP_PlayerController_Script_C* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Player Scored a Kill__DelegateSignature");

	Params::BP_Character_Script_C_Player_Scored_a_Kill__DelegateSignature Parms{};

	Parms.Killer = Killer;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Character Scored a Kill__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Character_Scored_a_Kill__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Character Scored a Kill__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.ExecuteUbergraph_BP_Character_Script
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ExecuteUbergraph_BP_Character_Script(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ExecuteUbergraph_BP_Character_Script");

	Params::BP_Character_Script_C_ExecuteUbergraph_BP_Character_Script Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.UnbindPesrsitentItemChanged
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::UnbindPesrsitentItemChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UnbindPesrsitentItemChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.BindPersistentItemChanged
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::BindPersistentItemChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BindPersistentItemChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.OnPersistentsChangedClient_Event_0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FPersistentChange                Change                                                 (BlueprintVisible, BlueprintReadOnly, Parm)

void ABP_Character_Script_C::OnPersistentsChangedClient_Event_0(const class AHumanCharacter* Sender, const struct FPersistentChange& Change)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnPersistentsChangedClient_Event_0");

	Params::BP_Character_Script_C_OnPersistentsChangedClient_Event_0 Parms{};

	Parms.Sender = Sender;
	Parms.Change = std::move(Change);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.AccumulateDamage
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::AccumulateDamage(float Damage, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "AccumulateDamage");

	Params::BP_Character_Script_C_AccumulateDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnAgregatedDamage
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::OnAgregatedDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnAgregatedDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.DelayedOnHit
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::DelayedOnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "DelayedOnHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.EventOnStanceChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EStance                                 NewStance                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::EventOnStanceChanged(EStance NewStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "EventOnStanceChanged");

	Params::BP_Character_Script_C_EventOnStanceChanged Parms{};

	Parms.NewStance = NewStance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.CharacterScoreKill
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::CharacterScoreKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CharacterScoreKill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Buried cache - send message about missing Cache Key
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Buried_cache_Minus_send_message_about_missing_Cache_Key()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Buried cache - send message about missing Cache Key");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.PlayerLootedLockedContainer
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::PlayerLootedLockedContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "PlayerLootedLockedContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.ShowGrenadeIndicator
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGrenade*                         Grenade                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ShowGrenadeIndicator(class AGrenade* Grenade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ShowGrenadeIndicator");

	Params::BP_Character_Script_C_ShowGrenadeIndicator Parms{};

	Parms.Grenade = Grenade;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.UpdateAnimsAfterCustomizationChanges
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::UpdateAnimsAfterCustomizationChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UpdateAnimsAfterCustomizationChanges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.RecheckLoadedUniformMesh
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::RecheckLoadedUniformMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "RecheckLoadedUniformMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.CustomEvent_0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UInventoryCustomizationComponent* Inventory_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::CustomEvent_0(class AHumanCharacter* Sender, class UInventoryCustomizationComponent* Inventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CustomEvent_0");

	Params::BP_Character_Script_C_CustomEvent_0 Parms{};

	Parms.Sender = Sender;
	Parms.Inventory_0 = Inventory_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.CheckForJiggleOnceClothesLoad
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::CheckForJiggleOnceClothesLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CheckForJiggleOnceClothesLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.DEBU_MovSpeedLoop
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::DEBU_MovSpeedLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "DEBU_MovSpeedLoop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.DEBUG_MovementSpeed
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Param                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::DEBUG_MovementSpeed(int32 Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "DEBUG_MovementSpeed");

	Params::BP_Character_Script_C_DEBUG_MovementSpeed Parms{};

	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.CheckForOffset_Exceptions
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::CheckForOffset_Exceptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CheckForOffset_Exceptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.UpdateAfterCustomizationChanges
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::UpdateAfterCustomizationChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UpdateAfterCustomizationChanges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Stop Radiation Effects on Spectator
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Stop_Radiation_Effects_on_Spectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Stop Radiation Effects on Spectator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.ReceivePossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ReceivePossessed");

	Params::BP_Character_Script_C_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Set Freezing Effect
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CurrentValue                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DamageThreshold                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Set_Freezing_Effect(bool Enabled, float CurrentValue, float DamageThreshold, float MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Set Freezing Effect");

	Params::BP_Character_Script_C_Set_Freezing_Effect Parms{};

	Parms.Enabled = Enabled;
	Parms.CurrentValue = CurrentValue;
	Parms.DamageThreshold = DamageThreshold;
	Parms.MaxValue = MaxValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnPingPressed
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::OnPingPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnPingPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.ShowBulletIndicatorNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsPlayerHit                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AHumanCharacter*                  PlayerInstigator                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Origin                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResultSimplified             HitOptimised                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABP_Character_Script_C::ShowBulletIndicatorNative(bool bIsPlayerHit, EDamageType DamageType, const class AHumanCharacter* PlayerInstigator, const struct FVector& Origin, const struct FHitResultSimplified& HitOptimised)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ShowBulletIndicatorNative");

	Params::BP_Character_Script_C_ShowBulletIndicatorNative Parms{};

	Parms.bIsPlayerHit = bIsPlayerHit;
	Parms.DamageType = DamageType;
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.Origin = std::move(Origin);
	Parms.HitOptimised = std::move(HitOptimised);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Start Check Persistent Item Icons
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Start_Check_Persistent_Item_Icons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Start Check Persistent Item Icons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Replicate Jammers Active
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Jammers_Active_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Friendly_Jammers_Active_0                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Replicate_Jammers_Active(int32 Jammers_Active_0, int32 Friendly_Jammers_Active_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Replicate Jammers Active");

	Params::BP_Character_Script_C_Replicate_Jammers_Active Parms{};

	Parms.Jammers_Active_0 = Jammers_Active_0;
	Parms.Friendly_Jammers_Active_0 = Friendly_Jammers_Active_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Stepped Out of Jammed Area
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Friendly_jammer                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Stepped_Out_of_Jammed_Area(bool Friendly_jammer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Stepped Out of Jammed Area");

	Params::BP_Character_Script_C_Stepped_Out_of_Jammed_Area Parms{};

	Parms.Friendly_jammer = Friendly_jammer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Stepped Into Jammed Area
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Friendly_jammer                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Stepped_Into_Jammed_Area(bool Friendly_jammer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Stepped Into Jammed Area");

	Params::BP_Character_Script_C_Stepped_Into_Jammed_Area Parms{};

	Parms.Friendly_jammer = Friendly_jammer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Scored a Kill
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PlayerController_Script_C*    Killer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerController_Script_C*    Victim                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Instigating_Item                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Headshot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Teamkill                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Scored_a_Kill(class ABP_PlayerController_Script_C* Killer, class ABP_PlayerController_Script_C* Victim, class UClass* Instigating_Item, bool Headshot, bool Teamkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Scored a Kill");

	Params::BP_Character_Script_C_Scored_a_Kill Parms{};

	Parms.Killer = Killer;
	Parms.Victim = Victim;
	Parms.Instigating_Item = Instigating_Item;
	Parms.Headshot = Headshot;
	Parms.Teamkill = Teamkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnLeaveCountdownFinished
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::OnLeaveCountdownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnLeaveCountdownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.EventCheckHealthValue
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::EventCheckHealthValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "EventCheckHealthValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.UpdateHealthPP
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsHealthPPVisible_0                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::UpdateHealthPP(bool IsHealthPPVisible_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UpdateHealthPP");

	Params::BP_Character_Script_C_UpdateHealthPP Parms{};

	Parms.IsHealthPPVisible_0 = IsHealthPPVisible_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Hide Mesh In Socket
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Hide_Mesh_In_Socket(class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Hide Mesh In Socket");

	Params::BP_Character_Script_C_Hide_Mesh_In_Socket Parms{};

	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Show Mesh In Socket
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      NewMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       NewTransform                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Show_Mesh_In_Socket(class FName SocketName, class UStaticMesh* NewMesh, const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Show Mesh In Socket");

	Params::BP_Character_Script_C_Show_Mesh_In_Socket Parms{};

	Parms.SocketName = SocketName;
	Parms.NewMesh = NewMesh;
	Parms.NewTransform = std::move(NewTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.EventShowBloodOnHUD
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::EventShowBloodOnHUD(float DamageAmount, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "EventShowBloodOnHUD");

	Params::BP_Character_Script_C_EventShowBloodOnHUD Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.BndEvt__Mesh_K2Node_ComponentBoundEvent_4_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_Script_C::BndEvt__Mesh_K2Node_ComponentBoundEvent_4_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BndEvt__Mesh_K2Node_ComponentBoundEvent_4_ComponentHitSignature__DelegateSignature");

	Params::BP_Character_Script_C_BndEvt__Mesh_K2Node_ComponentBoundEvent_4_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.BndEvt__Customization_K2Node_ComponentBoundEvent_3_CustomizationFromCloudLoadedClient__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UInventoryCustomizationComponent* Inventory_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::BndEvt__Customization_K2Node_ComponentBoundEvent_3_CustomizationFromCloudLoadedClient__DelegateSignature(class AHumanCharacter* Sender, class UInventoryCustomizationComponent* Inventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BndEvt__Customization_K2Node_ComponentBoundEvent_3_CustomizationFromCloudLoadedClient__DelegateSignature");

	Params::BP_Character_Script_C_BndEvt__Customization_K2Node_ComponentBoundEvent_3_CustomizationFromCloudLoadedClient__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Inventory_0 = Inventory_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.BndEvt__Customization_K2Node_ComponentBoundEvent_2_CustomizationFromCloudLoadedAuthority__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UInventoryCustomizationComponent* Inventory_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::BndEvt__Customization_K2Node_ComponentBoundEvent_2_CustomizationFromCloudLoadedAuthority__DelegateSignature(class AHumanCharacter* Sender, class UInventoryCustomizationComponent* Inventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BndEvt__Customization_K2Node_ComponentBoundEvent_2_CustomizationFromCloudLoadedAuthority__DelegateSignature");

	Params::BP_Character_Script_C_BndEvt__Customization_K2Node_ComponentBoundEvent_2_CustomizationFromCloudLoadedAuthority__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Inventory_0 = Inventory_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.BndEvt__Inventory_K2Node_ComponentBoundEvent_1_InventoryFromCloudLoadedClient__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UInventoryComponent*              Inventory_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::BndEvt__Inventory_K2Node_ComponentBoundEvent_1_InventoryFromCloudLoadedClient__DelegateSignature(class AHumanCharacter* Sender, class UInventoryComponent* Inventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BndEvt__Inventory_K2Node_ComponentBoundEvent_1_InventoryFromCloudLoadedClient__DelegateSignature");

	Params::BP_Character_Script_C_BndEvt__Inventory_K2Node_ComponentBoundEvent_1_InventoryFromCloudLoadedClient__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Inventory_0 = Inventory_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.BndEvt__Inventory_K2Node_ComponentBoundEvent_0_InventoryFromCloudLoadedAuthority__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Sender                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UInventoryComponent*              Inventory_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::BndEvt__Inventory_K2Node_ComponentBoundEvent_0_InventoryFromCloudLoadedAuthority__DelegateSignature(class AHumanCharacter* Sender, class UInventoryComponent* Inventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "BndEvt__Inventory_K2Node_ComponentBoundEvent_0_InventoryFromCloudLoadedAuthority__DelegateSignature");

	Params::BP_Character_Script_C_BndEvt__Inventory_K2Node_ComponentBoundEvent_0_InventoryFromCloudLoadedAuthority__DelegateSignature Parms{};

	Parms.Sender = Sender;
	Parms.Inventory_0 = Inventory_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.StopRadiationEffects
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::StopRadiationEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "StopRadiationEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.InWaterTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::InWaterTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "InWaterTick");

	Params::BP_Character_Script_C_InWaterTick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnPlayerExitWater
// (Event, Public, BlueprintEvent)

void ABP_Character_Script_C::OnPlayerExitWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnPlayerExitWater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.OnPlayerEnterWater
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FVector                          ImpactLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaterDepthAtImpact                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaterDepthInFront                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::OnPlayerEnterWater(const struct FVector& ImpactLocation, float WaterDepthAtImpact, float WaterDepthInFront)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnPlayerEnterWater");

	Params::BP_Character_Script_C_OnPlayerEnterWater Parms{};

	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.WaterDepthAtImpact = WaterDepthAtImpact;
	Parms.WaterDepthInFront = WaterDepthInFront;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnLanded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_Script_C::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnLanded");

	Params::BP_Character_Script_C_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnJumped
// (Event, Public, BlueprintEvent)

void ABP_Character_Script_C::OnJumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnJumped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.OnTakeDamage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AHumanCharacter*                  InstigatingActor                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class AItem>                InstigatingItemClass                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FHitResultSimplified             HitOptimised                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference)
// TArray<TSubclassOf<class AItem>>        AffectedItems                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, UObjectWrapper)

void ABP_Character_Script_C::OnTakeDamage(float DamageAmount, EDamageType DamageType, const class AHumanCharacter* InstigatingActor, TSubclassOf<class AItem> InstigatingItemClass, const struct FHitResultSimplified& HitOptimised, const TArray<TSubclassOf<class AItem>>& AffectedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnTakeDamage");

	Params::BP_Character_Script_C_OnTakeDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingActor = InstigatingActor;
	Parms.InstigatingItemClass = InstigatingItemClass;
	Parms.HitOptimised = std::move(HitOptimised);
	Parms.AffectedItems = std::move(AffectedItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Clear Stored Attackers of the Frame
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Clear_Stored_Attackers_of_the_Frame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Clear Stored Attackers of the Frame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.SetCameraFadeState
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// ECameraFadeState                        NewFadeState                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::SetCameraFadeState(ECameraFadeState NewFadeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "SetCameraFadeState");

	Params::BP_Character_Script_C_SetCameraFadeState Parms{};

	Parms.NewFadeState = NewFadeState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.ReceiveOnFire
// (Event, Public, BlueprintEvent)

void ABP_Character_Script_C::ReceiveOnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ReceiveOnFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.UpdateRadiationEffects
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Current_exposure                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Max_Exposure                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::UpdateRadiationEffects(float Current_exposure, float Max_Exposure)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UpdateRadiationEffects");

	Params::BP_Character_Script_C_UpdateRadiationEffects Parms{};

	Parms.Current_exposure = Current_exposure;
	Parms.Max_Exposure = Max_Exposure;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Die
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AHumanCharacter*                  InstigatingCharacter                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class AItem>                InstigatingItem                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FHitResult                       HitResult                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_Script_C::Die(float DamageAmount, EDamageType DamageType, class AHumanCharacter* InstigatingCharacter, TSubclassOf<class AItem> InstigatingItem, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Die");

	Params::BP_Character_Script_C_Die Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatingCharacter = InstigatingCharacter;
	Parms.InstigatingItem = InstigatingItem;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ReceiveTick");

	Params::BP_Character_Script_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Character_Script_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.CloseUI_NotifyPlayableExit
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::CloseUI_NotifyPlayableExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CloseUI_NotifyPlayableExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.OpenUI_NotifyPlayableExit
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::OpenUI_NotifyPlayableExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OpenUI_NotifyPlayableExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Show Player Count
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show_Player_Count_State                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Show_Player_Count(bool Show_Player_Count_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Show Player Count");

	Params::BP_Character_Script_C_Cheat_Show_Player_Count Parms{};

	Parms.Show_Player_Count_State = Show_Player_Count_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Get Actor Display Name
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Cheat_Get_Actor_Display_Name()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Get Actor Display Name");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Get Actor Display Name Timer
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle_Get_Actor_Display_Name_Timer                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Get_Actor_Display_Name_Timer(bool Toggle_Get_Actor_Display_Name_Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Get Actor Display Name Timer");

	Params::BP_Character_Script_C_Cheat_Get_Actor_Display_Name_Timer Parms{};

	Parms.Toggle_Get_Actor_Display_Name_Timer = Toggle_Get_Actor_Display_Name_Timer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Toggle Show Actor Display Name
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ToggleShowTracedActorDisplayName                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Toggle_Show_Actor_Display_Name(bool ToggleShowTracedActorDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Toggle Show Actor Display Name");

	Params::BP_Character_Script_C_Cheat_Toggle_Show_Actor_Display_Name Parms{};

	Parms.ToggleShowTracedActorDisplayName = ToggleShowTracedActorDisplayName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Blocking Volumes
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle_3d_Debug_Blocking_Volumes                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Blocking_Volumes(bool Toggle_3d_Debug_Blocking_Volumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Blocking Volumes");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Blocking_Volumes Parms{};

	Parms.Toggle_3d_Debug_Blocking_Volumes = Toggle_3d_Debug_Blocking_Volumes;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Player
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugPlayer                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Player(bool Toggle3dDebugPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Player");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Player Parms{};

	Parms.Toggle3dDebugPlayer = Toggle3dDebugPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Player Starts
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugPlayerStarts                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Player_Starts(bool Toggle3dDebugPlayerStarts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Player Starts");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Player_Starts Parms{};

	Parms.Toggle3dDebugPlayerStarts = Toggle3dDebugPlayerStarts;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Loot Spawns
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugLootSpawns                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Loot_Spawns(bool Toggle3dDebugLootSpawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Loot Spawns");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Loot_Spawns Parms{};

	Parms.Toggle3dDebugLootSpawns = Toggle3dDebugLootSpawns;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Spawned Loot
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugSpawnedLoot                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Spawned_Loot(bool Toggle3dDebugSpawnedLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Spawned Loot");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Spawned_Loot Parms{};

	Parms.Toggle3dDebugSpawnedLoot = Toggle3dDebugSpawnedLoot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Objective Spawns
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugObjectiveSpawns                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Objective_Spawns(bool Toggle3dDebugObjectiveSpawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Objective Spawns");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Objective_Spawns Parms{};

	Parms.Toggle3dDebugObjectiveSpawns = Toggle3dDebugObjectiveSpawns;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Objective Items
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugObjectiveItems                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Objective_Items(bool Toggle3dDebugObjectiveItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Objective Items");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Objective_Items Parms{};

	Parms.Toggle3dDebugObjectiveItems = Toggle3dDebugObjectiveItems;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug Resource Items
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebugResourceItems                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug_Resource_Items(bool Toggle3dDebugResourceItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug Resource Items");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug_Resource_Items Parms{};

	Parms.Toggle3dDebugResourceItems = Toggle3dDebugResourceItems;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Set Machine Hud
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ToggleMachineHud                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Set_Machine_Hud(bool ToggleMachineHud)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Set Machine Hud");

	Params::BP_Character_Script_C_Cheat_Set_Machine_Hud Parms{};

	Parms.ToggleMachineHud = ToggleMachineHud;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Set Consumable Hud
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle_Consumable_Hud                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Set_Consumable_Hud(bool Toggle_Consumable_Hud)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Set Consumable Hud");

	Params::BP_Character_Script_C_Cheat_Set_Consumable_Hud Parms{};

	Parms.Toggle_Consumable_Hud = Toggle_Consumable_Hud;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Spawn 3D Debug
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Toggle3dDebug                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Spawn_3D_Debug(bool Toggle3dDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Spawn 3D Debug");

	Params::BP_Character_Script_C_Cheat_Spawn_3D_Debug Parms{};

	Parms.Toggle3dDebug = Toggle3dDebug;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Draw Game Mode Debug
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           WidgetToDraw                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Cheat_Draw_Game_Mode_Debug(class UClass* WidgetToDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Draw Game Mode Debug");

	Params::BP_Character_Script_C_Cheat_Draw_Game_Mode_Debug Parms{};

	Parms.WidgetToDraw = WidgetToDraw;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Show Players In Session
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShowPlayersInSessionState                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Show_Players_In_Session(bool ShowPlayersInSessionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Show Players In Session");

	Params::BP_Character_Script_C_Cheat_Show_Players_In_Session Parms{};

	Parms.ShowPlayersInSessionState = ShowPlayersInSessionState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Show Player Location
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show_Player_Location_State                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Show_Player_Location(bool Show_Player_Location_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Show Player Location");

	Params::BP_Character_Script_C_Cheat_Show_Player_Location Parms{};

	Parms.Show_Player_Location_State = Show_Player_Location_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Draw FOV Selection
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Cheat_Draw_FOV_Selection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Draw FOV Selection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Draw Definable Damage
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Cheat_Draw_Definable_Damage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Draw Definable Damage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Draw Health Debug
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Health_Debug_State                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::Cheat_Draw_Health_Debug(bool Health_Debug_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Draw Health Debug");

	Params::BP_Character_Script_C_Cheat_Draw_Health_Debug Parms{};

	Parms.Health_Debug_State = Health_Debug_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Cheat Infinite Ammo
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Cheat_Infinite_Ammo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Cheat Infinite Ammo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.TriggerMeshSpecificParticle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ParticleTriggerConditions             TriggerType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HandleReplicationYourself                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::TriggerMeshSpecificParticle(E_ParticleTriggerConditions TriggerType, bool HandleReplicationYourself)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "TriggerMeshSpecificParticle");

	Params::BP_Character_Script_C_TriggerMeshSpecificParticle Parms{};

	Parms.TriggerType = TriggerType;
	Parms.HandleReplicationYourself = HandleReplicationYourself;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.PutMapToRightHand
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::PutMapToRightHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "PutMapToRightHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.ClearRightHand
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::ClearRightHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ClearRightHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.PutKitchenTimerToRightHand
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::PutKitchenTimerToRightHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "PutKitchenTimerToRightHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.AnimHitReaction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Impact                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::AnimHitReaction(class FName BoneName, const struct FVector& HitNormal, float Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "AnimHitReaction");

	Params::BP_Character_Script_C_AnimHitReaction Parms{};

	Parms.BoneName = BoneName;
	Parms.HitNormal = std::move(HitNormal);
	Parms.Impact = Impact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.AnimInteraction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Actions                               Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Interrupt                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::AnimInteraction(E_Actions Action, bool Interrupt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "AnimInteraction");

	Params::BP_Character_Script_C_AnimInteraction Parms{};

	Parms.Action = Action;
	Parms.Interrupt = Interrupt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.RespawnPlayerToShelter
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::RespawnPlayerToShelter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "RespawnPlayerToShelter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Handle3dDebug
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Condition                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TSoftClassPtr<class UClass>             ActorToDebug                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             VisualizationActor                                     (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UMaterialInterface*               VisualizedActorMaterial                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             TagName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Handle3dDebug(bool Condition, TSoftClassPtr<class UClass> ActorToDebug, TSoftClassPtr<class UClass> VisualizationActor, class UMaterialInterface* VisualizedActorMaterial, class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Handle3dDebug");

	Params::BP_Character_Script_C_Handle3dDebug Parms{};

	Parms.Condition = Condition;
	Parms.ActorToDebug = ActorToDebug;
	Parms.VisualizationActor = VisualizationActor;
	Parms.VisualizedActorMaterial = VisualizedActorMaterial;
	Parms.TagName = TagName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.OnRep_CameraFadeState
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::OnRep_CameraFadeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnRep_CameraFadeState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.HandleLadderSlide
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::HandleLadderSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "HandleLadderSlide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.HandleWaterLanding
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HitWaterSurface                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ImpactLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaterDepthAtImpact                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaterDepthInFront                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::HandleWaterLanding(bool HitWaterSurface, const struct FVector& ImpactLocation, float WaterDepthAtImpact, float WaterDepthInFront)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "HandleWaterLanding");

	Params::BP_Character_Script_C_HandleWaterLanding Parms{};

	Parms.HitWaterSurface = HitWaterSurface;
	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.WaterDepthAtImpact = WaterDepthAtImpact;
	Parms.WaterDepthInFront = WaterDepthInFront;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.HandleWaterTick
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::HandleWaterTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "HandleWaterTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.HandleOnHitSounds
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_Script_C::HandleOnHitSounds(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "HandleOnHitSounds");

	Params::BP_Character_Script_C_HandleOnHitSounds Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.Show Bullet Indicator
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPlayerHit                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          BulletOrigin                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResultSimplified             HitOptimised                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AHumanCharacter*                  Instigator_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Show_Bullet_Indicator(bool IsPlayerHit, const struct FVector& BulletOrigin, const struct FHitResultSimplified& HitOptimised, EDamageType DamageType, class AHumanCharacter* Instigator_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Show Bullet Indicator");

	Params::BP_Character_Script_C_Show_Bullet_Indicator Parms{};

	Parms.IsPlayerHit = IsPlayerHit;
	Parms.BulletOrigin = std::move(BulletOrigin);
	Parms.HitOptimised = std::move(HitOptimised);
	Parms.DamageType = DamageType;
	Parms.Instigator_0 = Instigator_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.ShowBloodOnHUD
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamageType                             DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ShowBloodOnHUD(float DamageAmount, EDamageType DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ShowBloodOnHUD");

	Params::BP_Character_Script_C_ShowBloodOnHUD Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.UpdateHoldBreathPP
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::UpdateHoldBreathPP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "UpdateHoldBreathPP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Update Map Tool
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Update_Map_Tool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Update Map Tool");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Check Persistent Item Icons
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Check_Persistent_Item_Icons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Check Persistent Item Icons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.Handle Freezing Effect
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Current_Value                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage_Threshold                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Max_Value                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::Handle_Freezing_Effect(bool Enabled, float Current_Value, float Damage_Threshold, float Max_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Handle Freezing Effect");

	Params::BP_Character_Script_C_Handle_Freezing_Effect Parms{};

	Parms.Enabled = Enabled;
	Parms.Current_Value = Current_Value;
	Parms.Damage_Threshold = Damage_Threshold;
	Parms.Max_Value = Max_Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.ShowIndicatorGrenade
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AGrenade*                         Grenade                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::ShowIndicatorGrenade(class AGrenade* Grenade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "ShowIndicatorGrenade");

	Params::BP_Character_Script_C_ShowIndicatorGrenade Parms{};

	Parms.Grenade = Grenade;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.GetCurrentJiggle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_Script_C::GetCurrentJiggle(bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "GetCurrentJiggle");

	Params::BP_Character_Script_C_GetCurrentJiggle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_Character_Script.BP_Character_Script_C.Handle radiation status effect icons
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_Script_C::Handle_radiation_status_effect_icons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "Handle radiation status effect icons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character_Script.BP_Character_Script_C.CreateBulletIndications
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   IndicatorsToCreate                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UUI_HitIndication_C*              OutputPin                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::CreateBulletIndications(int32 IndicatorsToCreate, class UUI_HitIndication_C** OutputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "CreateBulletIndications");

	Params::BP_Character_Script_C_CreateBulletIndications Parms{};

	Parms.IndicatorsToCreate = IndicatorsToCreate;

	UObject::ProcessEvent(Func, &Parms);

	if (OutputPin != nullptr)
		*OutputPin = Parms.OutputPin;
}


// Function BP_Character_Script.BP_Character_Script_C.OnArmorPlateDestroyed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AHumanCharacter*                  Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::OnArmorPlateDestroyed(class AHumanCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "OnArmorPlateDestroyed");

	Params::BP_Character_Script_C_OnArmorPlateDestroyed Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character_Script.BP_Character_Script_C.GetMovementSoundProperties
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USoundBase*                       Sound                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   VolumeMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PitchMultiplier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::GetMovementSoundProperties(const class USoundBase* Sound, float* VolumeMultiplier, float* PitchMultiplier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "GetMovementSoundProperties");

	Params::BP_Character_Script_C_GetMovementSoundProperties Parms{};

	Parms.Sound = Sound;

	UObject::ProcessEvent(Func, &Parms);

	if (VolumeMultiplier != nullptr)
		*VolumeMultiplier = Parms.VolumeMultiplier;

	if (PitchMultiplier != nullptr)
		*PitchMultiplier = Parms.PitchMultiplier;
}


// Function BP_Character_Script.BP_Character_Script_C.GetCharacterWeightSoundProperties
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   VolumeMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PitchMultiplier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_Script_C::GetCharacterWeightSoundProperties(float* VolumeMultiplier, float* PitchMultiplier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_Script_C", "GetCharacterWeightSoundProperties");

	Params::BP_Character_Script_C_GetCharacterWeightSoundProperties Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (VolumeMultiplier != nullptr)
		*VolumeMultiplier = Parms.VolumeMultiplier;

	if (PitchMultiplier != nullptr)
		*PitchMultiplier = Parms.PitchMultiplier;
}

}

